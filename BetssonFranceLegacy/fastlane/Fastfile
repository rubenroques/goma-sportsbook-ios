require 'dotenv'

# Load environment variables
Dotenv.load('.env')

ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"

# --- Start: Added Variables ---
XCODEPROJ_PATH = "Sportsbook.xcodeproj"
# Consider moving this sensitive URL to your .env file (e.g., ENV['DISCORD_WEBHOOK_URL'])
DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/1356283170596585635/_mbemzxXvNy71qlqYuzxxOuWvm0kfOfnxdv3BttrJfs1g5asnY444AfR1qPhpXIucsYa"
# --- End: Added Variables ---

# Verify Apple credentials are set
unless ENV["FASTLANE_USER"] && ENV["FASTLANE_PASSWORD"]
  UI.important "âš ï¸  Fastlane credentials not found in environment variables"
  UI.important "Please set FASTLANE_USER and FASTLANE_PASSWORD in your .env file"
end

# Fastfile
default_platform(:ios)

# Simple mapping between Xcode schemes and internal IDs
SCHEME_MAPPING = {
  "Betsson UAT" => "BETSSON_UAT",
  "Betsson PROD" => "BETSSON_PROD"
}

# Bundle ID mappings
BUNDLE_ID_MAPPING = {
  "BETSSON_UAT" => {
    "main_app" => "com.gomagaming.betsson"
  },
  "BETSSON_PROD" => {
    "main_app" => "fr.betsson.ios.app",
    "notification_service" => "fr.betsson.ios.app.betssonNotificationsService"
  }
}

# Provisioning profile mappings
PROVISIONING_PROFILE_MAPPING = {
  "BETSSON_UAT" => {
    "com.gomagaming.betsson" => "match AdHoc com.gomagaming.betsson"
  },
  "BETSSON_PROD" => {
    "fr.betsson.ios.app" => "match AdHoc fr.betsson.ios.app",
    "fr.betsson.ios.app.betssonNotificationsService" => "match AdHoc fr.betsson.ios.app.betssonNotificationsService"
  }
}

# before_all do |lane|
#   ensure_git_status_clean unless lane == :test
#   ensure_bundle_exec
# end

after_all do |lane|
  notification(subtitle: "Fastlane", message: "#{lane} completed successfully! ğŸ‰")
end

error do |lane, exception|
  notification(subtitle: "Fastlane", message: "#{lane} failed with error: #{exception}")
end

platform :ios do

  desc "Print environment variables and arguments"
  lane :test_env do |options|
    UI.message "ğŸ” Printing Environment Variables:"
    UI.message "--------------------------------"
    ENV.sort.each do |key, value|
      UI.message "#{key} = #{value}"
    end

    UI.message "\nğŸ“ Printing Lane Options/Arguments:"
    UI.message "--------------------------------"
    if options && !options.empty?
      options.each do |key, value|
        UI.message "#{key} = #{value}"
      end
    else
      UI.message "No arguments passed to the lane"
    end
  end

  desc "Update build number"
  lane :version_bump do
    current_build = get_build_number(xcodeproj: XCODEPROJ_PATH)
    puts "Current build number (CURRENT_PROJECT_VERSION): #{current_build}"

    # Prompt for new build number using UI.input
    new_build = UI.input("Enter new build number (CURRENT_PROJECT_VERSION), press enter to keep current, or '+' to increment:")

    # Handle the input
    new_build = if new_build.to_s.strip.empty?
      current_build  # Keep current if empty
    elsif new_build.strip == "+"
      (current_build.to_i + 1).to_s  # Increment if +
    else
      new_build  # Use provided number
    end

    # Update build number
    increment_build_number(
      build_number: new_build,
      xcodeproj: XCODEPROJ_PATH,
      skip_info_plist: true
    )

    puts "Build number updated to: #{new_build}"
  end

  desc "Update marketing version"
  lane :marketing_version_bump do
    current_version = get_version_number(xcodeproj: XCODEPROJ_PATH)
    puts "Current version (MARKETING_VERSION): #{current_version}"

    # Prompt for new version using UI.input
    new_version = UI.input("Enter new version number (MARKETING_VERSION) or press enter to keep current:")

    # Use current version if input is empty
    new_version = new_version.to_s.strip.empty? ? current_version : new_version

    # Update version
    increment_version_number(
      version_number: new_version,
      xcodeproj: XCODEPROJ_PATH
    )

    puts "Version updated to: #{new_version}"
  end

  desc "Setup certificates and provisioning profiles"
  lane :certificates do |options|
    app_scheme = options[:app_scheme]

    # Get internal ID from scheme mapping if a scheme is provided
    internal_id = app_scheme ? SCHEME_MAPPING[app_scheme] : app_scheme

    # Set Match parameters based on environment
    match_params = {
      type: "adhoc",
      force_for_new_devices: true,
      readonly: true,
      force: false,
      verbose: false
    }

    case internal_id
    when "BETSSON_UAT"
      match_params.merge!({
        git_url: ENV["MATCH_GIT_URL_UAT"],
        username: ENV["BETSSON_UAT_APPLE_ID"],
        team_id: ENV["BETSSON_UAT_TEAM_ID"],
        app_identifier: BUNDLE_ID_MAPPING[internal_id].values
      })
    when "BETSSON_PROD"
      match_params.merge!({
        git_url: ENV["MATCH_GIT_URL_PROD"],
        username: ENV["BETSSON_PROD_APPLE_ID"],
        team_id: ENV["BETSSON_PROD_TEAM_ID"],
        app_identifier: BUNDLE_ID_MAPPING[internal_id].values
      })
    else
      UI.user_error!("Please specify a valid scheme: 'Betsson UAT' or 'Betsson PROD'")
    end

    # Register new devices if devices.txt exists
    devices_file = "./fastlane/devices.txt"
    if File.exist?(devices_file)
      require 'csv'
      register_devices(
        devices_file: devices_file,
        username: match_params[:username],
        team_id: match_params[:team_id]
      )
    else
      UI.message "â„¹No devices.txt file found, skipping device registration"
    end

    # Fetch certificates and profiles
    match(match_params)
  end

  desc "Build and distribute to Firebase"
  lane :distribute_to_firebase do |options|
    is_verbose = options[:verbose] == true

    UI.message "ğŸš€ Starting distribution process..."

    app_scheme = options[:app_scheme]
    environment = options[:environment]
    release_notes = options[:release_notes]

    UI.message "ğŸ“± Building for scheme: #{app_scheme}"
    UI.message "ğŸŒ Environment: #{environment}"

    # Get internal ID from scheme mapping
    internal_id = SCHEME_MAPPING[app_scheme]
    unless internal_id
      UI.user_error!("Invalid scheme: #{app_scheme}. Must be one of: #{SCHEME_MAPPING.keys.join(', ')}")
    end

    UI.message "ğŸ” Using internal ID: #{internal_id}" if is_verbose

    # Validate scheme and environment variables
    unless ENV["#{internal_id}_FIREBASE_APP_ID"]
      UI.user_error!("Missing Firebase App ID for scheme: #{app_scheme}")
    end

    firebase_cli_token = ENV["FIREBASE_#{environment}_CLI_TOKEN"]
    firebase_groups = ENV["FIREBASE_#{environment}_DISTRIBUTION_GROUPS"] || "ios-internal"

    unless firebase_cli_token
      UI.user_error!("Missing Firebase CLI token for environment: #{environment}")
    end

    # Update certificates
    UI.message "ğŸ” Updating certificates..." if is_verbose
    certificates(app_scheme: app_scheme)

    # Print Xcode version
    if is_verbose
      UI.message "ğŸ›  Xcode Version:"
      sh("xcodebuild -version")
    end

    UI.message "ğŸ— Starting build process..." if is_verbose

    # Build app with detailed output
    build_ios_app(
      scheme: app_scheme,
      clean: true,
      silent: !is_verbose,
      suppress_xcode_output: !is_verbose,  # Only show xcodebuild output in verbose mode
      skip_profile_detection: true,
      export_method: "ad-hoc",
      export_options: {
        compileBitcode: false,
        uploadBitcode: false,
        uploadSymbols: true,
        manageAppVersionAndBuildNumber: false,
        provisioningProfiles: PROVISIONING_PROFILE_MAPPING[internal_id]
      },
      xcargs: is_verbose ? "-verbose" : nil,
      buildlog_path: "fastlane/logs",
      output_directory: "fastlane/builds",
      analyze_build_time: is_verbose,
      include_symbols: true,
      include_bitcode: false,
      export_xcargs: is_verbose ? "-verbose" : nil,
      xcodebuild_formatter: nil  # Remove xcpretty since we're using suppress_xcode_output
    )

    UI.message "ğŸ“¦ Build completed. Uploading to Firebase..."

    # Upload to Firebase
    firebase_app_distribution(
      app: ENV["#{internal_id}_FIREBASE_APP_ID"],
      firebase_cli_token: firebase_cli_token,
      groups: firebase_groups,
      release_notes: release_notes,
      debug: is_verbose
    )

    UI.success "âœ… Distribution completed successfully!"
  end

  # --- Start: Private Helper Lane for Discord Notification ---
  private_lane :_notify_discord do |options|
    begin
      env_name = options[:env_name]
      bundle_id_key = options[:bundle_id_key]
      emoji = options[:emoji]
      title_prefix = options[:title_prefix]
      target_name = options[:target_name]

      UI.message("Sending Discord notification for #{env_name}...")

      current_version = get_version_number(xcodeproj: XCODEPROJ_PATH)
      current_build = get_build_number(xcodeproj: XCODEPROJ_PATH)
      bundle_id = BUNDLE_ID_MAPPING[bundle_id_key]["main_app"]
      today_date = Time.now.strftime('%Y-%m-%d')

      # Format Release Notes
      raw_notes = options[:release_notes]
      if raw_notes && !raw_notes.strip.empty?
        release_notes_text = raw_notes.split(';')
                                      .map { |note| "- #{note.strip}" }
                                      .join("\n")
      else
        release_notes_text = "No release notes provided."
      end

      discord_notifier(
        webhook_url: DISCORD_WEBHOOK_URL,
        success: true,
        title: "#{emoji} Betsson #{title_prefix} Build Deployed",
        description: release_notes_text,
        fields: [
          { name: "Version", value: current_version, inline: true },
          { name: "Build", value: current_build, inline: true },
          { name: "Date", value: today_date, inline: true },
          { name: "Bundle ID (#{env_name})", value: bundle_id, inline: false }
        ]
      )
      UI.success("Discord notification sent for #{env_name}.")
    rescue => ex
      UI.error("Discord notification for #{env_name} failed: #{ex}")
    end
  end
  # --- End: Private Helper Lane for Discord Notification ---

  lane :betsson_uat do |options|
    distribute_to_firebase(
      app_scheme: "Betsson UAT",
      environment: "UAT",
      release_notes: options[:release_notes],
      verbose: options[:verbose]
    )

    # Call the helper lane for notification
    _notify_discord(
      env_name: "UAT",
      bundle_id_key: "BETSSON_UAT",
      emoji: "ğŸ”¸",
      title_prefix: "UAT",
      target_name: "Betsson UAT",
      release_notes: options[:release_notes]
    )
  end

  lane :betsson_prod do |options|
    distribute_to_firebase(
      app_scheme: "Betsson PROD",
      environment: "PROD",
      release_notes: options[:release_notes],
      verbose: options[:verbose]
    )

    # Call the helper lane for notification
    _notify_discord(
      env_name: "PROD",
      bundle_id_key: "BETSSON_PROD",
      emoji: "ğŸŸ ",
      title_prefix: "PROD",
      target_name: "Betsson PROD",
      release_notes: options[:release_notes]
    )
  end

  lane :betsson do |options|
    version_bump

    betsson_uat(
      release_notes: options[:release_notes],
      verbose: options[:verbose]
    )
    betsson_prod(
      release_notes: options[:release_notes],
      verbose: options[:verbose]
    )
  end

  # --- Start: Dry Run Test Lane ---
  desc "Dry run of the betsson lane: prints info without building, distributing, or notifying."
  lane :test do |options|
    UI.header("ğŸš€ Starting Betsson Dry Run ğŸš€")

    # --- Simulate version_bump ---
    UI.header("Simulating: version_bump")
    begin
      # Fetch current build number (no need to prompt in dry run)
      target_for_version_check = "Betsson UAT" # Build number should be consistent
      current_build = get_build_number(xcodeproj: XCODEPROJ_PATH, target: target_for_version_check)
      UI.message("Current build number (#{target_for_version_check}): #{current_build}")
      UI.important("Dry Run: Skipping actual prompt and build number increment.")
      # Note: In a real run, version_bump would prompt and potentially change current_build.
      # For dry run, we'll use the fetched current numbers below.
    rescue => ex
      UI.error("Dry Run: Failed to get current build number: #{ex}")
      current_build = "[DRY RUN ERROR]"
    end
    UI.message("---")

    # --- Simulate betsson_uat ---
    UI.header("Simulating: betsson_uat distribution and notification")
    begin
      uat_target = "Betsson UAT"
      uat_env = "UAT"
      uat_id_key = "BETSSON_UAT"
      uat_emoji = "ğŸ§ª"
      uat_title = "UAT"
      uat_firebase_app_id = ENV["#{uat_id_key}_FIREBASE_APP_ID"] || "[UAT Firebase App ID not found in .env]"
      uat_firebase_groups = ENV["FIREBASE_#{uat_env}_DISTRIBUTION_GROUPS"] || "ios-internal"

      # Get info (using current numbers as bump was skipped)
      current_version = get_version_number(xcodeproj: XCODEPROJ_PATH, target: uat_target)
      # Use build number fetched earlier
      bundle_id = BUNDLE_ID_MAPPING[uat_id_key]["main_app"]
      today_date = Time.now.strftime('%Y-%m-%d')

      # Format release notes
      raw_notes = options[:release_notes]
      if raw_notes && !raw_notes.strip.empty?
        release_notes_text = raw_notes.split(';').map { |note| "- #{note.strip}" }.join("\n")
      else
        release_notes_text = "No release notes provided."
      end

      UI.message("Firebase Distribution (Dry Run):")
      UI.message("  App ID: #{uat_firebase_app_id}")
      UI.message("  Groups: #{uat_firebase_groups}")
      UI.message("  Release Notes:\n#{release_notes_text.gsub(/^/, '    ')}") # Indent notes
      UI.important("Dry Run: Skipping actual call to distribute_to_firebase.")
      UI.message("---")

      UI.message("Discord Notification (Dry Run):")
      UI.message("  Webhook: #{DISCORD_WEBHOOK_URL}")
      UI.message("  Title: #{uat_emoji} Betsson #{uat_title} Build Deployed")
      UI.message("  Description:\n#{release_notes_text.gsub(/^/, '    ')}") # Indent notes
      UI.message("  Fields:")
      UI.message("    Version: #{current_version}")
      UI.message("    Build: #{current_build}")
      UI.message("    Date: #{today_date}")
      UI.message("    Bundle ID (#{uat_env}): #{bundle_id}")
      UI.important("Dry Run: Skipping actual call to _notify_discord.")

    rescue => ex
      UI.error("Dry Run Simulation Error (UAT): #{ex}")
    end
    UI.message("---")

    # --- Simulate betsson_prod ---
    UI.header("Simulating: betsson_prod distribution and notification")
    begin
      prod_target = "Betsson PROD"
      prod_env = "PROD"
      prod_id_key = "BETSSON_PROD"
      prod_emoji = "âœ…"
      prod_title = "PROD"
      prod_firebase_app_id = ENV["#{prod_id_key}_FIREBASE_APP_ID"] || "[PROD Firebase App ID not found in .env]"
      prod_firebase_groups = ENV["FIREBASE_#{prod_env}_DISTRIBUTION_GROUPS"] || "ios-internal"

      # Get info (using current numbers as bump was skipped)
      current_version = get_version_number(xcodeproj: XCODEPROJ_PATH, target: prod_target)
      # Use build number fetched earlier
      bundle_id = BUNDLE_ID_MAPPING[prod_id_key]["main_app"]
      today_date = Time.now.strftime('%Y-%m-%d')

      # Format release notes (same as UAT for this dry run)
      raw_notes = options[:release_notes]
      if raw_notes && !raw_notes.strip.empty?
        release_notes_text = raw_notes.split(';').map { |note| "- #{note.strip}" }.join("\n")
      else
        release_notes_text = "No release notes provided."
      end

      UI.message("Firebase Distribution (Dry Run):")
      UI.message("  App ID: #{prod_firebase_app_id}")
      UI.message("  Groups: #{prod_firebase_groups}")
      UI.message("  Release Notes:\n#{release_notes_text.gsub(/^/, '    ')}") # Indent notes
      UI.important("Dry Run: Skipping actual call to distribute_to_firebase.")
      UI.message("---")

      UI.message("Discord Notification (Dry Run):")
      UI.message("  Webhook: #{DISCORD_WEBHOOK_URL}")
      UI.message("  Title: #{prod_emoji} Betsson #{prod_title} Build Deployed")
      UI.message("  Description:\n#{release_notes_text.gsub(/^/, '    ')}") # Indent notes
      UI.message("  Fields:")
      UI.message("    Version: #{current_version}")
      UI.message("    Build: #{current_build}")
      UI.message("    Date: #{today_date}")
      UI.message("    Bundle ID (#{prod_env}): #{bundle_id}")
      UI.important("Dry Run: Skipping actual call to _notify_discord.")

    rescue => ex
      UI.error("Dry Run Simulation Error (PROD): #{ex}")
    end
    UI.success("ğŸ Betsson Dry Run Finished ğŸ")
  end
  # --- End: Dry Run Test Lane ---

end
