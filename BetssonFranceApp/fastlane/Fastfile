require 'dotenv'

# Load environment variables
Dotenv.load('.env')

ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"

# Fastfile for BetssonFranceApp
# Uses App Store Connect API Key authentication (no 2FA required)
# Supports dual accounts: UAT (GOMA) and PROD (Client)
default_platform(:ios)

# Simple mapping between Xcode schemes and internal IDs
SCHEME_MAPPING = {
  "Betsson UAT" => "BETSSON_UAT",
  "Betsson PROD" => "BETSSON_PROD"
}

# Bundle ID mappings
BUNDLE_ID_MAPPING = {
  "BETSSON_UAT" => {
    "main_app" => "com.gomagaming.betsson"
  },
  "BETSSON_PROD" => {
    "main_app" => "fr.betsson.ios.app",
    "notification_service" => "fr.betsson.ios.app.betssonNotificationsService"
  }
}

# Provisioning profile mappings
PROVISIONING_PROFILE_MAPPING = {
  "BETSSON_UAT" => {
    "com.gomagaming.betsson" => "match AdHoc com.gomagaming.betsson"
  },
  "BETSSON_PROD" => {
    "fr.betsson.ios.app" => "match AdHoc fr.betsson.ios.app",
    "fr.betsson.ios.app.betssonNotificationsService" => "match AdHoc fr.betsson.ios.app.betssonNotificationsService"
  }
}

# before_all do |lane|
#   ensure_git_status_clean unless lane == :test
#   ensure_bundle_exec
# end

after_all do |lane|
  notification(subtitle: "Fastlane", message: "#{lane} completed successfully! ðŸŽ‰")
end

error do |lane, exception|
  notification(subtitle: "Fastlane", message: "#{lane} failed with error: #{exception}")
end

platform :ios do

  # Helper: Setup App Store Connect API Key for authentication
  # Supports dual accounts: UAT (GOMA) and PROD (Client)
  lane :setup_api_key do |options|
    environment = options[:environment] || "UAT"

    if environment == "PROD"
      # Client's App Store Connect API Key
      app_store_connect_api_key(
        key_id: ENV["BFR_PROD_APP_STORE_CONNECT_API_KEY_ID"],
        issuer_id: ENV["BFR_PROD_APP_STORE_CONNECT_API_ISSUER_ID"],
        key_filepath: ENV["BFR_PROD_APP_STORE_CONNECT_API_KEY_FILEPATH"],
        in_house: false
      )
    else
      # GOMA's App Store Connect API Key (UAT)
      app_store_connect_api_key(
        key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
        issuer_id: ENV["APP_STORE_CONNECT_API_ISSUER_ID"],
        key_filepath: ENV["APP_STORE_CONNECT_API_KEY_FILEPATH"],
        in_house: false
      )
    end
  end

  desc "Print environment variables and arguments"
  lane :test do |options|
    UI.message "ðŸ” Printing Environment Variables:"
    UI.message "--------------------------------"
    ENV.sort.each do |key, value|
      UI.message "#{key} = #{value}"
    end

    UI.message "\nðŸ“ Printing Lane Options/Arguments:"
    UI.message "--------------------------------"
    if options && !options.empty?
      options.each do |key, value|
        UI.message "#{key} = #{value}"
      end
    else
      UI.message "No arguments passed to the lane"
    end
  end

  desc "Update build number"
  lane :version_bump do
    # Get current build number
    current_build = get_build_number(xcodeproj: "Sportsbook.xcodeproj")
    puts "Current build number (CURRENT_PROJECT_VERSION): #{current_build}"

    # Prompt for new build number using UI.input
    new_build = UI.input("Enter new build number (CURRENT_PROJECT_VERSION), press enter to keep current, or '+' to increment:")

    # Handle the input
    new_build = if new_build.to_s.strip.empty?
      current_build  # Keep current if empty
    elsif new_build.strip == "+"
      (current_build.to_i + 1).to_s  # Increment if +
    else
      new_build  # Use provided number
    end

    # Update build number
    increment_build_number(
      build_number: new_build,
      xcodeproj: "Sportsbook.xcodeproj",
      skip_info_plist: true
    )

    puts "Build number updated to: #{new_build}"
  end

  desc "Update marketing version"
  lane :marketing_version_bump do
    # Get current version
    current_version = get_version_number(xcodeproj: "Sportsbook.xcodeproj")
    puts "Current version (MARKETING_VERSION): #{current_version}"

    # Prompt for new version using UI.input
    new_version = UI.input("Enter new version number (MARKETING_VERSION) or press enter to keep current:")

    # Use current version if input is empty
    new_version = new_version.to_s.strip.empty? ? current_version : new_version

    # Update version
    increment_version_number(
      version_number: new_version,
      xcodeproj: "Sportsbook.xcodeproj"
    )

    puts "Version updated to: #{new_version}"
  end

  desc "Register new devices from local devices.txt and update provisioning profiles"
  lane :register_new_devices do |options|
    app_scheme = options[:app_scheme]
    internal_id = app_scheme ? SCHEME_MAPPING[app_scheme] : nil

    unless ["BETSSON_UAT", "BETSSON_PROD"].include?(internal_id)
      UI.user_error!("Please specify a valid scheme: 'Betsson UAT' or 'Betsson PROD'")
    end

    # Determine environment for API key
    environment = internal_id == "BETSSON_PROD" ? "PROD" : "UAT"

    # Setup API Key for this environment
    setup_api_key(environment: environment)

    UI.message "Starting device registration for #{app_scheme}..."

    devices_file = "./fastlane/devices.txt"
    unless File.exist?(devices_file)
      UI.message "No devices.txt found, skipping device registration"
      next
    end

    # Get team ID based on environment
    team_id = environment == "PROD" ? ENV["BETSSON_PROD_TEAM_ID"] : ENV["BETSSON_UAT_TEAM_ID"]

    # Register devices
    begin
      register_devices(
        devices_file: File.expand_path(devices_file),
        team_id: team_id
      )
      UI.success "Devices registered with Apple Developer"
    rescue => ex
      UI.message "Device registration completed (some may already exist): #{ex.message}"
    end

    # Update provisioning profiles
    match_params = {
      type: "adhoc",
      force_for_new_devices: true,
      readonly: false,
      verbose: true,
      git_url: environment == "PROD" ? ENV["MATCH_GIT_URL_PROD"] : ENV["MATCH_GIT_URL_UAT"],
      team_id: team_id,
      app_identifier: BUNDLE_ID_MAPPING[internal_id].values
    }

    if ENV["KEYCHAIN_NAME"] && ENV["KEYCHAIN_PASSWORD"]
      match_params[:keychain_name] = ENV["KEYCHAIN_NAME"]
      match_params[:keychain_password] = ENV["KEYCHAIN_PASSWORD"]
    end

    match(match_params)

    UI.success "Device registration and profile update completed!"
  end

  desc "Setup certificates and provisioning profiles (internal use only)"
  private_lane :certificates do |options|
    # Note: This lane ONLY handles match (fetching/updating provisioning profiles)
    # Device registration is handled separately by register_new_devices lane

    app_scheme = options[:app_scheme]

    # Get internal ID from scheme mapping if a scheme is provided
    internal_id = app_scheme ? SCHEME_MAPPING[app_scheme] : app_scheme

    # Determine environment for API key
    environment = internal_id == "BETSSON_PROD" ? "PROD" : "UAT"

    # Validate scheme
    unless ["BETSSON_UAT", "BETSSON_PROD"].include?(internal_id)
      UI.user_error!("Please specify a valid scheme: 'Betsson UAT' or 'Betsson PROD'")
    end

    # Setup API Key for this environment (uses context for match)
    setup_api_key(environment: environment)

    # Set Match parameters based on environment - API Key authentication via lane context
    match_params = {
      type: "adhoc",
      force_for_new_devices: true,
      readonly: false,
      force: false,
      verbose: true
    }

    case internal_id
    when "BETSSON_UAT"
      match_params.merge!({
        git_url: ENV["MATCH_GIT_URL_UAT"],
        team_id: ENV["BETSSON_UAT_TEAM_ID"],
        app_identifier: BUNDLE_ID_MAPPING[internal_id].values
      })
    when "BETSSON_PROD"
      match_params.merge!({
        git_url: ENV["MATCH_GIT_URL_PROD"],
        team_id: ENV["BETSSON_PROD_TEAM_ID"],
        app_identifier: BUNDLE_ID_MAPPING[internal_id].values
      })
    end

    # Add keychain configuration if running in CI
    if ENV["KEYCHAIN_NAME"] && ENV["KEYCHAIN_PASSWORD"]
      UI.message "Using CI keychain: #{ENV['KEYCHAIN_NAME']}"
      match_params[:keychain_name] = ENV["KEYCHAIN_NAME"]
      match_params[:keychain_password] = ENV["KEYCHAIN_PASSWORD"]
    end

    # Fetch certificates and profiles
    match(match_params)
  end

  desc "Internal: Build and distribute to Firebase"
  private_lane :build_and_distribute_to_firebase do |options|
    UI.message "Starting distribution process for Betsson France..."

    app_scheme = options[:app_scheme]
    environment = options[:environment]

    # Prompt for release notes if not provided
    release_notes = options[:release_notes]
    if release_notes.nil? || release_notes.strip.empty?
      release_notes = UI.input("Enter release notes for Firebase distribution:")
      if release_notes.strip.empty?
        release_notes = "Build #{get_build_number(xcodeproj: 'Sportsbook.xcodeproj')}"
      end
    end

    UI.message "Building for scheme: #{app_scheme}"
    UI.message "Environment: #{environment}"
    UI.message "Release notes: #{release_notes}"

    # Get internal ID from scheme mapping
    internal_id = SCHEME_MAPPING[app_scheme]
    unless internal_id
      UI.user_error!("Invalid scheme: #{app_scheme}. Must be one of: #{SCHEME_MAPPING.keys.join(', ')}")
    end

    UI.message "Using internal ID: #{internal_id}"

    # Validate scheme and environment variables
    unless ENV["#{internal_id}_FIREBASE_APP_ID"]
      UI.user_error!("Missing Firebase App ID for scheme: #{app_scheme}")
    end

    firebase_cli_token = ENV["FIREBASE_#{environment}_CLI_TOKEN"]
    firebase_groups = ENV["FIREBASE_#{environment}_DISTRIBUTION_GROUPS"] || "ios-internal"

    unless firebase_cli_token
      UI.user_error!("Missing Firebase CLI token for environment: #{environment}")
    end

    # Setup API Key and certificates (certificates lane handles API key setup)
    UI.message "Updating certificates..."
    certificates(app_scheme: app_scheme)

    # Print Xcode version
    UI.message "Xcode Version:"
    sh("xcodebuild -version")

    UI.message "Starting build process..."

    # Build app
    build_ios_app(
      scheme: app_scheme,
      workspace: "../Sportsbook.xcworkspace",
      clean: false,
      skip_profile_detection: true,
      export_method: "ad-hoc",
      export_options: {
        compileBitcode: false,
        uploadBitcode: false,
        uploadSymbols: true,
        manageAppVersionAndBuildNumber: false,
        provisioningProfiles: PROVISIONING_PROFILE_MAPPING[internal_id]
      },
      buildlog_path: "fastlane/logs",
      output_directory: "fastlane/builds"
    )

    UI.message "Build completed. Uploading to Firebase..."

    # Upload to Firebase
    firebase_app_distribution(
      app: ENV["#{internal_id}_FIREBASE_APP_ID"],
      firebase_cli_token: firebase_cli_token,
      groups: firebase_groups,
      release_notes: release_notes,
      debug: true
    )

    UI.success "Distribution completed successfully!"
  end

  desc "Keep version and distribute to UAT (SAME build, registers devices, distributes)"
  lane :keep_version_distribute_uat do |options|
    # Step 1: Register devices from devices.txt
    register_new_devices(app_scheme: "Betsson UAT")

    # Step 2: Build and distribute with updated profile
    release_notes = options[:release_notes]
    if release_notes.nil? || release_notes.strip.empty?
      current_build = get_build_number(xcodeproj: "Sportsbook.xcodeproj")
      release_notes = "Build #{current_build} - Updated device list"
    end

    build_and_distribute_to_firebase(
      app_scheme: "Betsson UAT",
      environment: "UAT",
      release_notes: release_notes
    )

    UI.success "UAT distribution completed (same build number)!"
  end

  desc "Keep version and distribute to Production (SAME build, registers devices, distributes)"
  lane :keep_version_distribute_prod do |options|
    # Step 1: Register devices from devices.txt
    register_new_devices(app_scheme: "Betsson PROD")

    # Step 2: Build and distribute with updated profile
    release_notes = options[:release_notes]
    if release_notes.nil? || release_notes.strip.empty?
      current_build = get_build_number(xcodeproj: "Sportsbook.xcodeproj")
      release_notes = "Build #{current_build} - Updated device list"
    end

    build_and_distribute_to_firebase(
      app_scheme: "Betsson PROD",
      environment: "PROD",
      release_notes: release_notes
    )

    UI.success "Production distribution completed (same build number)!"
  end

  desc "Keep version and distribute to both UAT and Production (SAME build)"
  lane :keep_version_distribute_all do |options|
    keep_version_distribute_uat(release_notes: options[:release_notes])
    keep_version_distribute_prod(release_notes: options[:release_notes])
  end

  # Main distribution lanes - call keep_version_distribute_* (includes device registration)
  lane :betsson_uat do |options|
    keep_version_distribute_uat(release_notes: options[:release_notes])
  end

  lane :betsson_prod do |options|
    keep_version_distribute_prod(release_notes: options[:release_notes])
  end

  lane :betsson do |options|
    version_bump
    betsson_uat(release_notes: options[:release_notes])
    betsson_prod(release_notes: options[:release_notes])
  end

end
