name: Tag-Based Dual Release Distribution

on:
  push:
    tags:
      - 'BCM-[0-9]*'
      - 'BCM-v[0-9]*'
      - 'bcm-[0-9]*'
      - 'bcm-v[0-9]*'
      - 'BFR-[0-9]*'
      - 'BFR-v[0-9]*'
      - 'bfr-[0-9]*'
      - 'bfr-v[0-9]*'

jobs:
  release:
    name: Build and Distribute Dual Release
    runs-on: macos-26
    timeout-minutes: 120

    steps:
      - name: Parse tag and determine configuration
        id: parse
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          echo "Processing tag: $TAG"

          # Parse tag (case-insensitive)
          # Format: CLIENT[-_]v?VERSION(BUILD)
          # Examples: BCM-2.1.3(21309), BCM-v2.1.3(21309), bcm_2.1(2100)
          if [[ $TAG =~ ^([A-Za-z]+)[-_]v?([0-9]+\.[0-9]+(\.[0-9]+)?)\(([0-9]+)\)$ ]]; then
            CLIENT=$(echo "${BASH_REMATCH[1]}" | tr '[:lower:]' '[:upper:]')  # Portable uppercase
            VERSION="${BASH_REMATCH[2]}"
            BUILD="${BASH_REMATCH[4]}"

            echo "client=$CLIENT" >> $GITHUB_OUTPUT
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "build=$BUILD" >> $GITHUB_OUTPUT
            echo "tag=$TAG" >> $GITHUB_OUTPUT

            echo "Parsed successfully:"
            echo "   Client: $CLIENT"
            echo "   Version: $VERSION"
            echo "   Build: $BUILD"
          else
            echo "::error::Invalid tag format: $TAG"
            echo "Expected format: CLIENT-VERSION(BUILD)"
            echo "Examples: BCM-2.1.3(21309), BFR-v1.5.0(15000)"
            exit 1
          fi

      - name: Validate version and build numbers
        run: |
          VERSION="${{ steps.parse.outputs.version }}"
          BUILD="${{ steps.parse.outputs.build }}"

          echo "Validating version and build numbers..."

          # Check version is >= 0.1
          if [ "$(echo "$VERSION < 0.1" | bc -l)" -eq 1 ]; then
            echo "::error::Invalid version: $VERSION (must be >= 0.1)"
            exit 1
          fi

          # Check build is >= 1
          if [ "$BUILD" -lt 1 ]; then
            echo "::error::Invalid build: $BUILD (must be >= 1)"
            exit 1
          fi

          echo "Version validation passed: v$VERSION ($BUILD)"

      - name: Initial checkout to read config
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Read configuration
        id: config
        run: |
          CLIENT="${{ steps.parse.outputs.client }}"

          # Install yq for YAML parsing
          brew install yq

          # Read configuration
          RELEASE_BRANCH=$(yq e ".clients.$CLIENT.release_branch" .github/tag-config.yml)
          STAGING_SCHEME=$(yq e ".clients.$CLIENT.staging_scheme" .github/tag-config.yml)
          PRODUCTION_SCHEME=$(yq e ".clients.$CLIENT.production_scheme" .github/tag-config.yml)
          DIRECTORY=$(yq e ".clients.$CLIENT.directory" .github/tag-config.yml)
          PROJECT=$(yq e ".clients.$CLIENT.project" .github/tag-config.yml)
          TARGET=$(yq e ".clients.$CLIENT.target" .github/tag-config.yml)
          CLIENT_NAME=$(yq e ".clients.$CLIENT.name" .github/tag-config.yml)
          CHANGELOG=$(yq e ".clients.$CLIENT.changelog" .github/tag-config.yml)
          DEVICES_FILE=$(yq e ".clients.$CLIENT.devices_file" .github/tag-config.yml)
          COLOR=$(yq e ".clients.$CLIENT.discord_color" .github/tag-config.yml)

          # Validate
          if [ "$RELEASE_BRANCH" == "null" ] || [ -z "$RELEASE_BRANCH" ]; then
            echo "::error::Configuration not found for $CLIENT in tag-config.yml"
            exit 1
          fi

          echo "release_branch=$RELEASE_BRANCH" >> $GITHUB_OUTPUT
          echo "staging_scheme=$STAGING_SCHEME" >> $GITHUB_OUTPUT
          echo "production_scheme=$PRODUCTION_SCHEME" >> $GITHUB_OUTPUT
          echo "directory=$DIRECTORY" >> $GITHUB_OUTPUT
          echo "project=$PROJECT" >> $GITHUB_OUTPUT
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "client_name=$CLIENT_NAME" >> $GITHUB_OUTPUT
          echo "changelog=$CHANGELOG" >> $GITHUB_OUTPUT
          echo "devices_file=$DEVICES_FILE" >> $GITHUB_OUTPUT
          echo "discord_color=$COLOR" >> $GITHUB_OUTPUT

          echo "Configuration loaded:"
          echo "   Release Branch: $RELEASE_BRANCH"
          echo "   Staging Scheme: $STAGING_SCHEME"
          echo "   Production Scheme: $PRODUCTION_SCHEME"
          echo "   Directory: $DIRECTORY"

      - name: Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.config.outputs.release_branch }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true
          working-directory: ${{ steps.config.outputs.directory }}

      - name: Validate tag matches Xcode project version
        working-directory: ${{ steps.config.outputs.directory }}
        run: |
          TAG_VERSION="${{ steps.parse.outputs.version }}"
          TAG_BUILD="${{ steps.parse.outputs.build }}"
          PROJECT="${{ steps.config.outputs.project }}"
          TARGET="${{ steps.config.outputs.target }}"

          echo "Validating tag version matches Xcode project..."
          echo "   Tag: v$TAG_VERSION ($TAG_BUILD)"

          # Extract version from Xcode project using fastlane-plugin-versioning (fast, no xcodebuild)
          PROJECT_VERSION=$(bundle exec fastlane run get_version_number_from_xcodeproj xcodeproj:"$PROJECT" target:"$TARGET" 2>&1 | grep -o "Result: [0-9.]*" | awk '{print $2}')
          PROJECT_BUILD=$(bundle exec fastlane run get_build_number_from_xcodeproj xcodeproj:"$PROJECT" target:"$TARGET" 2>&1 | grep -o "Result: [0-9]*" | awk '{print $2}')

          echo "   Xcode: v$PROJECT_VERSION ($PROJECT_BUILD)"

          if [ "$TAG_VERSION" != "$PROJECT_VERSION" ]; then
            echo "::error::Version mismatch! Tag has $TAG_VERSION but Xcode project has $PROJECT_VERSION"
            echo ""
            echo "Please update the Xcode project version before tagging:"
            echo "  1. Open Xcode project"
            echo "  2. Set MARKETING_VERSION to $TAG_VERSION"
            echo "  3. Commit and push"
            echo "  4. Delete this tag and recreate it"
            exit 1
          fi

          if [ "$TAG_BUILD" != "$PROJECT_BUILD" ]; then
            echo "::error::Build number mismatch! Tag has $TAG_BUILD but Xcode project has $PROJECT_BUILD"
            echo ""
            echo "Please update the Xcode project build number before tagging:"
            echo "  1. Open Xcode project"
            echo "  2. Set CURRENT_PROJECT_VERSION to $TAG_BUILD"
            echo "  3. Commit and push"
            echo "  4. Delete this tag and recreate it"
            exit 1
          fi

          echo "Version validation passed"

      - name: Read changelog and extract release notes
        id: changelog
        run: |
          VERSION="${{ steps.parse.outputs.version }}"
          BUILD="${{ steps.parse.outputs.build }}"
          CHANGELOG_FILE="${{ steps.config.outputs.changelog }}"

          echo "Reading changelog from: $CHANGELOG_FILE"

          if [ ! -f "$CHANGELOG_FILE" ]; then
            echo "Changelog file not found, using generic notes"
            NOTES="Build $BUILD - Version $VERSION"
          else
            # Find matching release in YAML (match version + build only, no environment)
            # Output each note on its own line, then prefix with bullet
            RAW_NOTES=$(yq e ".releases[] | select(.version == \"$VERSION\" and .build == $BUILD) | .notes[]" "$CHANGELOG_FILE")

            if [ -z "$RAW_NOTES" ] || [ "$RAW_NOTES" == "null" ]; then
              echo "No matching changelog entry found for v$VERSION ($BUILD)"
              NOTES="Build $BUILD - Version $VERSION"
            else
              # Prefix each line with bullet point
              NOTES=$(echo "$RAW_NOTES" | sed 's/^/- /')
              echo "Found changelog entry"
            fi
          fi

          # Store in multiline format for GitHub Actions
          {
            echo 'notes<<EOF'
            echo "$NOTES"
            echo 'EOF'
          } >> $GITHUB_OUTPUT

          echo "Release notes:"
          echo "$NOTES"

      - name: Cache SPM dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/Library/Developer/Xcode/DerivedData/*/SourcePackages
            ~/Library/Caches/org.swift.swiftpm
          key: ${{ runner.os }}-spm-${{ hashFiles('**/Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-spm-

      - name: Setup App Store Connect API Key
        working-directory: ${{ steps.config.outputs.directory }}/fastlane
        env:
          APP_STORE_CONNECT_API_KEY_CONTENT: ${{ secrets.APP_STORE_CONNECT_API_KEY_CONTENT }}
        run: |
          echo "Setting up App Store Connect API Key..."
          echo "$APP_STORE_CONNECT_API_KEY_CONTENT" > AuthKey_7NC93JSN42.p8
          chmod 600 AuthKey_7NC93JSN42.p8
          echo "API Key configured"

      - name: Setup environment variables
        working-directory: ${{ steps.config.outputs.directory }}/fastlane
        env:
          # Common secrets
          MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
          MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_API_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_ISSUER_ID }}
          FIREBASE_CLI_TOKEN: ${{ secrets.FIREBASE_CLI_TOKEN }}
          GOMA_TEAM_ID: ${{ secrets.GOMA_TEAM_ID }}
          # BCM-specific
          BETSSONCM_STG_FIREBASE_APP_ID: ${{ secrets.BETSSONCM_STG_FIREBASE_APP_ID }}
          BETSSONCM_PROD_FIREBASE_APP_ID: ${{ secrets.BETSSONCM_PROD_FIREBASE_APP_ID }}
          # BFR-specific
          BFR_MATCH_GIT_URL_PROD: ${{ secrets.BFR_MATCH_GIT_URL_PROD }}
          BFR_PROD_TEAM_ID: ${{ secrets.BFR_PROD_TEAM_ID }}
          BETSSON_UAT_FIREBASE_APP_ID: ${{ secrets.BFR_UAT_FIREBASE_APP_ID }}
          BETSSON_PROD_FIREBASE_APP_ID: ${{ secrets.BFR_PROD_FIREBASE_APP_ID }}
          FIREBASE_UAT_CLI_TOKEN: ${{ secrets.FIREBASE_CLI_TOKEN }}
          FIREBASE_PROD_CLI_TOKEN: ${{ secrets.BFR_PROD_FIREBASE_CLI_TOKEN }}
        run: |
          cat > .env << EOF
          MATCH_GIT_URL=$MATCH_GIT_URL
          MATCH_PASSWORD=$MATCH_PASSWORD
          APP_STORE_CONNECT_API_KEY_ID=$APP_STORE_CONNECT_API_KEY_ID
          APP_STORE_CONNECT_API_ISSUER_ID=$APP_STORE_CONNECT_API_ISSUER_ID
          APP_STORE_CONNECT_API_KEY_FILEPATH=./fastlane/AuthKey_7NC93JSN42.p8
          FIREBASE_CLI_TOKEN=$FIREBASE_CLI_TOKEN
          GOMA_TEAM_ID=$GOMA_TEAM_ID
          BETSSONCM_STG_FIREBASE_APP_ID=$BETSSONCM_STG_FIREBASE_APP_ID
          BETSSONCM_PROD_FIREBASE_APP_ID=$BETSSONCM_PROD_FIREBASE_APP_ID
          MATCH_GIT_URL_UAT=$MATCH_GIT_URL
          MATCH_GIT_URL_PROD=$BFR_MATCH_GIT_URL_PROD
          BETSSON_UAT_TEAM_ID=$GOMA_TEAM_ID
          BETSSON_PROD_TEAM_ID=$BFR_PROD_TEAM_ID
          BETSSON_UAT_FIREBASE_APP_ID=$BETSSON_UAT_FIREBASE_APP_ID
          BETSSON_PROD_FIREBASE_APP_ID=$BETSSON_PROD_FIREBASE_APP_ID
          FIREBASE_UAT_CLI_TOKEN=$FIREBASE_UAT_CLI_TOKEN
          FIREBASE_PROD_CLI_TOKEN=$FIREBASE_PROD_CLI_TOKEN
          EOF
          echo "Environment configured"

      - name: Setup SSH for Match
        env:
          MATCH_GIT_PRIVATE_KEY: ${{ secrets.MATCH_GIT_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$MATCH_GIT_PRIVATE_KEY" > ~/.ssh/match_deploy_key
          chmod 600 ~/.ssh/match_deploy_key
          ssh-keyscan github.com >> ~/.ssh/known_hosts
          cat > ~/.ssh/config << EOF
          Host github.com
            HostName github.com
            IdentityFile ~/.ssh/match_deploy_key
            IdentitiesOnly yes
          EOF

      - name: Setup Keychain
        run: |
          KEYCHAIN_NAME="ci-build.keychain-db"
          KEYCHAIN_PASSWORD="ci-temporary-password"
          KEYCHAIN_PATH="$HOME/Library/Keychains/$KEYCHAIN_NAME"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -t 3600 -u "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | sed s/\"//g)

          echo "KEYCHAIN_NAME=$KEYCHAIN_NAME" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV

      - name: Validate devices file exists
        working-directory: ${{ steps.config.outputs.directory }}
        run: |
          DEVICES_FILE="${{ steps.config.outputs.devices_file }}"
          echo "Checking for devices file: $DEVICES_FILE"

          if [ ! -f "$DEVICES_FILE" ]; then
            echo "WARNING: $DEVICES_FILE not found"
            echo "   Device registration will be skipped"
          else
            DEVICE_COUNT=$(grep -v "^#" "$DEVICES_FILE" | grep -v "^Device ID" | grep -v "^$" | wc -l | xargs)
            echo "Devices file found with $DEVICE_COUNT device(s)"
          fi

      - name: Build and distribute (Dual Release)
        working-directory: ${{ steps.config.outputs.directory }}
        run: |
          CLIENT="${{ steps.parse.outputs.client }}"
          VERSION="${{ steps.parse.outputs.version }}"
          BUILD="${{ steps.parse.outputs.build }}"
          NOTES="${{ steps.changelog.outputs.notes }}"
          FIREBASE_NOTES="Version $VERSION ($BUILD)"  # Generic message for public Firebase distribution

          echo "=============================================="
          echo "DUAL RELEASE: Deploying to Staging + Production"
          echo "=============================================="
          echo "   Client: $CLIENT"
          echo "   Version: v$VERSION ($BUILD)"
          echo ""

          if [ "$CLIENT" = "BCM" ]; then
            # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            # â•‘ BCM STAGING DISTRIBUTION - Comment this block to skip staging  â•‘
            # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            # echo ">>> Step 1/2: Building BCM Staging..."
            # bundle exec fastlane keep_version_distribute_staging release_notes:"$FIREBASE_NOTES"
            #
            # if [ $? -ne 0 ]; then
            #   echo "::error::BCM Staging distribution failed"
            #   exit 1
            # fi
            # echo "BCM Staging distribution complete"
            # echo ""
            # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            # â•‘ END BCM STAGING DISTRIBUTION                                   â•‘
            # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            # â•‘ BCM PRODUCTION DISTRIBUTION                                    â•‘
            # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            echo ">>> Building BCM Production..."
            bundle exec fastlane keep_version_distribute_production release_notes:"$FIREBASE_NOTES"

            if [ $? -ne 0 ]; then
              echo "::error::BCM Production distribution failed"
              exit 1
            fi
            echo "BCM Production distribution complete"
            # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            # â•‘ END BCM PRODUCTION DISTRIBUTION                                â•‘
            # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          elif [ "$CLIENT" = "BFR" ]; then
            # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            # â•‘ BFR UAT DISTRIBUTION - Comment this block to skip UAT          â•‘
            # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            echo ">>> Step 1/2: Building BFR UAT..."
            bundle exec fastlane betsson_uat release_notes:"$FIREBASE_NOTES"

            if [ $? -ne 0 ]; then
              echo "::error::BFR UAT distribution failed"
              exit 1
            fi
            echo "BFR UAT distribution complete"
            echo ""
            # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            # â•‘ END BFR UAT DISTRIBUTION                                       â•‘
            # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            # â•‘ BFR PRODUCTION DISTRIBUTION                                    â•‘
            # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            echo ">>> Step 2/2: Building BFR Production..."
            bundle exec fastlane betsson_prod release_notes:"$FIREBASE_NOTES"

            if [ $? -ne 0 ]; then
              echo "::error::BFR Production distribution failed"
              exit 1
            fi
            echo "BFR Production distribution complete"
            # â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
            # â•‘ END BFR PRODUCTION DISTRIBUTION                                â•‘
            # â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

          else
            echo "::error::Unknown client: $CLIENT"
            exit 1
          fi

          echo ""
          echo "=============================================="
          echo "DUAL RELEASE COMPLETE"
          echo "=============================================="

      - name: Send Discord success notification
        if: success()
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_TEST_RELEASE_BOT_WEBHOOK }}
        run: |
          CLIENT_NAME="${{ steps.config.outputs.client_name }}"
          VERSION="${{ steps.parse.outputs.version }}"
          BUILD="${{ steps.parse.outputs.build }}"
          TAG="${{ steps.parse.outputs.tag }}"
          NOTES="${{ steps.changelog.outputs.notes }}"

          # Random emoji flair
          EMOJIS=("ðŸš€" "ðŸŽ¯" "âœ¨" "ðŸ”¥" "ðŸ’«" "âš¡")
          RANDOM_EMOJI=${EMOJIS[$RANDOM % ${#EMOJIS[@]}]}

          # Friday easter egg
          DAY_OF_WEEK=$(date +%u)
          if [ "$DAY_OF_WEEK" = "5" ]; then
            EASTER_EGG="\n\n_Weekend deploy! Bold move._"
          else
            EASTER_EGG=""
          fi

          # Format release notes: escape quotes and convert newlines to \n for JSON
          NOTES_ESCAPED=$(printf '%s' "$NOTES" | awk '{gsub(/"/, "\\\""); printf "%s\\n", $0}' | sed 's/\\n$//')

          # Build the message content
          MESSAGE="${RANDOM_EMOJI} **${CLIENT_NAME}** â€” PROD Release\n\n"
          MESSAGE+="**Version:** ${VERSION} (${BUILD})\n"
          MESSAGE+="**Tag:** \`${TAG}\`\n\n"
          MESSAGE+="**Release Notes:**\n${NOTES_ESCAPED}\n\n"
          MESSAGE+="Deployed to Production${EASTER_EGG}"

          # Send webhook
          curl -s -X POST "$DISCORD_WEBHOOK" \
            -H "Content-Type: application/json" \
            -d "{\"content\": \"${MESSAGE}\"}"

          echo "Discord success notification sent"

      - name: Upload build artifacts (on failure)
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: fastlane-logs-${{ steps.parse.outputs.client }}-dual-release
          path: |
            ${{ steps.config.outputs.directory }}/fastlane/logs/
            ${{ steps.config.outputs.directory }}/fastlane/report.xml
          retention-days: 7

      - name: Cleanup
        if: always()
        run: |
          if [ -n "$KEYCHAIN_NAME" ]; then
            security delete-keychain "$HOME/Library/Keychains/$KEYCHAIN_NAME" 2>/dev/null || true
          fi
          rm -f ~/.ssh/match_deploy_key
          rm -f ${{ steps.config.outputs.directory }}/fastlane/.env
          rm -f ${{ steps.config.outputs.directory }}/fastlane/AuthKey_7NC93JSN42.p8
