{
  "version": "1.0.0",
  "generated": "2026-01-09T15:49:50.541Z",
  "featured": [
    "OutcomeItemView",
    "ButtonView",
    "MatchHeaderCompactView",
    "TallOddsMatchCardView",
    "CasinoGameCardView",
    "BetslipTicketView",
    "WalletDetailView",
    "BorderedTextFieldView"
  ],
  "categories": {
    "Betting": {
      "description": "Components for odds, markets, betslip, and bet placement",
      "subcategories": [
        "Odds",
        "Markets",
        "BetSlip",
        "Outcomes",
        "Cashout",
        "Tickets"
      ]
    },
    "MatchCards": {
      "description": "Match display components in various layouts",
      "subcategories": [
        "Compact",
        "Expanded",
        "Live",
        "Headers",
        "Scores"
      ]
    },
    "Navigation": {
      "description": "Tab bars, headers, toolbars, and navigation elements",
      "subcategories": [
        "TabBars",
        "Headers",
        "Toolbars",
        "Actions"
      ]
    },
    "Forms": {
      "description": "Input fields, text entry, and user data forms",
      "subcategories": [
        "TextFields",
        "Selection",
        "Sliders",
        "Validation",
        "Search"
      ]
    },
    "Filters": {
      "description": "Search, filtering, sorting, and selection controls",
      "subcategories": [
        "Pills",
        "Sports",
        "Time",
        "Leagues",
        "Options"
      ]
    },
    "Status": {
      "description": "Loading, empty states, notifications, and feedback",
      "subcategories": [
        "Loading",
        "Empty",
        "Notifications",
        "Progress",
        "Overlays"
      ]
    },
    "Promotions": {
      "description": "Banners, offers, bonuses, and promotional content",
      "subcategories": [
        "Banners",
        "Cards",
        "Bonuses",
        "ContentBlocks"
      ]
    },
    "Casino": {
      "description": "Casino game displays, categories, and game cards",
      "subcategories": [
        "Games",
        "Categories",
        "Search",
        "Grids"
      ]
    },
    "Wallet": {
      "description": "Balance, transactions, deposits, and financial displays",
      "subcategories": [
        "Balance",
        "Transactions",
        "Deposits",
        "Limits"
      ]
    },
    "Profile": {
      "description": "User profile, settings, and account management",
      "subcategories": [
        "Menu",
        "Settings",
        "Language",
        "Sharing"
      ]
    },
    "UIElements": {
      "description": "Basic UI building blocks and utility components",
      "subcategories": [
        "Buttons",
        "Labels",
        "Rows",
        "Expandable",
        "Misc"
      ]
    }
  },
  "statistics": {
    "totalComponents": 138,
    "withSnapshots": 79,
    "withReadme": 136,
    "byCategory": {
      "Promotions": 22,
      "UIElements": 14,
      "Navigation": 6,
      "Wallet": 9,
      "Betting": 27,
      "Forms": 12,
      "Casino": 9,
      "MatchCards": 11,
      "Filters": 14,
      "Status": 9,
      "Profile": 5
    },
    "byComplexity": {
      "simple": 64,
      "complex": 18,
      "composite": 56
    },
    "byMaturity": {
      "stable": 137,
      "maturing": 1
    }
  },
  "components": {
    "ActionButtonBlockView": {
      "displayName": "ActionButtonBlockView",
      "category": "Promotions",
      "subcategory": "ContentBlocks",
      "summary": "CTA button for promotional content with enabled/disabled state",
      "description": "A styled call-to-action button used in promotional detail pages. Supports customizable title text, enabled/disabled states, and triggers navigation to action URLs when tapped. Commonly used for bonus claims and marketing CTAs.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "button",
        "cta",
        "promotion",
        "bonus",
        "interactive",
        "navigation"
      ],
      "states": [
        "enabled",
        "disabled"
      ],
      "similarTo": [
        "ButtonView",
        "SingleButtonBannerView"
      ],
      "oftenUsedWith": [
        "TitleBlockView",
        "DescriptionBlockView",
        "StackViewBlockView",
        "ListBlockView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# ActionButtonBlockView\n\nA styled action button for promotional content blocks with customizable title and enabled state.\n\n## Overview\n\nActionButtonBlockView displays a prominent call-to-action button typically used in promotional sections, bonus claims, and marketing content blocks. It supports enabled/disabled states and delegates tap actions to the view model.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone component)\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Customizable button title through view model\n- Enabled/disabled state support\n- Rounded corners with fixed 8pt corner radius\n- Horizontal padding with 15pt margins\n- Fixed height of 50pt for consistent layout\n- Action URL support for navigation\n\n## Usage\n\n```swift\nlet viewModel = MockActionButtonBlockViewModel.defaultMock\nlet buttonView = ActionButtonBlockView(viewModel: viewModel)\n```\n\n## Data Model\n\n```swift\nprotocol ActionButtonBlockViewModelProtocol {\n    var title: String { get }\n    var actionName: String { get }\n    var actionURL: String? { get }\n    var isEnabled: Bool { get }\n\n    func didTapActionButton()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.highlightPrimary` - button background color\n- `StyleProvider.Color.buttonTextPrimary` - button text color\n- `StyleProvider.fontWith(type: .semibold, size: 16)` - button title font\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - enabled button with \"Claim Bonus\" title\n- `.disabledMock` - disabled button for unavailable actions\n- `.longTextMock` - button with longer \"Get Your Welcome Bonus Now\" title\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "ActionButtonBlockView/__Snapshots__/ActionButtonBlockViewSnapshotTests/testActionButtonBlockView_BasicStates_Light.1.png",
          "dark": "ActionButtonBlockView/__Snapshots__/ActionButtonBlockViewSnapshotTests/testActionButtonBlockView_BasicStates_Dark.1.png"
        },
        {
          "category": "ContentVariants",
          "light": "ActionButtonBlockView/__Snapshots__/ActionButtonBlockViewSnapshotTests/testActionButtonBlockView_ContentVariants_Light.1.png",
          "dark": "ActionButtonBlockView/__Snapshots__/ActionButtonBlockViewSnapshotTests/testActionButtonBlockView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "ActionRowView": {
      "displayName": "ActionRowView",
      "category": "UIElements",
      "subcategory": "Rows",
      "summary": "Generic tappable row for menus, settings, and action lists",
      "description": "A flexible row component for profile menus, settings screens, and action lists. Supports leading icons, titles, subtitles, trailing icons (chevron for navigation), custom backgrounds, and tap feedback animation. Two types: navigation (with chevron) and action.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "row",
        "menu",
        "settings",
        "navigation",
        "interactive",
        "profile",
        "list-item"
      ],
      "states": [
        "tappable",
        "non-tappable",
        "navigation",
        "action"
      ],
      "similarTo": [
        "InfoRowView",
        "SimpleOptionRowView"
      ],
      "oftenUsedWith": [
        "ProfileMenuListView"
      ],
      "parents": [
        "ProfileMenuListView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# ActionRowView\n\nA generic tappable row component for menu items, buttons, and action navigation.\n\n## Overview\n\nActionRowView provides a flexible row layout commonly used in profile menus, settings screens, and action lists. It supports leading icons, titles, subtitles, trailing icons, and customizable background colors with tap feedback animation.\n\n## Component Relationships\n\n### Used By (Parents)\n- `ProfileMenuListView` - displays rows in profile/settings menus\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Leading icon with system/bundle image support\n- Title and optional subtitle labels\n- Configurable trailing icon (chevron for navigation, custom icons)\n- Two row types: navigation (with chevron) and action (no chevron)\n- Custom background color support with automatic text contrast adjustment\n- Tap feedback animation with scale effect\n- Tappable/non-tappable states\n- Fixed 48pt height for consistent layout\n\n## Usage\n\n```swift\nlet item = ActionRowItem(\n    icon: \"bell\",\n    title: \"Notifications\",\n    type: .navigation,\n    action: .notifications\n)\n\nlet rowView = ActionRowView()\nrowView.configure(with: item) { tappedItem in\n    print(\"Tapped: \\(tappedItem.title)\")\n}\n```\n\n## Data Model\n\n```swift\nstruct ActionRowItem: Identifiable, Equatable, Codable {\n    let id: String\n    let icon: String\n    let title: String\n    let subtitle: String?\n    let type: ActionRowItemType  // .navigation or .action\n    let action: ActionRowAction\n    let trailingIcon: String?\n    let isTappable: Bool\n}\n\nenum ActionRowItemType: String, Codable {\n    case navigation  // Shows chevron by default\n    case action      // No default trailing icon\n}\n\nenum ActionRowAction: String, Codable {\n    case notifications, transactionHistory, changeLanguage\n    case responsibleGaming, helpCenter, changePassword\n    case logout, promotions, bonus, custom\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundSecondary` - default container background\n- `StyleProvider.Color.textPrimary` - title and subtitle text color\n- `StyleProvider.Color.highlightPrimary` - icon tint colors\n- `StyleProvider.Color.buttonTextPrimary` - text color on custom backgrounds\n- `StyleProvider.fontWith(type: .bold, size: 12)` - title font\n- `StyleProvider.fontWith(type: .regular, size: 12)` - subtitle font\n\n## Mock ViewModels\n\nThis component uses `ActionRowItem` structs directly without a dedicated mock view model. Create items inline for previews and testing.\n",
      "snapshots": [
        {
          "category": "CustomStyling",
          "light": "ActionRowView/__Snapshots__/ActionRowViewSnapshotTests/testActionRowView_CustomStyling_Light.1.png",
          "dark": "ActionRowView/__Snapshots__/ActionRowViewSnapshotTests/testActionRowView_CustomStyling_Dark.1.png"
        },
        {
          "category": "IconVariants",
          "light": "ActionRowView/__Snapshots__/ActionRowViewSnapshotTests/testActionRowView_IconVariants_Light.1.png",
          "dark": "ActionRowView/__Snapshots__/ActionRowViewSnapshotTests/testActionRowView_IconVariants_Dark.1.png"
        },
        {
          "category": "RowTypes",
          "light": "ActionRowView/__Snapshots__/ActionRowViewSnapshotTests/testActionRowView_RowTypes_Light.1.png",
          "dark": "ActionRowView/__Snapshots__/ActionRowViewSnapshotTests/testActionRowView_RowTypes_Dark.1.png"
        }
      ]
    },
    "AdaptiveTabBarView": {
      "displayName": "AdaptiveTabBarView",
      "category": "Navigation",
      "subcategory": "TabBars",
      "summary": "Multi-configuration tab bar with animated transitions",
      "description": "Dynamic tab bar supporting multiple layouts (Sports/Casino) with animated transitions. Maintains navigation history for back navigation, supports blur/solid/transparent backgrounds, and offers five animation types including 3D flips and cube rotations.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "tab-bar",
        "navigation",
        "animated",
        "multi-config",
        "main-navigation",
        "sports",
        "casino"
      ],
      "states": [
        "home",
        "casino",
        "selecting",
        "animating"
      ],
      "similarTo": [
        "QuickLinksTabBar"
      ],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# AdaptiveTabBarView Component Documentation\n\nWelcome to the documentation for the `AdaptiveTabBarView` component, a highly flexible and ViewModel-driven tab bar solution for iOS applications developed within the GomaUI framework.\n\n## Overview\n\nThe `AdaptiveTabBarView` provides a customizable tab bar UI that dynamically adapts its content and appearance based on a state provided by a ViewModel. It's designed to be robust, testable, and easy to integrate.\n\n**Key Features:**\n\n*   **ViewModel-Driven**: All UI state (tab structures, active tabs, appearances) is managed by a ViewModel, making the view itself a passive renderer.\n*   **Dynamic Content**: Supports multiple distinct tab bars (e.g., for different sections of an app like \"Home,\" \"Casino,\" \"Live Events\") and allows switching between them.\n*   **Customizable Items**: Each tab item can display an icon and a title, with distinct appearances for active and inactive states.\n*   **Inter-Tab Navigation**: Tab items can be configured to trigger a switch to a different tab bar.\n*   **Clear Separation of Concerns**: Follows a reactive pattern where the View observes a display state from the ViewModel.\n\n## Documentation Index\n\nTo help you understand and use the `AdaptiveTabBarView` effectively, the documentation is organized into the following sections:\n\n*   **[Architecture](./ARCHITECTURE.md)**: Understand the design principles and how the component is structured.\n*   **[Usage Guide](./USAGE_GUIDE.md)**: Learn how to integrate and use the component in your application.\n*   **[Data Structures](./DATA_STRUCTURES.md)**: Explore the data models that define the state and appearance of the tab bar.\n*   **[ViewModel Protocol](./VIEWMODEL_PROTOCOL.md)**: Details on the `AdaptiveTabBarViewModelProtocol` that your ViewModel must conform to.\n*   **[View Components](./VIEW_COMPONENTS.md)**: Information about the `AdaptiveTabBarView` and `AdaptiveTabBarItemView` Swift classes.\n*   **[Testing and Previews](./TESTING_AND_PREVIEWS.md)**: How to use the mock ViewModel for testing and SwiftUI Previews.\n\nWe encourage you to read through these documents to get a comprehensive understanding of the `AdaptiveTabBarView` component.",
      "snapshots": [
        {
          "category": "BackgroundModes",
          "light": "AdaptiveTabBarView/__Snapshots__/AdaptiveTabBarViewSnapshotTests/testAdaptiveTabBarView_BackgroundModes_Light.1.png",
          "dark": "AdaptiveTabBarView/__Snapshots__/AdaptiveTabBarViewSnapshotTests/testAdaptiveTabBarView_BackgroundModes_Dark.1.png"
        }
      ]
    },
    "AmountPillView": {
      "displayName": "AmountPillView",
      "category": "Wallet",
      "subcategory": "Deposits",
      "summary": "Pill-shaped button displaying monetary amount with selection",
      "description": "A single amount value displayed in a rounded pill container. Used in deposit/stake selection interfaces where users choose predefined amounts. Shows '+' prefix and inverts colors when selected.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "pill",
        "amount",
        "deposit",
        "selectable",
        "wallet",
        "quick-select"
      ],
      "states": [
        "selected",
        "unselected"
      ],
      "similarTo": [
        "PillItemView"
      ],
      "oftenUsedWith": [
        "AmountPillsContainerView"
      ],
      "parents": [
        "AmountPillsContainerView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# AmountPillView\n\nA pill-shaped button displaying a monetary amount with selection state.\n\n## Overview\n\nAmountPillView displays a single amount value in a rounded pill container. It's used as part of amount selection interfaces where users can pick from predefined deposit or stake amounts. The component updates reactively based on selection state changes.\n\n## Component Relationships\n\n### Used By (Parents)\n- `AmountPillsContainerView` - displays multiple pills in a horizontal scrollable container\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Displays amount with \"+\" prefix\n- Selected/unselected visual states\n- Reactive updates via Combine publisher\n- Fixed 32pt height with 16pt horizontal padding\n- Rounded corners (16pt radius) for pill appearance\n- Automatic color inversion on selection\n\n## Usage\n\n```swift\nlet pillData = AmountPillData(id: \"500\", amount: \"500\", isSelected: false)\nlet viewModel = MockAmountPillViewModel(pillData: pillData)\nlet pillView = AmountPillView(viewModel: viewModel)\n```\n\n## Data Model\n\n```swift\nstruct AmountPillData: Equatable, Hashable {\n    let id: String\n    let amount: String\n    let isSelected: Bool\n}\n\nprotocol AmountPillViewModelProtocol {\n    var pillDataPublisher: AnyPublisher<AmountPillData, Never> { get }\n    func setSelected(_ isSelected: Bool)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.navPills` - unselected background color\n- `StyleProvider.Color.highlightPrimary` - selected background color\n- `StyleProvider.Color.textPrimary` - unselected text color\n- `StyleProvider.Color.buttonTextPrimary` - selected text color\n- `StyleProvider.fontWith(type: .bold, size: 12)` - amount label font\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - unselected pill with \"250\" amount\n- `.selectedMock` - selected pill with \"250\" amount\n",
      "snapshots": [
        {
          "category": "ContentVariants",
          "light": "AmountPillView/__Snapshots__/AmountPillViewSnapshotTests/testAmountPillView_ContentVariants_Light.1.png",
          "dark": "AmountPillView/__Snapshots__/AmountPillViewSnapshotTests/testAmountPillView_ContentVariants_Dark.1.png"
        },
        {
          "category": "SelectionStates",
          "light": "AmountPillView/__Snapshots__/AmountPillViewSnapshotTests/testAmountPillView_SelectionStates_Light.1.png",
          "dark": "AmountPillView/__Snapshots__/AmountPillViewSnapshotTests/testAmountPillView_SelectionStates_Dark.1.png"
        }
      ]
    },
    "AmountPillsContainerView": {
      "displayName": "AmountPillsView",
      "category": "Wallet",
      "subcategory": "Deposits",
      "summary": "Horizontal scrollable container of amount selection pills",
      "description": "Manages a collection of AmountPillView components in a horizontal scroll view. Handles single selection, provides selection callbacks, and commonly used for quick deposit amount selection in first deposit bonus flows.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "container",
        "scrollable",
        "amount",
        "deposit",
        "selectable",
        "wallet",
        "quick-select"
      ],
      "states": [
        "none-selected",
        "one-selected"
      ],
      "similarTo": [
        "PillSelectorBarView"
      ],
      "oftenUsedWith": [
        "AmountPillView",
        "DepositBonusInfoView"
      ],
      "parents": [],
      "children": [
        "AmountPillView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# AmountPillsContainerView\n\nA horizontally scrollable container displaying multiple amount selection pills.\n\n## Overview\n\nAmountPillsView (located in AmountPillsContainerView folder) manages a collection of AmountPillView components in a horizontal scroll view. It handles pill selection, maintains selection state, and provides callbacks for amount selection events. Commonly used for quick deposit amount selection.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone component)\n\n### Uses (Children)\n- `AmountPillView` - individual pill buttons for each amount option\n\n## Features\n\n- Horizontal scrollable pill container\n- Single selection management (one pill selected at a time)\n- Reactive state updates via Combine\n- Selection callback for parent integration\n- Hidden scroll indicators for clean appearance\n- 12pt spacing between pills\n- Fixed 40pt container height\n\n## Usage\n\n```swift\nlet viewModel = MockAmountPillsViewModel.defaultMock\nlet pillsView = AmountPillsView(viewModel: viewModel)\n\npillsView.onPillSelected = { amountId in\n    print(\"Selected amount: \\(amountId)\")\n}\n```\n\n## Data Model\n\n```swift\nstruct AmountPillsData: Equatable {\n    let id: String\n    let pills: [AmountPillData]\n    let selectedPillId: String?\n}\n\nprotocol AmountPillsViewModelProtocol {\n    var pillsDataPublisher: AnyPublisher<AmountPillsData, Never> { get }\n    var pillsDataSubject: CurrentValueSubject<AmountPillsData, Never> { get }\n\n    func selectPill(withId id: String)\n    func clearSelection()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- Inherits styling from child `AmountPillView` components\n- Clear background for scroll view container\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - 8 pills (250, 500, 1000, 2000, 3000, 5000, 10000, 20000) with no selection\n- `.selectedMock` - 4 pills with 500 pre-selected\n",
      "snapshots": []
    },
    "BetDetailResultSummaryView": {
      "displayName": "BetDetailResultSummaryView",
      "category": "Betting",
      "subcategory": "Tickets",
      "summary": "Match details card with color-coded bet result status",
      "description": "Two-card stacked layout showing match information with bet type in top card, and color-coded result status pill (won/lost/draw/open) in bottom card. Used in My Bets detail screens.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "bet-detail",
        "result",
        "status",
        "match",
        "ticket",
        "won",
        "lost"
      ],
      "states": [
        "won",
        "lost",
        "draw",
        "open"
      ],
      "similarTo": [
        "BetTicketStatusView"
      ],
      "oftenUsedWith": [
        "BetDetailValuesSummaryView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BetDetailResultSummaryView\n\nA card displaying match details and bet result status with visual indicators.\n\n## Overview\n\nBetDetailResultSummaryView presents a two-card layout showing match information with bet type in the top card, and a result status pill in the bottom card. The result pill uses color-coded states to indicate won, lost, draw, or open (pending) outcomes.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone component)\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Two-card stacked layout with 8pt spacing\n- Match details with bet type description\n- Color-coded result pill (won/lost/draw/open)\n- Reactive updates via Combine publisher\n- Rounded 8pt corners on container and inner cards\n- Localized result labels\n\n## Usage\n\n```swift\nlet viewModel = MockBetDetailResultSummaryViewModel.wonMock()\nlet summaryView = BetDetailResultSummaryView(viewModel: viewModel)\n```\n\n## Data Model\n\n```swift\nenum BetDetailResultState: Equatable {\n    case won\n    case lost\n    case draw\n    case open\n}\n\nstruct BetDetailResultSummaryData: Equatable {\n    let matchDetails: String\n    let betType: String\n    let resultState: BetDetailResultState\n}\n\nprotocol BetDetailResultSummaryViewModelProtocol {\n    var dataPublisher: AnyPublisher<BetDetailResultSummaryData, Never> { get }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundSecondary` - outer container background\n- `StyleProvider.Color.backgroundTertiary` - inner card backgrounds\n- `StyleProvider.Color.textPrimary` - match details and bet type text\n- `StyleProvider.Color.alertSuccess` - won pill background\n- `StyleProvider.Color.alertWarning` - draw pill background\n- `StyleProvider.Color.alertError` - lost pill text\n- `StyleProvider.Color.backgroundGradient2` - lost pill background\n- `StyleProvider.fontWith(type: .bold, size: 14)` - match details font\n- `StyleProvider.fontWith(type: .regular, size: 14)` - bet type and result label fonts\n- `StyleProvider.fontWith(type: .semibold, size: 12)` - result pill label font\n\n## Mock ViewModels\n\nAvailable presets:\n- `.wonMock()` - green \"Won\" pill state\n- `.lostMock()` - red \"Lost\" pill state\n- `.drawMock()` - yellow \"Draw\" pill state\n- `.customMock(matchDetails:betType:resultState:)` - custom configuration\n",
      "snapshots": [
        {
          "category": "ResultStates",
          "light": "BetDetailResultSummaryView/__Snapshots__/BetDetailResultSummaryViewSnapshotTests/testBetDetailResultSummaryView_ResultStates_Light.1.png",
          "dark": "BetDetailResultSummaryView/__Snapshots__/BetDetailResultSummaryViewSnapshotTests/testBetDetailResultSummaryView_ResultStates_Dark.1.png"
        }
      ]
    },
    "BetDetailRowView": {
      "displayName": "BetDetailRowView",
      "category": "Betting",
      "subcategory": "Tickets",
      "summary": "Label-value row for bet details with corner radius styles",
      "description": "Single row with left-aligned label and right-aligned value. Supports standard and header display styles, configurable corner radius (none/top/bottom/all) for grouped lists. Fixed 52pt height.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "row",
        "bet-detail",
        "label-value",
        "ticket",
        "odds",
        "amount"
      ],
      "states": [
        "standard",
        "header"
      ],
      "similarTo": [
        "InfoRowView",
        "BetSummaryRowView"
      ],
      "oftenUsedWith": [
        "BetDetailValuesSummaryView"
      ],
      "parents": [
        "BetDetailValuesSummaryView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BetDetailRowView\n\nA label-value row for displaying bet details with configurable corner radius styles.\n\n## Overview\n\nBetDetailRowView displays a single row with a left-aligned label and right-aligned value. It supports two display styles (standard and header) and configurable corner radius for use in grouped lists. The component is designed for bet detail screens showing odds, amounts, and other transactional information.\n\n## Component Relationships\n\n### Used By (Parents)\n- `BetDetailValuesSummaryView` - displays multiple rows in a summary card\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Label-value pair layout with left/right alignment\n- Two display styles: standard and header (centered)\n- Four corner radius options: none, topOnly, bottomOnly, all\n- Fixed 52pt height for consistent layout\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockBetDetailRowViewModel.defaultMock()\nlet rowView = BetDetailRowView(viewModel: viewModel, cornerStyle: .topOnly(radius: 8))\n```\n\n## Data Model\n\n```swift\nenum BetDetailRowCornerStyle {\n    case none\n    case topOnly(radius: CGFloat)\n    case bottomOnly(radius: CGFloat)\n    case all(radius: CGFloat)\n}\n\nenum BetDetailRowStyle {\n    case standard   // Left-aligned label, right-aligned value\n    case header     // Centered text, value hidden\n}\n\nstruct BetDetailRowData: Equatable {\n    let label: String\n    let value: String\n    let style: BetDetailRowStyle\n}\n\nprotocol BetDetailRowViewModelProtocol {\n    var dataPublisher: AnyPublisher<BetDetailRowData, Never> { get }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundTertiary` - row background\n- `StyleProvider.Color.textPrimary` - value text and header label\n- `StyleProvider.Color.textSecondary` - standard label text\n- `StyleProvider.fontWith(type: .regular, size: 14)` - label font\n- `StyleProvider.fontWith(type: .bold, size: 14)` - value font\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock()` - \"Amount\" / \"XAF 100.75\" standard row\n- `.headerMock()` - \"Bet Placed on Sun 01/01 - 18:59\" centered header\n- `.customMock(label:value:style:)` - custom configuration\n",
      "snapshots": []
    },
    "BetDetailValuesSummaryView": {
      "displayName": "BetDetailValuesSummaryView",
      "category": "Betting",
      "subcategory": "Tickets",
      "summary": "Grouped card displaying bet values in header-content-footer layout",
      "description": "Organizes BetDetailRowView components into structured summary card with optional header (date), content rows (odds, amounts, stake), and optional footer (result). Used in My Bets detail screens.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "summary",
        "card",
        "bet-detail",
        "grouped",
        "ticket",
        "values"
      ],
      "states": [
        "with-header",
        "without-header",
        "with-footer",
        "without-footer"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "BetDetailRowView",
        "BetDetailResultSummaryView"
      ],
      "parents": [],
      "children": [
        "BetDetailRowView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BetDetailValuesSummaryView\n\nA grouped container displaying bet values in a header-content-footer card layout.\n\n## Overview\n\nBetDetailValuesSummaryView organizes multiple BetDetailRowView components into a structured summary card with optional header (date), content rows (bet values like odds, amounts, stake), and optional footer (result). The component uses internal 8pt padding and 1pt spacing between content rows for visual separation.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone component)\n\n### Uses (Children)\n- `BetDetailRowView` - individual rows for header, content, and footer sections\n\n## Features\n\n- Three-section layout: header, content, footer\n- Optional header and footer rows\n- Dynamic content row count\n- Automatic corner radius handling per row position\n- Reactive updates via Combine publisher\n- 8pt internal padding around content stack\n\n## Usage\n\n```swift\nlet viewModel = MockBetDetailValuesSummaryViewModel.defaultMock()\nlet summaryView = BetDetailValuesSummaryView(viewModel: viewModel)\n```\n\n## Data Model\n\n```swift\nstruct BetDetailValuesSummaryData: Equatable {\n    let headerRow: BetDetailRowData?     // Optional header (e.g., date)\n    let contentRows: [BetDetailRowData]  // Main value rows\n    let footerRow: BetDetailRowData?     // Optional footer (e.g., result)\n}\n\nprotocol BetDetailValuesSummaryViewModelProtocol {\n    var dataPublisher: AnyPublisher<BetDetailValuesSummaryData, Never> { get }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundPrimary` - section container backgrounds\n- Inherits styling from child `BetDetailRowView` components\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock()` - full layout with header (date), 6 content rows, footer (result)\n- `.singleRowMock()` - minimal layout with single \"Total Amount\" row\n- `.customMock(headerRow:contentRows:footerRow:)` - custom configuration\n",
      "snapshots": [
        {
          "category": "LayoutVariants",
          "light": "BetDetailValuesSummaryView/__Snapshots__/BetDetailValuesSummaryViewSnapshotTests/testBetDetailValuesSummaryView_LayoutVariants_Light.1.png",
          "dark": "BetDetailValuesSummaryView/__Snapshots__/BetDetailValuesSummaryViewSnapshotTests/testBetDetailValuesSummaryView_LayoutVariants_Dark.1.png"
        }
      ]
    },
    "BetInfoSubmissionView": {
      "displayName": "BetInfoSubmissionView",
      "category": "Betting",
      "subcategory": "BetSlip",
      "summary": "Complete bet submission form with summary, input, and place bet action",
      "description": "Comprehensive bet placement interface with bet summary rows (odds, potential winnings, win bonus, payout), amount input field, quick-add buttons (+100, +250, +500), and place bet button. Used in Sports and Virtual betslip screens.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "betslip",
        "submission",
        "form",
        "input",
        "place-bet",
        "odds",
        "stake"
      ],
      "states": [
        "enabled",
        "disabled",
        "validating"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "BetSummaryRowView",
        "BorderedTextFieldView",
        "ButtonView",
        "QuickAddButtonView"
      ],
      "parents": [],
      "children": [
        "BetSummaryRowView",
        "BorderedTextFieldView",
        "ButtonView",
        "QuickAddButtonView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BetInfoSubmissionView\n\nA comprehensive bet submission form with summary, amount input, and place bet action.\n\n## Overview\n\nBetInfoSubmissionView provides the complete bet placement interface including bet summary rows (odds, potential winnings, win bonus, payout), an amount input field with quick-add buttons (+100, +250, +500), and a place bet button. The component coordinates multiple child view models for a cohesive betting experience.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone component, typically used in betslip screens)\n\n### Uses (Children)\n- `BetSummaryRowView` - displays odds, potential winnings, win bonus, and payout rows\n- `BorderedTextFieldView` - amount input field\n- `ButtonView` - place bet button\n- `QuickAddButtonView` - quick amount add buttons (+100, +250, +500)\n\n## Features\n\n- Four bet summary rows with live values\n- Amount text field with numeric keyboard\n- Three quick-add buttons for common amounts\n- Place bet button with dynamic title showing amount\n- Enabled/disabled state management\n- Ticket validation integration\n- Return key dismisses keyboard\n- Reactive updates via Combine publisher\n- Currency-aware formatting\n\n## Usage\n\n```swift\nlet viewModel = MockBetInfoSubmissionViewModel.defaultMock(currency: \"XAF\")\nlet submissionView = BetInfoSubmissionView(viewModel: viewModel)\n\nviewModel.onPlaceBetTapped = {\n    print(\"Place bet tapped with amount: \\(viewModel.currentData.amount)\")\n}\n```\n\n## Data Model\n\n```swift\nstruct BetInfoSubmissionData: Equatable {\n    let odds: String\n    let potentialWinnings: String\n    let winBonus: String\n    let payout: String\n    let amount: String\n    let placeBetAmount: String\n    let isEnabled: Bool\n    let currency: String\n}\n\nprotocol BetInfoSubmissionViewModelProtocol {\n    var dataPublisher: AnyPublisher<BetInfoSubmissionData, Never> { get }\n    var currentData: BetInfoSubmissionData { get }\n\n    // Child view models\n    var oddsRowViewModel: BetSummaryRowViewModelProtocol { get }\n    var potentialWinningsRowViewModel: BetSummaryRowViewModelProtocol { get }\n    var winBonusRowViewModel: BetSummaryRowViewModelProtocol { get }\n    var payoutRowViewModel: BetSummaryRowViewModelProtocol { get }\n    var amount100ButtonViewModel: QuickAddButtonViewModelProtocol { get }\n    var amount250ButtonViewModel: QuickAddButtonViewModelProtocol { get }\n    var amount500ButtonViewModel: QuickAddButtonViewModelProtocol { get }\n    var amountTextFieldViewModel: BorderedTextFieldViewModelProtocol { get }\n    var placeBetButtonViewModel: ButtonViewModelProtocol { get }\n\n    // Actions\n    func onQuickAddTapped(_ amount: Int)\n    func onAmountChanged(_ amount: String)\n    var onPlaceBetTapped: (() -> Void)? { get set }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundSecondary` - container background with 8pt corner radius\n- Inherits styling from child components\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock(currency:)` - empty state with zero values\n- `.withAmountsMock(potentialWinnings:winBonus:payout:amount:currency:)` - preset values\n- `.disabledMock(currency:)` - disabled state\n",
      "snapshots": [
        {
          "category": "States",
          "light": "BetInfoSubmissionView/__Snapshots__/BetInfoSubmissionViewSnapshotTests/testBetInfoSubmissionView_States_Light.1.png",
          "dark": "BetInfoSubmissionView/__Snapshots__/BetInfoSubmissionViewSnapshotTests/testBetInfoSubmissionView_States_Dark.1.png"
        }
      ]
    },
    "BetSummaryRowView": {
      "displayName": "BetSummaryRowView",
      "category": "Betting",
      "subcategory": "BetSlip",
      "summary": "Title-value pair row for bet summary information",
      "description": "Horizontal row with left-aligned title (semibold) and right-aligned value (bold). Used in betslip for showing odds, potential winnings, bonuses, and payout amounts. Supports enabled/disabled states with alpha dimming.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "row",
        "summary",
        "betslip",
        "odds",
        "winnings",
        "payout"
      ],
      "states": [
        "enabled",
        "disabled"
      ],
      "similarTo": [
        "BetDetailRowView",
        "InfoRowView"
      ],
      "oftenUsedWith": [
        "BetInfoSubmissionView"
      ],
      "parents": [
        "BetInfoSubmissionView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BetSummaryRowView\n\nA single row displaying a title-value pair for bet summary information.\n\n## Overview\n\nBetSummaryRowView displays a horizontal row with a left-aligned title and right-aligned value, commonly used for showing bet odds, potential winnings, bonuses, and payout amounts. The component supports enabled/disabled states with visual feedback.\n\n## Component Relationships\n\n### Used By (Parents)\n- `BetInfoSubmissionView` - displays odds, potential winnings, win bonus, and payout rows\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Left-aligned title with semibold styling\n- Right-aligned value with bold styling\n- Enabled/disabled state with alpha dimming (0.5)\n- Reactive updates via Combine publisher\n- Minimal layout with flexible width between title and value\n\n## Usage\n\n```swift\nlet viewModel = MockBetSummaryRowViewModel.potentialWinningsMock()\nlet rowView = BetSummaryRowView(viewModel: viewModel)\n```\n\n## Data Model\n\n```swift\nstruct BetSummaryRowData: Equatable {\n    let title: String\n    let value: String\n    let isEnabled: Bool\n}\n\nprotocol BetSummaryRowViewModelProtocol {\n    var dataPublisher: AnyPublisher<BetSummaryRowData, Never> { get }\n    var currentData: BetSummaryRowData { get }\n\n    func updateTitle(_ title: String)\n    func updateValue(_ value: String)\n    func setEnabled(_ isEnabled: Bool)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.textPrimary` - both title and value text color\n- `StyleProvider.fontWith(type: .semibold, size: 10)` - title font\n- `StyleProvider.fontWith(type: .bold, size: 12)` - value font\n\n## Mock ViewModels\n\nAvailable presets:\n- `.oddsMock()` - \"ODDS\" / \"0.00\"\n- `.potentialWinningsMock()` - \"POTENTIAL WINNINGS\" / \"XAF 0\"\n- `.winBonusMock()` - \"X% WIN BONUS\" / \"XAF 0\"\n- `.payoutMock()` - \"PAYOUT\" / \"XAF 0\"\n- `.disabledMock()` - \"TITLE\" / \"VALUE\" with isEnabled: false\n",
      "snapshots": []
    },
    "BetTicketStatusView": {
      "displayName": "BetTicketStatusView",
      "category": "Betting",
      "subcategory": "Tickets",
      "summary": "Color-coded status indicator for bet ticket outcomes",
      "description": "Displays bet result status with icon and label using color-coded backgrounds. Shows won (green), lost (red), draw (yellow), or cashed out states. Fixed 48pt height.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "status",
        "ticket",
        "result",
        "won",
        "lost",
        "cashed-out",
        "indicator"
      ],
      "states": [
        "won",
        "lost",
        "draw",
        "cashedOut"
      ],
      "similarTo": [
        "BetDetailResultSummaryView"
      ],
      "oftenUsedWith": [
        "TicketBetInfoView"
      ],
      "parents": [
        "TicketBetInfoView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BetTicketStatusView\n\nA color-coded status indicator for bet ticket outcomes.\n\n## Overview\n\nBetTicketStatusView displays the result status of a settled bet ticket with an icon and label. It uses color-coded backgrounds and icons to visually communicate won, lost, draw, or cashed out states.\n\n## Component Relationships\n\n### Used By (Parents)\n- `TicketBetInfoView` - displays ticket status within bet info cards\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Four status states: won, lost, draw, cashedOut\n- Color-coded backgrounds per state\n- Status icon with tint color matching state\n- Localized status labels\n- Fixed 48pt height with 16pt horizontal padding\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockBetTicketStatusViewModel.wonMock()\nlet statusView = BetTicketStatusView(viewModel: viewModel)\n```\n\n## Data Model\n\n```swift\nenum BetTicketStatus: Equatable {\n    case won\n    case lost\n    case draw\n    case cashedOut\n}\n\nstruct BetTicketStatusData: Equatable {\n    let status: BetTicketStatus\n}\n\nprotocol BetTicketStatusViewModelProtocol {\n    var dataPublisher: AnyPublisher<BetTicketStatusData, Never> { get }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.highlightSecondary` - won background\n- `StyleProvider.Color.backgroundGradient2` - lost background\n- `StyleProvider.Color.alertWarning` - draw background\n- `StyleProvider.Color.buttonBackgroundSecondary` - cashed out background\n- `StyleProvider.Color.alertError` - lost text color\n- `StyleProvider.Color.allWhite` - default text and icon color\n- `StyleProvider.fontWith(type: .bold, size: 16)` - status label font\n\n## Mock ViewModels\n\nAvailable presets:\n- `.wonMock()` - green \"Won\" state with checkmark icon\n- `.lostMock()` - red \"Lost\" state (icon hidden)\n- `.drawMock()` - yellow \"Draw\" state (icon hidden)\n- `.cashedOutMock()` - secondary \"Cashed Out\" state (icon hidden)\n",
      "snapshots": [
        {
          "category": "StatusStates",
          "light": "BetTicketStatusView/__Snapshots__/BetTicketStatusViewSnapshotTests/testBetTicketStatusView_StatusStates_Light.1.png",
          "dark": "BetTicketStatusView/__Snapshots__/BetTicketStatusViewSnapshotTests/testBetTicketStatusView_StatusStates_Dark.1.png"
        }
      ]
    },
    "BetslipFloatingView": {
      "displayName": "BetslipFloatingView",
      "category": "Betting",
      "subcategory": "BetSlip",
      "summary": "Floating betslip indicator with selection count and odds boost progress",
      "description": "Two variants (tall/thin) for floating betslip status overlays. Tall shows odds boost promotion progress with animated segments. Auto-hides when no tickets. Shadow effect, tap opens betslip.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "floating",
        "overlay",
        "betslip",
        "indicator",
        "odds-boost",
        "animated"
      ],
      "states": [
        "noTickets",
        "withTickets",
        "boostProgress"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "AdaptiveTabBarView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BetslipFloatingView\n\nFloating betslip indicators showing selection count and odds boost progress.\n\n## Overview\n\nBetslipFloatingView provides two view variants (tall and thin) for displaying betslip status as floating overlays. The tall variant shows odds boost promotion progress with animated segments, while the thin variant provides a compact display. Both hide automatically when no tickets are present.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone floating component, typically anchored to bottom of screen)\n\n### Uses (Children)\n- `ProgressSegments` (internal) - animated progress bar segments\n\n## Features\n\n- Two display variants: `BetslipFloatingTallView` and `BetslipFloatingThinView`\n- Odds boost promotion display with percentage tiers\n- Animated progress segments showing selections toward boost\n- Auto-hide when no tickets or no boost available\n- Shadow effect for floating appearance\n- Tap gesture for opening betslip\n- 12pt corner radius on container\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\n// Tall variant with boost progress\nlet viewModel = MockBetslipFloatingViewModel(\n    state: .withTickets(\n        selectionCount: 2,\n        odds: \"5.71\",\n        winBoostPercentage: nil,\n        totalEligibleCount: 3,\n        nextTierPercentage: \"5%\"\n    )\n)\nlet floatingView = BetslipFloatingTallView(viewModel: viewModel)\n```\n\n## Data Model\n\n```swift\nenum BetslipFloatingState: Equatable {\n    case noTickets\n    case withTickets(\n        selectionCount: Int,\n        odds: String,\n        winBoostPercentage: String?,\n        totalEligibleCount: Int,\n        nextTierPercentage: String?\n    )\n}\n\nstruct BetslipFloatingData: Equatable {\n    let state: BetslipFloatingState\n    let isEnabled: Bool\n}\n\nprotocol BetslipFloatingViewModelProtocol {\n    var dataPublisher: AnyPublisher<BetslipFloatingData, Never> { get }\n    var currentData: BetslipFloatingData { get }\n    var onBetslipTapped: (() -> Void)? { get set }\n    func updateState(_ state: BetslipFloatingState)\n    func setEnabled(_ isEnabled: Bool)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundGradient2` - container background\n- `StyleProvider.Color.highlightPrimary` - title and boost icon color\n- `StyleProvider.Color.textPrimary` - heading text color\n- `StyleProvider.Color.textSecondary` - description text color\n- `StyleProvider.fontWith(type: .bold, size: 12)` - title font\n- `StyleProvider.fontWith(type: .bold, size: 16)` - heading font\n- `StyleProvider.fontWith(type: .regular, size: 12)` - description font\n\n## Mock ViewModels\n\nAvailable via `MockBetslipFloatingViewModel(state:isEnabled:)`:\n- `.noTickets` - hidden state\n- `.withTickets(selectionCount:odds:winBoostPercentage:totalEligibleCount:nextTierPercentage:)` - visible with progress\n",
      "snapshots": [
        {
          "category": "States",
          "light": "BetslipFloatingView/__Snapshots__/BetslipFloatingViewSnapshotTests/testBetslipFloatingView_States_Light.1.png",
          "dark": "BetslipFloatingView/__Snapshots__/BetslipFloatingViewSnapshotTests/testBetslipFloatingView_States_Dark.1.png"
        }
      ]
    },
    "BetslipHeaderView": {
      "displayName": "BetslipHeaderView",
      "category": "Betting",
      "subcategory": "BetSlip",
      "summary": "Betslip header adapting to user authentication state",
      "description": "Shows balance for logged-in users or Join Now/Log In buttons for guests. Betslip icon and title on left, close button always visible. Used at top of betslip screens.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "header",
        "betslip",
        "auth",
        "balance",
        "login"
      ],
      "states": [
        "loggedIn",
        "notLoggedIn",
        "enabled",
        "disabled"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "BetslipOddsBoostHeaderView",
        "BetslipTicketView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BetslipHeaderView\n\nA betslip header displaying user authentication state with balance or login prompts.\n\n## Overview\n\nBetslipHeaderView adapts its content based on user authentication status. For logged-in users, it shows their balance. For guests, it displays \"Join Now\" and \"Log In\" action buttons. A close button is always visible for dismissing the betslip.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone component, typically at top of betslip screen)\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Two authentication states: notLoggedIn and loggedIn\n- Betslip icon with title on left side\n- Auth buttons with underline styling for guests\n- Balance display for logged-in users\n- Close button always visible on right\n- Enabled/disabled state with alpha dimming\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockBetslipHeaderViewModel.loggedInMock()\nlet headerView = BetslipHeaderView(viewModel: viewModel)\n\nviewModel.onCloseTapped = {\n    // Dismiss betslip\n}\n```\n\n## Data Model\n\n```swift\nenum BetslipHeaderState: Equatable {\n    case notLoggedIn\n    case loggedIn(balance: String)\n}\n\nstruct BetslipHeaderData: Equatable {\n    let state: BetslipHeaderState\n    let isEnabled: Bool\n}\n\nprotocol BetslipHeaderViewModelProtocol {\n    var dataPublisher: AnyPublisher<BetslipHeaderData, Never> { get }\n    var currentData: BetslipHeaderData { get }\n    func updateState(_ state: BetslipHeaderState)\n    func setEnabled(_ isEnabled: Bool)\n\n    var onJoinNowTapped: (() -> Void)? { get set }\n    var onLogInTapped: (() -> Void)? { get set }\n    var onCloseTapped: (() -> Void)? { get set }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundPrimary` - container background\n- `StyleProvider.Color.highlightPrimary` - betslip icon and close button tint\n- `StyleProvider.Color.highlightPrimaryContrast` - text and button colors\n- `StyleProvider.fontWith(type: .bold, size: 14)` - betslip title and balance value font\n- `StyleProvider.fontWith(type: .regular, size: 14)` - balance label font\n- `StyleProvider.fontWith(type: .medium, size: 14)` - auth button underlined font\n\n## Mock ViewModels\n\nAvailable presets:\n- `.notLoggedInMock()` - shows Join Now | or | Log In buttons\n- `.loggedInMock()` - shows \"Balance: XAF 50,000\"\n",
      "snapshots": [
        {
          "category": "AuthStates",
          "light": "BetslipHeaderView/__Snapshots__/BetslipHeaderViewSnapshotTests/testBetslipHeaderView_AuthStates_Light.1.png",
          "dark": "BetslipHeaderView/__Snapshots__/BetslipHeaderViewSnapshotTests/testBetslipHeaderView_AuthStates_Dark.1.png"
        }
      ]
    },
    "BetslipOddsBoostHeaderView": {
      "displayName": "BetslipOddsBoostHeaderView",
      "category": "Betting",
      "subcategory": "BetSlip",
      "summary": "Odds boost promotion progress header in betslip",
      "description": "Shows user progress toward earning odds boost on bets. Displays boost icon, tier info, remaining selections needed, and animated progress segments. Positioned below BetslipHeaderView.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "header",
        "betslip",
        "odds-boost",
        "promotion",
        "progress",
        "animated"
      ],
      "states": [
        "active",
        "maxBoost",
        "enabled",
        "disabled"
      ],
      "similarTo": [
        "BetslipFloatingView"
      ],
      "oftenUsedWith": [
        "BetslipHeaderView",
        "BetslipTicketView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BetslipOddsBoostHeaderView\n\nA header component that displays odds boost promotion with animated progress tracking, designed to be positioned at the top of the betslip to encourage users to add more qualifying selections.\n\n## Architecture\n\n**Pattern**: MVVM with Combine publishers\n**Parent**: UIView\n**Protocol**: `BetslipOddsBoostHeaderViewModelProtocol`\n**Shared Component**: Uses `ProgressSegmentView` from `Components/Shared/`\n\n## Visual Design\n\nMatches Figma specification with three sections:\n\n1. **Title**: \"You're almost there!\" (12px bold orange)\n2. **Icon + Text Stack**: 32x32 boost icon + heading + description\n3. **Progress Segments**: Animated progress bar (8px height, 2px gaps)\n\n```\n\n [16px padding all sides]                \n                                         \n  You're almost there!  (12px bold )     Section 1\n  [16px gap]                            \n    Get a 3% Win Boost (16px B)    Section 2\n      by adding 2 more legs to     \n    your betslip (1.2 min odds). \n  32x32   (12px regular gray)           \n  [16px gap]                            \n                 Section 3\n                                         \n\n```\n\n## State Management\n\n**Component displays odds boost data only.** ViewController is responsible for showing/hiding the entire component based on whether odds boost is available.\n\nThe state struct contains:\n- **Selection count** - Current qualifying selections in betslip\n- **Total eligible count** - Selections needed to reach boost\n- **Next tier percentage** - Next boost level (e.g., \"5%\")\n- **Current boost percentage** - Current boost if max reached\n\nThe component always renders when visible - there is no \"hidden\" state in the data model.\n\n## Usage\n\n### Basic Implementation\n\n```swift\n\n\nclass BetslipViewController: UIViewController {\n    private let viewModel = BetslipOddsBoostHeaderViewModel()\n    private lazy var headerView = BetslipOddsBoostHeaderView(viewModel: viewModel)\n    private var cancellables = Set<AnyCancellable>()\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupHeaderView()\n        setupBindings()\n    }\n\n    private func setupHeaderView() {\n        headerView.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(headerView)\n\n        NSLayoutConstraint.activate([\n            headerView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 16),\n            headerView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -16),\n            headerView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 16)\n        ])\n    }\n\n    private func setupBindings() {\n        // Handle tap events\n        viewModel.onHeaderTapped = { [weak self] in\n            self?.expandBetslipDetails()\n        }\n    }\n\n    private func expandBetslipDetails() {\n        // Navigate or expand betslip\n    }\n}\n```\n\n### Updating State\n\n```swift\n// From betslip manager updates - ViewController manages visibility\nbetslipManager.oddsBoostPublisher\n    .sink { [weak self, weak viewModel] boostData in\n        if let boost = boostData {\n            let state = BetslipOddsBoostHeaderState(\n                selectionCount: boost.currentSelections,\n                totalEligibleCount: boost.requiredSelections,\n                nextTierPercentage: boost.nextTierBoost,\n                currentBoostPercentage: boost.currentBoost\n            )\n            viewModel?.updateState(state)\n            self?.headerView.isHidden = false\n        } else {\n            self?.headerView.isHidden = true\n        }\n    }\n    .store(in: &cancellables)\n```\n\n## Protocol\n\n```swift\npublic protocol BetslipOddsBoostHeaderViewModelProtocol {\n    var dataPublisher: AnyPublisher<BetslipOddsBoostHeaderData, Never> { get }\n    var currentData: BetslipOddsBoostHeaderData { get }\n    func updateState(_ state: BetslipOddsBoostHeaderState)\n    func setEnabled(_ isEnabled: Bool)\n    var onHeaderTapped: (() -> Void)? { get set }\n}\n```\n\n### State Struct\n\n```swift\npublic struct BetslipOddsBoostHeaderState: Equatable {\n    public let selectionCount: Int           // Current selections\n    public let totalEligibleCount: Int       // Required for boost\n    public let nextTierPercentage: String?   // e.g., \"5%\"\n    public let currentBoostPercentage: String? // e.g., \"10%\" when max reached\n}\n```\n\n## Animation Features\n\n### Wave Effect Progress\nSegments fill with 50ms stagger for smooth wave animation:\n\n```swift\n// Automatic when state updates\nlet newState = BetslipOddsBoostHeaderState(\n    selectionCount: 2,  // Will animate from 1 to 2\n    totalEligibleCount: 3,\n    nextTierPercentage: \"5%\",\n    currentBoostPercentage: nil\n)\nviewModel.updateState(newState)\n```\n\n### Add/Remove Segments\nSmooth scale + fade transitions when segment count changes:\n- New segments fade in from 0.3 scale\n- Removed segments fade out to 0.3 scale\n\n## Shared Component\n\n**ProgressSegmentView** is located in `Components/Shared/ProgressSegmentView.swift` and is reused by:\n- BetslipFloatingThinView\n- BetslipOddsBoostHeaderView\n\n## Layout Guidelines\n\n### Header Position (Recommended)\n```swift\n// Top of betslip, below navigation\nNSLayoutConstraint.activate([\n    headerView.topAnchor.constraint(equalTo: navigationBar.bottomAnchor, constant: 16),\n    headerView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 16),\n    headerView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -16)\n])\n```\n\n### Fixed Height (Optional)\n```swift\n// Component height adapts to content, but can be constrained if needed\nheaderView.heightAnchor.constraint(equalToConstant: 120).isActive = true\n```\n\n## Related Components\n\n- **BetslipFloatingThinView**: Compact floating betslip indicator (uses same protocol data)\n- **ProgressSegmentView**: Shared animated progress segment (`Components/Shared/`)\n\n## Testing\n\n### Mock Factory Methods\n\n```swift\n// Active with progress\nlet viewModel = MockBetslipOddsBoostHeaderViewModel.activeMock(\n    selectionCount: 1,\n    totalEligibleCount: 3,\n    nextTierPercentage: \"3%\"\n)\n\n// Max boost reached\nlet viewModel = MockBetslipOddsBoostHeaderViewModel.maxBoostMock()\n\n// Disabled state (component visible but not interactive)\nlet viewModel = MockBetslipOddsBoostHeaderViewModel.disabledMock(\n    selectionCount: 1,\n    totalEligibleCount: 3\n)\n```\n\n### SwiftUI Previews\n\n```swift\n@available(iOS 17.0, *)\n#Preview(\"Header - Progress 1/3\") {\n    PreviewUIViewController {\n        let vc = UIViewController()\n        vc.view.backgroundColor = StyleProvider.Color.backgroundPrimary\n\n        let headerView = BetslipOddsBoostHeaderView(\n            viewModel: MockBetslipOddsBoostHeaderViewModel.activeMock(\n                selectionCount: 1,\n                totalEligibleCount: 3,\n                nextTierPercentage: \"3%\"\n            )\n        )\n        headerView.translatesAutoresizingMaskIntoConstraints = false\n        vc.view.addSubview(headerView)\n\n        NSLayoutConstraint.activate([\n            headerView.leadingAnchor.constraint(equalTo: vc.view.leadingAnchor, constant: 16),\n            headerView.trailingAnchor.constraint(equalTo: vc.view.trailingAnchor, constant: -16),\n            headerView.topAnchor.constraint(equalTo: vc.view.safeAreaLayoutGuide.topAnchor, constant: 20)\n        ])\n\n        return vc\n    }\n}\n```\n\n## Important Design Decisions\n\n### 1. Visibility Management\n**Component does NOT hide itself** - the parent ViewController is responsible for showing/hiding the entire component based on whether odds boost data is available. This separation of concerns allows:\n- ViewController to coordinate multiple UI elements\n- Custom visibility animations\n- Complex visibility logic (e.g., user preferences, A/B testing)\n\n### 2. Shared ProgressSegmentView\nOriginally duplicated, now consolidated to `Components/Shared/` for:\n- Single source of truth\n- Consistent animations across components\n- Reduced code duplication (55 lines saved)\n\n### 3. No Odds Display\nUnlike `BetslipFloatingThinView`, this header focuses solely on odds boost promotion. Current odds are not displayed as they're shown elsewhere in the betslip.\n\n### 4. Struct Instead of Enum\nState is a struct, not an enum with cases, since component only displays data when visible. This provides:\n- Simpler API - direct property access instead of switch statements\n- Cleaner construction - no need to wrap in enum case\n- Better Swift practices - structs for data, enums for variants\n\n## Migration History\n\n- **Extracted from**: `BetslipFloatingTallView` (October 16, 2025)\n- **Purpose**: Dedicated betslip header component with focused data model\n- **Key Changes**:\n  - Replaced enum with struct (no `.hidden` case)\n  - Removed `odds` display (not needed in header)\n  - Visibility management delegated to parent ViewController\n  - Simplified render logic (no switch statement needed)\n",
      "snapshots": [
        {
          "category": "BoostStates",
          "light": "BetslipOddsBoostHeaderView/__Snapshots__/BetslipOddsBoostHeaderViewSnapshotTests/testBetslipOddsBoostHeaderView_BoostStates_Light.1.png",
          "dark": "BetslipOddsBoostHeaderView/__Snapshots__/BetslipOddsBoostHeaderViewSnapshotTests/testBetslipOddsBoostHeaderView_BoostStates_Dark.1.png"
        }
      ]
    },
    "BetslipTicketView": {
      "displayName": "BetslipTicketView",
      "category": "Betting",
      "subcategory": "BetSlip",
      "summary": "Betslip ticket card with match details, selection, and live odds",
      "description": "Single bet selection within betslip showing league, match date, teams, selected outcome, and odds. Animated odds change indicators (up/down arrows), swipe-to-delete close button, disabled state overlay.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "ticket",
        "betslip",
        "selection",
        "odds",
        "match",
        "animated",
        "removable"
      ],
      "states": [
        "normal",
        "oddsIncreased",
        "oddsDecreased",
        "disabled"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "BetslipHeaderView",
        "BetInfoSubmissionView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BetslipTicketView\n\nA betslip ticket card displaying match details, selection, and odds with live updates.\n\n## Overview\n\nBetslipTicketView presents a single bet selection within the betslip. It shows league, match date, team names, the user's selected outcome, and current odds. The component supports animated odds change indicators (up/down arrows) and a swipe-to-delete affordance via the left strip close button.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone component, typically in a list within betslip screen)\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Left strip with close/remove tap gesture\n- League and date info line\n- Home and away team display\n- Selected outcome with \"Your Selection\" label\n- Odds value with animated change indicators (up/down arrows)\n- Odds change animations with 4-second auto-hide\n- Disabled state overlay with message\n- Enabled/disabled alpha dimming\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockBetslipTicketViewModel.typicalMock()\nlet ticketView = BetslipTicketView(viewModel: viewModel)\n\nviewModel.onCloseTapped = {\n    // Remove ticket from betslip\n}\n```\n\n## Data Model\n\n```swift\nenum OddsChangeState: Equatable {\n    case none\n    case increased\n    case decreased\n}\n\nstruct BetslipTicketData: Equatable {\n    let leagueName: String\n    let startDate: String\n    let homeTeam: String\n    let awayTeam: String\n    let selectedTeam: String\n    let oddsValue: String\n    let oddsChangeState: OddsChangeState\n    let isEnabled: Bool\n    let bettingOfferId: String?\n    let disabledMessage: String?\n}\n\nprotocol BetslipTicketViewModelProtocol: AnyObject {\n    var dataPublisher: AnyPublisher<BetslipTicketData, Never> { get }\n    var oddsChangeStatePublisher: AnyPublisher<OddsChangeState, Never> { get }\n    var currentData: BetslipTicketData { get }\n    var onCloseTapped: (() -> Void)? { get set }\n\n    func updateOddsValue(_ oddsValue: String)\n    func updateOddsChangeState(_ state: OddsChangeState)\n    func setEnabled(_ isEnabled: Bool)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundSecondary` - container and disabled overlay background\n- `StyleProvider.Color.highlightPrimary` - left strip tint, close icon, and outcome/odds colors\n- `StyleProvider.Color.textPrimary` - team name colors\n- `StyleProvider.Color.textSecondary` - league/date and selection label colors\n- `StyleProvider.Color.alertSuccess` - up arrow (odds increased)\n- `StyleProvider.Color.alertError` - down arrow (odds decreased)\n- `StyleProvider.fontWith(type: .bold, size: 14)` - team names font\n- `StyleProvider.fontWith(type: .bold, size: 16)` - odds value font\n- `StyleProvider.fontWith(type: .bold, size: 12)` - outcome font\n- `StyleProvider.fontWith(type: .regular, size: 12)` - league/date font\n- `StyleProvider.fontWith(type: .medium, size: 10)` - selection label font\n\n## Mock ViewModels\n\nAvailable presets:\n- `.typicalMock()` - standard ticket with no odds change\n- `.increasedOddsMock()` - shows green up arrow\n- `.decreasedOddsMock()` - shows red down arrow\n- `.disabledMock()` - dimmed with disabled overlay\n",
      "snapshots": [
        {
          "category": "EnabledStates",
          "light": "BetslipTicketView/__Snapshots__/BetslipTicketViewSnapshotTests/testBetslipTicketView_EnabledStates_Light.1.png",
          "dark": "BetslipTicketView/__Snapshots__/BetslipTicketViewSnapshotTests/testBetslipTicketView_EnabledStates_Dark.1.png"
        },
        {
          "category": "OddsStates",
          "light": "BetslipTicketView/__Snapshots__/BetslipTicketViewSnapshotTests/testBetslipTicketView_OddsStates_Light.1.png",
          "dark": "BetslipTicketView/__Snapshots__/BetslipTicketViewSnapshotTests/testBetslipTicketView_OddsStates_Dark.1.png"
        }
      ]
    },
    "BetslipTypeSelectorView": {
      "displayName": "BetslipTypeSelectorView",
      "category": "Betting",
      "subcategory": "BetSlip",
      "summary": "Horizontal tab selector for switching betslip types",
      "description": "Tab row for filtering betslip by bet category (Sports, Virtuals). Manages BetslipTypeTabItemView collection with single selection. Animated transitions, fixed 50pt height.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "tabs",
        "selector",
        "betslip",
        "filter",
        "sports",
        "virtuals"
      ],
      "states": [
        "sportsSelected",
        "virtualsSelected"
      ],
      "similarTo": [
        "PillSelectorBarView",
        "MarketGroupSelectorTabView"
      ],
      "oftenUsedWith": [
        "BetslipTypeTabItemView"
      ],
      "parents": [],
      "children": [
        "BetslipTypeTabItemView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BetslipTypeSelectorView\n\nA horizontal tab selector for switching between betslip types (Sports, Virtuals).\n\n## Overview\n\nBetslipTypeSelectorView displays a row of selectable tabs allowing users to filter their betslip by bet category. It manages a collection of BetslipTypeTabItemView components and coordinates selection state across all tabs. Common use cases include separating sports bets from virtual sports bets.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone component, typically in betslip screens)\n\n### Uses (Children)\n- `BetslipTypeTabItemView` - individual tab item buttons\n\n## Features\n\n- Horizontal tab layout with equal distribution\n- Single selection management\n- Selection event publishing for parent integration\n- Animated selection state transitions\n- 16pt horizontal padding with 8pt corner radius\n- Fixed 50pt height\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockBetslipTypeSelectorViewModel.sportsSelectedMock()\nlet selectorView = BetslipTypeSelectorView(viewModel: viewModel)\n\n// Listen for selection changes\nviewModel.selectionEventPublisher\n    .sink { event in\n        print(\"Selected: \\(event.selectedId)\")\n    }\n    .store(in: &cancellables)\n```\n\n## Data Model\n\n```swift\nstruct BetslipTypeTabData: Equatable, Hashable {\n    let id: String\n    let title: String\n    let icon: String\n    var isSelected: Bool\n}\n\nstruct BetslipTypeSelectionEvent: Equatable {\n    let selectedId: String\n    let previouslySelectedId: String?\n}\n\nprotocol BetslipTypeSelectorViewModelProtocol {\n    var tabsPublisher: AnyPublisher<[BetslipTypeTabData], Never> { get }\n    var selectedTabIdPublisher: AnyPublisher<String?, Never> { get }\n    var selectionEventPublisher: AnyPublisher<BetslipTypeSelectionEvent, Never> { get }\n    var currentSelectedTabId: String? { get }\n    var currentTabs: [BetslipTypeTabData] { get }\n\n    func selectTab(id: String)\n    func updateTabs(_ tabs: [BetslipTypeTabData])\n    func clearSelection()\n    func selectFirstAvailableTab()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- Clear background on container\n- Inherits styling from child `BetslipTypeTabItemView` components\n\n## Mock ViewModels\n\nAvailable presets:\n- `.sportsSelectedMock()` - Sports tab selected\n- `.virtualsSelectedMock()` - Virtuals tab selected\n",
      "snapshots": [
        {
          "category": "SelectionStates",
          "light": "BetslipTypeSelectorView/__Snapshots__/BetslipTypeSelectorViewSnapshotTests/testBetslipTypeSelectorView_SelectionStates_Light.1.png",
          "dark": "BetslipTypeSelectorView/__Snapshots__/BetslipTypeSelectorViewSnapshotTests/testBetslipTypeSelectorView_SelectionStates_Dark.1.png"
        }
      ]
    },
    "BetslipTypeTabItemView": {
      "displayName": "BetslipTypeTabItemView",
      "category": "Betting",
      "subcategory": "BetSlip",
      "summary": "Individual tab item for betslip type selection",
      "description": "Single tab option with icon and title displaying selected/unselected states. Animated bottom indicator line highlights selection. 0.3s animated state transitions.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "tab",
        "item",
        "betslip",
        "selectable",
        "indicator"
      ],
      "states": [
        "selected",
        "unselected"
      ],
      "similarTo": [
        "PillItemView"
      ],
      "oftenUsedWith": [
        "BetslipTypeSelectorView"
      ],
      "parents": [
        "BetslipTypeSelectorView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BetslipTypeTabItemView\n\nAn individual tab item for betslip type selection with icon and label.\n\n## Overview\n\nBetslipTypeTabItemView represents a single tab option within BetslipTypeSelectorView. It displays an icon and title with visual feedback for selected/unselected states. The component includes an animated bottom indicator line that highlights the selected state.\n\n## Component Relationships\n\n### Used By (Parents)\n- `BetslipTypeSelectorView` - container managing multiple tab items\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Icon and title horizontal layout (centered)\n- Selected/unselected visual states with animation\n- Bottom indicator line (3pt height) for selected state\n- Custom or SF Symbol icon support\n- Tap gesture for selection\n- 0.3s animated state transitions\n\n## Usage\n\n```swift\nlet viewModel = MockBetslipTypeTabItemViewModel.sportsSelectedMock()\nlet tabItemView = BetslipTypeTabItemView(viewModel: viewModel)\n\nviewModel.onTabTapped = {\n    print(\"Tab tapped\")\n}\n```\n\n## Data Model\n\n```swift\nprotocol BetslipTypeTabItemViewModelProtocol {\n    var title: String { get }\n    var icon: String { get }\n    var isSelected: Bool { get }\n    var onTabTapped: (() -> Void)? { get set }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.highlightPrimary` - selected icon, title, and indicator colors\n- `StyleProvider.Color.textPrimary` - unselected icon and title colors\n- `StyleProvider.Color.textSecondary` - default icon/title tint\n- `StyleProvider.Color.separatorLineSecondary` - unselected indicator color\n- `StyleProvider.fontWith(type: .semibold, size: 16)` - title font\n\n## Mock ViewModels\n\nAvailable presets:\n- `.sportsSelectedMock()` - \"Sports\" with sportscourt icon, selected\n- `.sportsUnselectedMock()` - \"Sports\" with sportscourt icon, unselected\n- `.virtualsSelectedMock()` - \"Virtuals\" with gamecontroller icon, selected\n- `.virtualsUnselectedMock()` - \"Virtuals\" with gamecontroller icon, unselected\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "BetslipTypeTabItemView/__Snapshots__/BetslipTypeTabItemViewSnapshotTests/testBetslipTypeTabItemView_BasicStates_Light.1.png",
          "dark": "BetslipTypeTabItemView/__Snapshots__/BetslipTypeTabItemViewSnapshotTests/testBetslipTypeTabItemView_BasicStates_Dark.1.png"
        },
        {
          "category": "TabVariants",
          "light": "BetslipTypeTabItemView/__Snapshots__/BetslipTypeTabItemViewSnapshotTests/testBetslipTypeTabItemView_TabVariants_Light.1.png",
          "dark": "BetslipTypeTabItemView/__Snapshots__/BetslipTypeTabItemViewSnapshotTests/testBetslipTypeTabItemView_TabVariants_Dark.1.png"
        }
      ]
    },
    "BonusCardView": {
      "displayName": "BonusCardView",
      "category": "Promotions",
      "subcategory": "Bonuses",
      "summary": "Card for bonus offers with CTA button and terms",
      "description": "Displays bonus promotions with image, title, description, tag, CTA button, and terms button. Similar to PromotionCardView but includes terms & conditions display requirement.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "card",
        "bonus",
        "promotion",
        "cta",
        "terms",
        "offer"
      ],
      "states": [
        "withTerms",
        "withoutTerms",
        "enabled",
        "disabled"
      ],
      "similarTo": [
        "PromotionCardView",
        "BonusInfoCardView"
      ],
      "oftenUsedWith": [
        "ButtonView"
      ],
      "parents": [],
      "children": [
        "ButtonView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BonusCardView\n\nA reusable card component for displaying bonus offers with call-to-action buttons and terms information.\n\n## Overview\n\n`BonusCardView` is a production-ready UI component that displays bonus promotions with rich content including an image, title, description, tag, CTA button, and terms text. It's similar to `PromotionCardView` but specifically designed for bonus offers that require terms and conditions display.\n\n## Features\n\n- **Image Display**: Shows a promotional image with optional tag overlay\n- **Content Layout**: Title and description with multi-line support\n- **CTA Button**: Always-visible call-to-action ButtonView with configurable text\n- **Terms Button**: ButtonView for terms that is enabled/disabled based on URL availability\n- **Optional Fields**: Tag, CTA URL, and terms URL are all optional\n- **Reactive Updates**: Uses Combine publishers for state management\n- **Themed Styling**: Uses StyleProvider for consistent theming\n\n## Architecture\n\n### Components\n\n1. **BonusCardData**: Data model containing all card information\n2. **BonusCardDisplayState**: Display state wrapper for reactive updates\n3. **BonusCardViewModelProtocol**: Protocol defining the view model interface\n4. **MockBonusCardViewModel**: Mock implementation for testing and demos\n5. **BonusCardView**: Main UIView implementation\n\n### Key Differences from PromotionCardView\n\n- **Required CTA Text**: `ctaText` is always required (not optional)\n- **Optional CTA URL**: `ctaURL` is optional\n- **Terms Button Instead of Read More**: Uses a ButtonView for terms instead of a \"Read More\" button\n- **Smart Terms Button**: Button is enabled only when `termsURL` is provided, disabled (non-interactive) when URL is nil\n\n## Usage\n\n### Basic Implementation\n\n```swift\nimport GomaUI\n\n// Create the data\nlet bonusData = BonusCardData(\n    id: \"bonus_1\",\n    title: \"Welcome Bonus\",\n    description: \"Get 100% match on your first deposit\",\n    imageURL: \"https://example.com/image.jpg\",\n    tag: \"Popular\",\n    ctaText: \"Claim Bonus\",\n    ctaURL: \"https://example.com/claim\",\n    termsText: \"Terms & Conditions Apply\",\n    termsURL: \"https://example.com/terms\"\n)\n\n// Create the view model\nlet viewModel = MockBonusCardViewModel(cardData: bonusData)\n\n// Create the view\nlet bonusCard = BonusCardView(viewModel: viewModel)\n\n// Add to your view hierarchy\nview.addSubview(bonusCard)\n```\n\n### Handling Actions\n\n```swift\n// Set up callbacks in your view model\nviewModel.onCTATapped = { url in\n    if let url = url {\n        // Open the CTA URL\n        print(\"Open CTA: \\(url)\")\n    } else {\n        // Handle CTA without URL\n        print(\"CTA tapped without URL\")\n    }\n}\n\nviewModel.onTermsTapped = { url in\n    if let url = url {\n        // Open terms URL\n        print(\"Open terms: \\(url)\")\n    } else {\n        // Terms text only (no URL)\n        print(\"Terms has no URL\")\n    }\n}\n\nviewModel.onCardTapped = {\n    // Handle card tap\n    print(\"Card tapped\")\n}\n```\n\n### Using Factory Methods\n\n```swift\n// Default bonus with all features\nlet defaultCard = BonusCardView(\n    viewModel: MockBonusCardViewModel.defaultMock\n)\n\n// Bonus without URLs\nlet noURLCard = BonusCardView(\n    viewModel: MockBonusCardViewModel.noURLsMock\n)\n\n// Casino-specific bonus\nlet casinoCard = BonusCardView(\n    viewModel: MockBonusCardViewModel.casinoBonusMock\n)\n```\n\n## Data Model\n\n### BonusCardData\n\n```swift\npublic struct BonusCardData {\n    public let id: String              // Unique identifier\n    public let title: String           // Bonus title\n    public let description: String     // Detailed description\n    public let imageURL: String        // Image URL\n    public let tag: String?            // Optional tag (e.g., \"Popular\", \"VIP\")\n    public let ctaText: String         // CTA button text (required)\n    public let ctaURL: String?         // Optional CTA destination URL\n    public let termsText: String       // Terms text (required)\n    public let termsURL: String?       // Optional terms URL\n}\n```\n\n## Layout\n\n```\n\n   [Image with Tag]          \n\n Title                       \n Description text that can   \n span multiple lines         \n                             \n [   Claim Bonus Button   ]  \n Terms & Conditions Apply     (underlined if URL exists)\n\n```\n\n## Customization\n\n### Theming\n\nThe component uses `StyleProvider` for all visual properties:\n\n- **Background Colors**: `backgroundCards`, `backgroundSecondary`\n- **Border Colors**: `backgroundBorder`\n- **Text Colors**: `textPrimary`, `textSecondary`, `allWhite`\n- **Highlight Colors**: `highlightPrimary` (for tag background)\n- **Fonts**: `bold` (16pt), `regular` (14pt), `semibold` (12pt)\n\n### Size Constraints\n\n- **Image Height**: Fixed at 131pt\n- **Container**: Full width with 8pt corner radius\n- **Padding**: 24pt horizontal, 16pt vertical\n- **Spacing**: 8-16pt between elements\n\n## Production Implementation\n\nTo use in production:\n\n1. Implement `BonusCardViewModelProtocol` in your production view model\n2. Connect to your data source and business logic\n3. Implement proper error handling for image loading\n4. Handle navigation/URL opening in callbacks\n5. Add analytics tracking in action methods\n\n```swift\nclass ProductionBonusCardViewModel: BonusCardViewModelProtocol {\n    private let bonusService: BonusServiceProtocol\n    private let analyticsService: AnalyticsServiceProtocol\n    \n    func didTapCTAButton() {\n        analyticsService.track(.bonusCTATapped)\n        // Navigate or perform action\n    }\n    \n    func didTapTerms() {\n        analyticsService.track(.bonusTermsTapped)\n        // Open terms sheet or web view\n    }\n}\n```\n\n## Mock Implementations\n\nThe component includes several mock variants:\n\n- **defaultMock**: Full-featured bonus with all fields\n- **noURLsMock**: Bonus without any URLs (text only)\n- **casinoBonusMock**: Casino-specific bonus\n- **sportsBonusMock**: Sports betting bonus\n- **vipBonusMock**: VIP exclusive bonus\n- **noTagMock**: Bonus without a tag\n\n## Testing\n\nUse the included mock view models for SwiftUI previews and testing:\n\n```swift\n@available(iOS 17.0, *)\n#Preview(\"Default State\") {\n    PreviewUIViewController {\n        let vc = UIViewController()\n        let card = BonusCardView(\n            viewModel: MockBonusCardViewModel.defaultMock\n        )\n        // Setup constraints\n        return vc\n    }\n}\n```\n\n## Accessibility\n\nThe component supports:\n- VoiceOver for all interactive elements\n- Dynamic Type for text scaling\n- High contrast mode through StyleProvider\n\n## Requirements\n\n- iOS 16.0+\n- Swift 5.7+\n- Kingfisher (for image loading)\n\n## Related Components\n\n- **PromotionCardView**: Similar card for general promotions with \"Read More\" button\n- **ButtonView**: Used for both CTA and Terms buttons\n- **StyleProvider**: Provides theming and styling\n\n",
      "snapshots": [
        {
          "category": "ContentVariants",
          "light": "BonusCardView/__Snapshots__/BonusCardViewSnapshotTests/testBonusCardView_ContentVariants_Light.1.png",
          "dark": "BonusCardView/__Snapshots__/BonusCardViewSnapshotTests/testBonusCardView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "BonusInfoCardView": {
      "displayName": "BonusInfoCardView",
      "category": "Promotions",
      "subcategory": "Bonuses",
      "summary": "Detailed bonus card with status, progress, and expiry",
      "description": "Comprehensive bonus display with optional header image, status indicator (Active/Released), dual amounts (bonus/remaining), wagering progress bar, terms button, and expiry date. Flexible layout auto-hides unavailable elements.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "card",
        "bonus",
        "status",
        "progress",
        "wagering",
        "expiry"
      ],
      "states": [
        "active",
        "released",
        "withImage",
        "withoutImage"
      ],
      "similarTo": [
        "BonusCardView"
      ],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BonusInfoCardView\n\nA comprehensive card component for displaying bonus information with optional header images, status indicators, wagering progress, and expiry details.\n\n## Overview\n\n`BonusInfoCardView` is a production-ready GomaUI component that displays detailed bonus information in a visually appealing card layout. The component follows MVVM architecture and is fully customizable through its protocol-based interface.\n\n## Features\n\n- **Optional Header Image**: Display promotional imagery at the top of the card\n- **Status Indicator**: Visual pill showing bonus status (Active/Released)\n- **Dual Amount Display**: Shows both bonus amount and remaining balance\n- **Wagering Progress**: Visual progress bar with optional remaining amount text\n- **Terms & Conditions Button**: Interactive button for accessing bonus terms\n- **Expiry Information**: Displays bonus expiration date with calendar icon\n- **Flexible Layout**: Automatically hides optional elements when data is not available\n\n## Component Structure\n\n```\nBonusInfoCardView/\n BonusStatus.swift                      # Enum for bonus status types\n BonusInfoCardView.swift                # Main view implementation\n BonusInfoCardViewModelProtocol.swift   # Protocol interface\n MockBonusInfoCardViewModel.swift       # Mock implementation with presets\n README.md                              # This documentation\n```\n\n## Usage\n\n### Basic Implementation\n\n```swift\nimport GomaUI\n\n// Create bonus data\nlet bonusData = BonusInfoCardData(\n    id: \"bonus_123\",\n    title: \"Welcome Bonus\",\n    subtitle: \"oddsBoost\",\n    status: .active,\n    headerImageURL: \"https://example.com/bonus-header.jpg\",\n    bonusAmount: \"XAF 2000.00\",\n    remainingAmount: \"XAF 3000.00\",\n    wageringProgress: 0.33,\n    remainingToWagerText: \"+ XAF 1500.00 remaining to wager\",\n    expiryText: \"Sun 01/01 - 18:59\"\n)\n\n// Create view model (production implementation)\nlet viewModel = MyBonusInfoCardViewModel(cardData: bonusData)\n\n// Create and configure the view\nlet bonusCard = BonusInfoCardView(viewModel: viewModel)\nbonusCard.translatesAutoresizingMaskIntoConstraints = false\nview.addSubview(bonusCard)\n\n// Setup constraints\nNSLayoutConstraint.activate([\n    bonusCard.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 16),\n    bonusCard.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -16),\n    bonusCard.topAnchor.constraint(equalTo: view.topAnchor, constant: 20)\n])\n```\n\n### Using Mock Data\n\n```swift\n// Use preset mocks for testing/development\nlet bonusCard = BonusInfoCardView(viewModel: MockBonusInfoCardViewModel.complete)\n\n// Available presets:\n// - .complete: Full bonus with all features\n// - .withoutHeader: No header image\n// - .withoutRemainingText: No remaining wager text\n// - .released: Completed bonus\n// - .minimal: Only required elements\n// - .almostComplete: High progress bonus\n```\n\n### Implementing the Protocol\n\n```swift\nimport Combine\n\nclass MyBonusInfoCardViewModel: BonusInfoCardViewModelProtocol {\n    \n    // MARK: - Properties\n    private let displayStateSubject: CurrentValueSubject<BonusInfoCardDisplayState, Never>\n    \n    var displayStatePublisher: AnyPublisher<BonusInfoCardDisplayState, Never> {\n        displayStateSubject.eraseToAnyPublisher()\n    }\n    \n    private let coordinator: BonusCoordinatorProtocol\n    \n    // MARK: - Initialization\n    init(cardData: BonusInfoCardData, coordinator: BonusCoordinatorProtocol) {\n        self.displayStateSubject = CurrentValueSubject(\n            BonusInfoCardDisplayState(cardData: cardData)\n        )\n        self.coordinator = coordinator\n    }\n    \n    // MARK: - Actions\n    func didTapTermsAndConditions() {\n        let currentState = displayStateSubject.value\n        coordinator.showTermsAndConditions(for: currentState.id)\n    }\n    \n    // MARK: - Configuration\n    func configure(with cardData: BonusInfoCardData) {\n        displayStateSubject.send(BonusInfoCardDisplayState(cardData: cardData))\n    }\n}\n\n// Helper to create BonusInfoCardData from domain model\nextension BonusInfoCardData {\n    init(from domainBonus: Bonus) {\n        self.init(\n            id: domainBonus.id,\n            title: domainBonus.name,\n            subtitle: domainBonus.type,\n            status: domainBonus.isActive ? .active : .released,\n            headerImageURL: domainBonus.imageURL,\n            bonusAmount: domainBonus.formattedAmount,\n            remainingAmount: domainBonus.formattedRemaining,\n            wageringProgress: domainBonus.wageringProgress,\n            remainingToWagerText: domainBonus.remainingToWager > 0 \n                ? \"+ \\(domainBonus.formattedRemainingToWager) remaining to wager\" \n                : nil,\n            expiryText: domainBonus.formattedExpiryDate\n        )\n    }\n}\n```\n\n## Data Models\n\n### BonusInfoCardData\n\nThe immutable data structure containing all bonus information:\n\n```swift\npublic struct BonusInfoCardData: Equatable, Hashable {\n    public let id: String\n    public let title: String\n    public let subtitle: String?\n    public let status: BonusStatus\n    public let headerImageURL: String?\n    public let bonusAmount: String\n    public let remainingAmount: String\n    public let wageringProgress: Float\n    public let remainingToWagerText: String?\n    public let expiryText: String\n}\n```\n\n### BonusInfoCardDisplayState\n\nDisplay state wrapper with convenience properties:\n\n```swift\npublic struct BonusInfoCardDisplayState: Equatable {\n    public let cardData: BonusInfoCardData\n    public let isVisible: Bool\n    \n    // Convenience properties for easier access\n    public var id: String { cardData.id }\n    public var title: String { cardData.title }\n    // ... other properties\n}\n```\n\n## Protocol Requirements\n\n### Required Properties\n\n- `displayStatePublisher: AnyPublisher<BonusInfoCardDisplayState, Never>` - Publisher for reactive updates\n\n### Required Methods\n\n- `didTapTermsAndConditions()` - Called when Terms & Conditions button is tapped\n- `configure(with cardData: BonusInfoCardData)` - Update the bonus data\n\n### BonusInfoCardData Properties\n\n**Required:**\n- `id: String` - Unique identifier\n- `title: String` - Main bonus title\n- `status: BonusStatus` - Current status (.active or .released)\n- `bonusAmount: String` - Formatted bonus amount\n- `remainingAmount: String` - Formatted remaining balance\n- `wageringProgress: Float` - Progress value (0.0 to 1.0)\n- `expiryText: String` - Expiry date/time text\n\n**Optional:**\n- `headerImageURL: String?` - Header image URL (card hides header if nil)\n- `subtitle: String?` - Bonus type or subtitle\n- `remainingToWagerText: String?` - Remaining wager text (hidden if nil)\n\n## Optional Elements Behavior\n\nThe component intelligently handles optional elements:\n\n| Element | When Hidden |\n|---------|-------------|\n| Header Image | When `headerImage` is `nil` |\n| Subtitle | When `subtitle` is `nil` |\n| Remaining Wager Text | When `remainingToWagerText` is `nil` |\n\nAll other elements are always visible.\n\n## Status Types\n\n### BonusStatus.active\n- Green background pill\n- Green text\n- Indicates bonus is currently active and can be used\n\n### BonusStatus.released\n- Gray background pill\n- Gray text\n- Indicates bonus has been completed and released\n\n## Styling\n\nThe component uses `StyleProvider` for all visual properties:\n\n- Colors adapt to app theme automatically\n- Fonts use centralized typography system\n- No hardcoded visual properties\n- Fully themeable without code changes\n\n## Design Specifications\n\n- **Card Corner Radius**: 12pt\n- **Card Shadow**: Subtle shadow for elevation\n- **Header Image Height**: 160pt (when present)\n- **Amount Box Corner Radius**: 8pt\n- **Progress Bar Height**: 8pt\n- **Button Height**: 48pt\n- **Expiry Section Height**: 44pt\n- **Spacing**: Consistent 16pt margins, 8-20pt internal spacing\n\n## Integration Checklist\n\nWhen implementing a production ViewModel:\n\n- [ ] Create `BonusInfoCardData` from your domain model\n- [ ] Implement `BonusInfoCardViewModelProtocol` with publisher pattern\n- [ ] Initialize `CurrentValueSubject<BonusInfoCardDisplayState, Never>`\n- [ ] Handle optional properties correctly (set to nil when not available)\n- [ ] Format currency values consistently\n- [ ] Format dates in appropriate locale\n- [ ] Implement `didTapTermsAndConditions()` action\n- [ ] Provide header image URLs (images loaded automatically via Kingfisher)\n- [ ] Validate wagering progress is between 0.0 and 1.0\n- [ ] Update display state when bonus data changes via `configure(with:)`\n\n## Dependencies\n\nThis component requires:\n- **Kingfisher**: For asynchronous image loading from URLs\n- **Combine**: For reactive publisher pattern\n\n## Example Integration\n\n```swift\n// In your view controller\nclass BonusDetailViewController: UIViewController {\n    private lazy var bonusCard = BonusInfoCardView(viewModel: viewModel)\n    private let viewModel: BonusCardViewModelProtocol\n    \n    init(viewModel: BonusCardViewModelProtocol) {\n        self.viewModel = viewModel\n        super.init(nibName: nil, bundle: nil)\n    }\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupBonusCard()\n    }\n    \n    private func setupBonusCard() {\n        bonusCard.translatesAutoresizingMaskIntoConstraints = false\n        view.addSubview(bonusCard)\n        \n        NSLayoutConstraint.activate([\n            bonusCard.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 16),\n            bonusCard.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -16),\n            bonusCard.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 20)\n        ])\n    }\n}\n```\n\n## SwiftUI Previews\n\nThe component includes multiple SwiftUI preview configurations:\n\n- Complete Bonus (with all features)\n- Without Header Image\n- Minimal (no optional elements)\n- Released Status\n- Almost Complete (high progress)\n\nUse these previews during development to quickly iterate on the design.\n\n## Accessibility\n\nThe component is designed with accessibility in mind:\n\n- All text uses dynamic type through `StyleProvider`\n- Interactive elements have appropriate touch targets (48pt minimum)\n- Semantic colors provide good contrast ratios\n- Progress bar provides visual feedback\n\n## Performance Considerations\n\n- Lazy property initialization for efficient memory usage\n- Static factory methods for consistent object creation\n- Minimal view hierarchy depth\n- Efficient constraint management\n\n## Related Components\n\n- `BonusCardView` (existing) - Original bonus card implementation\n- Consider `BonusInfoCardView` for new implementations requiring detailed bonus display\n\n---\n\n*Created: October 24, 2025*\n*Version: 1.0.0*\n*Framework: GomaUI*\n\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "BonusInfoCardView/__Snapshots__/BonusInfoCardViewSnapshotTests/testBonusInfoCardView_BasicStates_Light.1.png",
          "dark": "BonusInfoCardView/__Snapshots__/BonusInfoCardViewSnapshotTests/testBonusInfoCardView_BasicStates_Dark.1.png"
        },
        {
          "category": "ContentVariants",
          "light": "BonusInfoCardView/__Snapshots__/BonusInfoCardViewSnapshotTests/testBonusInfoCardView_ContentVariants_Light.1.png",
          "dark": "BonusInfoCardView/__Snapshots__/BonusInfoCardViewSnapshotTests/testBonusInfoCardView_ContentVariants_Dark.1.png"
        },
        {
          "category": "StatusVariants",
          "light": "BonusInfoCardView/__Snapshots__/BonusInfoCardViewSnapshotTests/testBonusInfoCardView_StatusVariants_Light.1.png",
          "dark": "BonusInfoCardView/__Snapshots__/BonusInfoCardViewSnapshotTests/testBonusInfoCardView_StatusVariants_Dark.1.png"
        }
      ]
    },
    "BorderedTextFieldView": {
      "displayName": "BorderedTextFieldView",
      "category": "Forms",
      "subcategory": "TextInput",
      "summary": "Material-design text field with floating label and validation",
      "description": "Modern text input with floating placeholder labels, animated border with label cutout, password visibility toggle, prefix text, error states, and custom input view support (date pickers). Fixed 56pt height.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "input",
        "text-field",
        "form",
        "validation",
        "floating-label",
        "password"
      ],
      "states": [
        "idle",
        "focused",
        "error",
        "disabled"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "BetInfoSubmissionView",
        "CodeInputView"
      ],
      "parents": [
        "BetInfoSubmissionView",
        "CodeInputView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BorderedTextFieldView\n\nBorderedTextFieldView is a sophisticated text input component featuring floating labels, customizable styling, and comprehensive input support. It provides a modern, accessible interface for user text input with real-time validation and state management.\n\n## Features\n\n- **Floating Label Animation** - Label smoothly transitions between placeholder and floated positions\n- **Multiple Input Types** - Support for text, password, email, phone number, and more\n- **Real-time Text Publisher** - Constant stream of text changes via Combine publishers\n- **Password Visibility Toggle** - Built-in eye icon for secure text fields\n- **Required Field Indication** - Visual asterisk for mandatory fields\n- **Error State Handling** - Red styling and error message display\n- **Focus State Management** - Border and label color changes on focus\n- **Accessibility Support** - Full VoiceOver and accessibility identifier support\n\n## Use Cases\n\n- Login and registration forms\n- Profile editing interfaces\n- Search input fields\n- Settings and configuration screens\n- Contact information forms\n\n## Usage Example\n\n### Basic Text Field\n\n```swift\n// Create a view model\nlet viewModel = MockBorderedTextFieldViewModel(\n    textFieldData: BorderedTextFieldData(\n        id: \"email\",\n        placeholder: \"Enter email address\",\n        label: \"Email Address\",\n        isRequired: true,\n        keyboardType: .emailAddress,\n        textContentType: .emailAddress\n    )\n)\n\n// Create the component\nlet textFieldView = BorderedTextFieldView(viewModel: viewModel)\ntextFieldView.translatesAutoresizingMaskIntoConstraints = false\n\n// Add to your view hierarchy\nparentView.addSubview(textFieldView)\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    textFieldView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 20),\n    textFieldView.trailingAnchor.constraint(equalTo: parentView.trailingAnchor, constant: -20),\n    textFieldView.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor, constant: 20)\n])\n\n// Handle text changes\ntextFieldView.onTextChanged = { text in\n    print(\"Text changed: \\(text)\")\n    // Perform validation or other actions\n}\n\n// Handle focus changes\ntextFieldView.onFocusChanged = { isFocused in\n    print(\"Focus changed: \\(isFocused)\")\n}\n```\n\n### Password Field with Toggle\n\n```swift\nlet passwordViewModel = MockBorderedTextFieldViewModel(\n    textFieldData: BorderedTextFieldData(\n        id: \"password\",\n        placeholder: \"Enter password\",\n        label: \"Password\",\n        isRequired: true,\n        isSecure: true,\n        textContentType: .password\n    )\n)\n\nlet passwordField = BorderedTextFieldView(viewModel: passwordViewModel)\n\n// Listen to text changes for real-time validation\npasswordField.onTextChanged = { password in\n    // Perform password strength validation\n    validatePasswordStrength(password)\n}\n```\n\n### Form with Multiple Fields\n\n```swift\nclass RegistrationViewController: UIViewController {\n    private var textFieldViewModels: [BorderedTextFieldViewModelProtocol] = []\n    private var cancellables = Set<AnyCancellable>()\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupForm()\n        setupTextFieldObservation()\n    }\n    \n    private func setupForm() {\n        // Create view models\n        let nameViewModel = MockBorderedTextFieldViewModel.nameField\n        let emailViewModel = MockBorderedTextFieldViewModel.emailField\n        let phoneViewModel = MockBorderedTextFieldViewModel.phoneNumberField\n        let passwordViewModel = MockBorderedTextFieldViewModel.passwordField\n        \n        textFieldViewModels = [nameViewModel, emailViewModel, phoneViewModel, passwordViewModel]\n        \n        // Create and layout text fields\n        let stackView = UIStackView()\n        stackView.axis = .vertical\n        stackView.spacing = 20\n        stackView.translatesAutoresizingMaskIntoConstraints = false\n        \n        for viewModel in textFieldViewModels {\n            let textField = BorderedTextFieldView(viewModel: viewModel)\n            stackView.addArrangedSubview(textField)\n        }\n        \n        view.addSubview(stackView)\n        // Add constraints...\n    }\n    \n    private func setupTextFieldObservation() {\n        // Observe all text fields for real-time form validation\n        let textPublishers = textFieldViewModels.map { $0.textPublisher }\n        \n        Publishers.CombineLatest4(\n            textPublishers[0],\n            textPublishers[1],\n            textPublishers[2],\n            textPublishers[3]\n        )\n        .sink { [weak self] name, email, phone, password in\n            self?.validateForm(name: name, email: email, phone: phone, password: password)\n        }\n        .store(in: &cancellables)\n    }\n    \n    private func validateForm(name: String, email: String, phone: String, password: String) {\n        // Real-time form validation logic\n        let isValid = !name.isEmpty && isValidEmail(email) && isValidPhone(phone) && isValidPassword(password)\n        updateSubmitButton(enabled: isValid)\n    }\n}\n```\n\n## Configuration Options\n\n### BorderedTextFieldData Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `id` | String | Unique identifier for the text field |\n| `text` | String | Current text content |\n| `placeholder` | String | Placeholder text (usually hidden due to floating label) |\n| `label` | String | Floating label text |\n| `isRequired` | Bool | Whether to show required asterisk indicator |\n| `isSecure` | Bool | Whether this is a password field with toggle |\n| `isEnabled` | Bool | Whether the field accepts input |\n| `errorMessage` | String? | Error message to display below field |\n| `keyboardType` | UIKeyboardType | Keyboard type for input optimization |\n| `textContentType` | UITextContentType? | Content type for AutoFill support |\n\n### Publisher Architecture\n\nThe component uses individual publishers for granular state management:\n\n- `textPublisher` - Real-time text content updates\n- `labelPublisher` - Floating label text changes\n- `isRequiredPublisher` - Required state changes\n- `isSecurePublisher` - Secure field state\n- `isFocusedPublisher` - Focus state changes\n- `isPasswordVisiblePublisher` - Password visibility state\n- `errorMessagePublisher` - Error state changes\n\n### Real-time Text Observation\n\n```swift\n// Subscribe to text changes\ntextFieldView.viewModel.textPublisher\n    .debounce(for: .milliseconds(300), scheduler: RunLoop.main)\n    .sink { text in\n        // Perform debounced validation\n        performAsyncValidation(text)\n    }\n    .store(in: &cancellables)\n```\n\n## States and Animations\n\n### Visual States\n\n1. **Empty & Unfocused** - Label in center, gray border\n2. **Empty & Focused** - Label floated up, accent border, cursor visible\n3. **Filled & Unfocused** - Label floated up, gray border\n4. **Filled & Focused** - Label floated up, accent border\n5. **Error State** - Red border, red label, error message visible\n6. **Disabled State** - Reduced opacity, no interaction\n\n### Label Animation\n\nThe floating label smoothly animates between two positions:\n- **Placeholder Position** - Centered vertically in the field\n- **Floated Position** - Small and positioned above the field\n\nAnimation triggers:\n- Text field gains/loses focus\n- Text content changes (empty  filled)\n\n## Styling\n\nThe BorderedTextFieldView uses StyleProvider for consistent theming:\n\n```swift\n// Customize colors\nStyleProvider.Color.customize(\n    primaryColor: UIColor(named: \"BrandPrimary\"),\n    secondaryColor: UIColor(named: \"BorderGray\"),\n    backgroundColor: .systemBackground,\n    textColor: .label\n)\n\n// Customize fonts\nStyleProvider.setFontProvider { type, size in\n    // Return custom fonts based on type and size\n}\n```\n\n## Accessibility\n\nThe component provides comprehensive accessibility support:\n\n- Text field is properly labeled with floating label text\n- Required state is announced\n- Error messages are read automatically\n- Password toggle button has descriptive accessibility label\n- Focus management follows accessibility guidelines\n\n## Implementation Notes\n\n- The floating label uses transform animations for smooth scaling\n- Password visibility toggle automatically manages secure text entry\n- Text field constraints dynamically adjust based on suffix button visibility\n- Error state takes precedence over focus state for styling\n- Component height adjusts to accommodate error messages\n- Real-time text publisher enables immediate validation feedback\n\n## Error Handling\n\n```swift\n// Set an error\nviewModel.setError(\"Please enter a valid email address\")\n\n// Clear error\nviewModel.clearError()\n\n// The component automatically:\n// - Shows red border and label\n// - Displays error message below field\n// - Announces error to screen readers\n```\n\nThis component provides a complete, production-ready text input solution with modern UX patterns and comprehensive state management. ",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "BorderedTextFieldView/__Snapshots__/BorderedTextFieldViewSnapshotTests/testBorderedTextFieldView_BasicStates_Light.1.png",
          "dark": "BorderedTextFieldView/__Snapshots__/BorderedTextFieldViewSnapshotTests/testBorderedTextFieldView_BasicStates_Dark.1.png"
        },
        {
          "category": "ErrorStates",
          "light": "BorderedTextFieldView/__Snapshots__/BorderedTextFieldViewSnapshotTests/testBorderedTextFieldView_ErrorStates_Light.1.png",
          "dark": "BorderedTextFieldView/__Snapshots__/BorderedTextFieldViewSnapshotTests/testBorderedTextFieldView_ErrorStates_Dark.1.png"
        },
        {
          "category": "InputTypes",
          "light": "BorderedTextFieldView/__Snapshots__/BorderedTextFieldViewSnapshotTests/testBorderedTextFieldView_InputTypes_Light.1.png",
          "dark": "BorderedTextFieldView/__Snapshots__/BorderedTextFieldViewSnapshotTests/testBorderedTextFieldView_InputTypes_Dark.1.png"
        }
      ]
    },
    "BulletItemBlockView": {
      "displayName": "BulletItemBlockView",
      "category": "Promotions",
      "subcategory": "ContentBlocks",
      "summary": "Bullet point list item with highlighted bullet character",
      "description": "Single bullet point with highlight-colored bullet and primary text. Multi-line support, 1.2x line height, designed for promotional content, terms, and informational lists.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "bullet",
        "list",
        "item",
        "promotion",
        "terms",
        "content-block"
      ],
      "states": [],
      "similarTo": [
        "TitleBlockView"
      ],
      "oftenUsedWith": [
        "ListBlockView",
        "StackViewBlockView"
      ],
      "parents": [
        "ListBlockView",
        "StackViewBlockView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# BulletItemBlockView\n\nA simple bullet point list item with highlighted bullet character.\n\n## Overview\n\nBulletItemBlockView displays a single bullet point item with the bullet character styled in the highlight color and the text in the primary text color. It's designed for use in promotional content, terms, and informational lists.\n\n## Component Relationships\n\n### Used By (Parents)\n- `ListBlockView` - renders multiple bullet items in a list\n- `StackViewBlockView` - displays bullet items within stacked content\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Bullet character with highlight color\n- Multi-line text support\n- 1.2x line height multiplier with 2pt line spacing\n- 15pt horizontal padding, 5pt vertical padding\n- Clear background\n\n## Usage\n\n```swift\nlet viewModel = MockBulletItemBlockViewModel(title: \"Free bet on your first deposit\")\nlet bulletView = BulletItemBlockView(viewModel: viewModel)\n```\n\n## Data Model\n\n```swift\nprotocol BulletItemBlockViewModelProtocol {\n    var title: String { get }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.highlightPrimary` - bullet character color\n- `StyleProvider.Color.textPrimary` - title text color\n- `StyleProvider.fontWith(type: .semibold, size: 14)` - title font\n\n## Mock ViewModels\n\nCreate via `MockBulletItemBlockViewModel(title:)`:\n- Custom title text for each bullet point\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "BulletItemBlockView/__Snapshots__/BulletItemBlockViewSnapshotTests/testBulletItemBlockView_BasicStates_Light.1.png",
          "dark": "BulletItemBlockView/__Snapshots__/BulletItemBlockViewSnapshotTests/testBulletItemBlockView_BasicStates_Dark.1.png"
        },
        {
          "category": "ContentVariants",
          "light": "BulletItemBlockView/__Snapshots__/BulletItemBlockViewSnapshotTests/testBulletItemBlockView_ContentVariants_Light.1.png",
          "dark": "BulletItemBlockView/__Snapshots__/BulletItemBlockViewSnapshotTests/testBulletItemBlockView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "ButtonIconView": {
      "displayName": "ButtonIconView",
      "category": "UIElements",
      "subcategory": "Buttons",
      "summary": "Button with configurable icon position (left or right)",
      "description": "Tappable button with icon and text label. Icon can be positioned on either side. Custom or SF Symbol icons, customizable tint color, optional background. 16x16pt icon with 8pt spacing.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "button",
        "icon",
        "action",
        "interactive",
        "flexible"
      ],
      "states": [
        "enabled",
        "disabled",
        "iconLeft",
        "iconRight"
      ],
      "similarTo": [
        "ButtonView"
      ],
      "oftenUsedWith": [
        "TicketBetInfoView"
      ],
      "parents": [
        "TicketBetInfoView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# ButtonIconView\n\nA button component with configurable icon position (left or right of title).\n\n## Overview\n\nButtonIconView displays a tappable button with an icon and text label. The icon can be positioned on either side of the text, making it suitable for various action buttons like \"Add Booking Code\" or \"Clear Betslip\" with trailing icons.\n\n## Component Relationships\n\n### Used By (Parents)\n- `TicketBetInfoView` - action buttons within bet ticket info\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Configurable icon position: left or right of title\n- Custom or SF Symbol icon support\n- Customizable icon tint color\n- Optional background color and corner radius\n- Enabled/disabled state with alpha dimming\n- Reactive updates via Combine publisher\n- 16x16pt icon size with 8pt spacing from title\n\n## Usage\n\n```swift\nlet viewModel = MockButtonIconViewModel.bookingCodeMock()\nlet buttonView = ButtonIconView(viewModel: viewModel)\n\nviewModel.onButtonTapped = {\n    print(\"Button tapped\")\n}\n```\n\n## Data Model\n\n```swift\nenum ButtonIconLayoutType: Equatable {\n    case iconLeft\n    case iconRight\n}\n\nstruct ButtonIconData: Equatable {\n    let title: String\n    let icon: String?\n    let layoutType: ButtonIconLayoutType\n    let isEnabled: Bool\n    let backgroundColor: UIColor?\n    let cornerRadius: CGFloat?\n    let iconColor: UIColor?\n}\n\nprotocol ButtonIconViewModelProtocol {\n    var dataPublisher: AnyPublisher<ButtonIconData, Never> { get }\n    var currentData: ButtonIconData { get }\n\n    func updateTitle(_ title: String)\n    func updateIcon(_ icon: String?)\n    func updateLayoutType(_ layoutType: ButtonIconLayoutType)\n    func setEnabled(_ isEnabled: Bool)\n    func updateBackgroundColor(_ color: UIColor?)\n    func updateCornerRadius(_ radius: CGFloat?)\n    func updateIconColor(_ color: UIColor?)\n\n    var onButtonTapped: (() -> Void)? { get set }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.textPrimary` - title text color\n- `StyleProvider.Color.highlightPrimary` - default icon tint color\n- `StyleProvider.fontWith(type: .regular, size: 14)` - title font\n\n## Mock ViewModels\n\nAvailable presets:\n- `.bookingCodeMock()` - \"Add Booking Code\" with barcode icon (left)\n- `.clearBetslipMock()` - \"Clear Betslip\" with trash icon (right)\n- `.disabledMock()` - disabled state example\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "ButtonIconView/__Snapshots__/ButtonIconViewSnapshotTests/testButtonIconView_BasicStates_Light.1.png",
          "dark": "ButtonIconView/__Snapshots__/ButtonIconViewSnapshotTests/testButtonIconView_BasicStates_Dark.1.png"
        },
        {
          "category": "LayoutVariants",
          "light": "ButtonIconView/__Snapshots__/ButtonIconViewSnapshotTests/testButtonIconView_LayoutVariants_Light.1.png",
          "dark": "ButtonIconView/__Snapshots__/ButtonIconViewSnapshotTests/testButtonIconView_LayoutVariants_Dark.1.png"
        },
        {
          "category": "StyleVariants",
          "light": "ButtonIconView/__Snapshots__/ButtonIconViewSnapshotTests/testButtonIconView_StyleVariants_Light.1.png",
          "dark": "ButtonIconView/__Snapshots__/ButtonIconViewSnapshotTests/testButtonIconView_StyleVariants_Dark.1.png"
        }
      ]
    },
    "ButtonView": {
      "displayName": "ButtonView",
      "category": "UIElements",
      "subcategory": "Buttons",
      "summary": "Highly customizable button with three visual styles",
      "description": "Production-ready button supporting solid background, bordered, and transparent styles. Complete color customization for background, border, and text. Typography control, haptic feedback, enabled/disabled states.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "button",
        "cta",
        "action",
        "interactive",
        "customizable"
      ],
      "states": [
        "enabled",
        "disabled",
        "solidBackground",
        "bordered",
        "transparent"
      ],
      "similarTo": [
        "ButtonIconView",
        "ActionButtonBlockView"
      ],
      "oftenUsedWith": [
        "BetInfoSubmissionView",
        "CashoutSubmissionInfoView",
        "BonusCardView"
      ],
      "parents": [
        "BetInfoSubmissionView",
        "BonusCardView",
        "CashoutSliderView",
        "CashoutSubmissionInfoView",
        "CodeInputView",
        "PromotionCardView",
        "PromotionalBonusCardView",
        "UserLimitCardView",
        "WalletDetailView",
        "WalletStatusView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# ButtonView Component\n\nA highly customizable, protocol-driven button component that supports three distinct visual styles with comprehensive color and typography customization options.\n\n## Overview\n\nButtonView is a production-ready UIKit component that follows GomaUI's MVVM architecture patterns. It provides complete customization capabilities while maintaining backward compatibility and falling back to StyleProvider defaults.\n\n## Features\n\n###  Core Capabilities\n- **Three Button Styles**: Solid background, bordered, and transparent\n- **Complete Color Customization**: Background, border, and text colors\n- **Typography Control**: Font size and weight customization  \n- **State Management**: Enabled/disabled states with proper visual feedback\n- **Haptic Feedback**: Built-in tactile response on button press\n- **Reactive Updates**: Combine-based state management\n- **SwiftUI Previews**: Live preview support for rapid development\n\n###  Visual Styles\n\n#### 1. Solid Background (`.solidBackground`)\n- Filled button with custom or default background color\n- Supports custom text color\n- Automatic disabled state styling\n\n#### 2. Bordered (`.bordered`) \n- Outlined button with 2pt border\n- Custom border and text colors\n- Intelligent color fallback (uses border color for text if no explicit text color)\n- Clear background\n\n#### 3. Transparent (`.transparent`)\n- Text-only button with underline styling\n- Custom text color support\n- Maintains underline in both enabled/disabled states\n\n## Usage\n\n### Basic Implementation\n\n```swift\n\n\n// Create a view model (production or mock)\nlet viewModel = MockButtonViewModel.solidBackgroundMock\n\n// Initialize the button view\nlet buttonView = ButtonView(viewModel: viewModel)\n\n// Add to your view hierarchy\nview.addSubview(buttonView)\n```\n\n### Custom Color Examples\n\n```swift\n// Custom solid background button\nlet customSolidData = ButtonData(\n    id: \"custom_button\",\n    title: \"Custom Button\",\n    style: .solidBackground,\n    backgroundColor: UIColor.systemRed,\n    textColor: UIColor.white\n)\n\n// Custom bordered button\nlet customBorderedData = ButtonData(\n    id: \"bordered_button\", \n    title: \"Custom Border\",\n    style: .bordered,\n    borderColor: UIColor.systemBlue,\n    textColor: UIColor.systemBlue\n)\n\n// Custom transparent button\nlet customTransparentData = ButtonData(\n    id: \"transparent_button\",\n    title: \"Custom Link\",\n    style: .transparent,\n    textColor: UIColor.systemPurple\n)\n```\n\n### Font Customization Examples\n\n```swift\n// Large bold button\nlet largeFontData = ButtonData(\n    id: \"large_button\",\n    title: \"Large Button\",\n    style: .solidBackground,\n    fontSize: 24.0,\n    fontType: .bold\n)\n\n// Small medium weight button\nlet smallFontData = ButtonData(\n    id: \"small_button\", \n    title: \"Small Button\",\n    style: .bordered,\n    fontSize: 12.0,\n    fontType: .medium\n)\n\n// Light weight button\nlet lightFontData = ButtonData(\n    id: \"light_button\",\n    title: \"Light Button\", \n    style: .solidBackground,\n    fontSize: 18.0,\n    fontType: .light\n)\n```\n\n### Complete Customization Example\n\n```swift\nlet fullyCustomData = ButtonData(\n    id: \"fully_custom\",\n    title: \"Fully Custom\",\n    style: .solidBackground,\n    backgroundColor: UIColor.systemGreen,\n    textColor: UIColor.black,\n    fontSize: 20.0,\n    fontType: .semibold,\n    isEnabled: true\n)\n\nlet viewModel = MockButtonViewModel(buttonData: fullyCustomData)\nlet buttonView = ButtonView(viewModel: viewModel)\n```\n\n## ButtonData Properties\n\n| Property | Type | Description | Default |\n|----------|------|-------------|---------|\n| `id` | `String` | Unique identifier for the button | Required |\n| `title` | `String` | Button text content | Required |\n| `style` | `ButtonStyle` | Visual style (.solidBackground, .bordered, .transparent) | Required |\n| `backgroundColor` | `UIColor?` | Custom background color (solid style only) | `StyleProvider.Color.buttonBackgroundPrimary` |\n| `disabledBackgroundColor` | `UIColor?` | Custom disabled background color | `StyleProvider.Color.buttonDisablePrimary` |\n| `borderColor` | `UIColor?` | Custom border color (bordered style) | `StyleProvider.Color.highlightPrimary` |\n| `textColor` | `UIColor?` | Custom text color (all styles) | Style-specific StyleProvider color |\n| `fontSize` | `CGFloat?` | Custom font size | `16.0` |\n| `fontType` | `StyleProvider.FontType?` | Font weight (.thin, .light, .regular, .medium, .semibold, .bold, .heavy) | `.bold` |\n| `isEnabled` | `Bool` | Button enabled state | `true` |\n\n## Available Font Types\n\nButtonView supports all StyleProvider font types:\n\n- `.thin` - Ultra-light weight\n- `.light` - Light weight  \n- `.regular` - Normal weight\n- `.medium` - Medium weight\n- `.semibold` - Semi-bold weight\n- `.bold` - Bold weight (default)\n- `.heavy` - Heavy/black weight\n\n## Mock Examples\n\n### Basic Styles\n```swift\nMockButtonViewModel.solidBackgroundMock\nMockButtonViewModel.borderedMock  \nMockButtonViewModel.transparentMock\n```\n\n### Color Customization\n```swift\nMockButtonViewModel.solidBackgroundCustomColorMock    // Red background, white text\nMockButtonViewModel.borderedCustomColorMock           // Blue border and text\nMockButtonViewModel.transparentCustomColorMock        // Purple text\nMockButtonViewModel.redThemeMock                      // Red themed button\nMockButtonViewModel.blueThemeMock                     // Blue themed button\nMockButtonViewModel.greenThemeMock                    // Green themed button\nMockButtonViewModel.orangeThemeMock                   // Orange themed button\n```\n\n### Font Customization  \n```swift\nMockButtonViewModel.largeFontMock                     // 24pt Bold\nMockButtonViewModel.smallFontMock                     // 12pt Medium\nMockButtonViewModel.lightFontMock                     // 18pt Light\nMockButtonViewModel.heavyFontMock                     // 20pt Heavy\nMockButtonViewModel.customFontStyleMock               // 16pt Semibold\n```\n\n## SwiftUI Previews\n\nThe component includes comprehensive SwiftUI previews:\n\n- **\"All Button States\"** - Basic styles and disabled states\n- **\"Custom Color Examples\"** - Color customization showcase\n- **\"Color Themes Comparison\"** - Side-by-side theme comparison\n- **\"Font Customization Examples\"** - Typography variations\n- **\"Font Weight Comparison\"** - Font weight showcase\n\n## Architecture\n\n### MVVM Pattern\n- **ButtonView**: UIView implementation\n- **ButtonViewModelProtocol**: Reactive interface\n- **MockButtonViewModel**: Comprehensive test implementation\n\n### Protocol-Driven Design\n```swift\nprotocol ButtonViewModelProtocol {\n    var buttonDataPublisher: AnyPublisher<ButtonData, Never> { get }\n    func buttonTapped()\n    func setEnabled(_ isEnabled: Bool)\n    func updateTitle(_ title: String)\n    var onButtonTapped: (() -> Void)? { get set }\n}\n```\n\n### Reactive Updates\nButtonView uses Combine for reactive state management:\n```swift\nviewModel.buttonDataPublisher\n    .receive(on: DispatchQueue.main)\n    .sink { [weak self] buttonData in\n        self?.configure(buttonData: buttonData)\n    }\n    .store(in: &cancellables)\n```\n\n## Color Fallback Strategy\n\n1. **Custom Colors First**: Uses provided custom colors when available\n2. **StyleProvider Fallback**: Falls back to StyleProvider colors for consistency\n3. **Intelligent Defaults**: Bordered buttons use border color for text when no explicit text color provided\n4. **Disabled State Preservation**: Disabled states always use StyleProvider colors\n\n## Best Practices\n\n###  Do\n- Use mock implementations for testing and previews\n- Leverage StyleProvider for consistent theming\n- Provide meaningful button IDs for analytics\n- Test different font sizes for accessibility\n- Use appropriate button styles for context\n\n###  Don't  \n- Hardcode colors - always use custom properties or StyleProvider\n- Create buttons without proper enabled/disabled states\n- Ignore font size accessibility considerations\n- Mix button styles inconsistently within the same interface\n\n## Testing\n\nThe component includes extensive testing support:\n\n### Catalog App Testing\nRun `GomaUICatalog` target to see all button variations:\n- 6 basic style examples\n- 7 color customization examples  \n- 5 font customization examples\n- 18 total interactive examples\n\n### SwiftUI Preview Testing\nUse Xcode previews for rapid iteration:\n- Individual component testing\n- Color theme comparisons\n- Font weight showcases\n- State variation testing\n\n## Integration\n\n### Adding to GomaUICatalog\n```swift\n// Add to ButtonViewController\n(\"Your Custom Button\", MockButtonViewModel.yourCustomMock)\n```\n\n### Creating Custom Mocks\n```swift\npublic static var yourCustomMock: MockButtonViewModel {\n    let buttonData = ButtonData(\n        id: \"your_custom_id\",\n        title: \"Your Title\",\n        style: .solidBackground,\n        backgroundColor: UIColor.systemTeal,\n        textColor: UIColor.white,\n        fontSize: 18.0,\n        fontType: .semibold,\n        isEnabled: true\n    )\n    return MockButtonViewModel(buttonData: buttonData)\n}\n```\n\n## Files Structure\n\n```\nButtonView/\n ButtonView.swift                     # Main UIView implementation\n ButtonViewModelProtocol.swift        # Protocol + ButtonData model\n MockButtonViewModel.swift            # Mock implementation with examples\n README.md                           # This documentation\n```\n\n## Dependencies\n\n- **UIKit**: Core UI framework\n- **Combine**: Reactive programming  \n- **StyleProvider**: GomaUI theming system\n- **SwiftUI**: Preview support\n\n## Backward Compatibility\n\nAll new customization properties are optional with sensible defaults, ensuring complete backward compatibility with existing implementations. Existing code continues to work without modification while gaining access to new customization capabilities.\n",
      "snapshots": [
        {
          "category": "BasicStyles",
          "light": "ButtonView/__Snapshots__/ButtonViewSnapshotTests/testButtonView_BasicStyles_Light.1.png",
          "dark": "ButtonView/__Snapshots__/ButtonViewSnapshotTests/testButtonView_BasicStyles_Dark.1.png"
        },
        {
          "category": "CommonActions",
          "light": "ButtonView/__Snapshots__/ButtonViewSnapshotTests/testButtonView_CommonActions_Light.1.png",
          "dark": "ButtonView/__Snapshots__/ButtonViewSnapshotTests/testButtonView_CommonActions_Dark.1.png"
        },
        {
          "category": "CustomColors",
          "light": "ButtonView/__Snapshots__/ButtonViewSnapshotTests/testButtonView_CustomColors_Light.1.png",
          "dark": "ButtonView/__Snapshots__/ButtonViewSnapshotTests/testButtonView_CustomColors_Dark.1.png"
        },
        {
          "category": "DisabledStates",
          "light": "ButtonView/__Snapshots__/ButtonViewSnapshotTests/testButtonView_DisabledStates_Light.1.png",
          "dark": "ButtonView/__Snapshots__/ButtonViewSnapshotTests/testButtonView_DisabledStates_Dark.1.png"
        },
        {
          "category": "FontCustomization",
          "light": "ButtonView/__Snapshots__/ButtonViewSnapshotTests/testButtonView_FontCustomization_Light.1.png",
          "dark": "ButtonView/__Snapshots__/ButtonViewSnapshotTests/testButtonView_FontCustomization_Dark.1.png"
        },
        {
          "category": "ThemeVariants",
          "light": "ButtonView/__Snapshots__/ButtonViewSnapshotTests/testButtonView_ThemeVariants_Light.1.png",
          "dark": "ButtonView/__Snapshots__/ButtonViewSnapshotTests/testButtonView_ThemeVariants_Dark.1.png"
        }
      ]
    },
    "CapsuleView": {
      "displayName": "CapsuleView",
      "category": "UIElements",
      "subcategory": "Badges",
      "summary": "Pill-shaped badge for labels, status, and tags",
      "description": "Versatile capsule component with perfect pill shape (radius = height/2). Customizable colors, fonts, padding. Supports custom content views. Used for live badges, count badges, status indicators, category tags.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "badge",
        "pill",
        "capsule",
        "tag",
        "status",
        "indicator",
        "live"
      ],
      "states": [],
      "similarTo": [
        "PillItemView"
      ],
      "oftenUsedWith": [
        "MatchDateNavigationBar",
        "TicketSelectionView"
      ],
      "parents": [
        "MatchDateNavigationBar",
        "TicketSelectionView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CapsuleView\n\nA versatile UIKit component that creates perfectly rounded capsule/pill-shaped containers with automatic shape management and customizable styling.\n\n## Overview\n\n`CapsuleView` is designed for displaying badges, status indicators, count labels, and other pill-shaped UI elements. It automatically maintains a perfect capsule shape regardless of content size and provides extensive customization options.\n\n## Key Features\n\n- **Perfect Capsule Shape**: Automatically calculates corner radius as half the view height\n- **Automatic Layout**: Self-managing shape that updates when content changes\n- **Flexible Content**: Supports text with customizable fonts, colors, and padding\n- **Themeable**: Uses StyleProvider for consistent design system integration\n- **Performance**: Efficient layout updates only when bounds change\n- **Stack View Friendly**: Works seamlessly in UIStackView and Auto Layout\n\n## Visual Examples\n\n### Live Badge\nGreen capsule with \"LIVE\" text for match status indicators\n\n### Count Badge\nOrange capsule with numbers for notification counts or item quantities\n\n### Status Badge\nCustomizable capsules for various status states\n\n## Usage\n\n### Basic Usage\n```swift\n// Create view model\nlet viewModel = MockCapsuleViewModel.liveBadge\nlet capsuleView = CapsuleView(viewModel: viewModel)\n\n// Add to your view hierarchy\nstackView.addArrangedSubview(capsuleView)\n```\n\n### Custom Configuration\n```swift\nlet customData = CapsuleData(\n    text: \"Custom Badge\",\n    backgroundColor: .systemBlue,\n    textColor: .white,\n    font: StyleProvider.fontWith(type: .bold, size: 12),\n    horizontalPadding: 16.0,\n    verticalPadding: 6.0\n)\nlet viewModel = MockCapsuleViewModel(data: customData)\nlet capsuleView = CapsuleView(viewModel: viewModel)\n```\n\n### Dynamic Updates\n```swift\n// Update text dynamically\nlet newData = CapsuleData(\n    text: \"Updated\",\n    backgroundColor: capsuleView.viewModel.data.backgroundColor,\n    textColor: capsuleView.viewModel.data.textColor\n)\ncapsuleView.viewModel.configure(with: newData)\n```\n\n## Customization Options\n\n### CapsuleData Properties\n\n- **text**: The text to display (optional)\n- **backgroundColor**: Capsule background color\n- **textColor**: Text color\n- **font**: Text font\n- **horizontalPadding**: Left/right padding around text\n- **verticalPadding**: Top/bottom padding around text\n- **minimumHeight**: Optional minimum height constraint\n\n### Default Values\n- Horizontal padding: 12pt\n- Vertical padding: 4pt\n- Uses StyleProvider colors and fonts for consistency\n\n## Pre-built Configurations\n\nThe component includes several factory methods for common use cases:\n\n### Live Badge\n```swift\nMockCapsuleViewModel.liveBadge\n// Green background, white text, \"LIVE\"\n```\n\n### Count Badge\n```swift\nMockCapsuleViewModel.countBadge\n// Orange background, white text, \"16\"\n```\n\n### Status Badge\n```swift\nMockCapsuleViewModel.statusBadge\n// Blue background, white text, \"Active\"\n```\n\n### Warning Badge\n```swift\nMockCapsuleViewModel.warningBadge\n// Yellow background, dark text, \"Warning\"\n```\n\n### Notification Badge\n```swift\nMockCapsuleViewModel.notificationBadge\n// Red background, white text, \"3\"\n```\n\n## Implementation Details\n\n### Automatic Shape Management\nThe view uses a self-contained approach where the shape is managed in `layoutSubviews`:\n\n```swift\noverride func layoutSubviews() {\n    super.layoutSubviews()\n    layer.cornerRadius = bounds.height / 2\n    layer.masksToBounds = true\n}\n```\n\n### Constraint-Based Layout\nThe view uses Auto Layout with proper content hugging and compression resistance:\n- Text label with configurable padding\n- Minimum height constraints when specified\n- Intrinsic content sizing\n\n### Performance Considerations\n- Shape updates only when bounds actually change\n- Efficient text measurement and layout\n- No unnecessary constraint activation/deactivation\n\n## Design System Integration\n\nThe component integrates with GomaUI's design system:\n\n```swift\n// Uses StyleProvider colors\nbackgroundColor: StyleProvider.Color.highlightSecondary\ntextColor: StyleProvider.Color.buttonTextPrimary\n\n// Uses StyleProvider fonts\nfont: StyleProvider.fontWith(type: .bold, size: 10)\n```\n\n## Common Use Cases\n\n1. **Live Match Indicators**: \"LIVE\", \"1st Half, 41mins\"\n2. **Notification Badges**: Count indicators on tabs or buttons\n3. **Status Labels**: \"Active\", \"Pending\", \"Completed\"\n4. **Category Tags**: Pill-shaped category labels\n5. **Action Badges**: \"New\", \"Updated\", \"Hot\"\n\n## SwiftUI Previews\n\nThe component includes comprehensive SwiftUI previews showing:\n- Different badge types and configurations\n- Various text lengths and styles\n- Color combinations and themes\n- Sizing variations\n\n## Best Practices\n\n1. **Consistent Styling**: Use factory methods or StyleProvider for consistency\n2. **Appropriate Sizing**: Consider minimum touch targets for interactive elements\n3. **Color Contrast**: Ensure sufficient contrast between background and text\n4. **Content Length**: Keep text concise for optimal pill shape\n5. **Accessibility**: Provide appropriate accessibility labels when needed\n\n## Related Components\n\n- **PillItemView**: For interactive pill-shaped buttons\n- **StatusNotificationView**: For larger status displays\n- **MarketNamePillLabelView**: For specific betting market labels\n\n## Testing\n\nUse the Demo app to test different configurations and see live examples of all badge types and customization options.",
      "snapshots": []
    },
    "CashoutAmountView": {
      "displayName": "CashoutAmountView",
      "category": "Betting",
      "subcategory": "Cashout",
      "summary": "Compact display of cashout title and currency amount",
      "description": "Simple row with title label and formatted currency amount. Rounded container background. Fixed 35pt height. Used for showing partial or full cashout amounts in bet ticket interfaces.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "cashout",
        "amount",
        "currency",
        "display",
        "ticket"
      ],
      "states": [],
      "similarTo": [],
      "oftenUsedWith": [
        "TicketBetInfoView"
      ],
      "parents": [
        "TicketBetInfoView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CashoutAmountView\n\nA compact display component showing cashout title and amount with currency.\n\n## Overview\n\nCashoutAmountView displays a simple row with a title label on the left and a formatted currency amount on the right. It's designed for showing partial or full cashout amounts within bet ticket interfaces, with a rounded container background.\n\n## Component Relationships\n\n### Used By (Parents)\n- `TicketBetInfoView` - displays cashout amount within bet ticket\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Title and amount horizontal layout\n- Currency symbol prefix\n- Secondary background with 8pt corner radius\n- Fixed 35pt height\n- Bold amount styling\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockCashoutAmountViewModel.defaultMock()\nlet cashoutAmountView = CashoutAmountView(viewModel: viewModel)\n```\n\n## Data Model\n\n```swift\nstruct CashoutAmountData: Equatable {\n    let title: String\n    let currency: String\n    let amount: String\n}\n\nprotocol CashoutAmountViewModelProtocol {\n    var dataPublisher: AnyPublisher<CashoutAmountData, Never> { get }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundSecondary` - container background\n- `StyleProvider.Color.textPrimary` - title and amount text color\n- `StyleProvider.fontWith(type: .regular, size: 14)` - title font\n- `StyleProvider.fontWith(type: .bold, size: 14)` - amount font\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock()` - \"Partial Cashout\" with XAF 32.00\n- `.customMock(title:currency:amount:)` - custom values\n",
      "snapshots": []
    },
    "CashoutSliderView": {
      "displayName": "CashoutSliderView",
      "category": "Betting",
      "subcategory": "Cashout",
      "summary": "Slider for selecting partial cashout amounts with action button",
      "description": "Interactive slider for cashout amount selection between min/max values. Dynamic button title updates as slider moves. Custom thumb, highlight colors. 12pt corner radius container.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "slider",
        "cashout",
        "partial",
        "amount",
        "interactive"
      ],
      "states": [
        "enabled",
        "disabled"
      ],
      "similarTo": [
        "CustomSliderView"
      ],
      "oftenUsedWith": [
        "TicketBetInfoView",
        "ButtonView"
      ],
      "parents": [
        "TicketBetInfoView"
      ],
      "children": [
        "ButtonView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CashoutSliderView\n\nA slider component for selecting partial cashout amounts with integrated action button.\n\n## Overview\n\nCashoutSliderView provides an interactive slider for users to select a cashout amount between minimum and maximum values. It displays the current range, updates the cashout button title dynamically as the slider moves, and includes a built-in ButtonView for executing the cashout action.\n\n## Component Relationships\n\n### Used By (Parents)\n- `TicketBetInfoView` - partial cashout interface within bet tickets\n\n### Uses (Children)\n- `ButtonView` - cashout action button\n\n## Features\n\n- Interactive UISlider with customizable range\n- Dynamic min/max value labels\n- Real-time button title updates reflecting selected amount\n- Custom thumb image (circle icon)\n- Highlight primary color for slider track and thumb\n- 12pt container corner radius\n- Enable/disable state support\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockCashoutSliderViewModel.defaultMock()\nlet sliderView = CashoutSliderView(viewModel: viewModel)\n\nviewModel.onCashoutTap = {\n    print(\"Cashout requested\")\n}\n```\n\n## Data Model\n\n```swift\nstruct CashoutSliderData: Equatable {\n    let title: String\n    let minimumValue: Float\n    let maximumValue: Float\n    let currentValue: Float\n    let currency: String\n    let isEnabled: Bool\n}\n\nprotocol CashoutSliderViewModelProtocol {\n    var dataPublisher: AnyPublisher<CashoutSliderData, Never> { get }\n    var buttonViewModel: ButtonViewModelProtocol { get }\n\n    func updateSliderValue(_ value: Float)\n    func handleCashoutTap()\n    func setEnabled(_ isEnabled: Bool)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundPrimary` - container background\n- `StyleProvider.Color.highlightPrimary` - slider minimum track and thumb\n- `StyleProvider.Color.backgroundSecondary` - slider maximum track\n- `StyleProvider.Color.textPrimary` - title and value labels\n- `StyleProvider.fontWith(type: .regular, size: 12)` - title font\n- `StyleProvider.fontWith(type: .regular, size: 14)` - value labels font\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock()` - XAF 0.1 to 200, current at 200\n- `.maximumMock()` - slider at maximum value\n- `.minimumMock()` - slider at minimum value\n- `.customMock(title:minimumValue:maximumValue:currentValue:currency:)` - custom configuration\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CashoutSliderView/__Snapshots__/CashoutSliderViewSnapshotTests/testCashoutSliderView_BasicStates_Light.1.png",
          "dark": "CashoutSliderView/__Snapshots__/CashoutSliderViewSnapshotTests/testCashoutSliderView_BasicStates_Dark.1.png"
        },
        {
          "category": "ValueVariants",
          "light": "CashoutSliderView/__Snapshots__/CashoutSliderViewSnapshotTests/testCashoutSliderView_ValueVariants_Light.1.png",
          "dark": "CashoutSliderView/__Snapshots__/CashoutSliderViewSnapshotTests/testCashoutSliderView_ValueVariants_Dark.1.png"
        }
      ]
    },
    "CashoutSubmissionInfoView": {
      "displayName": "CashoutSubmissionInfoView",
      "category": "Betting",
      "subcategory": "Cashout",
      "summary": "Status notification bar for cashout submission results",
      "description": "Feedback after cashout showing success/error state with icon, message, and action button. Distinct backgrounds and icons per state. Visibility toggle for show/hide. Fixed 56pt height.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "notification",
        "cashout",
        "status",
        "success",
        "error",
        "feedback"
      ],
      "states": [
        "success",
        "error",
        "visible",
        "hidden"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "ButtonView"
      ],
      "parents": [],
      "children": [
        "ButtonView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CashoutSubmissionInfoView\n\nA status notification bar displaying cashout submission results with icon and action button.\n\n## Overview\n\nCashoutSubmissionInfoView shows feedback after a cashout operation, displaying either success or error state with appropriate icon, message, and action button. The component uses distinct background colors and icons for each state, with visibility control for showing/hiding the notification.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone notification component)\n\n### Uses (Children)\n- `ButtonView` - action button (OK/Retry)\n\n## Features\n\n- Success and error visual states\n- State-appropriate icon (checkmark or warning)\n- Customizable message text\n- Visibility toggle for show/hide\n- Integrated action button with state-specific label\n- Fixed 56pt height with 12pt corner radius\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockCashoutSubmissionInfoViewModel.successMock()\nlet infoView = CashoutSubmissionInfoView(viewModel: viewModel)\n\nviewModel.onButtonTap = {\n    print(\"User acknowledged\")\n}\n```\n\n## Data Model\n\n```swift\nenum CashoutSubmissionState: Equatable {\n    case success\n    case error\n}\n\nstruct CashoutSubmissionInfoData: Equatable {\n    let state: CashoutSubmissionState\n    let message: String\n    let isVisible: Bool\n}\n\nprotocol CashoutSubmissionInfoViewModelProtocol {\n    var dataPublisher: AnyPublisher<CashoutSubmissionInfoData, Never> { get }\n    var buttonViewModel: ButtonViewModelProtocol { get }\n\n    func handleButtonTap()\n    func setVisible(_ isVisible: Bool)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.highlightSecondary` - success state background\n- `StyleProvider.Color.highlightPrimary` - error state background\n- `StyleProvider.fontWith(type: .regular, size: 14)` - message font\n- White text color for messages\n\nIcons:\n- Success: \"success_circle_icon\" or SF Symbol \"checkmark.circle.fill\"\n- Error: \"alert_icon\" or SF Symbol \"exclamationmark.triangle.fill\"\n\n## Mock ViewModels\n\nAvailable presets:\n- `.successMock()` - \"Cashout Successful\" with OK button\n- `.errorMock()` - \"Cashout Failed\" with Retry button\n- `.customMock(state:message:isVisible:)` - custom configuration\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CashoutSubmissionInfoView/__Snapshots__/CashoutSubmissionInfoViewSnapshotTests/testCashoutSubmissionInfoView_BasicStates_Light.1.png",
          "dark": "CashoutSubmissionInfoView/__Snapshots__/CashoutSubmissionInfoViewSnapshotTests/testCashoutSubmissionInfoView_BasicStates_Dark.1.png"
        }
      ]
    },
    "CasinoCategoryBarView": {
      "displayName": "CasinoCategoryBarView",
      "category": "Casino",
      "subcategory": "Sections",
      "summary": "Section header bar with category title and See All action",
      "description": "Header for casino game sections with category title on left and action button with count/chevron on right. Secondary background, placeholder state support.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "header",
        "category",
        "section",
        "navigation",
        "see-all"
      ],
      "states": [
        "normal",
        "placeholder"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "CasinoCategorySectionView",
        "CasinoGameImageGridSectionView"
      ],
      "parents": [
        "CasinoCategorySectionView",
        "CasinoGameImageGridSectionView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CasinoCategoryBarView\n\nA simple horizontal bar component for displaying casino game categories with a title and action button.\n\n## Overview\n\nThe `CasinoCategoryBarView` provides a clean, consistent way to display category information with an interactive button. It features a title label on the left side and an action button on the right side containing count text and a chevron icon.\n\n## Features\n\n- **Flexible Content**: Configurable title and button text\n- **Optional ViewModel**: Can be initialized with or without a viewModel\n- **Runtime Configuration**: Supports changing viewModel after initialization\n- **Reactive Updates**: Uses Combine publishers for real-time UI updates\n- **Interactive Button**: Tap handling with callback support\n- **Consistent Styling**: Follows GomaUI design system\n\n## Architecture\n\n### MVVM Pattern\nThe component follows the MVVM (Model-View-ViewModel) architectural pattern:\n\n- **Model**: `CasinoCategoryBarData` - Contains category information\n- **View**: `CasinoCategoryBarView` - The UI component\n- **ViewModel**: `CasinoCategoryBarViewModelProtocol` - Business logic and data binding\n\n### Components Structure\n```\nCasinoCategoryBarView/\n CasinoCategoryBarViewModelProtocol.swift  # Protocol and data models\n CasinoCategoryBarView.swift               # Main UI component\n MockCasinoCategoryBarViewModel.swift      # Mock implementation\n Documentation/\n     README.md                             # This file\n```\n\n## Usage\n\n### Basic Usage\n```swift\n\n\n// With viewModel\nlet viewModel = MockCasinoCategoryBarViewModel.newGames\nlet categoryBar = CasinoCategoryBarView(viewModel: viewModel)\n\n// Without viewModel (shows placeholder)\nlet categoryBar = CasinoCategoryBarView()\n```\n\n### Runtime Configuration\n```swift\nlet categoryBar = CasinoCategoryBarView()\n\n// Configure with viewModel\ncategoryBar.configure(with: viewModel)\n\n// Clear viewModel (shows placeholder)\ncategoryBar.configure(with: nil)\n```\n\n### Button Action Handling\n```swift\ncategoryBar.onButtonTapped = { categoryId in\n    print(\"Button tapped for category: \\(categoryId)\")\n    // Handle navigation or filtering\n}\n```\n\n## Data Models\n\n### CasinoCategoryBarData\n```swift\npublic struct CasinoCategoryBarData: Equatable, Hashable, Identifiable {\n    public let id: String           // category identifier\n    public let title: String        // category title (e.g., \"New Games\")\n    public let buttonText: String   // button text (e.g., \"All 41\")\n}\n```\n\n## ViewModel Protocol\n\n### CasinoCategoryBarViewModelProtocol\n```swift\npublic protocol CasinoCategoryBarViewModelProtocol: AnyObject {\n    // Publishers for reactive updates\n    var titlePublisher: AnyPublisher<String, Never> { get }\n    var buttonTextPublisher: AnyPublisher<String, Never> { get }\n    \n    // Read-only properties\n    var categoryId: String { get }\n    \n    // Actions\n    func buttonTapped()\n}\n```\n\n## Mock ViewModel\n\nThe `MockCasinoCategoryBarViewModel` provides several factory methods for common casino categories:\n\n```swift\n// Predefined categories\nlet newGames = MockCasinoCategoryBarViewModel.newGames\nlet popularGames = MockCasinoCategoryBarViewModel.popularGames\nlet slotGames = MockCasinoCategoryBarViewModel.slotGames\nlet liveGames = MockCasinoCategoryBarViewModel.liveGames\nlet jackpotGames = MockCasinoCategoryBarViewModel.jackpotGames\n\n// Custom category\nlet custom = MockCasinoCategoryBarViewModel.customCategory(\n    id: \"custom-id\",\n    title: \"Custom Category\",\n    buttonText: \"All 15\"\n)\n```\n\n## Visual Design\n\nThe component follows the Figma design specifications:\n\n- **Background**: `backgroundSecondary` color\n- **Title**: Bold 16px, `textPrimary` color\n- **Button**: `highlightPrimary` background, white text, 14px semibold\n- **Icon**: Right chevron in button\n- **Layout**: Horizontal with space-between alignment\n- **Padding**: 16px horizontal, 12px vertical\n- **Button**: 10px horizontal, 4px vertical padding\n\n## States\n\n### Normal State\n- Displays title and button text from viewModel\n- Button is interactive\n- Publishers provide real-time updates\n\n### Placeholder State\n- Shows when no viewModel is provided\n- Displays \"Category Title\" and \"All 0\" as placeholders\n- Button is still interactive but returns empty categoryId\n\n## Accessibility\n\nThe component supports:\n- VoiceOver navigation\n- Dynamic type scaling\n- High contrast support\n- Touch target sizing (minimum 44pt)\n\n## Demo\n\nSee `CasinoCategoryBarViewController` in the GomaUI Demo app for interactive examples showcasing:\n- Multiple category bars with different data\n- Runtime configuration switching\n- Button tap handling\n- Placeholder state demonstration\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CasinoCategoryBarView/__Snapshots__/CasinoCategoryBarViewSnapshotTests/testCasinoCategoryBarView_BasicStates_Light.1.png",
          "dark": "CasinoCategoryBarView/__Snapshots__/CasinoCategoryBarViewSnapshotTests/testCasinoCategoryBarView_BasicStates_Dark.1.png"
        },
        {
          "category": "CategoryVariants",
          "light": "CasinoCategoryBarView/__Snapshots__/CasinoCategoryBarViewSnapshotTests/testCasinoCategoryBarView_CategoryVariants_Light.1.png",
          "dark": "CasinoCategoryBarView/__Snapshots__/CasinoCategoryBarViewSnapshotTests/testCasinoCategoryBarView_CategoryVariants_Dark.1.png"
        }
      ]
    },
    "CasinoCategorySectionView": {
      "displayName": "CasinoCategorySectionView",
      "category": "Casino",
      "subcategory": "Sections",
      "summary": "Category section with header and horizontal scrolling game cards",
      "description": "Complete casino section with CasinoCategoryBarView header and horizontal CasinoGameCardView collection. Fixed 164x272pt cards, 12pt spacing. Tertiary background. Game selection and category callbacks.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "section",
        "category",
        "games",
        "horizontal-scroll",
        "collection"
      ],
      "states": [
        "normal",
        "placeholder"
      ],
      "similarTo": [
        "CasinoGameImageGridSectionView"
      ],
      "oftenUsedWith": [
        "CasinoCategoryBarView",
        "CasinoGameCardView"
      ],
      "parents": [],
      "children": [
        "CasinoCategoryBarView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CasinoCategorySectionView\n\nA composite component that combines a category header with a horizontal collection of casino game cards, following MVVM architecture with proper child ViewModel management.\n\n## Overview\n\nThe `CasinoCategorySectionView` provides a complete category section for casino games, featuring a `CasinoCategoryBarView` header and a horizontal collection view of `CasinoGameCardView` components. This component strictly follows the MVVM Vertical Pattern where the parent ViewModel creates and manages child ViewModels for its subviews.\n\n## Features\n\n- **MVVM Compliant**: Follows Documentation/MVVM.md guidelines with proper Vertical Pattern implementation\n- **Child ViewModel Management**: Parent ViewModel creates and manages child ViewModels for subcomponents\n- **Composite Architecture**: Combines existing CasinoCategoryBarView and CasinoGameCardView components\n- **Separate Cell Component**: CasinoGameCardCollectionViewCell for proper collection view architecture\n- **Reactive Updates**: Uses Combine publishers for real-time UI updates\n- **Interactive Elements**: Game selection and category button tap handling\n- **Optional ViewModel**: Can be initialized with or without a viewModel\n- **Runtime Configuration**: Supports changing viewModel after initialization\n\n## Architecture\n\n### MVVM Hierarchy (Vertical Pattern )\n\n```swift\nCasinoCategorySectionViewModel (Parent)\n     CasinoCategoryBarViewModel (Child)\n     [CasinoGameCardViewModel] (Children array)\n\n//  CORRECT: Parent ViewModel creates children for its subviews\nclass CasinoCategorySectionViewModel {\n    let categoryBarViewModel: CasinoCategoryBarViewModelProtocol\n    let gameCardViewModels: [CasinoGameCardViewModelProtocol]\n    \n    init(sectionData: CasinoCategorySectionData) {\n        // Parent creates child ViewModels for its own component\n        self.categoryBarViewModel = MockCasinoCategoryBarViewModel(...)\n        self.gameCardViewModels = sectionData.games.map { game in\n            MockCasinoGameCardViewModel(gameData: game)\n        }\n        \n        setupChildCommunication()\n    }\n}\n```\n\n### Components Structure\n```\nCasinoCategorySectionView/\n CasinoCategorySectionViewModelProtocol.swift    # Protocol and data models\n CasinoCategorySectionView.swift                 # Main UI component\n CasinoGameCardCollectionViewCell.swift          # Separate cell wrapper\n MockCasinoCategorySectionViewModel.swift        # Mock implementation\n Documentation/\n     README.md                                   # This file\n```\n\n## Usage\n\n### Basic Usage\n```swift\n\n\n// With viewModel\nlet viewModel = MockCasinoCategorySectionViewModel.newGamesSection\nlet categorySection = CasinoCategorySectionView(viewModel: viewModel)\n\n// Without viewModel (shows placeholder)\nlet categorySection = CasinoCategorySectionView()\n```\n\n### Runtime Configuration\n```swift\nlet categorySection = CasinoCategorySectionView()\n\n// Configure with viewModel\ncategorySection.configure(with: viewModel)\n\n// Clear viewModel (shows placeholder)\ncategorySection.configure(with: nil)\n```\n\n### Callback Handling\n```swift\ncategorySection.onGameSelected = { gameId in\n    print(\"Game selected: \\(gameId)\")\n    // Handle navigation to game or launch game\n}\n\ncategorySection.onCategoryButtonTapped = { categoryId in\n    print(\"Category button tapped: \\(categoryId)\")\n    // Handle navigation to full category view\n}\n```\n\n## Data Models\n\n### CasinoCategorySectionData\n```swift\npublic struct CasinoCategorySectionData: Equatable, Hashable, Identifiable {\n    public let id: String               // category identifier  \n    public let categoryTitle: String    // category title (e.g., \"New Games\")\n    public let categoryButtonText: String // button text (e.g., \"All 41\")\n    public let games: [CasinoGameCardData] // array of games in this category\n}\n```\n\n## ViewModel Protocol\n\n### CasinoCategorySectionViewModelProtocol\n```swift\npublic protocol CasinoCategorySectionViewModelProtocol: AnyObject {\n    // Child ViewModels (Vertical Pattern - Parent creates children)\n    var categoryBarViewModel: CasinoCategoryBarViewModelProtocol { get }\n    var gameCardViewModels: [CasinoGameCardViewModelProtocol] { get }\n    \n    // Publishers for reactive updates\n    var gameCardViewModelsPublisher: AnyPublisher<[CasinoGameCardViewModelProtocol], Never> { get }\n    \n    // Read-only properties\n    var sectionId: String { get }\n    var categoryTitle: String { get }\n    \n    // Actions\n    func gameSelected(_ gameId: String)\n    func categoryButtonTapped()\n    func refreshGames()\n}\n```\n\n## Child ViewModel Management\n\n### MVVM Compliance\nThe component follows the **Vertical Pattern** from Documentation/MVVM.md:\n\n** DO (Vertical Pattern):**\n- Parent ViewModel creates child ViewModels for its subviews\n- `CasinoCategorySectionViewModel` creates `CasinoCategoryBarViewModel`\n- `CasinoCategorySectionViewModel` creates array of `CasinoGameCardViewModel`\n- Parent manages all child ViewModels for the same component\n- Children communicate up via callbacks/publishers\n\n** DON'T (Horizontal Pattern):**\n- ViewModels creating ViewModels for other ViewControllers\n- Direct ViewModel-to-ViewModel communication across components\n- Circular references between ViewModels\n\n### Communication Pattern\n```swift\n// Children communicate UP to parent via callbacks\ngameCardViewModels.forEach { gameVM in\n    gameVM.onGameSelected = { [weak self] gameId in\n        self?.handleGameSelection(gameId)\n    }\n}\n\n// Parent coordinates between children if needed\nprivate func setupChildCommunication() {\n    // Any cross-child communication handled by parent\n    // For example, game selection updating category bar state\n}\n```\n\n## Collection View Architecture\n\n### CasinoGameCardCollectionViewCell\nThe separate cell component provides:\n\n- **Wrapper Pattern**: Wraps `CasinoGameCardView` in collection view cell\n- **Proper Reuse**: Handles cell reuse with state cleanup\n- **Callback Forwarding**: Forwards game selection callbacks\n- **ViewModel Management**: Manages bindings and cancellables\n\n```swift\nclass CasinoGameCardCollectionViewCell: UICollectionViewCell {\n    private let gameCardView = CasinoGameCardView()\n    \n    func configure(with viewModel: CasinoGameCardViewModelProtocol?) {\n        gameCardView.configure(with: viewModel)\n    }\n    \n    var onGameSelected: ((String) -> Void) {\n        get { gameCardView.onGameSelected }\n        set { gameCardView.onGameSelected = newValue }\n    }\n}\n```\n\n## Mock ViewModel\n\nThe `MockCasinoCategorySectionViewModel` provides factory methods for different scenarios:\n\n```swift\n// Predefined sections\nlet newGames = MockCasinoCategorySectionViewModel.newGamesSection      // 4 games\nlet popular = MockCasinoCategorySectionViewModel.popularGamesSection   // 3 games\nlet slots = MockCasinoCategorySectionViewModel.slotGamesSection        // 2 games\nlet empty = MockCasinoCategorySectionViewModel.emptySection            // 0 games\n\n// Custom section\nlet custom = MockCasinoCategorySectionViewModel.customSection(\n    id: \"custom-id\",\n    categoryTitle: \"Custom Category\",\n    categoryButtonText: \"All 15\",\n    games: customGamesArray\n)\n```\n\n## Visual Design\n\nThe component follows a vertical layout:\n\n### Category Bar (Top)\n- Uses existing `CasinoCategoryBarView` component\n- Orange background with title and button\n- Full width with proper padding\n\n### Collection View (Bottom)\n- **Layout**: Horizontal scrolling\n- **Cell size**: 164272pt (CasinoGameCardView dimensions)\n- **Spacing**: 12pt between cells\n- **Content insets**: 16pt horizontal\n- **Height**: Fixed at 272pt\n\n### Overall Layout\n- **Vertical spacing**: 12pt between category bar and collection\n- **Background**: StyleProvider.Color.backgroundPrimary\n\n## States\n\n### Normal State\n- Category bar displays title and button text from ViewModel\n- Collection displays game cards from child ViewModels\n- All interactive elements are functional\n- Publishers provide real-time updates\n\n### Placeholder State\n- Shows when no viewModel is provided\n- Category bar shows placeholder content\n- Collection displays 3 placeholder game cards\n- Interactive elements still functional but return empty IDs\n\n### Empty State\n- Category bar displays normally\n- Collection shows placeholder cards when games array is empty\n- Proper handling of edge cases\n\n## MVVM Benefits\n\n### Testability\n```swift\n// Each ViewModel can be unit tested independently\nfunc testGameSelection() {\n    let viewModel = MockCasinoCategorySectionViewModel.newGamesSection\n    var selectedGameId: String?\n    \n    // Test child ViewModel communication\n    viewModel.gameSelected(\"test-game-id\")\n    // Assert expected behavior\n}\n```\n\n### Separation of Concerns\n- **View**: Only displays and captures input\n- **ViewModel**: Contains all business logic and child management\n- **Parent ViewModel**: Coordinates between child ViewModels\n- **Child ViewModels**: Handle their specific domain logic\n\n### Maintainability\n- Clear ownership hierarchy\n- Easy to add new child components\n- Consistent communication patterns\n- Follows established GomaUI patterns\n\n## Integration\n\n### With Main Casino Screen\nWhen used in a main casino screen, the parent screen's ViewModel would create multiple category section ViewModels:\n\n```swift\n//  CORRECT: Main screen ViewModel creates section ViewModels\nclass CasinoMainScreenViewModel {\n    let categorySectionViewModels: [CasinoCategorySectionViewModelProtocol]\n    \n    init(categories: [CasinoCategorySectionData]) {\n        self.categorySectionViewModels = categories.map { categoryData in\n            MockCasinoCategorySectionViewModel(sectionData: categoryData)\n        }\n    }\n}\n```\n\n## Performance Considerations\n\n- **ViewModel Creation**: Efficient batch creation of child ViewModels\n- **Collection View**: Proper cell reuse with state cleanup\n- **Memory Management**: Weak references prevent retain cycles\n- **Reactive Updates**: Combine publishers are properly disposed\n\n## Collection View Integration\n\nFor use within UICollectionView layouts, use the provided wrapper cell:\n\n### CasinoCategorySectionCollectionViewCell\n\n```swift\n\n\n// Register the cell\ncollectionView.register(CasinoCategorySectionCollectionViewCell.self, forCellWithReuseIdentifier: \"CategorySectionCell\")\n\n// Configure in cellForItemAt\nfunc collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"CategorySectionCell\", for: indexPath) as! CasinoCategorySectionCollectionViewCell\n    \n    // Configure with your view model\n    let categorySection = categorySections[indexPath.item]\n    cell.configure(with: categorySection)\n    \n    // Setup callbacks\n    cell.onCategoryButtonTapped = { categoryId in\n        print(\"Category button tapped: \\(categoryId)\")\n        // Handle navigation to full category view\n    }\n    \n    cell.onGameSelected = { gameId in\n        print(\"Game selected: \\(gameId)\")\n        // Handle game selection navigation\n    }\n    \n    return cell\n}\n\n// Size for collection view layout\nfunc collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {\n    return CGSize(width: collectionView.bounds.width, height: 330) // CasinoCategorySectionView height + spacing\n}\n```\n\n### Collection View Cell Features\n\n- **Automatic cleanup**: Properly handles reuse and memory management\n- **Callback forwarding**: All CasinoCategorySectionView callbacks are available\n- **Configuration support**: Works with any CasinoCategorySectionViewModelProtocol\n- **Placeholder handling**: Falls back to placeholder state when no viewModel provided\n\n## Demo\n\nSee `CasinoCategorySectionViewController` in the GomaUI Demo app for interactive examples showcasing:\n- Multiple category sections with different game counts\n- Runtime configuration switching\n- Game selection and category button handling\n- Refresh functionality\n- MVVM child ViewModel management demonstration\n\n## MVVM Summary\n\nThis component demonstrates proper MVVM architecture with:\n-  Parent ViewModel creates child ViewModels for its subviews\n-  Clear communication patterns via callbacks/publishers\n-  No UIKit imports in ViewModels\n-  Proper separation of concerns\n-  Testable architecture\n-  Memory-safe with weak references\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CasinoCategorySectionView/__Snapshots__/CasinoCategorySectionViewSnapshotTests/testCasinoCategorySectionView_BasicStates_Light.1.png",
          "dark": "CasinoCategorySectionView/__Snapshots__/CasinoCategorySectionViewSnapshotTests/testCasinoCategorySectionView_BasicStates_Dark.1.png"
        },
        {
          "category": "ContentVariants",
          "light": "CasinoCategorySectionView/__Snapshots__/CasinoCategorySectionViewSnapshotTests/testCasinoCategorySectionView_ContentVariants_Light.1.png",
          "dark": "CasinoCategorySectionView/__Snapshots__/CasinoCategorySectionViewSnapshotTests/testCasinoCategorySectionView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "CasinoGameCardView": {
      "displayName": "CasinoGameCardView",
      "category": "Casino",
      "subcategory": "Games",
      "summary": "Detailed game card with image, title, provider, stake, and rating",
      "description": "Rich game card with async image loading, title, provider, min stake, and 5-thunderbolt rating. Loading/failure states. Fixed 164x272pt. Shadow and rounded corners. For horizontal collections.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "card",
        "game",
        "casino",
        "image",
        "rating",
        "provider"
      ],
      "states": [
        "loading",
        "loaded",
        "failed",
        "placeholder"
      ],
      "similarTo": [
        "CasinoGameImageView"
      ],
      "oftenUsedWith": [
        "CasinoCategorySectionView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CasinoGameCardView\n\nA GomaUI component for displaying casino game cards with optional viewModel initialization and runtime configuration support.\n\n## Overview\n\nCasinoGameCardView is a self-contained UIView component that displays casino game information including game image, title, provider, star rating, minimum stake, and optional badges/favorite icons. The component follows GomaUI's MVVM architecture with protocol-based ViewModels and supports both optional initialization and runtime configuration.\n\n## Features\n\n- **Optional ViewModel Initialization**: Can be initialized with or without a viewModel\n- **Runtime Configuration**: Supports configuring with a new viewModel at any time\n- **Self-Rendering Placeholder**: Displays placeholder content when no viewModel is provided\n- **Reactive UI Updates**: Uses Combine framework for reactive data binding\n- **Image Loading**: Built-in image loading with loading states and error handling\n- **Interactive Elements**: Supports game selection and favorite toggling\n- **Consistent Theming**: Uses StyleProvider for consistent colors and fonts\n\n## Architecture\n\n### Core Components\n\n1. **CasinoGameCardViewModelProtocol**: Defines the contract for ViewModels\n2. **CasinoGameCardView**: Main UI component with optional viewModel support\n3. **MockCasinoGameCardViewModel**: Mock implementation for testing and previews\n4. **README.md**: This documentation file\n\n### ViewModel Protocol\n\n```swift\npublic protocol CasinoGameCardViewModelProtocol: AnyObject {\n    // Data Publishers\n    var displayStatePublisher: AnyPublisher<CasinoGameCardDisplayState, Never> { get }\n    var gameNamePublisher: AnyPublisher<String, Never> { get }\n    var providerNamePublisher: AnyPublisher<String, Never> { get }\n    var ratingPublisher: AnyPublisher<Double, Never> { get }\n    var minStakePublisher: AnyPublisher<String, Never> { get }\n    var imageURLPublisher: AnyPublisher<String?, Never> { get }\n    var showNewBadgePublisher: AnyPublisher<Bool, Never> { get }\n    var showFavoriteIconPublisher: AnyPublisher<Bool, Never> { get }\n    var isSelectedPublisher: AnyPublisher<Bool, Never> { get }\n    \n    // Properties\n    var gameId: String { get }\n    \n    // Actions\n    func selectGame()\n    func toggleFavorite()\n    func imageLoadingSucceeded()\n    func imageLoadingFailed()\n}\n```\n\n## Usage\n\n### Basic Usage (Optional ViewModel)\n\n```swift\n// Initialize without viewModel (shows placeholder)\nlet gameCardView = CasinoGameCardView()\n\n// Configure with viewModel later\nlet viewModel = MockCasinoGameCardViewModel.plinkGoal()\ngameCardView.configure(with: viewModel)\n```\n\n### Direct Initialization\n\n```swift\n// Initialize with viewModel directly\nlet viewModel = MockCasinoGameCardViewModel.aviator()\nlet gameCardView = CasinoGameCardView(viewModel: viewModel)\n```\n\n### Handling User Interactions\n\n```swift\ngameCardView.onGameSelected = { gameId in\n    // Handle game selection\n    print(\"Game selected: \\(gameId)\")\n}\n\ngameCardView.onFavoriteToggled = { gameId, isFavorite in\n    // Handle favorite toggle\n    print(\"Game \\(gameId) favorite status: \\(isFavorite)\")\n}\n```\n\n## Data Models\n\n### CasinoGameCardData\n\n```swift\npublic struct CasinoGameCardData {\n    public let gameId: String\n    public let gameName: String\n    public let providerName: String\n    public let imageURL: String?\n    public let rating: Double\n    public let minStake: String\n    public let currency: String\n    public let isNew: Bool\n    public let isFavorite: Bool\n    public let isSelected: Bool\n}\n```\n\n### CasinoGameCardDisplayState\n\n```swift\npublic struct CasinoGameCardDisplayState {\n    public let isLoading: Bool\n    public let imageLoadingFailed: Bool\n    \n    public static let loading = CasinoGameCardDisplayState(isLoading: true, imageLoadingFailed: false)\n    public static let normal = CasinoGameCardDisplayState(isLoading: false, imageLoadingFailed: false)\n    public static let imageError = CasinoGameCardDisplayState(isLoading: false, imageLoadingFailed: true)\n}\n```\n\n## Visual Specifications\n\n- **Card Dimensions**: 160220 points\n- **Corner Radius**: 12 points\n- **Image Height**: 120 points\n- **Shadow**: Subtle shadow with StyleProvider.Color.shadow\n- **Star Rating**: 5-star system with half-star support\n- **Typography**: Uses StyleProvider fonts (bold 14pt for title, regular 12pt for provider)\n\n## States\n\n### Loading State\n- Shows activity indicator over placeholder image\n- Displays \"Loading...\" text for game name\n- Shows placeholder text for other fields\n\n### Normal State\n- Displays all game information\n- Shows loaded game image\n- Interactive elements enabled\n\n### Image Error State\n- Shows \"?\" placeholder when image fails to load\n- All other information displayed normally\n- User can still interact with the card\n\n### Placeholder State (No ViewModel)\n- Shows when initialized without viewModel\n- Displays placeholder content\n- Non-interactive until viewModel is configured\n\n## Mock Data\n\nThe component includes comprehensive mock data for testing and previews:\n\n- `MockCasinoGameCardViewModel.plinkGoal()`: Popular game example\n- `MockCasinoGameCardViewModel.beastBelow()`: Horror-themed game\n- `MockCasinoGameCardViewModel.aviator()`: High-rating crash game\n- `MockCasinoGameCardViewModel.loadingGame()`: Loading state example\n- `MockCasinoGameCardViewModel.imageFailedGame()`: Image error state\n\n## Testing\n\n### Unit Tests\n- Test optional viewModel initialization\n- Test runtime configuration\n- Test state transitions\n- Test user interaction callbacks\n\n### SwiftUI Previews\n- Placeholder state preview (no viewModel)\n- Various game examples\n- Different states (loading, error, normal)\n\n## Implementation Notes\n\n1. **Memory Management**: Uses weak references in Combine bindings to prevent retain cycles\n2. **Thread Safety**: All UI updates dispatched to main queue\n3. **Image Loading**: Simple URLSession implementation (production should use proper image caching)\n4. **Accessibility**: Component supports accessibility features through standard UIKit properties\n5. **Performance**: Minimal view hierarchy with efficient constraint setup\n\n## Dependencies\n\n- **UIKit**: Core UI framework\n- **Combine**: Reactive data binding\n- **SwiftUI**: Preview support (iOS 17.0+)\n- **GomaUI StyleProvider**: Consistent theming and colors\n\n## Version History\n\n- **1.0.0**: Initial implementation with optional viewModel support\n  - Basic game card layout\n  - MVVM architecture with protocols\n  - Combine-based reactive updates\n  - Mock implementations for testing",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CasinoGameCardView/__Snapshots__/CasinoGameCardViewSnapshotTests/testCasinoGameCardView_BasicStates_Light.1.png",
          "dark": "CasinoGameCardView/__Snapshots__/CasinoGameCardViewSnapshotTests/testCasinoGameCardView_BasicStates_Dark.1.png"
        },
        {
          "category": "ContentVariants",
          "light": "CasinoGameCardView/__Snapshots__/CasinoGameCardViewSnapshotTests/testCasinoGameCardView_ContentVariants_Light.1.png",
          "dark": "CasinoGameCardView/__Snapshots__/CasinoGameCardViewSnapshotTests/testCasinoGameCardView_ContentVariants_Dark.1.png"
        },
        {
          "category": "DisplayStates",
          "light": "CasinoGameCardView/__Snapshots__/CasinoGameCardViewSnapshotTests/testCasinoGameCardView_DisplayStates_Light.1.png",
          "dark": "CasinoGameCardView/__Snapshots__/CasinoGameCardViewSnapshotTests/testCasinoGameCardView_DisplayStates_Dark.1.png"
        },
        {
          "category": "RatingVariants",
          "light": "CasinoGameCardView/__Snapshots__/CasinoGameCardViewSnapshotTests/testCasinoGameCardView_RatingVariants_Light.1.png",
          "dark": "CasinoGameCardView/__Snapshots__/CasinoGameCardViewSnapshotTests/testCasinoGameCardView_RatingVariants_Dark.1.png"
        }
      ]
    },
    "CasinoGameImageGridSectionView": {
      "displayName": "CasinoGameImageGridSectionView",
      "category": "Casino",
      "subcategory": "Sections",
      "summary": "Casino section with 2-row horizontal scrolling image grid",
      "description": "Category header with horizontal grid of game images in 2-row vertical pairs via CasinoGameImagePairView. 100x100pt images, 8pt vertical/12pt horizontal spacing. Ideal for Lite/Crash games.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "section",
        "grid",
        "games",
        "horizontal-scroll",
        "compact",
        "2-row"
      ],
      "states": [
        "normal",
        "placeholder"
      ],
      "similarTo": [
        "CasinoCategorySectionView"
      ],
      "oftenUsedWith": [
        "CasinoCategoryBarView",
        "CasinoGameImagePairView"
      ],
      "parents": [],
      "children": [
        "CasinoCategoryBarView",
        "CasinoGameImagePairView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CasinoGameImageGridSectionView\n\nA casino section displaying games in a 2-row horizontal scrolling image grid.\n\n## Overview\n\nCasinoGameImageGridSectionView displays a category header (via CasinoCategoryBarView) followed by a horizontal scrolling collection of game images arranged in 2-row vertical pairs. Each column contains a CasinoGameImagePairView with up to 2 game images stacked vertically. This compact layout is ideal for \"Lite Games\" or \"Crash Games\" sections where images alone convey the game.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone section component, typically used in table/collection views)\n\n### Uses (Children)\n- `CasinoCategoryBarView` - section header with title and \"See All\" button\n- `CasinoGameImagePairView` - vertical pairs of game images (via collection view cells)\n\n## Features\n\n- Category header bar with title and action button\n- 2-row horizontal scrolling grid layout\n- 100x100pt game image cards with 16pt corner radius\n- Vertical spacing: 8pt between rows\n- Horizontal spacing: 12pt between columns\n- 16pt horizontal edge padding\n- Handles odd number of games (last column shows only top image)\n- Tertiary background color\n- Placeholder state with 3 empty pairs when no ViewModel\n- Game selection and category button callbacks\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockCasinoGameImageGridSectionViewModel.liteGamesSection\nlet sectionView = CasinoGameImageGridSectionView(viewModel: viewModel)\n\nviewModel.onGameSelected = { gameId in\n    print(\"Game selected: \\(gameId)\")\n}\n\nviewModel.onCategoryButtonTapped = {\n    print(\"Category button tapped\")\n}\n\nsectionView.onGameSelected = { gameId in\n    print(\"Game selected via view callback: \\(gameId)\")\n}\n```\n\n## Data Model\n\n```swift\nstruct CasinoGameImageGridSectionData: Equatable, Hashable, Identifiable {\n    let id: String\n    let categoryTitle: String\n    let categoryButtonText: String\n    let games: [CasinoGameImageData]\n}\n\nprotocol CasinoGameImageGridSectionViewModelProtocol: AnyObject {\n    var categoryBarViewModel: CasinoCategoryBarViewModelProtocol { get }\n    var gamePairViewModels: [CasinoGameImagePairViewModelProtocol] { get }\n    var gamePairViewModelsPublisher: AnyPublisher<[CasinoGameImagePairViewModelProtocol], Never> { get }\n    var sectionId: String { get }\n    var categoryTitle: String { get }\n\n    func gameSelected(_ gameId: String)\n    func categoryButtonTapped()\n    func refreshGames()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundTertiary` - section background\n- `StyleProvider.Color.backgroundPrimary` - used for view backgrounds\n- Inherits styling from child `CasinoCategoryBarView` and `CasinoGameImageView` components\n\nLayout constants:\n- Category bar height: 48pt\n- Card size: 100pt (from CasinoGameImageView)\n- Collection height: 208pt (2 cards + 8pt spacing)\n- Horizontal padding: 16pt\n- Horizontal spacing: 12pt\n- Vertical spacing: 8pt\n\n## Mock ViewModels\n\nAvailable presets:\n- `.liteGamesSection` - \"Lite Games\" with 8 games (4 full columns)\n- `.oddGamesSection` - \"Crash Games\" with 7 games (last column has only top)\n- `.emptySection` - empty category (shows placeholders)\n- `.fewGamesSection` - section with only 2 games (1 column)\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CasinoGameImageGridSectionView/__Snapshots__/CasinoGameImageGridSectionViewSnapshotTests/testCasinoGameImageGridSectionView_BasicStates_Light.1.png",
          "dark": "CasinoGameImageGridSectionView/__Snapshots__/CasinoGameImageGridSectionViewSnapshotTests/testCasinoGameImageGridSectionView_BasicStates_Dark.1.png"
        },
        {
          "category": "ContentVariants",
          "light": "CasinoGameImageGridSectionView/__Snapshots__/CasinoGameImageGridSectionViewSnapshotTests/testCasinoGameImageGridSectionView_ContentVariants_Light.1.png",
          "dark": "CasinoGameImageGridSectionView/__Snapshots__/CasinoGameImageGridSectionViewSnapshotTests/testCasinoGameImageGridSectionView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "CasinoGameImagePairView": {
      "displayName": "CasinoGameImagePairView",
      "category": "Casino",
      "subcategory": "Games",
      "summary": "Vertical container stacking two casino game images",
      "description": "Two CasinoGameImageView components stacked vertically. Top game required, bottom optional for odd-numbered lists. Maintains consistent height. 8pt vertical spacing.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "container",
        "pair",
        "vertical",
        "game",
        "image"
      ],
      "states": [
        "full",
        "topOnly"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "CasinoGameImageGridSectionView",
        "CasinoGameImageView"
      ],
      "parents": [
        "CasinoGameImageGridSectionView"
      ],
      "children": [
        "CasinoGameImageView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CasinoGameImagePairView\n\nA vertical container displaying two casino game images stacked in a column.\n\n## Overview\n\nCasinoGameImagePairView displays two CasinoGameImageView components arranged vertically with consistent spacing. The top game is always required, while the bottom game is optional to handle odd-numbered game lists. When the bottom game is absent, the view maintains its height with an invisible placeholder to ensure consistent 2-row grid layout.\n\n## Component Relationships\n\n### Used By (Parents)\n- `CasinoGameImageGridSectionView` - displays pairs in horizontal collection\n\n### Uses (Children)\n- `CasinoGameImageView` - individual game image card (2 instances: top and bottom)\n\n## Features\n\n- Vertical stack of 2 game images\n- Optional bottom game for odd-numbered lists\n- 8pt vertical spacing between images\n- Maintains consistent height when bottom is missing (alpha = 0)\n- Tap callbacks for both top and bottom games\n- Cell reuse support via prepareForReuse()\n- Placeholder state when no ViewModel\n\n## Usage\n\n```swift\nlet viewModel = MockCasinoGameImagePairViewModel.fullPair\nlet pairView = CasinoGameImagePairView(viewModel: viewModel)\n\npairView.onGameSelected = { gameId in\n    print(\"Game selected: \\(gameId)\")\n}\n```\n\n## Data Model\n\n```swift\nprotocol CasinoGameImagePairViewModelProtocol: AnyObject {\n    var topGameViewModel: CasinoGameImageViewModelProtocol { get }\n    var bottomGameViewModel: CasinoGameImageViewModelProtocol? { get }\n    var pairId: String { get }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- Inherits styling from child `CasinoGameImageView` components\n- `StyleProvider.Color.backgroundPrimary` - used for preview backgrounds\n\nLayout constants:\n- Vertical spacing: 8pt\n- Total height: 208pt (2 x 100pt cards + 8pt spacing)\n\n## Mock ViewModels\n\nAvailable presets:\n- `.fullPair` - both top and bottom games present\n- `.topOnly` - only top game (odd number scenario)\n- `.noImages` - both games with no images (failure state)\n- `.pairs(from: [CasinoGameImageData])` - creates array of pairs from game list\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CasinoGameImagePairView/__Snapshots__/CasinoGameImagePairViewSnapshotTests/testCasinoGameImagePairView_BasicStates_Light.1.png",
          "dark": "CasinoGameImagePairView/__Snapshots__/CasinoGameImagePairViewSnapshotTests/testCasinoGameImagePairView_BasicStates_Dark.1.png"
        },
        {
          "category": "ContentVariants",
          "light": "CasinoGameImagePairView/__Snapshots__/CasinoGameImagePairViewSnapshotTests/testCasinoGameImagePairView_ContentVariants_Light.1.png",
          "dark": "CasinoGameImagePairView/__Snapshots__/CasinoGameImagePairViewSnapshotTests/testCasinoGameImagePairView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "CasinoGameImageView": {
      "displayName": "CasinoGameImageView",
      "category": "Casino",
      "subcategory": "Games",
      "summary": "Square image-only card for compact casino game display",
      "description": "Fixed 100x100pt square game image with 16pt corner radius. Async loading from URL/bundle. Loading indicator and failure placeholder. Minimal design for 2-row grid layouts.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "image",
        "game",
        "casino",
        "thumbnail",
        "compact",
        "square"
      ],
      "states": [
        "loading",
        "loaded",
        "failed",
        "placeholder"
      ],
      "similarTo": [
        "CasinoGameCardView"
      ],
      "oftenUsedWith": [
        "CasinoGameImagePairView",
        "SquareSeeMoreView"
      ],
      "parents": [
        "CasinoGameImagePairView",
        "SquareSeeMoreView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CasinoGameImageView\n\nA simple image-only card for displaying casino games in compact grid layouts.\n\n## Overview\n\nCasinoGameImageView displays a square game image with rounded corners, supporting async image loading from URLs or bundle assets. It shows loading and failure states, and responds to tap gestures for game selection. This minimal component is designed for use in the 2-row compact grid layout of casino sections.\n\n## Component Relationships\n\n### Used By (Parents)\n- `CasinoGameImagePairView` - stacks two images vertically\n- `SquareSeeMoreView` - uses as game preview thumbnail\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Fixed 100x100pt square card size\n- 16pt corner radius\n- Async image loading from URL or bundle\n- Loading indicator during fetch\n- Failure state with \"?\" placeholder\n- Tap gesture for game selection\n- Cell reuse support via prepareForReuse()\n- Cancellable image loading task\n- Placeholder state when no ViewModel\n\n## Usage\n\n```swift\nlet viewModel = MockCasinoGameImageViewModel.aviator\nlet gameImageView = CasinoGameImageView(viewModel: viewModel)\n\n// Handle game selection via ViewModel callback\nviewModel.onGameSelected = { gameId in\n    print(\"Game selected: \\(gameId)\")\n}\n```\n\n## Data Model\n\n```swift\nstruct CasinoGameImageData: Equatable, Hashable, Identifiable {\n    let id: String\n    let iconURL: String?    // URL or bundle image name\n    let gameURL: String\n}\n\nprotocol CasinoGameImageViewModelProtocol: AnyObject {\n    var gameId: String { get }\n    var gameURL: String { get }\n    var iconURL: String? { get }\n\n    func gameSelected()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundCards` - container and image background\n- `StyleProvider.Color.textSecondary` - loading indicator color\n- `StyleProvider.Color.textDisablePrimary` - failure \"?\" label color\n- `StyleProvider.fontWith(type: .bold, size: 32)` - failure label font\n\nLayout constants:\n- Card size: 100pt x 100pt\n- Corner radius: 16pt\n\n## Mock ViewModels\n\nAvailable presets:\n- `.plinkGoal` - game with placeholder image\n- `.aviator` - game with placeholder image\n- `.sambaSoccer` - game with placeholder image\n- `.failed` - game with invalid URL (triggers failure state)\n- `.noImage` - game with nil iconURL\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CasinoGameImageView/__Snapshots__/CasinoGameImageViewSnapshotTests/testCasinoGameImageView_BasicStates_Light.1.png",
          "dark": "CasinoGameImageView/__Snapshots__/CasinoGameImageViewSnapshotTests/testCasinoGameImageView_BasicStates_Dark.1.png"
        }
      ]
    },
    "CasinoGamePlayModeSelectorView": {
      "displayName": "CasinoGamePlayModeSelectorView",
      "category": "Casino",
      "subcategory": "Games",
      "summary": "Full-screen game details overlay with play mode selection",
      "description": "Modal overlay showing game thumbnail, title, description, and configurable action buttons. Supports filled/outlined/text button styles. Loading overlay with activity indicator. For game launch screens.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "modal",
        "overlay",
        "game",
        "play",
        "buttons",
        "selection"
      ],
      "states": [
        "loggedOut",
        "loggedIn",
        "insufficientFunds",
        "loading"
      ],
      "similarTo": [],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CasinoGamePlayModeSelectorView\n\nA sophisticated reusable component for displaying casino game details with configurable play mode buttons. This component adapts to different user states and provides flexible button configurations for various casino game scenarios.\n\n## Features\n\n- **Configurable Button States**: Support for primary, secondary, and tertiary buttons with different styles (filled, outlined, text)\n- **Dynamic Button Management**: Buttons can be enabled, disabled, or show loading states\n- **Rich Game Display**: Shows game image, title, description, volatility, and minimum stake\n- **Adaptive Layout**: Responsive design that works across different screen sizes\n- **StyleProvider Integration**: Uses centralized theming for consistent appearance\n- **Reactive State Management**: Uses Combine publishers for seamless state updates\n- **Accessibility Support**: Full accessibility support with appropriate labels and hints\n\n## Usage Example\n\n### Basic Usage\n\n```swift\n// Create game data\nlet gameData = CasinoGamePlayModeSelectorGameData(\n    id: \"surging-7s\",\n    name: \"Surging 7s\",\n    imageURL: \"https://example.com/game-image.jpg\",\n    provider: \"Pragmatic Play\",\n    volatility: \"Medium\",\n    minStake: \"XAF 1\",\n    description: \"Engross yourself into the world of Surging 7s...\"\n)\n\n// Configure buttons for logged-out user\nlet buttons = [\n    CasinoGamePlayModeButton(\n        id: \"login\",\n        type: .primary,\n        title: \"LOGIN_TO_PLAY\",\n        state: .enabled,\n        style: .filled\n    ),\n    CasinoGamePlayModeButton(\n        id: \"practice\",\n        type: .secondary,\n        title: \"PRACTICE_PLAY\",\n        state: .enabled,\n        style: .outlined\n    )\n]\n\n// Create view model\nlet viewModel = MockCasinoGamePlayModeSelectorViewModel(\n    gameData: gameData,\n    buttons: buttons\n)\n\n// Create the component\nlet selectorView = CasinoGamePlayModeSelectorView(viewModel: viewModel)\n\n// Add to your view hierarchy\nparentView.addSubview(selectorView)\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    selectorView.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor),\n    selectorView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor),\n    selectorView.trailingAnchor.constraint(equalTo: parentView.trailingAnchor),\n    selectorView.bottomAnchor.constraint(equalTo: parentView.bottomAnchor)\n])\n\n// Handle button taps\nselectorView.onButtonTapped = { buttonId in\n    switch buttonId {\n    case \"login\":\n        // Navigate to login screen\n        break\n    case \"practice\":\n        // Start practice mode\n        break\n    case \"play\":\n        // Start real money play\n        break\n    default:\n        break\n    }\n}\n```\n\n## Button Configuration Scenarios\n\n### Logged-Out User\n```swift\nlet buttons = [\n    CasinoGamePlayModeButton(\n        id: \"login\",\n        type: .primary,\n        title: \"LOGIN_TO_PLAY\",\n        state: .enabled,\n        style: .filled\n    ),\n    CasinoGamePlayModeButton(\n        id: \"practice\",\n        type: .secondary,\n        title: \"PRACTICE_PLAY\",\n        state: .enabled,\n        style: .outlined\n    )\n]\n```\n\n### Logged-In User with Funds\n```swift\nlet buttons = [\n    CasinoGamePlayModeButton(\n        id: \"play\",\n        type: .primary,\n        title: \"PLAY_NOW\",\n        state: .enabled,\n        style: .filled\n    ),\n    CasinoGamePlayModeButton(\n        id: \"practice\",\n        type: .secondary,\n        title: \"PRACTICE_MODE\",\n        state: .enabled,\n        style: .outlined\n    )\n]\n```\n\n### Insufficient Funds\n```swift\nlet buttons = [\n    CasinoGamePlayModeButton(\n        id: \"deposit\",\n        type: .primary,\n        title: \"DEPOSIT_TO_PLAY\",\n        state: .enabled,\n        style: .filled\n    ),\n    CasinoGamePlayModeButton(\n        id: \"practice\",\n        type: .secondary,\n        title: \"PRACTICE_PLAY\",\n        state: .enabled,\n        style: .outlined\n    )\n]\n```\n\n### Loading State\n```swift\nlet buttons = [\n    CasinoGamePlayModeButton(\n        id: \"login\",\n        type: .primary,\n        title: \"LOGIN_TO_PLAY\",\n        state: .loading,\n        style: .filled\n    ),\n    CasinoGamePlayModeButton(\n        id: \"practice\",\n        type: .secondary,\n        title: \"PRACTICE_PLAY\",\n        state: .disabled,\n        style: .outlined\n    )\n]\n```\n\n## Data Models\n\n### CasinoGamePlayModeSelectorGameData\n- **id**: Unique identifier for the game\n- **name**: Display name of the game\n- **imageURL**: Optional URL for the game image\n- **provider**: Game provider name (e.g., \"Pragmatic Play\")\n- **volatility**: Game volatility level (e.g., \"Low\", \"Medium\", \"High\")\n- **minStake**: Minimum stake required (e.g., \"XAF 1\")\n- **description**: Optional game description\n\n### CasinoGamePlayModeButton\n- **id**: Unique identifier for the button\n- **type**: Button hierarchy (.primary, .secondary, .tertiary)\n- **title**: Button text\n- **state**: Button state (.enabled, .disabled, .loading)\n- **style**: Visual style (.filled, .outlined, .text)\n\n## State Management\n\nThe component uses reactive state management through Combine publishers:\n\n```swift\n// Listen to state changes\nviewModel.displayStatePublisher\n    .sink { displayState in\n        // Component automatically updates UI\n        print(\"Game: \\(displayState.gameData.name)\")\n        print(\"Buttons: \\(displayState.buttons.count)\")\n        print(\"Loading: \\(displayState.isLoading)\")\n    }\n    .store(in: &cancellables)\n\n// Update states programmatically\nviewModel.setLoading(true)\nviewModel.refreshGameData()\n```\n\n## Mock Implementations\n\nThe component includes several pre-configured mock implementations:\n\n- `MockCasinoGamePlayModeSelectorViewModel.defaultMock` - Logged-out user state\n- `MockCasinoGamePlayModeSelectorViewModel.loggedInMock` - Logged-in user with funds\n- `MockCasinoGamePlayModeSelectorViewModel.insufficientFundsMock` - User needs to deposit\n- `MockCasinoGamePlayModeSelectorViewModel.loadingMock` - Loading state\n- `MockCasinoGamePlayModeSelectorViewModel.disabledMock` - Maintenance mode\n- `MockCasinoGamePlayModeSelectorViewModel.interactiveMock` - Interactive demo\n\n## Integration with Navigation\n\nThe component works seamlessly with coordinator-based navigation:\n\n```swift\n// In your coordinator\nselectorView.onButtonTapped = { [weak self] buttonId in\n    switch buttonId {\n    case \"login\":\n        self?.showLogin()\n    case \"practice\":\n        self?.showGamePlay(mode: .practice)\n    case \"play\":\n        self?.showGamePlay(mode: .realMoney)\n    case \"deposit\":\n        self?.showDeposit()\n    default:\n        break\n    }\n}\n```\n\n## Design Specifications\n\n- **Layout**: Scrollable vertical layout with centered game image\n- **Image Size**: 200x120pt game image with 12pt corner radius\n- **Typography**: \n  - Title: Bold 24pt\n  - Description: Regular 14pt\n  - Details: Medium 12pt\n- **Spacing**: 24pt margins, 12pt internal spacing\n- **Button Height**: 50pt with 8pt corner radius\n- **Colors**: Uses StyleProvider for consistent theming\n\n## Accessibility\n\nThe component provides comprehensive accessibility support:\n\n- **Dynamic Labels**: Button titles and states are properly announced\n- **Semantic Roles**: Buttons have appropriate accessibility roles\n- **State Changes**: Loading and disabled states are announced\n- **Touch Targets**: All buttons meet minimum 44pt touch target requirements\n\n## Testing\n\nUse the mock implementations for testing different scenarios:\n\n```swift\nfunc testLoggedOutUser() {\n    let viewModel = MockCasinoGamePlayModeSelectorViewModel.defaultMock\n    let selectorView = CasinoGamePlayModeSelectorView(viewModel: viewModel)\n    \n    // Test button configuration\n    XCTAssertEqual(viewModel.buttons.count, 2)\n    XCTAssertEqual(viewModel.buttons[0].id, \"login\")\n    XCTAssertEqual(viewModel.buttons[1].id, \"practice\")\n}\n```\n\nThis component provides a professional, flexible solution for casino game pre-play screens that adapts to different user states while maintaining consistent design patterns and accessibility standards.",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CasinoGamePlayModeSelectorView/__Snapshots__/CasinoGamePlayModeSelectorViewSnapshotTests/testCasinoGamePlayModeSelectorView_BasicStates_Light.1.png",
          "dark": "CasinoGamePlayModeSelectorView/__Snapshots__/CasinoGamePlayModeSelectorViewSnapshotTests/testCasinoGamePlayModeSelectorView_BasicStates_Dark.1.png"
        },
        {
          "category": "UserStates",
          "light": "CasinoGamePlayModeSelectorView/__Snapshots__/CasinoGamePlayModeSelectorViewSnapshotTests/testCasinoGamePlayModeSelectorView_UserStates_Light.1.png",
          "dark": "CasinoGamePlayModeSelectorView/__Snapshots__/CasinoGamePlayModeSelectorViewSnapshotTests/testCasinoGamePlayModeSelectorView_UserStates_Dark.1.png"
        }
      ]
    },
    "CasinoGameSearchedView": {
      "displayName": "CasinoGameSearchedView",
      "category": "Casino",
      "subcategory": "Search",
      "summary": "Compact search result row for casino games",
      "description": "Horizontal row with 56pt square game image, title, provider, and play icon. Image loading states. Fixed 56pt height. 16pt corner radius. For search result lists.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "search",
        "result",
        "row",
        "game",
        "casino"
      ],
      "states": [
        "loading",
        "loaded",
        "failed"
      ],
      "similarTo": [],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CasinoGameSearchedView\n\nA compact search result row for casino games with thumbnail, title, provider, and play icon.\n\n## Overview\n\nCasinoGameSearchedView displays a horizontal row for casino game search results. It shows a square game image on the left, game title and provider in the center, and a play icon on the right. The component handles image loading states and provides tap interaction for game selection.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone component for search result lists)\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Fixed 56pt row height\n- Square 56pt game image with rounded corners\n- Image loading with activity indicator\n- Image failure state with \"?\" placeholder\n- Game title (semibold 18pt, single line)\n- Provider name (regular 14pt, optional)\n- Play/chevron icon on right side\n- 16pt corner radius on container\n- Secondary background color\n- Tap gesture for game selection\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockCasinoGameSearchedViewModel.normal\nlet searchedView = CasinoGameSearchedView(viewModel: viewModel)\n\nsearchedView.onGameSelected = {\n    print(\"Game selected\")\n}\n```\n\n## Data Model\n\n```swift\nstruct CasinoGameSearchedData: Equatable, Hashable, Identifiable {\n    let id: String\n    let title: String\n    let provider: String?\n    let iconURL: String?\n}\n\nstruct CasinoGameSearchedDisplayState: Equatable {\n    let isLoading: Bool\n    let imageLoadingFailed: Bool\n}\n\nprotocol CasinoGameSearchedViewModelProtocol: AnyObject {\n    var dataPublisher: AnyPublisher<CasinoGameSearchedData, Never> { get }\n    var displayStatePublisher: AnyPublisher<CasinoGameSearchedDisplayState, Never> { get }\n    var onSelected: AnyPublisher<String, Never> { get }\n\n    func didSelect()\n    func imageLoadingSucceeded()\n    func imageLoadingFailed()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundSecondary` - container background\n- `StyleProvider.Color.backgroundPrimary` - image failure background\n- `StyleProvider.Color.textPrimary` - title text color\n- `StyleProvider.Color.textSecondary` - provider text and failure \"?\" color\n- `StyleProvider.Color.highlightPrimary` - play icon tint\n- `StyleProvider.fontWith(type: .semibold, size: 18)` - title font\n- `StyleProvider.fontWith(type: .regular, size: 14)` - provider font\n- `StyleProvider.fontWith(type: .bold, size: 18)` - failure label font\n\nLayout constants:\n- Row height: 56pt\n- Image size: 56pt\n- Container corner radius: 16pt\n- Icon size: 16pt\n- Horizontal padding: 16pt\n- Vertical spacing: 4pt\n\n## Mock ViewModels\n\nAvailable presets:\n- `.loading` - loading state\n- `.normal` - normal state with image\n- `.imageError` - image loading failed state\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CasinoGameSearchedView/__Snapshots__/CasinoGameSearchedViewSnapshotTests/testCasinoGameSearchedView_BasicStates_Light.1.png",
          "dark": "CasinoGameSearchedView/__Snapshots__/CasinoGameSearchedViewSnapshotTests/testCasinoGameSearchedView_BasicStates_Dark.1.png"
        }
      ]
    },
    "CodeClipboardView": {
      "displayName": "CodeClipboardView",
      "category": "Forms",
      "subcategory": "Clipboard",
      "summary": "Copyable code display with clipboard functionality and visual feedback",
      "description": "Displays a label (e.g., 'Copy Booking Code') on the left and a tappable code badge on the right with copy icon. Tapping copies to clipboard and shows animated 'Copied' confirmation that auto-reverts after 5 seconds. Used for booking codes, referral codes, or any shareable text.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "clipboard",
        "copy",
        "code",
        "booking-code",
        "referral",
        "share"
      ],
      "states": [
        "default",
        "copied",
        "enabled",
        "disabled"
      ],
      "similarTo": [],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CodeClipboardView\n\nA copyable code display with clipboard functionality and visual feedback.\n\n## Overview\n\nCodeClipboardView displays a label on the left and a tappable code badge on the right. Tapping the code copies it to the clipboard and shows a \"Copied\" confirmation that automatically reverts after a delay. The component is commonly used for booking codes, referral codes, or any shareable text that users need to copy.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone component for code display)\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Left label for code description\n- Right tappable badge with code and copy icon\n- Animated state transition on copy\n- \"Copied to clipboard\" confirmation text\n- 5-second auto-revert to default state\n- Enable/disable state with alpha dimming\n- 4pt corner radius on container\n- Secondary background color\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockCodeClipboardViewModel.defaultMock()\nlet clipboardView = CodeClipboardView(viewModel: viewModel)\n\n// Tapping automatically copies and shows confirmation\n// Custom logic can be added via ViewModel's onCopyTapped()\n```\n\n## Data Model\n\n```swift\nenum CodeClipboardState: Equatable {\n    case `default`\n    case copied\n}\n\nstruct CodeClipboardData: Equatable {\n    let state: CodeClipboardState\n    let code: String\n    let labelText: String\n    let isEnabled: Bool\n}\n\nprotocol CodeClipboardViewModelProtocol {\n    var dataPublisher: AnyPublisher<CodeClipboardData, Never> { get }\n    var currentData: CodeClipboardData { get }\n\n    func updateCode(_ code: String)\n    func setCopied(_ isCopied: Bool)\n    func setEnabled(_ isEnabled: Bool)\n    func onCopyTapped()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundSecondary` - container background\n- `StyleProvider.Color.backgroundGradient2` - copy button background\n- `StyleProvider.Color.textPrimary` - left label text color\n- `StyleProvider.Color.highlightPrimary` - code text, copy icon, and status text\n- `StyleProvider.fontWith(type: .medium, size: 16)` - left label font\n- `StyleProvider.fontWith(type: .bold, size: 18)` - code text font\n- `StyleProvider.fontWith(type: .bold, size: 12)` - copied status font\n\nLayout constants:\n- Container corner radius: 4pt\n- Badge corner radius: 12pt\n- Badge padding: 12pt horizontal, 8pt vertical\n- Icon size: 24pt\n- Horizontal padding: 16pt\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock()` - default state with code \"ABCD1E2\"\n- `.copiedMock()` - showing \"Copied\" state\n- `.withCustomCodeMock()` - custom code \"XYZ789\"\n- `.disabledMock()` - disabled/non-interactive state\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CodeClipboardView/__Snapshots__/CodeClipboardViewSnapshotTests/testCodeClipboardView_BasicStates_Light.1.png",
          "dark": "CodeClipboardView/__Snapshots__/CodeClipboardViewSnapshotTests/testCodeClipboardView_BasicStates_Dark.1.png"
        },
        {
          "category": "ContentVariants",
          "light": "CodeClipboardView/__Snapshots__/CodeClipboardViewSnapshotTests/testCodeClipboardView_ContentVariants_Light.1.png",
          "dark": "CodeClipboardView/__Snapshots__/CodeClipboardViewSnapshotTests/testCodeClipboardView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "CodeInputView": {
      "displayName": "CodeInputView",
      "category": "Forms",
      "subcategory": "CodeEntry",
      "summary": "Code entry form with text field, submit button, and error display",
      "description": "Complete booking/promo code input interface with BorderedTextFieldView for entry, ButtonView for submission, and error banner (orange with icon) for validation feedback. Supports loading state with activity indicator. Used in betslip for loading saved bets via booking codes.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "form",
        "input",
        "code",
        "booking-code",
        "promo-code",
        "validation",
        "error"
      ],
      "states": [
        "default",
        "loading",
        "error"
      ],
      "similarTo": [
        "CodeClipboardView"
      ],
      "oftenUsedWith": [
        "BorderedTextFieldView",
        "ButtonView"
      ],
      "parents": [],
      "children": [
        "BorderedTextFieldView",
        "ButtonView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CodeInputView\n\nA code entry form with text field, submit button, and error display.\n\n## Overview\n\nCodeInputView provides a complete booking code input interface with a bordered text field, submit button, and optional error message display. It supports loading and error states, automatically managing the visual appearance of child components based on the current state. Common uses include booking code entry, promo code redemption, and verification code input.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone form component)\n\n### Uses (Children)\n- `BorderedTextFieldView` - code input field\n- `ButtonView` - submit button\n\n## Features\n\n- Bordered text field with placeholder\n- Configurable submit button title\n- Error state with warning banner (orange background, icon, message)\n- Loading state with centered activity indicator\n- Default, loading, and error states\n- Text change callback for validation\n- Button tap callback for submission\n- Secondary background color\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockCodeInputViewModel.defaultMock()\nlet codeInputView = CodeInputView(viewModel: viewModel)\n\nviewModel.onSubmitRequested = { code in\n    // Validate and process the code\n    if code.isEmpty {\n        viewModel.setError(\"Please enter a code\")\n    } else {\n        viewModel.setLoading(true)\n        // API call...\n    }\n}\n```\n\n## Data Model\n\n```swift\nenum CodeInputState: Equatable {\n    case `default`\n    case loading\n    case error(message: String)\n}\n\nstruct CodeInputData: Equatable {\n    let state: CodeInputState\n    let code: String\n    let placeholder: String\n    let buttonTitle: String\n    let isButtonEnabled: Bool\n}\n\nprotocol CodeInputViewModelProtocol {\n    var dataPublisher: AnyPublisher<CodeInputData, Never> { get }\n    var currentData: CodeInputData { get }\n    var codeTextFieldViewModel: BorderedTextFieldViewModelProtocol { get }\n    var submitButtonViewModel: ButtonViewModelProtocol { get }\n\n    func updateCode(_ code: String)\n    func setLoading(_ isLoading: Bool)\n    func setError(_ message: String)\n    func clearError()\n    func onButtonTapped()\n\n    var onSubmitRequested: ((String) -> Void)? { get set }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundSecondary` - container background\n- `StyleProvider.Color.alertWarning` - error banner background\n- `StyleProvider.Color.allWhite` - error icon and text color\n- `StyleProvider.fontWith(type: .bold, size: 14)` - error message font\n\nLayout constants:\n- Text field height: 52pt\n- Button height: 50pt\n- Content padding: 16pt\n- Vertical spacing: 12pt\n- Error banner corner radius: 8pt\n- Error icon size: 24pt\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock()` - empty default state\n- `.loadingMock()` - loading with code \"BA2672\"\n- `.errorMock()` - error state with message\n- `.withCodeMock()` - pre-filled with code \"BA2672\"\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CodeInputView/__Snapshots__/CodeInputViewSnapshotTests/testCodeInputView_BasicStates_Light.1.png",
          "dark": "CodeInputView/__Snapshots__/CodeInputViewSnapshotTests/testCodeInputView_BasicStates_Dark.1.png"
        },
        {
          "category": "InputStates",
          "light": "CodeInputView/__Snapshots__/CodeInputViewSnapshotTests/testCodeInputView_InputStates_Light.1.png",
          "dark": "CodeInputView/__Snapshots__/CodeInputViewSnapshotTests/testCodeInputView_InputStates_Dark.1.png"
        }
      ]
    },
    "CompactMatchHeaderView": {
      "displayName": "CompactMatchHeaderView",
      "category": "MatchCards",
      "subcategory": "Headers",
      "summary": "Compact header for inline match cards with time/status and market count",
      "description": "Shows match timing info on left (date/time for pre-live or LIVE badge with game status like '2ND SET', '45'', 'HT') and market count with optional icons on right. Designed for space-constrained inline match card layouts. Supports tap on market count for navigation.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "header",
        "match",
        "live",
        "pre-live",
        "status",
        "market-count",
        "compact"
      ],
      "states": [
        "preLive",
        "live"
      ],
      "similarTo": [
        "MatchHeaderCompactView"
      ],
      "oftenUsedWith": [
        "InlineMatchCardView"
      ],
      "parents": [
        "InlineMatchCardView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CompactMatchHeaderView\n\nA compact header component for inline match cards displaying date/time or LIVE status with optional icons and market count.\n\n## Overview\n\n`CompactMatchHeaderView` provides a flexible header row for match cards with two modes:\n- **Pre-live**: Shows date/time text (e.g., \"TODAY, 14:00\")\n- **Live**: Shows LIVE badge + game status (e.g., \"2ND SET\")\n\n## Architecture\n\n### Files\n```\nCompactMatchHeaderView/\n CompactMatchHeaderView.swift              # Main view\n CompactMatchHeaderViewModelProtocol.swift # Protocol + data models\n MockCompactMatchHeaderViewModel.swift     # Mock implementation\n Documentation/\n     README.md\n```\n\n### Component Structure\n```\nCompactMatchHeaderView\n containerStackView (horizontal)\n    leftStackView\n       liveBadge (hidden when pre-live)\n          liveBadgeLabel (\"LIVE\")\n       statusLabel (date/time or game status)\n   \n    rightStackView\n        iconsStackView (EP, bet-builder, etc.)\n        marketCountLabel (\"+123\")\n        arrowImageView (chevron.right)\n```\n\n## Usage\n\n### Basic Usage\n\n```swift\n// Pre-live header\nlet preLiveHeader = CompactMatchHeaderView(\n    viewModel: MockCompactMatchHeaderViewModel.preLiveToday\n)\n\n// Live header\nlet liveHeader = CompactMatchHeaderView(\n    viewModel: MockCompactMatchHeaderViewModel.liveTennis\n)\n```\n\n### In Card Layout\n\n```swift\n// Add header at top of card\ncardStackView.addArrangedSubview(headerView)\ncardStackView.addArrangedSubview(contentView)\n```\n\n### Handle Market Count Tap\n\n```swift\nheaderView.onMarketCountTapped = { [weak self] in\n    self?.coordinator?.showMoreMarkets()\n}\n```\n\n### Cell Reuse\n\n```swift\noverride func prepareForReuse() {\n    super.prepareForReuse()\n    headerView.cleanupForReuse()\n}\n\nfunc configure(with viewModel: CompactMatchHeaderViewModelProtocol) {\n    headerView.configure(with: viewModel)\n}\n```\n\n## Data Models\n\n### CompactMatchHeaderMode\n\n```swift\nenum CompactMatchHeaderMode {\n    case preLive(dateText: String)  // \"TODAY, 14:00\"\n    case live(statusText: String)   // \"2ND SET\", \"45'\"\n}\n```\n\n### CompactMatchHeaderIcon\n\n```swift\nstruct CompactMatchHeaderIcon {\n    let id: String\n    let iconName: String     // Asset name in bundle\n    let isVisible: Bool      // Can hide icons per client config\n}\n```\n\n### CompactMatchHeaderDisplayState\n\n```swift\nstruct CompactMatchHeaderDisplayState {\n    let mode: CompactMatchHeaderMode\n    let icons: [CompactMatchHeaderIcon]\n    let marketCount: Int?\n    let showMarketCountArrow: Bool\n}\n```\n\n## Mode Examples\n\n### Pre-Live\n```\n[TODAY, 14:00]                    [EP][BB] +123 >\n[17/07, 11:00]                    [EP][BB] +89 >\n[TOMORROW, 20:00]                        +45 >\n```\n\n### Live\n```\n[LIVE] 2ND SET                    [EP][BB] +123 >\n[LIVE] 45'                        [EP][BB] +78 >\n[LIVE] HT                                +65 >\n```\n\n## Icons Configuration\n\nIcons can be shown or hidden based on client configuration:\n\n```swift\n// With icons (design mockup)\nlet icons = [\n    CompactMatchHeaderIcon(id: \"ep\", iconName: \"erep_short_info\", isVisible: true),\n    CompactMatchHeaderIcon(id: \"betBuilder\", iconName: \"bet_builder_info\", isVisible: true)\n]\n\n// Without icons (production)\nlet icons = [\n    CompactMatchHeaderIcon(id: \"ep\", iconName: \"erep_short_info\", isVisible: false),\n    CompactMatchHeaderIcon(id: \"betBuilder\", iconName: \"bet_builder_info\", isVisible: false)\n]\n```\n\n## Mock Configurations\n\n### Pre-Live States\n```swift\nMockCompactMatchHeaderViewModel.preLiveToday       // \"TODAY, 14:00\"\nMockCompactMatchHeaderViewModel.preLiveFutureDate  // \"17/07, 11:00\"\nMockCompactMatchHeaderViewModel.preLiveTomorrow    // \"TOMORROW, 20:00\"\nMockCompactMatchHeaderViewModel.preLiveNoIcons     // Hidden icons\n```\n\n### Live States\n```swift\nMockCompactMatchHeaderViewModel.liveTennis         // \"2ND SET\"\nMockCompactMatchHeaderViewModel.liveFootball       // \"45'\"\nMockCompactMatchHeaderViewModel.liveBasketball     // \"3RD QTR\"\nMockCompactMatchHeaderViewModel.liveHalftime       // \"HT\"\nMockCompactMatchHeaderViewModel.liveNoIcons        // Hidden icons\n```\n\n### Edge Cases\n```swift\nMockCompactMatchHeaderViewModel.highMarketCount    // +999\nMockCompactMatchHeaderViewModel.noMarketCount      // No count shown\nMockCompactMatchHeaderViewModel.minimal            // No icons, no arrow\n```\n\n## Styling\n\nAll colors and fonts use `StyleProvider`:\n- Date/status text: `StyleProvider.Color.highlightPrimary`\n- LIVE badge background: `StyleProvider.Color.highlightPrimary`\n- LIVE badge text: `StyleProvider.Color.textOnHighlight`\n- Market count: `StyleProvider.Color.highlightPrimary`\n- Arrow tint: `StyleProvider.Color.highlightPrimary`\n\n## Design Decisions\n\n1. **Flexible Height**: No fixed height constraint to accommodate client customization\n2. **Icon Visibility**: Icons can be toggled per-icon for client-specific configurations\n3. **Market Count Arrow**: Optional arrow for \"more markets\" indication\n4. **LIVE Badge**: Rounded pill badge with bold text for visibility\n",
      "snapshots": [
        {
          "category": "LiveStates",
          "light": "CompactMatchHeaderView/__Snapshots__/CompactMatchHeaderViewSnapshotTests/testCompactMatchHeaderView_LiveStates_Light.1.png",
          "dark": "CompactMatchHeaderView/__Snapshots__/CompactMatchHeaderViewSnapshotTests/testCompactMatchHeaderView_LiveStates_Dark.1.png"
        },
        {
          "category": "PreLiveStates",
          "light": "CompactMatchHeaderView/__Snapshots__/CompactMatchHeaderViewSnapshotTests/testCompactMatchHeaderView_PreLiveStates_Light.1.png",
          "dark": "CompactMatchHeaderView/__Snapshots__/CompactMatchHeaderViewSnapshotTests/testCompactMatchHeaderView_PreLiveStates_Dark.1.png"
        }
      ]
    },
    "CompactOutcomesLineView": {
      "displayName": "CompactOutcomesLineView",
      "category": "MatchCards",
      "subcategory": "Outcomes",
      "summary": "Compact single-line display of betting outcomes for inline match cards",
      "description": "Displays 2-3 OutcomeItemView instances horizontally in a fixed 50pt row. Supports 2-way markets (tennis, over/under) and 3-way markets (football 1X2). Manages selection states via publishers, supports odds change indicators and locked outcomes. Equal-width distribution with 4pt spacing.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "outcomes",
        "odds",
        "betting",
        "market",
        "2-way",
        "3-way",
        "selection",
        "compact"
      ],
      "states": [
        "double",
        "triple"
      ],
      "similarTo": [
        "MarketOutcomesLineView"
      ],
      "oftenUsedWith": [
        "InlineMatchCardView",
        "OutcomeItemView"
      ],
      "parents": [
        "InlineMatchCardView"
      ],
      "children": [
        "OutcomeItemView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CompactOutcomesLineView\n\nA compact single-line outcomes display for inline match cards. Displays 2-3 OutcomeItemView instances horizontally.\n\n## Overview\n\n`CompactOutcomesLineView` provides a simplified outcomes row for compact match cards. Unlike `MarketOutcomesLineView`, it:\n- Only supports single-line display (no multi-line)\n- No market name pill\n- No suspended/seeAll states\n- Simpler layout for card integration\n\n## Architecture\n\n### Files\n```\nCompactOutcomesLineView/\n CompactOutcomesLineView.swift              # Main view\n CompactOutcomesLineViewModelProtocol.swift # Protocol + data models\n MockCompactOutcomesLineViewModel.swift     # Mock implementation\n Documentation/\n     README.md\n```\n\n### Component Structure\n```\nCompactOutcomesLineView\n containerStackView (horizontal, fillEqually)\n    OutcomeItemView (left - \"1\")\n    OutcomeItemView (middle - \"X\", hidden in double mode)\n    OutcomeItemView (right - \"2\")\n```\n\n## Usage\n\n### Basic Usage\n\n```swift\n// 3-way market (Football)\nlet threeWayView = CompactOutcomesLineView(\n    viewModel: MockCompactOutcomesLineViewModel.threeWayMarket\n)\n\n// 2-way market (Tennis)\nlet twoWayView = CompactOutcomesLineView(\n    viewModel: MockCompactOutcomesLineViewModel.twoWayMarket\n)\n```\n\n### Handle Selection Callbacks\n\n```swift\noutcomesView.onOutcomeSelected = { [weak self] outcomeId, outcomeType in\n    self?.coordinator?.addToBetslip(outcomeId: outcomeId)\n}\n\noutcomesView.onOutcomeDeselected = { [weak self] outcomeId, outcomeType in\n    self?.coordinator?.removeFromBetslip(outcomeId: outcomeId)\n}\n```\n\n### Cell Reuse\n\n```swift\noverride func prepareForReuse() {\n    super.prepareForReuse()\n    outcomesView.cleanupForReuse()\n}\n\nfunc configure(with viewModel: CompactOutcomesLineViewModelProtocol) {\n    outcomesView.configure(with: viewModel)\n\n    // Re-establish callbacks after configure\n    outcomesView.onOutcomeSelected = { ... }\n    outcomesView.onOutcomeDeselected = { ... }\n}\n```\n\n## Display Modes\n\n### Double (2-way)\n```\n[   1   ] [   2   ]\n[  2.90 ] [  3.05 ]\n```\n\nUsed for:\n- Tennis (Player 1 / Player 2)\n- Over/Under markets\n- Yes/No markets\n\n### Triple (3-way)\n```\n[   1   ] [   X   ] [   2   ]\n[  2.90 ] [  3.05 ] [  2.68 ]\n```\n\nUsed for:\n- Football 1X2\n- Home/Draw/Away markets\n\n## Data Models\n\n### CompactOutcomesDisplayMode\n\n```swift\nenum CompactOutcomesDisplayMode {\n    case double  // 2 outcomes\n    case triple  // 3 outcomes\n}\n```\n\n### CompactOutcomesLineDisplayState\n\n```swift\nstruct CompactOutcomesLineDisplayState {\n    let displayMode: CompactOutcomesDisplayMode\n    let leftOutcome: OutcomeItemData?\n    let middleOutcome: OutcomeItemData?  // nil for double mode\n    let rightOutcome: OutcomeItemData?\n}\n```\n\n## Mock Configurations\n\n### 3-Way Markets\n```swift\nMockCompactOutcomesLineViewModel.threeWayMarket      // Standard 1X2\nMockCompactOutcomesLineViewModel.withSelectedOutcome // With selection\nMockCompactOutcomesLineViewModel.highOdds            // High odds values\n```\n\n### 2-Way Markets\n```swift\nMockCompactOutcomesLineViewModel.twoWayMarket        // Standard 1/2\nMockCompactOutcomesLineViewModel.overUnderMarket     // Over/Under\nMockCompactOutcomesLineViewModel.twoWayWithSelection // With selection\n```\n\n### Special States\n```swift\nMockCompactOutcomesLineViewModel.lockedMarket        // All locked\nMockCompactOutcomesLineViewModel.withOddsChanges     // Odds arrows\n```\n\n## Integration with InlineMatchCardView\n\n```swift\n// In InlineMatchCardView\nprivate lazy var outcomesView = CompactOutcomesLineView()\n\n// Configuration\nfunc configureOutcomes(with viewModel: CompactOutcomesLineViewModelProtocol) {\n    outcomesView.configure(with: viewModel)\n    setupOutcomesCallbacks()\n}\n\nprivate func setupOutcomesCallbacks() {\n    outcomesView.onOutcomeSelected = { [weak self] id, type in\n        self?.onOutcomeSelected(id)\n        self?.viewModel?.onOutcomeSelected(outcomeId: id)\n    }\n}\n```\n\n## Differences from MarketOutcomesLineView\n\n| Feature | CompactOutcomesLineView | MarketOutcomesLineView |\n|---------|------------------------|------------------------|\n| Multi-line | No | Yes |\n| Market name pill | No | Yes |\n| Suspended state | No | Yes |\n| See All state | No | Yes |\n| Use case | Inline cards | Full market display |\n\n## Styling\n\nUses `OutcomeItemView` directly, inheriting all its styling:\n- Background: `StyleProvider.Color.backgroundOdds`\n- Selected: `StyleProvider.Color.highlightPrimary`\n- Text: `StyleProvider.fontWith(type: .bold, size: 16)`\n\n## Constants\n\n```swift\nstackSpacing: 4.0pt      // Between outcomes\noutcomeHeight: 52.0pt    // Fixed height\noutcomeMinWidth: 60.0pt  // Minimum width per outcome\n```\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CompactOutcomesLineView/__Snapshots__/CompactOutcomesLineViewSnapshotTests/testCompactOutcomesLineView_BasicStates_Light.1.png",
          "dark": "CompactOutcomesLineView/__Snapshots__/CompactOutcomesLineViewSnapshotTests/testCompactOutcomesLineView_BasicStates_Dark.1.png"
        },
        {
          "category": "SpecialStates",
          "light": "CompactOutcomesLineView/__Snapshots__/CompactOutcomesLineViewSnapshotTests/testCompactOutcomesLineView_SpecialStates_Light.1.png",
          "dark": "CompactOutcomesLineView/__Snapshots__/CompactOutcomesLineViewSnapshotTests/testCompactOutcomesLineView_SpecialStates_Dark.1.png"
        }
      ]
    },
    "CopyableCodeView": {
      "displayName": "CopyableCodeView",
      "category": "Forms",
      "subcategory": "Clipboard",
      "summary": "Simple code display with tap-to-copy and haptic feedback",
      "description": "Displays a label on left and tappable code badge on right with copy icon. Tapping copies to clipboard with haptic feedback and shows cross-dissolve 'Copied' animation that auto-reverts after 2 seconds. Simpler non-reactive alternative to CodeClipboardView for booking/promo/referral codes.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "clipboard",
        "copy",
        "code",
        "booking-code",
        "promo-code",
        "referral",
        "haptic"
      ],
      "states": [
        "default",
        "copied"
      ],
      "similarTo": [
        "CodeClipboardView"
      ],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CopyableCodeView\n\nA simple code display component with tap-to-copy functionality and visual feedback.\n\n## Overview\n\nCopyableCodeView displays a label on the left and a tappable code badge on the right. Tapping the code copies it to the clipboard and shows a \"Copied\" confirmation with haptic feedback that automatically reverts after 2 seconds. This component is useful for displaying booking codes, promo codes, referral codes, or any shareable text.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone component for code display)\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Left label for code description\n- Right tappable badge with code and copy icon\n- System copy icon (doc.on.doc.fill)\n- Haptic feedback on copy\n- Cross-dissolve animation to \"Copied\" state\n- 2-second auto-revert to default state\n- 4pt corner radius on container\n- 12pt corner radius on badge\n- Secondary background color\n- Gradient background on badge\n\n## Usage\n\n```swift\nlet viewModel = MockCopyableCodeViewModel.bookingCodeMock\nlet codeView = CopyableCodeView(viewModel: viewModel)\n\n// Copy action is handled internally via viewModel.onCopyTapped()\n// Real implementation should copy to UIPasteboard.general.string\n```\n\n## Data Model\n\n```swift\nprotocol CopyableCodeViewModelProtocol {\n    var code: String { get }\n    var label: String { get }\n    var copiedMessage: String { get }\n\n    func onCopyTapped()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundSecondary` - container background\n- `StyleProvider.Color.backgroundGradient2` - badge background\n- `StyleProvider.Color.backgroundTertiary` - preview background\n- `StyleProvider.Color.textPrimary` - label text color\n- `StyleProvider.Color.highlightPrimary` - code text, copy icon, and status text\n- `StyleProvider.fontWith(type: .semibold, size: 13)` - label font\n- `StyleProvider.fontWith(type: .bold, size: 18)` - code text font\n- `StyleProvider.fontWith(type: .bold, size: 14)` - copied status font\n\nLayout constants:\n- Container corner radius: 4pt\n- Badge corner radius: 12pt\n- Badge height: 44pt\n- Icon size: 24pt\n- Horizontal padding: 16pt\n- Badge padding: 12pt\n\n## Mock ViewModels\n\nAvailable presets:\n- `.bookingCodeMock` - \"ABCD1E2\" with \"Copy Booking Code\" label\n- `.promoCodeMock` - \"SUMMER2025\" with \"Copy Promo Code\" label\n- `.longCodeMock` - \"ABCD1E2F3G4H5J6K7\" with \"Copy Transaction ID\" label\n- `.referralCodeMock` - \"REF-XYZ789\" with \"Copy Referral Code\" label\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CopyableCodeView/__Snapshots__/CopyableCodeViewSnapshotTests/testCopyableCodeView_BasicStates_Light.1.png",
          "dark": "CopyableCodeView/__Snapshots__/CopyableCodeViewSnapshotTests/testCopyableCodeView_BasicStates_Dark.1.png"
        },
        {
          "category": "ContentVariants",
          "light": "CopyableCodeView/__Snapshots__/CopyableCodeViewSnapshotTests/testCopyableCodeView_ContentVariants_Light.1.png",
          "dark": "CopyableCodeView/__Snapshots__/CopyableCodeViewSnapshotTests/testCopyableCodeView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "CountryLeaguesFilterView": {
      "displayName": "CountryLeaguesFilterView",
      "category": "Filters",
      "subcategory": "Sports",
      "summary": "Collapsible country/league filter panel with nested expandable sections",
      "description": "Displays countries with nested league lists in collapsible structure. Header with chevron rotation animation, country rows that expand to show leagues, single league selection across all countries. Used in sports event filtering screens like CombinedFiltersViewController.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "filter",
        "country",
        "league",
        "collapsible",
        "expandable",
        "nested",
        "sports"
      ],
      "states": [
        "collapsed",
        "expanded",
        "countryExpanded",
        "countryCollapsed"
      ],
      "similarTo": [
        "SortOptionsView",
        "GeneralFilterBarView"
      ],
      "oftenUsedWith": [
        "SortOptionsView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CountryLeaguesFilterView\n\nA hierarchical, collapsible filter component built with UIKit and Combine that allows users to browse and select leagues organized by country. The component features a two-level structure with expandable country sections containing their respective leagues, complete with visual selection indicators and event counts.\n\n## Overview\n\nThe `CountryLeaguesFilterView` displays leagues grouped by country in an expandable/collapsible interface. Each country can be expanded to reveal its leagues, and users can select individual leagues within any country. The component follows MVVM architecture and uses reactive programming with Combine for state management across multiple nested levels.\n\n## Architecture\n\n### Component Structure\n```\nCountryLeaguesFilterView/\n CountryLeaguesFilterView.swift                     # Main component view\n CountryLeaguesFilterViewModelProtocol.swift        # View model protocol\n MockCountryLeaguesFilterViewModel.swift            # Mock implementation\n CountryLeagueOptionRowView/\n    CountryLeagueOptionRowView.swift               # Country header row\n    CountryLeagueOptionRowViewModelProtocol.swift  # Country row protocol\n    MockCountryLeagueOptionRowViewModel.swift     # Country row mock\n LeagueOptionSelectionRowView/\n    LeagueOptionSelectionRowView.swift             # Individual league row\n    LeagueOptionSelectionRowViewModelProtocol.swift # League row protocol\n    MockLeagueOptionSelectionRowViewModel.swift   # League row mock\n Models/\n     CountryLeaguesModels.swift                     # Data models\n```\n\n### MVVM Pattern\n- **View**: `CountryLeaguesFilterView` - Main hierarchical filter component\n- **ViewModel**: `CountryLeaguesFilterViewModelProtocol` - Business logic and state management\n- **Model**: `CountryLeagueOptions` - Data structure for country-league relationships\n- **Sub-Views**: Country and league row components with their own view models\n\n## Key Features\n\n### Hierarchical Structure\n- **Country Headers**: Expandable sections with country flags and total counts\n- **League Lists**: Nested leagues within each country with individual selection\n- **Two-Level Navigation**: Country expansion and league selection\n- **Visual Hierarchy**: Clear distinction between country headers and league items\n\n### Interactive Elements\n- **Country Expansion**: Tap country headers to expand/collapse league lists\n- **League Selection**: Individual league selection with radio button interface\n- **Main Collapse**: Global collapse/expand functionality for entire component\n- **Visual Feedback**: Multiple levels of selection and state indicators\n\n### Visual Design\n- **Country Indicators**: Left accent lines for countries containing selected leagues\n- **League Selection**: Radio buttons with visual selection states\n- **Count Displays**: Event counts for both countries and individual leagues\n- **Smooth Animations**: Coordinated expand/collapse transitions across levels\n- **Flag Icons**: Country flag support for visual identification\n\n### State Management\n- **Multi-Level State**: Country expansion and league selection states\n- **Reactive Updates**: Combine-based synchronization across all levels\n- **Selection Propagation**: Country selection state based on contained leagues\n- **Dynamic Updates**: Support for refreshing country and league data\n\n## Models\n\n### CountryLeagueOptions\n```swift\npublic struct CountryLeagueOptions: Equatable {\n    public let id: Int\n    public let icon: String?\n    public let title: String\n    public var leagues: [LeagueOption]\n    public var isExpanded: Bool\n}\n```\n\n**Properties:**\n- `id`: Unique identifier for the country\n- `icon`: Optional country flag icon name\n- `title`: Country display name (e.g., \"England\", \"Spain\")\n- `leagues`: Array of leagues within this country\n- `isExpanded`: Current expansion state of the country section\n\n### Integration with LeagueOption\nThe component reuses the `LeagueOption` model from other filter components:\n```swift\npublic struct LeagueOption: Equatable {\n    public let id: Int\n    public let icon: String?\n    public let title: String\n    public let count: Int\n}\n```\n\n## Protocols\n\n### CountryLeaguesFilterViewModelProtocol\n```swift\npublic protocol CountryLeaguesFilterViewModelProtocol {\n    var title: String { get }\n    var countryLeagueOptions: [CountryLeagueOptions] { get }\n    var selectedOptionId: CurrentValueSubject<Int, Never> { get }\n    var isCollapsed: CurrentValueSubject<Bool, Never> { get }\n    var shouldRefreshData: PassthroughSubject<Void, Never> { get }\n\n    func toggleCollapse()\n    func toggleCountryExpansion(at index: Int)\n    func updateCountryLeagueOptions(_ newSortOptions: [CountryLeagueOptions])\n}\n```\n\n**Key Methods:**\n- `toggleCollapse()`: Collapses/expands the entire component\n- `toggleCountryExpansion(at:)`: Expands/collapses individual country sections\n- `updateCountryLeagueOptions(_:)`: Updates the data and refreshes UI\n\n## Usage Examples\n\n### Basic Implementation\n```swift\nlet countryLeagueOptions = [\n    CountryLeagueOptions(\n        id: 1,\n        icon: \"england_flag\",\n        title: \"England\",\n        leagues: [\n            LeagueOption(id: 1, icon: nil, title: \"Premier League\", count: 25),\n            LeagueOption(id: 2, icon: nil, title: \"Championship\", count: 24),\n            LeagueOption(id: 3, icon: nil, title: \"League One\", count: 22)\n        ],\n        isExpanded: true\n    ),\n    CountryLeagueOptions(\n        id: 2,\n        icon: \"spain_flag\",\n        title: \"Spain\",\n        leagues: [\n            LeagueOption(id: 16, icon: nil, title: \"La Liga\", count: 20),\n            LeagueOption(id: 17, icon: nil, title: \"La Liga 2\", count: 22)\n        ],\n        isExpanded: false\n    )\n]\n\nlet viewModel = MockCountryLeaguesFilterViewModel(\n    title: \"Popular Countries\",\n    countryLeagueOptions: countryLeagueOptions\n)\n\nlet countryLeaguesFilterView = CountryLeaguesFilterView(viewModel: viewModel)\n\n// Handle league selection\ncountryLeaguesFilterView.onLeagueFilterSelected = { selectedLeagueId in\n    print(\"Selected league ID: \\(selectedLeagueId)\")\n}\n```\n\n### Custom ViewModel Implementation\n```swift\nclass CustomCountryLeaguesFilterViewModel: CountryLeaguesFilterViewModelProtocol {\n    var title: String = \"Countries & Leagues\"\n    var countryLeagueOptions: [CountryLeagueOptions] = []\n    var selectedOptionId = CurrentValueSubject<Int, Never>(0)\n    var isCollapsed = CurrentValueSubject<Bool, Never>(false)\n    var shouldRefreshData = PassthroughSubject<Void, Never>()\n    \n    private let apiService: LeagueAPIService\n    \n    init(apiService: LeagueAPIService) {\n        self.apiService = apiService\n        loadCountryLeagues()\n    }\n    \n    func toggleCollapse() {\n        isCollapsed.send(!isCollapsed.value)\n    }\n    \n    func toggleCountryExpansion(at index: Int) {\n        guard index < countryLeagueOptions.count else { return }\n        countryLeagueOptions[index].isExpanded.toggle()\n        \n        // Save expansion preferences\n        UserDefaults.standard.set(\n            countryLeagueOptions[index].isExpanded,\n            forKey: \"country_\\(countryLeagueOptions[index].id)_expanded\"\n        )\n    }\n    \n    func updateCountryLeagueOptions(_ newOptions: [CountryLeagueOptions]) {\n        self.countryLeagueOptions = newOptions\n        shouldRefreshData.send()\n    }\n    \n    private func loadCountryLeagues() {\n        apiService.fetchCountryLeagues { [weak self] result in\n            switch result {\n            case .success(let options):\n                self?.updateCountryLeagueOptions(options)\n            case .failure(let error):\n                // Handle error\n                print(\"Failed to load country leagues: \\(error)\")\n            }\n        }\n    }\n}\n```\n\n### Integration in Filter Interface\n```swift\nclass FiltersViewController: UIViewController {\n    private var countryLeaguesFilterView: CountryLeaguesFilterView!\n    private var selectedLeagueIds: Set<Int> = []\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupCountryLeaguesFilter()\n    }\n    \n    private func setupCountryLeaguesFilter() {\n        let countryData = loadCountryLeagueData()\n        let viewModel = MockCountryLeaguesFilterViewModel(\n            title: \"Browse by Country\",\n            countryLeagueOptions: countryData\n        )\n        \n        countryLeaguesFilterView = CountryLeaguesFilterView(viewModel: viewModel)\n        countryLeaguesFilterView.translatesAutoresizingMaskIntoConstraints = false\n        \n        view.addSubview(countryLeaguesFilterView)\n        \n        NSLayoutConstraint.activate([\n            countryLeaguesFilterView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),\n            countryLeaguesFilterView.leadingAnchor.constraint(equalTo: view.leadingAnchor),\n            countryLeaguesFilterView.trailingAnchor.constraint(equalTo: view.trailingAnchor)\n        ])\n        \n        countryLeaguesFilterView.onLeagueFilterSelected = { [weak self] leagueId in\n            self?.handleLeagueSelection(leagueId)\n        }\n    }\n    \n    private func handleLeagueSelection(_ leagueId: Int) {\n        if selectedLeagueIds.contains(leagueId) {\n            selectedLeagueIds.remove(leagueId)\n        } else {\n            selectedLeagueIds.insert(leagueId)\n        }\n        \n        updateFilteredContent()\n    }\n}\n```\n\n### Multi-Selection Support\n```swift\nclass MultiSelectCountryLeaguesViewModel: CountryLeaguesFilterViewModelProtocol {\n    var selectedLeagueIds = CurrentValueSubject<Set<Int>, Never>([])\n    \n    func selectLeague(_ leagueId: Int) {\n        var current = selectedLeagueIds.value\n        if current.contains(leagueId) {\n            current.remove(leagueId)\n        } else {\n            current.insert(leagueId)\n        }\n        selectedLeagueIds.send(current)\n    }\n    \n    func clearAllSelections() {\n        selectedLeagueIds.send([])\n    }\n    \n    func selectAllLeaguesInCountry(_ countryId: Int) {\n        guard let country = countryLeagueOptions.first(where: { $0.id == countryId }) else { return }\n        \n        var current = selectedLeagueIds.value\n        country.leagues.forEach { league in\n            current.insert(league.id)\n        }\n        selectedLeagueIds.send(current)\n    }\n}\n```\n\n## Component Behavior\n\n### Hierarchical Selection Logic\n- **League Selection**: Individual leagues can be selected within any country\n- **Country Indication**: Countries show selection state if they contain selected leagues\n- **Visual Hierarchy**: Clear distinction between country headers and league items\n- **State Propagation**: Country selection state reflects contained league selections\n\n### Expansion/Collapse Behavior\n- **Country Expansion**: Individual countries can be expanded/collapsed independently\n- **Global Collapse**: Main component can be collapsed hiding all countries\n- **Animation Coordination**: Smooth transitions across multiple levels\n- **State Persistence**: Expansion states maintained during data updates\n\n### Visual Feedback System\n- **Country Headers**: Left indicators for countries with selected leagues\n- **League Rows**: Radio button selection with color changes\n- **Count Updates**: Real-time event count displays\n- **Smooth Animations**: 0.3 second transitions for all state changes\n\n## Sub-Component Details\n\n### CountryLeagueOptionRowView\nThe country header component handles:\n\n#### Visual Elements\n- **Country Flag**: Flag icon display (16x16pt)\n- **Country Name**: Bold country title\n- **Total Count**: Aggregate event count for all leagues\n- **Expand/Collapse Chevron**: Animated rotation indicator\n- **Left Indicator**: Orange accent line when containing selected leagues\n\n#### Functionality\n- Individual country expand/collapse\n- Selection state management\n- League count aggregation\n- Nested league list management\n\n### LeagueOptionSelectionRowView\nThe individual league component handles:\n\n#### Visual Elements\n- **League Name**: League title with indentation (40pt left margin)\n- **Event Count**: Individual league event count\n- **Radio Button**: Selection indicator with filled state\n- **Bottom Separator**: Visual separation between leagues\n\n#### Functionality\n- Individual league selection\n- Visual selection feedback\n- Event count display\n- Radio button state management\n\n## Country Data Examples\n\n### European Football Countries\n```swift\nlet europeanCountries = [\n    CountryLeagueOptions(\n        id: 1,\n        icon: \"england_flag\",\n        title: \"England\",\n        leagues: [\n            LeagueOption(id: 1, icon: nil, title: \"Premier League\", count: 25),\n            LeagueOption(id: 2, icon: nil, title: \"Championship\", count: 24),\n            LeagueOption(id: 3, icon: nil, title: \"FA Cup\", count: 18)\n        ],\n        isExpanded: false\n    ),\n    CountryLeagueOptions(\n        id: 2,\n        icon: \"spain_flag\", \n        title: \"Spain\",\n        leagues: [\n            LeagueOption(id: 16, icon: nil, title: \"La Liga\", count: 20),\n            LeagueOption(id: 17, icon: nil, title: \"Copa del Rey\", count: 15)\n        ],\n        isExpanded: false\n    )\n]\n```\n\n### International Competitions\n```swift\nlet internationalCompetitions = [\n    CountryLeagueOptions(\n        id: 99,\n        icon: \"international_flag\",\n        title: \"International\",\n        leagues: [\n            LeagueOption(id: 101, icon: nil, title: \"Champions League\", count: 32),\n            LeagueOption(id: 102, icon: nil, title: \"Europa League\", count: 24),\n            LeagueOption(id: 103, icon: nil, title: \"World Cup Qualifiers\", count: 28)\n        ],\n        isExpanded: true\n    )\n]\n```\n\n## Styling Integration\n\nThe component integrates with `StyleProvider` for consistent theming:\n\n- **Colors**:\n  - `highlightPrimary`: Orange accent for indicators and selections\n  - `textPrimary`: Main text color for titles\n  - `separatorLine`: Background color for selected items\n  - `allWhite`: Radio button and dot colors\n- **Typography**:\n  - Bold 14pt for country names and selected leagues\n  - Regular 14pt for unselected league names\n  - Regular 12pt for count displays\n- **Spacing**:\n  - 16pt margins for main elements\n  - 40pt left margin for league indentation\n  - 4pt indicator width\n\n## Accessibility Features\n\n- **Clear Hierarchy**: Visual and structural distinction between levels\n- **Touch Targets**: Appropriate sizes for country headers and league rows\n- **State Communication**: Multiple visual indicators for selection states\n- **Logical Navigation**: Intuitive expand/collapse behavior\n- **Screen Reader Support**: Proper accessibility labels and hints\n\n## Performance Considerations\n\n### Efficient Updates\n- Selective row updates during selection changes\n- Optimized constraint management during animations\n- Efficient state propagation across hierarchical structure\n- Minimal layout calculations for large country/league lists\n\n### Memory Management\n- Weak references in nested callbacks\n- Proper Combine cancellable storage across multiple levels\n- Efficient view recycling for large datasets\n- Automatic cleanup of nested components\n\n## Integration Patterns\n\n### With Other Filter Components\n```swift\nclass CombinedFiltersViewController: UIViewController {\n    private var sportsFilter: SportGamesFilterView!\n    private var countryLeaguesFilter: CountryLeaguesFilterView!\n    private var sortFilter: SortFilterView!\n    \n    func setupCombinedFilters() {\n        let stackView = UIStackView(arrangedSubviews: [\n            sportsFilter,\n            countryLeaguesFilter,\n            sortFilter\n        ])\n        stackView.axis = .vertical\n        stackView.spacing = 16\n        \n        // Coordinate filter selections\n        countryLeaguesFilter.onLeagueFilterSelected = { [weak self] leagueId in\n            self?.syncFilters(selectedLeague: leagueId)\n        }\n    }\n}\n```\n\n### With Search Functionality\n```swift\nclass SearchableCountryLeaguesFilter {\n    private let originalData: [CountryLeagueOptions]\n    private let filterView: CountryLeaguesFilterView\n    \n    func filterBySearch(_ searchText: String) {\n        let filteredData = originalData.compactMap { country in\n            let filteredLeagues = country.leagues.filter { league in\n                league.title.localizedCaseInsensitiveContains(searchText)\n            }\n            \n            guard !filteredLeagues.isEmpty else { return nil }\n            \n            return CountryLeagueOptions(\n                id: country.id,\n                icon: country.icon,\n                title: country.title,\n                leagues: filteredLeagues,\n                isExpanded: true // Expand when filtering\n            )\n        }\n        \n        filterView.viewModel.updateCountryLeagueOptions(filteredData)\n    }\n}\n```\n\n## Error Handling\n\n### Data Validation\n- Unique ID validation for countries and leagues\n- Non-empty league arrays for countries\n- Valid country flag icon verification\n- Proper count value validation (non-negative)\n\n### State Management\n- Safe array access patterns\n- Graceful handling of missing country data\n- Proper state synchronization across levels\n- Recovery from inconsistent selection states\n\n## Dependencies\n\n- **UIKit**: Core UI framework and animations\n- **Combine**: Reactive programming and multi-level state management\n- **StyleProvider**: Internal styling and theming system\n- **Foundation**: Basic data structures and utilities\n\n## Best Practices\n\n1. **Data Consistency**: Ensure unique IDs across all countries and leagues\n2. **Memory Management**: Use weak references in nested callback chains\n3. **State Synchronization**: Keep country and league selection states consistent\n4. **Performance**: Monitor memory usage with large country/league datasets\n5. **User Experience**: Provide clear visual feedback for hierarchical navigation\n6. **Accessibility**: Test with VoiceOver for proper hierarchy navigation\n7. **Animation Timing**: Coordinate expand/collapse animations across levels\n\n## Future Enhancements\n\n- Multi-selection support with checkboxes\n- Search and filter functionality within countries/leagues\n- Drag-to-reorder favorite countries\n- Country grouping by region (Europe, Americas, etc.)\n- League favorites and bookmarking\n- Dynamic loading with pagination for large datasets\n- Custom country flag support beyond predefined assets\n- Keyboard navigation support for accessibility\n- Export/import of country/league preferences\n- Advanced filtering (by league type, division level, etc.)\n- Integration with live data updates for event counts\n- Custom expansion animations and effects ",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CountryLeaguesFilterView/__Snapshots__/CountryLeaguesFilterViewSnapshotTests/testCountryLeaguesFilterView_BasicStates_Light.1.png",
          "dark": "CountryLeaguesFilterView/__Snapshots__/CountryLeaguesFilterViewSnapshotTests/testCountryLeaguesFilterView_BasicStates_Dark.1.png"
        }
      ]
    },
    "CustomExpandableSectionView": {
      "displayName": "CustomExpandableSectionView",
      "category": "UIElements",
      "subcategory": "Containers",
      "summary": "Generic expandable section with header, icon, and content container",
      "description": "Reusable collapsible section with tappable header containing optional leading icon, title, and chevron toggle. Content area is a UIStackView for custom content injection. Animated expand/collapse with constraint switching. 40pt header height, 8pt corner radius.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "expandable",
        "collapsible",
        "section",
        "container",
        "accordion",
        "generic"
      ],
      "states": [
        "collapsed",
        "expanded"
      ],
      "similarTo": [
        "CountryLeaguesFilterView"
      ],
      "oftenUsedWith": [
        "WalletDetailView"
      ],
      "parents": [
        "WalletDetailView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CustomExpandableSectionView\n\nA generic expandable section with header, icon, and content container.\n\n## Overview\n\nCustomExpandableSectionView provides a reusable collapsible section with a tappable header containing an optional leading icon, title, and toggle button. The content area is a UIStackView that can contain any custom views. The component handles expand/collapse animations and constraint switching automatically.\n\n## Component Relationships\n\n### Used By (Parents)\n- `WalletDetailView` - expandable wallet sections\n\n### Uses (Children)\n- None (provides contentContainer for external content injection)\n\n## Features\n\n- Tappable header for expand/collapse\n- Optional leading icon (system or asset)\n- Customizable collapse/expand icons\n- Toggle button with icon rotation\n- Content container (UIStackView) for custom content\n- Animated expand/collapse with constraint switching\n- 8pt corner radius on container\n- 40pt header height\n- Tertiary background color\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockCustomExpandableSectionViewModel.defaultCollapsed\nlet sectionView = CustomExpandableSectionView(viewModel: viewModel)\n\n// Add content to the expandable section\nlet contentLabel = UILabel()\ncontentLabel.text = \"This is the expandable content\"\nsectionView.contentContainer.addArrangedSubview(contentLabel)\n```\n\n## Data Model\n\n```swift\nprotocol CustomExpandableSectionViewModelProtocol: AnyObject {\n    var title: String { get }\n    var leadingIconName: String? { get }\n    var collapsedIconName: String? { get }\n    var expandedIconName: String? { get }\n    var isExpandedPublisher: AnyPublisher<Bool, Never> { get }\n\n    func toggleExpanded()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundTertiary` - container background\n- `StyleProvider.Color.backgroundSecondary` - preview background\n- `StyleProvider.Color.textPrimary` - title text color\n- `StyleProvider.Color.textSecondary` - content text color in previews\n- `StyleProvider.Color.highlightPrimary` - leading icon and toggle button tint\n- `StyleProvider.fontWith(type: .bold, size: 12)` - title font\n- `StyleProvider.fontWith(type: .regular, size: 13)` - content font in previews\n\nLayout constants:\n- Container corner radius: 8pt\n- Header height: 40pt\n- Leading icon size: 24pt\n- Toggle button size: 40pt\n- Content padding: 8pt horizontal\n- Content bottom padding: 8pt (when expanded)\n- Content stack spacing: 12pt\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultCollapsed` - \"Account Overview\" with person icon, collapsed\n- `.defaultExpanded` - \"Responsible Gaming\" with shield icon, expanded\n- `.custom(title:icon:collapsedIcon:expandedIcon:isExpanded:)` - custom configuration\n\nDefault icons:\n- Leading: configurable per instance\n- Collapsed: \"chevron.down\"\n- Expanded: \"chevron.up\"\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CustomExpandableSectionView/__Snapshots__/CustomExpandableSectionViewSnapshotTests/testCustomExpandableSectionView_BasicStates_Light.1.png",
          "dark": "CustomExpandableSectionView/__Snapshots__/CustomExpandableSectionViewSnapshotTests/testCustomExpandableSectionView_BasicStates_Dark.1.png"
        },
        {
          "category": "ContentVariants",
          "light": "CustomExpandableSectionView/__Snapshots__/CustomExpandableSectionViewSnapshotTests/testCustomExpandableSectionView_ContentVariants_Light.1.png",
          "dark": "CustomExpandableSectionView/__Snapshots__/CustomExpandableSectionViewSnapshotTests/testCustomExpandableSectionView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "CustomNavigationView": {
      "displayName": "CustomNavigationView",
      "category": "Navigation",
      "subcategory": "Headers",
      "summary": "Branded navigation bar with logo and dismissible close button",
      "description": "Fixed-height 80pt navigation bar featuring a configurable logo image (leading, max 150pt width) and circular close button (trailing, 40pt). Fully customizable via CustomNavigationData model: background color, logo image asset, close icon, button background color, and tint color. Uses StyleProvider.Color.highlightPrimary as default background. Reactive updates via Combine publisher. Commonly used in modal flows like deposit alternative steps where branded headers with dismiss capability are needed.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "navigation",
        "header",
        "modal",
        "logo",
        "close-button",
        "branded",
        "dismissible"
      ],
      "states": [
        "default",
        "blue-style",
        "green-style",
        "dark-style"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "ButtonView",
        "StepInstructionView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CustomNavigationView\n\nA custom navigation bar with logo and close button for modal presentations.\n\n## Overview\n\nCustomNavigationView provides a branded navigation header typically used for modal flows. It displays a logo image on the left and a close button on the right, with customizable colors and icons. The component is commonly used in registration flows, payment screens, or any modal presentation requiring branded navigation.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone navigation component)\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Left-aligned logo image\n- Right-aligned close button with circular icon\n- Customizable background color\n- Customizable close button background color\n- Customizable close icon tint color\n- Custom close icon support\n- Fixed 80pt height\n- Close action callback\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockCustomNavigationViewModel.defaultMock\nlet navigationView = CustomNavigationView(viewModel: viewModel)\n\nnavigationView.onCloseTapped = {\n    print(\"Close button tapped\")\n    // Dismiss modal\n}\n```\n\n## Data Model\n\n```swift\nstruct CustomNavigationData {\n    let id: String\n    let logoImage: String?\n    let closeIcon: String?\n    let backgroundColor: UIColor?\n    let closeButtonBackgroundColor: UIColor?\n    let closeIconTintColor: UIColor?\n}\n\nprotocol CustomNavigationViewModelProtocol {\n    var data: CustomNavigationData { get }\n    var dataPublisher: AnyPublisher<CustomNavigationData, Never> { get }\n\n    func configure(with data: CustomNavigationData)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.highlightPrimary` - default background color\n- `StyleProvider.Color.allWhite` - default close icon tint\n\nLayout constants:\n- Container height: 80pt\n- Logo padding: 20pt leading\n- Logo height: 40pt\n- Logo max width: 150pt\n- Close button padding: 20pt trailing\n- Close button size: 40pt\n- Close button corner radius: 20pt\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - Betsson logo with default primary highlight background\n- `.blueMock` - Betsson logo with blue background, white close icon\n\nCustom configuration:\n```swift\nlet customData = CustomNavigationData(\n    logoImage: \"custom_logo\",\n    closeIcon: \"custom_close_icon\",\n    backgroundColor: .systemGreen,\n    closeButtonBackgroundColor: .white,\n    closeIconTintColor: .systemGreen\n)\nlet viewModel = MockCustomNavigationViewModel(data: customData)\n```\n",
      "snapshots": [
        {
          "category": "BasicStyles",
          "light": "CustomNavigationView/__Snapshots__/CustomNavigationViewSnapshotTests/testCustomNavigationView_BasicStyles_Light.1.png",
          "dark": "CustomNavigationView/__Snapshots__/CustomNavigationViewSnapshotTests/testCustomNavigationView_BasicStyles_Dark.1.png"
        }
      ]
    },
    "CustomSliderView": {
      "displayName": "CustomSliderView",
      "category": "Forms",
      "subcategory": "Sliders",
      "summary": "Customizable slider with configurable track, thumb, and step snapping",
      "description": "Flexible slider component with support for custom thumb images (SF Symbols or asset images), configurable track appearance (height, corner radius), and step-based value snapping. Supports both pan and tap gestures for value adjustment. Features onValueChanged and onEditingEnded callbacks, enable/disable state with alpha dimming, thumb shadow effects, and full accessibility support. Uses StyleProvider.Color.highlightSecondary (30% alpha) for track and highlightPrimary for default thumb tint. Common use cases include time filtering and volume controls.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "slider",
        "input",
        "range",
        "form",
        "gesture",
        "accessibility",
        "time-filter",
        "volume"
      ],
      "states": [
        "enabled",
        "disabled",
        "start-position",
        "mid-position",
        "end-position"
      ],
      "similarTo": [
        "TimeSliderView"
      ],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# CustomSliderView\n\nCustomSliderView is a highly customizable slider component that provides precise control over appearance and behavior. Unlike the native UISlider, it offers complete visual customization with custom track and thumb styling, discrete step positioning, and smooth animations.\n\n## Features\n\n- **Custom Visual Design**: Full control over track height, corner radius, and thumb size\n- **Custom Thumb Images**: Support for SF Symbols, custom images, or default circular thumb\n- **Thumb Tinting**: Customizable thumb colors with automatic tinting support\n- **Discrete Step Positioning**: Automatic snapping to predefined positions\n- **Smooth Animations**: Fluid transitions between positions\n- **Touch Interaction**: Supports both dragging and tapping for value changes\n- **Accessibility**: Full VoiceOver support with appropriate traits\n- **StyleProvider Integration**: Uses centralized styling system\n\n## Use Cases\n\n- Time-based filters with discrete options\n- Rating selectors with specific values\n- Volume controls with step increments\n- Any slider requiring custom visual design\n- Replacement for native UISlider when precise styling is needed\n\n## Usage Example\n\n```swift\n// Create slider configuration\nlet configuration = SliderConfiguration(\n    minimumValue: 0.0,\n    maximumValue: 1.0,\n    numberOfSteps: 5,\n    trackHeight: 4.0,\n    trackCornerRadius: 2.0,\n    thumbSize: 24.0,\n    thumbImageName: nil,        // Uses default circular thumb\n    thumbTintColor: nil         // Uses StyleProvider.Color.highlightPrimary\n)\n\n// Create view model\nlet viewModel = MockCustomSliderViewModel.customMock(\n    configuration: configuration,\n    initialValue: 0.0,\n    isEnabled: true\n)\n\n// Create the component\nlet customSlider = CustomSliderView(viewModel: viewModel)\ncustomSlider.translatesAutoresizingMaskIntoConstraints = false\n\n// Add to your view hierarchy\nparentView.addSubview(customSlider)\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    customSlider.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 16),\n    customSlider.trailingAnchor.constraint(equalTo: parentView.trailingAnchor, constant: -16),\n    customSlider.centerYAnchor.constraint(equalTo: parentView.centerYAnchor),\n    customSlider.heightAnchor.constraint(equalToConstant: 44)\n])\n\n// Handle value changes\ncustomSlider.onValueChanged = { value in\n    print(\"Slider value changing: \\(value)\")\n    // Update UI during dragging\n}\n\ncustomSlider.onEditingEnded = { value in\n    print(\"Final slider value: \\(value)\")\n    // Apply final value when user stops interacting\n}\n```\n\n## Integration with Time Filter\n\n```swift\n// Example: Using in TimeSliderFilterView\nprivate func setupCustomSlider(with state: TimeSliderFilterDisplayState) {\n    let sliderConfiguration = SliderConfiguration(\n        minimumValue: 0.0,\n        maximumValue: 1.0,\n        numberOfSteps: state.options.count, // Number of time options\n        trackHeight: 4.0,\n        trackCornerRadius: 2.0,\n        thumbSize: 24.0\n    )\n    \n    let sliderViewModel = MockCustomSliderViewModel.customMock(\n        configuration: sliderConfiguration,\n        initialValue: state.sliderPosition,\n        isEnabled: true\n    )\n    \n    customSlider = CustomSliderView(viewModel: sliderViewModel)\n    \n    // Handle interactions\n    customSlider.onEditingEnded = { [weak self] value in\n        self?.handleSliderValueChange(value)\n    }\n}\n```\n\n## Configuration Options\n\n### SliderConfiguration Properties\n\n| Property | Type | Description | Default |\n|----------|------|-------------|---------|\n| `minimumValue` | Float | Minimum slider value | 0.0 |\n| `maximumValue` | Float | Maximum slider value | 1.0 |\n| `numberOfSteps` | Int | Number of discrete positions | 5 |\n| `trackHeight` | CGFloat | Height of the slider track | 4.0 |\n| `trackCornerRadius` | CGFloat | Corner radius of the track | 2.0 |\n| `thumbSize` | CGFloat | Size of the thumb (width & height) | 24.0 |\n| `thumbImageName` | String? | Name of image/SF Symbol for thumb | nil |\n| `thumbTintColor` | UIColor? | Custom tint color for thumb | nil |\n\n### CustomSliderDisplayState Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `configuration` | SliderConfiguration | Slider appearance and behavior settings |\n| `currentValue` | Float | Current slider value (0.0 to 1.0) |\n| `isEnabled` | Bool | Whether the slider is interactive |\n\n### Interaction Methods\n\n| Method | Description |\n|--------|-------------|\n| `updateValue(_:)` | Programmatically set slider value |\n| `snapToNearestStep()` | Snap current value to nearest discrete step |\n| `setEnabled(_:)` | Enable or disable slider interaction |\n\n## Visual Design\n\nThe CustomSliderView provides exact visual control matching design specifications:\n\n### Track Styling\n- **Height**: Configurable (default 4px)\n- **Corner Radius**: Configurable (default 2px)\n- **Color**: Uses `StyleProvider.Color.highlightSecondary` with alpha\n- **Background**: Transparent\n\n### Thumb Styling\n- **Size**: Configurable (default 24x24px)\n- **Image**: Custom images, SF Symbols, or default circular shape\n- **Tinting**: Automatic color tinting with custom or StyleProvider colors\n- **Shadow**: Subtle drop shadow for depth\n- **Animation**: Smooth position transitions\n\n## Styling\n\nThe CustomSliderView uses StyleProvider for consistent theming:\n\n```swift\n// Customize colors\nStyleProvider.Color.customize(\n    primaryColor: UIColor(named: \"BrandOrange\"),    // Thumb color\n    secondaryColor: UIColor(named: \"TrackGray\")     // Track color\n)\n\n// The component automatically applies:\n// - primaryColor: Thumb background\n// - secondaryColor (with alpha): Track background\n```\n\n## Accessibility\n\nThe CustomSliderView includes comprehensive accessibility support:\n\n### VoiceOver Features\n- **Adjustable Trait**: Exposed as adjustable element\n- **Value Announcement**: Current value is announced\n- **Gesture Support**: Swipe up/down to adjust value\n- **Custom Hints**: Contextual interaction guidance\n\n### Accessibility Identifiers\n- `customSlider.slider` - Main slider element\n\n## Available Mock Data\n\n### Predefined Configurations\n\n```swift\nMockCustomSliderViewModel.defaultMock        // Basic 5-step slider at minimum\nMockCustomSliderViewModel.midPositionMock    // 5-step slider at middle position\nMockCustomSliderViewModel.timeFilterMock     // Configured for time filtering\nMockCustomSliderViewModel.disabledMock       // Disabled state example\nMockCustomSliderViewModel.customImageMock    // Blue circle SF Symbol thumb\nMockCustomSliderViewModel.volumeSliderMock   // Green speaker icon thumb\n```\n\n### Custom Configuration\n\n```swift\n// Basic custom configuration\nMockCustomSliderViewModel.customMock(\n    configuration: SliderConfiguration(\n        minimumValue: 0.0,\n        maximumValue: 100.0,\n        numberOfSteps: 11,\n        trackHeight: 6.0,\n        trackCornerRadius: 3.0,\n        thumbSize: 28.0,\n        thumbImageName: nil,\n        thumbTintColor: nil\n    ),\n    initialValue: 50.0,\n    isEnabled: true\n)\n\n// Custom thumb image with SF Symbol\nMockCustomSliderViewModel.customMock(\n    configuration: SliderConfiguration(\n        minimumValue: 0.0,\n        maximumValue: 1.0,\n        numberOfSteps: 5,\n        trackHeight: 4.0,\n        trackCornerRadius: 2.0,\n        thumbSize: 28.0,\n        thumbImageName: \"star.fill\",        // SF Symbol\n        thumbTintColor: UIColor.systemYellow\n    ),\n    initialValue: 0.5,\n    isEnabled: true\n)\n```\n\n## Implementation Notes\n\n### Gesture Handling\n- **Pan Gesture**: Continuous value updates during dragging\n- **Tap Gesture**: Direct positioning by tapping on track\n- **Touch Area**: Minimum 44pt touch target for accessibility\n- **Smooth Tracking**: Real-time position updates\n\n### Step Snapping\n- **Automatic**: Snaps to nearest step on interaction end\n- **Configurable**: Number of steps defined in configuration\n- **Precise**: Calculated positioning for exact step alignment\n\n### Performance Considerations\n- **Efficient Rendering**: Minimal view hierarchy with UIView elements\n- **Smooth Animations**: Uses Core Animation for position changes\n- **Memory Management**: Proper cleanup of constraints and observers\n- **Layout Updates**: Responsive to bounds changes\n\n## Advanced Usage\n\n### Custom Configurations\n\n```swift\n// Volume slider with 11 steps (0-10)\nlet volumeConfig = SliderConfiguration(\n    minimumValue: 0.0,\n    maximumValue: 10.0,\n    numberOfSteps: 11,\n    trackHeight: 6.0,\n    trackCornerRadius: 3.0,\n    thumbSize: 28.0\n)\n\n// Rating slider with 5 stars\nlet ratingConfig = SliderConfiguration(\n    minimumValue: 1.0,\n    maximumValue: 5.0,\n    numberOfSteps: 5,\n    trackHeight: 8.0,\n    trackCornerRadius: 4.0,\n    thumbSize: 32.0\n)\n\n// Progress indicator (read-only)\nlet progressConfig = SliderConfiguration(\n    minimumValue: 0.0,\n    maximumValue: 1.0,\n    numberOfSteps: 100,\n    trackHeight: 2.0,\n    trackCornerRadius: 1.0,\n    thumbSize: 0.0 // No thumb for progress bars\n)\n```\n\n### Integration Patterns\n\n```swift\n// Coordinated sliders\nclass MultiSliderView: UIView {\n    private let volumeSlider: CustomSliderView\n    private let bassSlider: CustomSliderView\n    private let trebleSlider: CustomSliderView\n    \n    private func setupSliders() {\n        // Configure each slider with different parameters\n        // Coordinate their interactions\n        \n        volumeSlider.onEditingEnded = { [weak self] value in\n            self?.updateAudioSettings()\n        }\n    }\n}\n\n// Dynamic reconfiguration\nfunc updateSliderForContext(_ context: FilterContext) {\n    let newConfig = SliderConfiguration(\n        numberOfSteps: context.availableOptions.count,\n        trackHeight: context.isCompact ? 2.0 : 4.0,\n        thumbSize: context.isCompact ? 16.0 : 24.0\n    )\n    \n    // Update slider with new configuration\n    sliderViewModel.updateConfiguration(newConfig)\n}\n```\n\n## Best Practices\n\n1. **Consistent Sizing**: Use standard thumb sizes (20-28pt) for touch targets\n2. **Appropriate Steps**: Choose step counts that make sense for your data\n3. **Visual Feedback**: Provide immediate visual response to user interaction\n4. **Accessibility**: Always test with VoiceOver enabled\n5. **Performance**: Avoid excessive step counts for smooth interaction\n\nThe CustomSliderView provides the foundation for creating pixel-perfect slider interfaces that match design specifications while maintaining excellent usability and accessibility. \n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "CustomSliderView/__Snapshots__/CustomSliderViewSnapshotTests/testCustomSliderView_BasicStates_Light.1.png",
          "dark": "CustomSliderView/__Snapshots__/CustomSliderViewSnapshotTests/testCustomSliderView_BasicStates_Dark.1.png"
        },
        {
          "category": "ConfigurationVariants",
          "light": "CustomSliderView/__Snapshots__/CustomSliderViewSnapshotTests/testCustomSliderView_ConfigurationVariants_Light.1.png",
          "dark": "CustomSliderView/__Snapshots__/CustomSliderViewSnapshotTests/testCustomSliderView_ConfigurationVariants_Dark.1.png"
        },
        {
          "category": "PositionVariants",
          "light": "CustomSliderView/__Snapshots__/CustomSliderViewSnapshotTests/testCustomSliderView_PositionVariants_Light.1.png",
          "dark": "CustomSliderView/__Snapshots__/CustomSliderViewSnapshotTests/testCustomSliderView_PositionVariants_Dark.1.png"
        }
      ]
    },
    "DepositBonusInfoView": {
      "displayName": "DepositBonusInfoView",
      "category": "Wallet",
      "subcategory": "Deposits",
      "summary": "Gradient banner displaying deposit bonus info with icon and currency amount",
      "description": "Horizontal banner with diagonal gradient background (liveBorder1 to liveBorder2) showing deposit bonus details. Features a left icon (asset or SF Symbol, white tinted, 24pt), descriptive balance text in the center, and right-aligned bold currency amount. Uses GradientView for background with 8pt corner radius and 16pt internal padding. The component supports dynamic amount updates via protocol method. Commonly used in deposit flows to display the user's deposit plus bonus calculation.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "bonus",
        "deposit",
        "wallet",
        "banner",
        "gradient",
        "currency",
        "promotion"
      ],
      "states": [
        "default",
        "with-amount",
        "placeholder"
      ],
      "similarTo": [
        "BonusInfoCardView"
      ],
      "oftenUsedWith": [
        "PromotionalHeaderView",
        "AmountPillsView",
        "BorderedTextFieldView",
        "ButtonView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# DepositBonusInfoView\n\nA gradient banner displaying deposit bonus information with icon and currency amount.\n\n## Overview\n\nDepositBonusInfoView displays a horizontal banner with a diagonal gradient background showing deposit bonus details. It includes an icon on the left, descriptive text in the center, and a currency amount on the right. The component is commonly used on deposit screens to show the user's potential bonus amount.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone banner component)\n\n### Uses (Children)\n- `GradientView` - diagonal gradient background\n\n## Features\n\n- Diagonal gradient background (live border colors)\n- Left icon (asset or SF Symbol, white tinted)\n- Balance description text\n- Right-aligned currency amount\n- 8pt corner radius\n- 16pt internal padding\n- Fixed 60pt height in previews\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockDepositBonusInfoViewModel.defaultMock\nlet bonusInfoView = DepositBonusInfoView(viewModel: viewModel)\n\n// Update amount dynamically\nviewModel.updateAmount(\"XAF 10,000\")\n```\n\n## Data Model\n\n```swift\nstruct DepositBonusInfoData: Equatable, Hashable {\n    let id: String\n    let icon: String\n    let balanceText: String\n    let currencyAmount: String\n}\n\nprotocol DepositBonusBalanceViewModelProtocol {\n    var depositBonusInfoPublisher: AnyPublisher<DepositBonusInfoData, Never> { get }\n\n    func updateAmount(_ newAmount: String)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.liveBorder1` - gradient start color\n- `StyleProvider.Color.liveBorder2` - gradient end color\n- `StyleProvider.Color.buttonTextPrimary` - balance text color\n- `StyleProvider.Color.allWhite` - icon tint color\n- `StyleProvider.fontWith(type: .medium, size: 12)` - balance text font\n- `StyleProvider.fontWith(type: .bold, size: 12)` - currency amount font\n\nLayout constants:\n- Container corner radius: 8pt\n- Icon size: 24pt\n- Stack spacing: 12pt\n- Padding: 16pt all sides\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - \"Your deposit + Bonus\" with \"XAF --\" amount, gift icon\n- `.usdMock` - \"Your deposit + Bonus\" with \"USD $150.00\" amount, SF Symbol gift icon\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "DepositBonusInfoView/__Snapshots__/DepositBonusInfoViewSnapshotTests/testDepositBonusInfoView_BasicStates_Light.1.png",
          "dark": "DepositBonusInfoView/__Snapshots__/DepositBonusInfoViewSnapshotTests/testDepositBonusInfoView_BasicStates_Dark.1.png"
        },
        {
          "category": "ContentVariants",
          "light": "DepositBonusInfoView/__Snapshots__/DepositBonusInfoViewSnapshotTests/testDepositBonusInfoView_ContentVariants_Light.1.png",
          "dark": "DepositBonusInfoView/__Snapshots__/DepositBonusInfoViewSnapshotTests/testDepositBonusInfoView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "DescriptionBlockView": {
      "displayName": "DescriptionBlockView",
      "category": "Promotions",
      "subcategory": "ContentBlocks",
      "summary": "Simple text block for displaying promotional descriptions",
      "description": "Multi-line text label for promotional or informational content with consistent styling. Features left-aligned text, highlightSecondaryContrast color, regular font at 14pt, 15pt horizontal padding, 5pt vertical padding, and clear background. Static content component without reactive updates. Commonly used within StackViewBlockView for promotional layouts and in promotion detail screens.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "text",
        "description",
        "promotion",
        "content-block",
        "label",
        "static"
      ],
      "states": [
        "default"
      ],
      "similarTo": [
        "TitleBlockView",
        "BulletItemBlockView"
      ],
      "oftenUsedWith": [
        "StackViewBlockView",
        "TitleBlockView",
        "BulletItemBlockView"
      ],
      "parents": [
        "StackViewBlockView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# DescriptionBlockView\n\nA simple text block for displaying promotional or informational descriptions.\n\n## Overview\n\nDescriptionBlockView displays a multi-line text label with consistent styling for promotional content or informational text blocks. It's designed to be used within stack views or promotional layouts where descriptive text is needed.\n\n## Component Relationships\n\n### Used By (Parents)\n- `StackViewBlockView` - content block in promotional stacks\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Multi-line text support\n- Left-aligned text\n- Secondary highlight contrast color\n- 15pt horizontal padding\n- 5pt vertical padding\n- Clear background\n- Static content (no reactive updates)\n\n## Usage\n\n```swift\nlet viewModel = MockDescriptionBlockViewModel.defaultMock\nlet descriptionView = DescriptionBlockView(viewModel: viewModel)\n```\n\n## Data Model\n\n```swift\nprotocol DescriptionBlockViewModelProtocol {\n    var description: String { get }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.highlightSecondaryContrast` - text color\n- `StyleProvider.fontWith(type: .regular, size: 14)` - text font\n\nLayout constants:\n- Horizontal padding: 15pt\n- Vertical padding: 5pt\n- Number of lines: unlimited (0)\n- Text alignment: left\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - welcome promotion text\n- `.shortMock` - \"Limited time offer available now.\"\n- `.longMock` - extended promotional description with multiple sentences\n",
      "snapshots": [
        {
          "category": "ContentVariants",
          "light": "DescriptionBlockView/__Snapshots__/DescriptionBlockViewSnapshotTests/testDescriptionBlockView_ContentVariants_Light.1.png",
          "dark": "DescriptionBlockView/__Snapshots__/DescriptionBlockViewSnapshotTests/testDescriptionBlockView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "EmptyStateActionView": {
      "displayName": "EmptyStateActionView",
      "category": "Status",
      "subcategory": "Empty",
      "summary": "Empty state display with image, title, and optional action button",
      "description": "Centered empty state layout featuring an image (200x80pt, system or asset), multi-line descriptive title, and configurable action button. The component supports logged-in vs logged-out states, automatically hiding the action button when logged in. Features enable/disable state with 50% alpha dimming. Uses backgroundSecondary container, textPrimary for title, highlightPrimary for image tint, and highlightSecondary for button background. Commonly used for empty betslips to prompt login or indicate minimum selection requirements.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "empty-state",
        "betslip",
        "login",
        "action-button",
        "placeholder",
        "status"
      ],
      "states": [
        "logged-out",
        "logged-in",
        "disabled"
      ],
      "similarTo": [
        "EmptyStateView"
      ],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# EmptyStateActionView\n\nAn empty state display with image, title, and optional action button.\n\n## Overview\n\nEmptyStateActionView displays a centered empty state layout with an optional image, descriptive title text, and a configurable action button. The component supports logged-in vs logged-out states, automatically showing or hiding the action button based on the current state. It's commonly used for empty betslips, search results, or list states.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone empty state component)\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Centered image (200x80pt, system or asset image)\n- Multi-line title text\n- Action button (visible only in logged-out state)\n- Logged-in/logged-out state handling\n- Enable/disable state with alpha dimming\n- Secondary background color\n- 16pt padding\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockEmptyStateActionViewModel.loggedOutMock()\nlet emptyStateView = EmptyStateActionView(viewModel: viewModel)\n\nviewModel.onActionButtonTapped = {\n    print(\"Navigate to login\")\n}\n```\n\n## Data Model\n\n```swift\nenum EmptyStateActionState: Equatable {\n    case loggedOut\n    case loggedIn\n}\n\nstruct EmptyStateActionData: Equatable {\n    let state: EmptyStateActionState\n    let title: String\n    let actionButtonTitle: String\n    let image: String?\n    let isEnabled: Bool\n}\n\nprotocol EmptyStateActionViewModelProtocol {\n    var dataPublisher: AnyPublisher<EmptyStateActionData, Never> { get }\n    var currentData: EmptyStateActionData { get }\n\n    func updateState(_ state: EmptyStateActionState)\n    func updateTitle(_ title: String)\n    func updateActionButtonTitle(_ title: String)\n    func updateImage(_ image: String?)\n    func setEnabled(_ isEnabled: Bool)\n\n    var onActionButtonTapped: (() -> Void)? { get set }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundSecondary` - container background\n- `StyleProvider.Color.textPrimary` - title text color\n- `StyleProvider.Color.highlightPrimary` - image tint\n- `StyleProvider.Color.highlightSecondary` - button background\n- `StyleProvider.Color.buttonTextPrimary` - button text color\n- `StyleProvider.fontWith(type: .regular, size: 14)` - title font\n- `StyleProvider.fontWith(type: .bold, size: 14)` - button font\n\nLayout constants:\n- Image size: 200x80pt\n- Button height: 48pt\n- Button corner radius: 4pt\n- Stack spacing: 16pt\n- Content padding: 16pt\n\n## Mock ViewModels\n\nAvailable presets:\n- `.loggedOutMock()` - logged out with \"Log in to bet\" button, ticket image\n- `.loggedInMock()` - logged in (button hidden), ticket image\n- `.disabledMock()` - disabled state with 50% alpha\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "EmptyStateActionView/__Snapshots__/EmptyStateActionViewSnapshotTests/testEmptyStateActionView_BasicStates_Light.1.png",
          "dark": "EmptyStateActionView/__Snapshots__/EmptyStateActionViewSnapshotTests/testEmptyStateActionView_BasicStates_Dark.1.png"
        }
      ]
    },
    "ExpandableSectionView": {
      "displayName": "ExpandableSectionView",
      "category": "UIElements",
      "subcategory": "Containers",
      "summary": "Expandable section with title header and plus/minus toggle button",
      "description": "Collapsible section container featuring a 56pt header with semibold title label and circular toggle button (plus when collapsed, minus when expanded). The content area is exposed as a contentContainer UIStackView for injecting custom views. Both header tap and button tap trigger expand/collapse. Uses backgroundTertiary container with 8pt corner radius, highlightPrimary toggle button tint, and textPrimary title color. Constraint-based expand/collapse with 12pt content stack spacing. Commonly used for information sections and terms display in responsible gaming screens.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "expandable",
        "collapsible",
        "accordion",
        "section",
        "container",
        "toggle"
      ],
      "states": [
        "collapsed",
        "expanded"
      ],
      "similarTo": [
        "CustomExpandableSectionView"
      ],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# ExpandableSectionView\n\nAn expandable section with header title and plus/minus toggle button.\n\n## Overview\n\nExpandableSectionView provides a collapsible section with a title header and a circular toggle button showing plus (collapsed) or minus (expanded) icons. The content area is exposed as a UIStackView for adding custom views. The component supports both header tap and button tap for toggling the expanded state.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone expandable container)\n\n### Uses (Children)\n- None (provides contentContainer for external content injection)\n\n## Features\n\n- Tappable header for expand/collapse\n- Title label (semibold 16pt)\n- Plus/minus toggle button with primary highlight tint\n- Custom expand/collapse icons support (asset or SF Symbol)\n- Content container (UIStackView) for custom content\n- 56pt header height\n- 8pt corner radius on container\n- Tertiary background color\n- Constraint-based expand/collapse (animation commented out)\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockExpandableSectionViewModel.defaultMock\nlet sectionView = ExpandableSectionView(viewModel: viewModel)\n\n// Add content to the expandable section\nlet contentLabel = UILabel()\ncontentLabel.text = \"This content appears when expanded\"\ncontentLabel.numberOfLines = 0\nsectionView.contentContainer.addArrangedSubview(contentLabel)\n```\n\n## Data Model\n\n```swift\nprotocol ExpandableSectionViewModelProtocol {\n    var title: String { get }\n    var isExpandedPublisher: AnyPublisher<Bool, Never> { get }\n\n    func toggleExpanded()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundTertiary` - container background\n- `StyleProvider.Color.backgroundPrimary` - preview background\n- `StyleProvider.Color.textPrimary` - title text color\n- `StyleProvider.Color.textSecondary` - content text color in previews\n- `StyleProvider.Color.highlightPrimary` - toggle button tint\n- `StyleProvider.fontWith(type: .semibold, size: 16)` - title font\n- `StyleProvider.fontWith(type: .regular, size: 14)` - content font in previews\n- `StyleProvider.fontWith(type: .regular, size: 13)` - smaller content font\n\nLayout constants:\n- Container corner radius: 8pt\n- Header height: 56pt\n- Title padding: 16pt leading\n- Toggle button background size: 32pt\n- Toggle button touch target: 44pt\n- Content padding: 16pt horizontal, 12pt top, 16pt bottom\n- Content stack spacing: 12pt\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - \"Information\" title, collapsed\n- `.expandedMock` - \"Details\" title, expanded\n- `.customMock(title:isExpanded:)` - custom configuration\n\nIcons:\n- Collapsed: plus icon (custom \"expand_icon\" or SF Symbol \"plus\")\n- Expanded: minus icon (custom \"collapse_icon\" or SF Symbol \"minus\")\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "ExpandableSectionView/__Snapshots__/ExpandableSectionViewSnapshotTests/testExpandableSectionView_BasicStates_Light.1.png",
          "dark": "ExpandableSectionView/__Snapshots__/ExpandableSectionViewSnapshotTests/testExpandableSectionView_BasicStates_Dark.1.png"
        },
        {
          "category": "ContentVariants",
          "light": "ExpandableSectionView/__Snapshots__/ExpandableSectionViewSnapshotTests/testExpandableSectionView_ContentVariants_Light.1.png",
          "dark": "ExpandableSectionView/__Snapshots__/ExpandableSectionViewSnapshotTests/testExpandableSectionView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "ExtendedListFooterView": {
      "displayName": "ExtendedListFooterView",
      "category": "UIElements",
      "subcategory": "Footers",
      "summary": "Comprehensive footer with sponsors, links, payments, social, and legal info",
      "description": "Full-featured app footer containing seven sections: partnership sponsor logos (2-column grid, tappable), navigation links (Terms, Privacy, Affiliates, etc.), payment provider icons (MTN, Orange), social media links (4-column grid), responsible gambling warnings with EGBA/eCOGRA certification badges, copyright text, and license information. Supports CMS-driven dynamic content with callbacks for sponsors, social links, and navigation updates. Uses allDark background with allWhite text, 48pt vertical padding, 16pt horizontal padding, and 32pt section spacing. Employs Kingfisher for remote image loading. Commonly used at the bottom of scrollable list screens.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "footer",
        "sponsors",
        "legal",
        "social-media",
        "payments",
        "navigation",
        "cms",
        "responsible-gambling"
      ],
      "states": [
        "full-content",
        "minimal",
        "no-links",
        "dynamic-grid"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "GradientView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# ExtendedListFooterView\n\nA comprehensive footer component with sponsors, navigation links, payment providers, social media, and legal information.\n\n## Overview\n\nExtendedListFooterView displays a full-featured footer suitable for app list endings. It includes partnership sponsor logos, navigation links (Terms, Privacy, etc.), payment provider icons, social media links, responsible gambling warnings, copyright text, and license information. The component supports both CMS-driven content and fallback static content.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone footer component)\n\n### Uses (Children)\n- `GradientView` - internal use for backgrounds\n- Kingfisher - for remote image loading\n\n## Features\n\n- Partnership sponsor logos section (2-column grid, tappable)\n- Navigation links section (Terms, Affiliates, Privacy, Cookie, etc.)\n- Payment provider icons (MTN, Orange, etc.)\n- Social media links section (4-column grid, CMS or static)\n- Responsible gambling warning and advice text\n- EGBA and eCOGRA certification badges\n- Copyright text\n- License header and body text\n- Dark background (allDark)\n- 48pt vertical padding, 16pt horizontal padding\n- 32pt section spacing\n- Dynamic content updates via callbacks\n- Image loading with Kingfisher\n- Tap gesture handling for sponsors and social links\n\n## Usage\n\n```swift\nlet viewModel = MockExtendedListFooterViewModel.cameroonFooter\nlet footerView = ExtendedListFooterView(viewModel: viewModel)\n\nviewModel.onLinkTap = { linkType in\n    switch linkType {\n    case .termsAndConditions:\n        print(\"Navigate to Terms\")\n    case .socialMedia(let platform):\n        print(\"Open \\(platform.displayName)\")\n    default:\n        break\n    }\n}\n```\n\n## Data Model\n\n```swift\nprotocol ExtendedListFooterViewModelProtocol {\n    var paymentOperators: [PaymentOperator] { get }\n    var socialMediaPlatforms: [SocialPlatform] { get }\n    var socialLinks: [FooterSocialLink] { get }\n    var partnerClubs: [PartnerClub] { get }\n    var sponsors: [FooterSponsor] { get }\n    var navigationLinks: [FooterLink] { get }\n    var responsibleGamblingText: ResponsibleGamblingText { get }\n    var copyrightText: String { get }\n    var licenseHeaderText: String { get }\n    var licenseBodyText: String { get }\n    var partnershipHeaderText: String { get }\n    var socialMediaHeaderText: String { get }\n    var imageResolver: ExtendedListFooterImageResolver { get }\n\n    var onLinkTap: ((FooterLinkType) -> Void)? { get set }\n    var onSponsorsUpdated: (([FooterSponsor]) -> Void)? { get set }\n    var onSocialLinksUpdated: (([FooterSocialLink]) -> Void)? { get set }\n    var onNavigationLinksUpdated: (([FooterLink]) -> Void)? { get set }\n\n    func handleSponsorTap(_ sponsor: FooterSponsor)\n    func handleSocialLinkTap(_ link: FooterSocialLink)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.allDark` - background color\n- `StyleProvider.Color.allWhite` - text and icon colors\n- `StyleProvider.fontWith(type: .regular, size: 14)` - section headers\n- `StyleProvider.fontWith(type: .regular, size: 16)` - body text, navigation links\n- `StyleProvider.fontWith(type: .semibold, size: 16)` - license header\n\nLayout constants:\n- Container padding: 48pt vertical, 16pt horizontal\n- Section spacing: 32pt\n- Sub-section spacing: 16pt\n- Partner logo size: 168x80pt\n- Payment logo size: 64pt\n- Social icon size: 64pt\n- EGBA badge: 128x80pt\n- eCOGRA badge: 168x80pt\n- License max width: 672pt\n\n## Mock ViewModels\n\nAvailable presets:\n- `.cameroonFooter` - full Cameroon footer with all content\n- `.minimalFooter` - reduced content (fewer sponsors, fewer links)\n- `.noLinksFooter` - footer without navigation links\n- `.threePartnersFooter` - 3 sponsors (tests odd grid count)\n- `.singlePartnerFooter` - 1 sponsor (tests single layout)\n- `.fivePartnersFooter` - 5 sponsors (tests 3 rows: 2+2+1)\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "ExtendedListFooterView/__Snapshots__/ExtendedListFooterViewSnapshotTests/testExtendedListFooterView_BasicStates_Light.1.png",
          "dark": "ExtendedListFooterView/__Snapshots__/ExtendedListFooterViewSnapshotTests/testExtendedListFooterView_BasicStates_Dark.1.png"
        },
        {
          "category": "PartnerVariants",
          "light": "ExtendedListFooterView/__Snapshots__/ExtendedListFooterViewSnapshotTests/testExtendedListFooterView_PartnerVariants_Light.1.png",
          "dark": "ExtendedListFooterView/__Snapshots__/ExtendedListFooterViewSnapshotTests/testExtendedListFooterView_PartnerVariants_Dark.1.png"
        }
      ]
    },
    "FilterOptionCell": {
      "displayName": "FilterOptionCell",
      "category": "Filters",
      "subcategory": "Cells",
      "summary": "Collection view cell displaying filter option with icon and title",
      "description": "UICollectionViewCell for filter options in horizontal collection views. Features pill-shaped white container (21pt corner radius) with horizontal stack layout: 22pt icon with highlightPrimary tint, 8pt spacing, and bold 12pt title in textPrimary color. Supports FilterOptionType values: sport, sortBy, and league. Uses 10pt vertical padding and 8pt horizontal padding. Commonly used within GeneralFilterBarView for displaying available filter selections.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "filter",
        "cell",
        "collection-view",
        "option",
        "pill",
        "icon",
        "horizontal"
      ],
      "states": [
        "default"
      ],
      "similarTo": [
        "SportSelectorCell",
        "MainFilterPillView"
      ],
      "oftenUsedWith": [
        "GeneralFilterBarView"
      ],
      "parents": [
        "GeneralFilterBarView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# FilterOptionCell\n\nA versatile collection view cell built with UIKit that displays filter options with a clean, pill-shaped design. The component serves as a general-purpose filter display cell for various filter types including sports, sorting options, and leagues, featuring an icon and title in a horizontal layout.\n\n## Overview\n\nThe `FilterOptionCell` is a custom `UICollectionViewCell` designed for displaying filter options in horizontal collection views. Unlike the specialized `SportSelectorCell`, this component provides a clean, borderless design suitable for general filter options. It follows a simple view-model pattern and integrates seamlessly with the shared `FilterOptionItem` model.\n\n## Architecture\n\n### Component Structure\n```\nFilterOptionCell/\n FilterOptionCell.swift           # Main collection view cell\n FilterOptionCellViewModel.swift  # View model for data binding\n Models/\n     FilterOptionModels.swift     # Shared data models\n```\n\n### Design Pattern\n- **View**: `FilterOptionCell` - Custom collection view cell with clean styling\n- **ViewModel**: `FilterOptionCellViewModel` - Simple data container for filter options\n- **Model**: `FilterOptionItem` & `FilterOptionType` - Shared data structures\n\n## Key Features\n\n### Visual Design\n- **Clean Pill Shape**: Rounded corners (21pt radius) with white background\n- **No Border**: Minimalist design without borders for subtle appearance\n- **Icon Integration**: System icon display with orange tint color\n- **Compact Layout**: Optimized for horizontal collection view usage\n- **Consistent Typography**: Bold 12pt font for filter titles\n\n### Interactive Elements\n- **Filter Icon**: Displays context-appropriate system icon\n- **Title Label**: Bold filter option name display\n- **Touch Feedback**: Standard collection view cell selection behavior\n- **Flexible Content**: Adapts to different filter types and content\n\n### Layout Structure\n- **Horizontal Stack**: Icon and title arranged horizontally\n- **Center Alignment**: All elements vertically centered\n- **Consistent Spacing**: 8pt spacing between icon and title\n- **Adaptive Width**: Dynamically sizes based on content\n\n## Models\n\n### FilterOptionItem\n```swift\npublic struct FilterOptionItem {\n    public let type: FilterOptionType\n    public let title: String\n    public let icon: String\n}\n```\n\n**Properties:**\n- `type`: Filter category (`.sport`, `.sortBy`, `.league`)\n- `title`: Display text for the filter option\n- `icon`: System icon name for visual representation\n\n### FilterOptionType\n```swift\npublic enum FilterOptionType {\n    case sport\n    case sortBy\n    case league\n}\n```\n\n**Filter Types:**\n- `sport`: Sports-related filter options\n- `sortBy`: Sorting and ordering options\n- `league`: League and competition filters\n\n## View Model\n\n### FilterOptionCellViewModel\n```swift\npublic class FilterOptionCellViewModel {\n    let filterOptionItem: FilterOptionItem\n    \n    public init(filterOptionItem: FilterOptionItem) {\n        self.filterOptionItem = filterOptionItem\n    }\n}\n```\n\n**Purpose:**\n- Simple data container for filter option information\n- Provides clean separation between data and view\n- Enables easy testing and mocking\n- Maintains consistency with other filter components\n\n## Usage Examples\n\n### Basic Collection View Implementation\n```swift\nclass FilterViewController: UIViewController {\n    @IBOutlet weak var collectionView: UICollectionView!\n    \n    private var filterOptions: [FilterOptionItem] = []\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupCollectionView()\n        setupFilterData()\n    }\n    \n    private func setupCollectionView() {\n        collectionView.register(\n            FilterOptionCell.self,\n            forCellWithReuseIdentifier: \"FilterOptionCell\"\n        )\n        \n        // Configure horizontal layout\n        if let layout = collectionView.collectionViewLayout as? UICollectionViewFlowLayout {\n            layout.scrollDirection = .horizontal\n            layout.minimumInteritemSpacing = 8\n            layout.sectionInset = UIEdgeInsets(top: 0, left: 16, bottom: 0, right: 16)\n        }\n    }\n    \n    private func setupFilterData() {\n        filterOptions = [\n            FilterOptionItem(type: .sortBy, title: \"Popular\", icon: \"flame.fill\"),\n            FilterOptionItem(type: .sortBy, title: \"Recent\", icon: \"clock.fill\"),\n            FilterOptionItem(type: .league, title: \"Premier League\", icon: \"trophy.fill\"),\n            FilterOptionItem(type: .sport, title: \"Basketball\", icon: \"basketball\")\n        ]\n    }\n}\n\nextension FilterViewController: UICollectionViewDataSource {\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n        return filterOptions.count\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n        let cell = collectionView.dequeueReusableCell(\n            withReuseIdentifier: \"FilterOptionCell\",\n            for: indexPath\n        ) as! FilterOptionCell\n        \n        let filterOption = filterOptions[indexPath.item]\n        let viewModel = FilterOptionCellViewModel(filterOptionItem: filterOption)\n        cell.configure(with: viewModel)\n        \n        return cell\n    }\n}\n```\n\n### Integration with GeneralFilterViewController\n```swift\nclass GeneralFilterViewController: UIViewController {\n    private var selectedFilters: [FilterOptionItem] = []\n    \n    func updateFilterDisplay() {\n        let filterCells = createFilterCells(from: selectedFilters)\n        updateCollectionView(with: filterCells)\n    }\n    \n    private func createFilterCells(from filters: [FilterOptionItem]) -> [FilterOptionCell] {\n        return filters.compactMap { filterOption in\n            let cell = FilterOptionCell()\n            let viewModel = FilterOptionCellViewModel(filterOptionItem: filterOption)\n            cell.configure(with: viewModel)\n            return cell\n        }\n    }\n    \n    func addFilter(_ filterOption: FilterOptionItem) {\n        selectedFilters.append(filterOption)\n        updateFilterDisplay()\n    }\n    \n    func removeFilter(at index: Int) {\n        guard index < selectedFilters.count else { return }\n        selectedFilters.remove(at: index)\n        updateFilterDisplay()\n    }\n}\n```\n\n### Filter Category Examples\n```swift\nclass FilterDataManager {\n    static func createSortOptions() -> [FilterOptionItem] {\n        return [\n            FilterOptionItem(type: .sortBy, title: \"Popular\", icon: \"flame.fill\"),\n            FilterOptionItem(type: .sortBy, title: \"Upcoming\", icon: \"clock.fill\"),\n            FilterOptionItem(type: .sortBy, title: \"Favorites\", icon: \"heart.fill\"),\n            FilterOptionItem(type: .sortBy, title: \"Alphabetical\", icon: \"textformat.abc\")\n        ]\n    }\n    \n    static func createLeagueOptions() -> [FilterOptionItem] {\n        return [\n            FilterOptionItem(type: .league, title: \"Premier League\", icon: \"trophy.fill\"),\n            FilterOptionItem(type: .league, title: \"Champions League\", icon: \"star.fill\"),\n            FilterOptionItem(type: .league, title: \"La Liga\", icon: \"soccerball\"),\n            FilterOptionItem(type: .league, title: \"Serie A\", icon: \"football\")\n        ]\n    }\n    \n    static func createSportOptions() -> [FilterOptionItem] {\n        return [\n            FilterOptionItem(type: .sport, title: \"Football\", icon: \"soccerball\"),\n            FilterOptionItem(type: .sport, title: \"Basketball\", icon: \"basketball\"),\n            FilterOptionItem(type: .sport, title: \"Tennis\", icon: \"tennis.racket\"),\n            FilterOptionItem(type: .sport, title: \"Baseball\", icon: \"baseball\")\n        ]\n    }\n}\n```\n\n### Dynamic Filter Management\n```swift\nclass DynamicFilterManager {\n    private var activeFilters: [FilterOptionItem] = []\n    private weak var collectionView: UICollectionView?\n    \n    init(collectionView: UICollectionView) {\n        self.collectionView = collectionView\n    }\n    \n    func addFilter(_ filter: FilterOptionItem) {\n        // Prevent duplicates\n        guard !activeFilters.contains(where: { $0.title == filter.title }) else { return }\n        \n        activeFilters.append(filter)\n        refreshCollectionView()\n    }\n    \n    func removeFilter(withTitle title: String) {\n        activeFilters.removeAll { $0.title == title }\n        refreshCollectionView()\n    }\n    \n    func clearAllFilters() {\n        activeFilters.removeAll()\n        refreshCollectionView()\n    }\n    \n    func getFiltersByType(_ type: FilterOptionType) -> [FilterOptionItem] {\n        return activeFilters.filter { $0.type == type }\n    }\n    \n    private func refreshCollectionView() {\n        DispatchQueue.main.async { [weak self] in\n            self?.collectionView?.reloadData()\n        }\n    }\n}\n```\n\n### Custom Filter Creation\n```swift\nextension FilterOptionItem {\n    static func createCustomSort(title: String, systemIcon: String) -> FilterOptionItem {\n        return FilterOptionItem(type: .sortBy, title: title, icon: systemIcon)\n    }\n    \n    static func createCustomLeague(title: String, systemIcon: String) -> FilterOptionItem {\n        return FilterOptionItem(type: .league, title: title, icon: systemIcon)\n    }\n    \n    static func createCustomSport(title: String, systemIcon: String) -> FilterOptionItem {\n        return FilterOptionItem(type: .sport, title: title, icon: systemIcon)\n    }\n}\n\n// Usage examples\nlet customFilters = [\n    FilterOptionItem.createCustomSort(title: \"Trending\", systemIcon: \"arrow.up.right\"),\n    FilterOptionItem.createCustomLeague(title: \"World Cup\", systemIcon: \"globe\"),\n    FilterOptionItem.createCustomSport(title: \"Swimming\", systemIcon: \"figure.pool.swim\")\n]\n```\n\n## Component Behavior\n\n### Visual Characteristics\n- **Background**: Clean white background without borders\n- **Corner Radius**: 21pt rounded corners for pill shape\n- **Icon Styling**: Orange tint color using `highlightPrimary`\n- **Typography**: Bold 12pt font for clear readability\n- **Minimal Design**: Clean appearance without visual clutter\n\n### Layout Behavior\n- **Container Padding**: 10pt top/bottom, 8pt left/right padding\n- **Icon Sizing**: Fixed 22x22pt system icons\n- **Stack Spacing**: 8pt between icon and title\n- **Adaptive Width**: Automatically adjusts to content length\n- **Center Alignment**: Vertical centering of all elements\n\n### Content Configuration\n- **System Icons**: Uses SF Symbols with template rendering\n- **Title Display**: Bold text with primary text color\n- **Dynamic Updates**: Supports runtime content changes\n- **Type Flexibility**: Handles multiple filter types seamlessly\n\n## Styling Integration\n\nThe component integrates with `StyleProvider` for consistent theming:\n\n- **Colors**:\n  - `highlightPrimary`: Orange tint for icons\n  - `textPrimary`: Title text color\n  - White background (hardcoded for clean appearance)\n- **Typography**:\n  - Bold 12pt font for filter titles\n- **Layout**:\n  - 21pt corner radius for pill shape\n  - Consistent padding and spacing\n\n## Collection View Integration\n\n### Cell Registration\n```swift\ncollectionView.register(\n    FilterOptionCell.self,\n    forCellWithReuseIdentifier: \"FilterOptionCell\"\n)\n```\n\n### Dynamic Sizing\n```swift\nfunc collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {\n    let filterOption = filterOptions[indexPath.item]\n    let title = filterOption.title\n    \n    // Calculate text width\n    let titleWidth = title.size(withAttributes: [\n        .font: StyleProvider.fontWith(type: .bold, size: 12)\n    ]).width\n    \n    // Icon (22) + spacing (8) + title + padding (16)\n    let cellWidth = 22 + 8 + titleWidth + 16\n    \n    return CGSize(width: cellWidth, height: 42)\n}\n```\n\n### Section Handling\n```swift\nextension FilterViewController: UICollectionViewDataSource {\n    func numberOfSections(in collectionView: UICollectionView) -> Int {\n        return FilterOptionType.allCases.count\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n        let filterType = FilterOptionType.allCases[section]\n        return filterOptions.filter { $0.type == filterType }.count\n    }\n}\n```\n\n## Accessibility Features\n\n- **Content Labels**: Clear filter option names for screen readers\n- **Icon Semantics**: System icons provide meaningful context\n- **Touch Targets**: Adequate cell size for easy interaction\n- **Visual Hierarchy**: Bold typography for clear text distinction\n- **Color Independence**: Information conveyed through text and icons\n\n## Use Cases\n\n### Active Filter Display\n```swift\n// Show currently applied filters\nlet activeFilters = [\n    FilterOptionItem(type: .sortBy, title: \"Popular\", icon: \"flame.fill\"),\n    FilterOptionItem(type: .league, title: \"Premier League\", icon: \"trophy.fill\")\n]\n```\n\n### Filter Category Browsing\n```swift\n// Display available filter options by category\nlet sortingOptions = FilterDataManager.createSortOptions()\nlet leagueOptions = FilterDataManager.createLeagueOptions()\n```\n\n### Search Result Filters\n```swift\n// Show filters applied to search results\nlet searchFilters = [\n    FilterOptionItem(type: .sport, title: \"Football\", icon: \"soccerball\"),\n    FilterOptionItem(type: .sortBy, title: \"Recent\", icon: \"clock.fill\")\n]\n```\n\n## Technical Implementation\n\n### Memory Management\n- Lightweight cell design optimized for collection view reuse\n- Simple view model pattern with minimal overhead\n- Proper cleanup during cell reuse cycles\n- Efficient constraint setup for performance\n\n### Performance Considerations\n- Minimal view hierarchy for fast scrolling\n- Efficient system icon loading and caching\n- Optimized for large numbers of filter options\n- Small memory footprint per cell instance\n\n### Layout Optimization\n- Stack view for efficient element arrangement\n- Fixed icon constraints to prevent layout shifts\n- Flexible title width with proper compression\n- Consistent spacing across varying content lengths\n\n## Error Handling\n\n### Defensive Programming\n- Safe handling of optional view model data\n- Graceful fallbacks for missing system icons\n- Proper validation of filter option types\n- Safe string handling for empty or nil titles\n\n### Data Validation\n- FilterOptionType enum ensures type safety\n- Non-empty title validation in initializers\n- Valid system icon name verification\n- Proper view model initialization checks\n\n## Dependencies\n\n- **UIKit**: Core UI framework for collection view cells\n- **StyleProvider**: Internal styling and theming system\n- **Foundation**: Basic data structures and utilities\n\n## Best Practices\n\n1. **Icon Selection**: Choose appropriate SF Symbols for each filter type\n2. **Title Length**: Keep filter names concise for better layout\n3. **Type Consistency**: Use appropriate FilterOptionType for each filter\n4. **Collection Layout**: Ensure proper spacing and sizing in collections\n5. **State Management**: Track filter selections externally to the cell\n6. **Accessibility**: Provide meaningful labels for screen reader users\n7. **Performance**: Use efficient cell reuse patterns for large datasets\n\n## Integration Patterns\n\n### With Filter State Management\n```swift\nclass FilterStateCoordinator {\n    private var activeFilters: Set<FilterOptionItem> = []\n    private weak var collectionView: UICollectionView?\n    \n    func toggleFilter(_ filter: FilterOptionItem) {\n        if activeFilters.contains(filter) {\n            activeFilters.remove(filter)\n        } else {\n            activeFilters.insert(filter)\n        }\n        \n        updateCollectionView()\n    }\n    \n    func isFilterActive(_ filter: FilterOptionItem) -> Bool {\n        return activeFilters.contains(filter)\n    }\n    \n    private func updateCollectionView() {\n        collectionView?.reloadData()\n    }\n}\n```\n\n### With Search Integration\n```swift\nclass SearchableFilterManager {\n    private let allFilters: [FilterOptionItem]\n    private var filteredOptions: [FilterOptionItem] = []\n    \n    func searchFilters(with text: String) {\n        if text.isEmpty {\n            filteredOptions = allFilters\n        } else {\n            filteredOptions = allFilters.filter { filter in\n                filter.title.localizedCaseInsensitiveContains(text)\n            }\n        }\n        \n        notifyFiltersChanged()\n    }\n    \n    private func notifyFiltersChanged() {\n        NotificationCenter.default.post(\n            name: .filtersDidChange,\n            object: filteredOptions\n        )\n    }\n}\n```\n\n## Comparison with SportSelectorCell\n\n| Feature | FilterOptionCell | SportSelectorCell |\n|---------|------------------|-------------------|\n| Border | None | Orange 2pt border |\n| Purpose | General filters | Sport selection |\n| Arrows | None | Selector arrows |\n| Design | Minimal | Prominent |\n| Usage | Active filters | Primary selector |\n\n## Future Enhancements\n\n- Support for custom filter icons beyond system images\n- Badge overlay for indicating filter counts\n- Animation effects for filter selection/deselection\n- Custom color schemes for different filter types\n- Multi-state support (active, inactive, disabled)\n- Integration with haptic feedback\n- Support for filter expiration/timing\n- Custom corner radius and styling options\n- Advanced accessibility features\n- Filter grouping and categorization ",
      "snapshots": []
    },
    "FloatingOverlay": {
      "displayName": "FloatingOverlayView",
      "category": "Status",
      "subcategory": "Notifications",
      "summary": "Floating notification overlay for mode switching feedback",
      "description": "Pill-shaped floating notification that animates in/out for mode switching feedback (Sportsbook/Casino). Features 24pt icon with highlightPrimary tint, 16pt medium message text, 16pt corner radius container with shadow (offset 0,4, radius 8pt, opacity 0.2). Spring animation on show (0.4s), ease-in on hide (0.3s) with scale/translation transforms. Supports auto-dismiss timer and tap-to-dismiss interaction. Three modes: sportsbook (soccer icon), casino (dice icon), or custom (configurable icon/message). Used in MainTabBarViewController for section switching indicators.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "overlay",
        "notification",
        "toast",
        "feedback",
        "mode-switch",
        "animated",
        "floating"
      ],
      "states": [
        "hidden",
        "visible-sportsbook",
        "visible-casino",
        "visible-custom"
      ],
      "similarTo": [],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# FloatingOverlay\n\nA modern floating overlay component that displays contextual messages with smooth animations. Perfect for notifying users about their current context (Sportsbook, Casino, or custom states).\n\n## Features\n\n- **Multiple Modes**: Built-in Sportsbook and Casino modes, plus custom mode support\n- **Content-Adaptive**: Automatically sizes to fit icon and message content\n- **Smooth Animations**: Slide-up entrance with fade and scale effects\n- **Flexible Dismissal**: Auto-dismiss with timer or tap to dismiss\n- **Single Instance**: Ensures only one overlay is visible at a time\n- **Customizable**: Support for custom icons and messages\n\n## Usage Example\n\n### Basic Usage\n\n```swift\n// Create a view model\nlet viewModel = MockFloatingOverlayViewModel.sportsbookMode\n\n// Create the overlay\nlet overlay = FloatingOverlayView(viewModel: viewModel)\n\n// Add to your view hierarchy\nview.addSubview(overlay)\n\n// Position it (parent is responsible for positioning)\noverlay.translatesAutoresizingMaskIntoConstraints = false\nNSLayoutConstraint.activate([\n    overlay.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n    overlay.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -20)\n])\n\n// Show the overlay with auto-dismiss after 3 seconds\nviewModel.show(mode: .sportsbook, duration: 3.0)\n```\n\n### Custom Mode\n\n```swift\nlet customIcon = UIImage(systemName: \"star.fill\") ?? UIImage()\nviewModel.show(mode: .custom(icon: customIcon, message: \"Welcome to VIP! \"), duration: 5.0)\n```\n\n### Manual Dismissal\n\n```swift\n// Show without auto-dismiss\nviewModel.show(mode: .casino, duration: nil)\n\n// Hide manually\nviewModel.hide()\n```\n\n### Handle Tap Events\n\n```swift\noverlay.onTap = {\n    print(\"Overlay was tapped!\")\n    // Perform additional actions if needed\n}\n```\n\n## Configuration Options\n\n### Modes\n\n1. **Sportsbook**: Shows soccer ball icon with \"You're in Sportsbook \"\n2. **Casino**: Shows dice icon with \"You're in Casino \"\n3. **Custom**: Provide your own icon and message\n\n### Duration\n\n- Pass a `TimeInterval` for auto-dismiss\n- Pass `nil` for manual dismiss only\n- Tapping always dismisses regardless of duration\n\n## Positioning\n\nThe parent view/controller is responsible for positioning the overlay. Common patterns:\n\n```swift\n// Bottom center (most common)\nNSLayoutConstraint.activate([\n    overlay.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n    overlay.bottomAnchor.constraint(equalTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -20)\n])\n\n// Top center\nNSLayoutConstraint.activate([\n    overlay.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n    overlay.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 20)\n])\n\n// Center of screen\nNSLayoutConstraint.activate([\n    overlay.centerXAnchor.constraint(equalTo: view.centerXAnchor),\n    overlay.centerYAnchor.constraint(equalTo: view.centerYAnchor)\n])\n```\n\n## Animation Details\n\n- **Show**: Slides up 50pts + fades in + scales from 0.95 to 1.0\n- **Hide**: Slides down 50pts + fades out + scales from 1.0 to 0.95\n- **Duration**: 0.4s show, 0.3s hide\n- **Spring**: Damping 0.8 for natural bounce\n\n## Best Practices\n\n1. **Single Instance**: Only show one overlay at a time\n2. **Context Awareness**: Use appropriate mode for current app section\n3. **Duration**: 3-5 seconds is typically sufficient for auto-dismiss\n4. **Positioning**: Keep consistent positioning across your app\n5. **Accessibility**: The component includes proper accessibility support",
      "snapshots": []
    },
    "GeneralFilterBarView": {
      "displayName": "GeneralFilterBarView",
      "category": "Filters",
      "subcategory": "Bars",
      "summary": "Horizontal filter bar with scrollable pills and pinned main filter button",
      "description": "Horizontal filter bar featuring a scrollable collection of filter pills (SportSelectorCell for sports, FilterOptionCell for leagues/sort options) with a pinned MainFilterPillView on the right. Uses UICollectionViewFlowLayout with automatic sizing, 8pt item spacing, and 16pt horizontal content inset. backgroundPrimary background. Provides onItemSelected and onMainFilterTapped callbacks. Supports dynamic item updates via updateFilterItems method. Commonly used for sports event filtering in next-up event screens.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "filter",
        "horizontal",
        "collection",
        "pills",
        "sports",
        "scrollable",
        "bar"
      ],
      "states": [
        "default"
      ],
      "similarTo": [
        "SportGamesFilterView",
        "QuickLinksTabBar"
      ],
      "oftenUsedWith": [
        "MainFilterPillView",
        "SportSelectorCell",
        "FilterOptionCell"
      ],
      "parents": [],
      "children": [
        "MainFilterPillView",
        "SportSelectorCell",
        "FilterOptionCell"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# GeneralFilterBarView\n\nA horizontal filter bar with scrollable filter pills and a main filter button.\n\n## Overview\n\nGeneralFilterBarView displays a horizontal collection of filter options (sports, leagues, sort options) with a pinned main filter button on the right side. The component uses a horizontal collection view for scrollable filter items and a dedicated container for the main filter pill.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone filter bar component)\n\n### Uses (Children)\n- `MainFilterPillView` - main filter button on the right\n- `SportSelectorCell` - sport filter cells\n- `FilterOptionCell` - other filter option cells\n\n## Features\n\n- Horizontal scrolling collection view for filter items\n- Fixed main filter pill on the right\n- 8pt minimum spacing between items\n- 16pt horizontal content inset\n- Self-sizing cells (automatic size estimation)\n- Primary background color\n- Filter item tap callbacks\n- Main filter tap callback\n- Dynamic item updates\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockGeneralFilterBarViewModel.defaultMock\nlet filterBarView = GeneralFilterBarView(viewModel: viewModel)\n\nfilterBarView.onItemSelected = { filterType in\n    print(\"Selected filter type: \\(filterType)\")\n}\n\nfilterBarView.onMainFilterTapped = {\n    print(\"Main filter tapped - show filter modal\")\n}\n\n// Update items dynamically\nfilterBarView.updateFilterItems(filterOptionItems: newItems)\n```\n\n## Data Model\n\n```swift\nstruct GeneralFilterBarItems {\n    var items: [FilterOptionItem]\n    let mainFilterItem: MainFilterItem\n}\n\nstruct FilterOptionItem {\n    let type: FilterOptionType\n    let title: String\n    let icon: String\n}\n\nstruct MainFilterItem {\n    let type: FilterOptionType\n    let title: String\n    let icon: String?\n    let actionIcon: String?\n}\n\nprotocol GeneralFilterBarViewModelProtocol {\n    var generalFilterItemsPublisher: CurrentValueSubject<GeneralFilterBarItems, Never> { get }\n\n    func updateFilterOptionItems(filterOptionItems: [FilterOptionItem])\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundPrimary` - view background\n\nLayout constants:\n- Collection view content inset: 16pt left/right\n- Item spacing: 8pt\n- Main filter container padding: 10pt horizontal\n- Height: 56pt (typical)\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - Football sport, Popular sort, All Leagues, and \"Filter\" main button\n",
      "snapshots": []
    },
    "GradientHeaderView": {
      "displayName": "GradientHeaderView",
      "category": "Promotions",
      "subcategory": "ContentBlocks",
      "summary": "Gradient banner header with centered title for promotional content",
      "description": "Banner header featuring a customizable diagonal gradient background (bottom-left to top-right) with centered multi-line title text. Uses GradientView for background rendering with configurable color stops. Fixed 208pt height, bold 24pt buttonTextPrimary colored title with 15pt horizontal padding. Reconfigurable via configure(viewModel:) method. Commonly used for promotional headers, welcome banners, and section headers requiring visual emphasis in promotion detail screens.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "gradient",
        "header",
        "banner",
        "promotion",
        "title",
        "welcome"
      ],
      "states": [
        "orange-red",
        "blue-cyan",
        "purple-pink",
        "green-yellow"
      ],
      "similarTo": [
        "PromotionalHeaderView"
      ],
      "oftenUsedWith": [
        "GradientView",
        "StackViewBlockView"
      ],
      "parents": [
        "StackViewBlockView"
      ],
      "children": [
        "GradientView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# GradientHeaderView\n\nA gradient banner header with centered title text for promotional content.\n\n## Overview\n\nGradientHeaderView displays a banner with a customizable diagonal gradient background and centered title text. It's designed for promotional headers, welcome banners, or section headers that need visual emphasis.\n\n## Component Relationships\n\n### Used By (Parents)\n- `StackViewBlockView` - promotional stack headers\n\n### Uses (Children)\n- `GradientView` - gradient background\n\n## Features\n\n- Diagonal gradient background (bottom-left to top-right)\n- Centered multi-line title text\n- Bold 24pt white text\n- Fixed 208pt height\n- Customizable gradient colors with location stops\n- Clear background on container\n- Static content (reconfigurable via configure method)\n\n## Usage\n\n```swift\nlet viewModel = MockGradientHeaderViewModel.defaultMock\nlet headerView = GradientHeaderView(viewModel: viewModel)\n\n// Reconfigure with different view model\nlet newViewModel = MockGradientHeaderViewModel.blueGradientMock\nheaderView.configure(viewModel: newViewModel)\n```\n\n## Data Model\n\n```swift\nprotocol GradientHeaderViewModelProtocol {\n    var title: String { get }\n    var gradientColors: [(color: UIColor, location: NSNumber)] { get }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.buttonTextPrimary` - title text color\n- `StyleProvider.fontWith(type: .bold, size: 24)` - title font\n\nLayout constants:\n- Header height: 208pt\n- Title padding: 15pt horizontal\n- Gradient direction: diagonal (bottom-left to top-right)\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - \"Welcome Bonus\" with orange-to-red gradient\n- `.blueGradientMock` - \"Special Promotion\" with blue-to-cyan gradient\n- `.purpleGradientMock` - \"Premium Offer\" with purple-to-pink gradient\n- `.longTitleMock` - \"Amazing Welcome Bonus Promotion\" with green-to-yellow gradient\n",
      "snapshots": [
        {
          "category": "GradientVariants",
          "light": "GradientHeaderView/__Snapshots__/GradientHeaderViewSnapshotTests/testGradientHeaderView_GradientVariants_Light.1.png",
          "dark": "GradientHeaderView/__Snapshots__/GradientHeaderViewSnapshotTests/testGradientHeaderView_GradientVariants_Dark.1.png"
        }
      ]
    },
    "HeaderTextView": {
      "displayName": "HeaderTextView",
      "category": "UIElements",
      "subcategory": "Headers",
      "summary": "Simple section header with rounded background container",
      "description": "Compact section header displaying a single-line title inside a rounded container with secondary background color. Features bold 14pt textPrimary font, 4pt corner radius, and 8pt padding on all sides. Supports dynamic title updates via updateTitle() method with reactive refreshData callback. Commonly used for category labels and section headers in list/grid views. Ideal for labeling content sections like 'Suggested Events', 'Popular Matches', 'Live Now', or casino category names. Used in production wrapped in HeaderTextReusableView as UICollectionView section headers.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "section",
        "header",
        "title",
        "label",
        "rounded",
        "container",
        "category",
        "casino"
      ],
      "states": [
        "short-text",
        "medium-text",
        "long-text",
        "all-caps"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "QuickLinksTabBarView",
        "SimpleNavigationBarView",
        "CasinoGameImageView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# HeaderTextView\n\nA simple, reusable header text component that displays a centered title with customizable styling.\n\n## Overview\n\n`HeaderTextView` is a lightweight UI component designed to display section headers or titles with consistent styling. It follows the GomaUI component architecture with MVVM pattern, protocol-based design, and reactive updates.\n\n## Features\n\n- **Centered text display** with customizable title\n- **Flexible styling** - customizable text color, background color, and font\n- **Protocol-based design** for easy testing and mocking\n- **Reactive updates** through view model binding\n- **Consistent theming** using StyleProvider\n- **Rounded corners** with 8pt radius for modern appearance\n\n## Usage\n\n### Basic Implementation\n\n```swift\n\n\n// Create view model\nlet viewModel = MockHeaderTextViewViewModel()\nviewModel.updateTitle(\"Suggested Events\")\n\n// Create and configure view\nlet headerView = HeaderTextView(viewModel: viewModel)\nheaderView.configure()\n```\n\n### Custom Styling\n\n```swift\nlet viewModel = MockHeaderTextViewViewModel()\nviewModel.updateTitle(\"Custom Header\")\nviewModel.updateColors(\n    textColor: UIColor.systemBlue,\n    backgroundColor: UIColor.systemGray6\n)\nviewModel.updateFont(UIFont.systemFont(ofSize: 20, weight: .bold))\n\nlet headerView = HeaderTextView(viewModel: viewModel)\nheaderView.configure()\n```\n\n### Custom ViewModel Implementation\n\n```swift\nclass MyHeaderViewModel: HeaderTextViewViewModelProtocol {\n    var title: String = \"My Title\"\n    var textColor: UIColor? = UIColor.systemBlue\n    var backgroundColor: UIColor? = UIColor.systemGray6\n    var font: UIFont? = UIFont.systemFont(ofSize: 18, weight: .semibold)\n    \n    var refreshData: (() -> Void)?\n    \n    func updateTitle(_ title: String) {\n        self.title = title\n        self.refreshData?()\n    }\n    \n    func updateColors(textColor: UIColor?, backgroundColor: UIColor?) {\n        self.textColor = textColor\n        self.backgroundColor = backgroundColor\n        self.refreshData?()\n    }\n    \n    func updateFont(_ font: UIFont?) {\n        self.font = font\n        self.refreshData?()\n    }\n}\n```\n\n## Architecture\n\n### Protocol Interface\n\nThe component uses `HeaderTextViewViewModelProtocol` to define the contract between the view and its view model:\n\n- `title: String` - The text to display\n- `textColor: UIColor?` - Optional custom text color\n- `backgroundColor: UIColor?` - Optional custom background color\n- `font: UIFont?` - Optional custom font\n- `refreshData: (() -> Void)?` - Callback for reactive updates\n\n### View Model Methods\n\n- `updateTitle(_:)` - Updates the displayed title\n- `updateColors(textColor:backgroundColor:)` - Updates text and background colors\n- `updateFont(_:)` - Updates the font\n\n## Styling\n\n### Default Theme\n\n- **Text Color**: `StyleProvider.Color.textPrimary`\n- **Background**: `StyleProvider.Color.backgroundSecondary`\n- **Font**: `StyleProvider.fontWith(type: .semibold, size: 16)`\n- **Corner Radius**: 8pt\n\n### Customization\n\nAll styling properties can be customized through the view model. The component will automatically apply custom styles when provided, falling back to default theme values when not specified.\n\n## Layout\n\nThe component uses Auto Layout with:\n- **Horizontal padding**: 16pt on leading and trailing edges\n- **Vertical padding**: 12pt on top and bottom edges\n- **Text alignment**: Centered\n- **Single line**: Text is limited to one line with truncation\n\n## Integration\n\n### Adding to View Hierarchy\n\n```swift\n// Add to parent view\nparentView.addSubview(headerView)\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    headerView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 16),\n    headerView.trailingAnchor.constraint(equalTo: parentView.trailingAnchor, constant: -16),\n    headerView.topAnchor.constraint(equalTo: parentView.topAnchor, constant: 20),\n    headerView.heightAnchor.constraint(equalToConstant: 44) // Recommended minimum height\n])\n```\n\n### Reactive Updates\n\nThe component automatically updates when the view model calls `refreshData?()`. This enables reactive programming patterns where the view responds to data changes.\n\n## Testing\n\nUse `MockHeaderTextViewViewModel` for testing and SwiftUI previews. The mock implementation provides all protocol methods and allows easy configuration of different states.\n\n## Examples\n\nSee the SwiftUI preview in the component file for visual examples of different styling configurations.\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "HeaderTextView/__Snapshots__/HeaderTextViewSnapshotTests/testHeaderTextView_BasicStates_Light.1.png",
          "dark": "HeaderTextView/__Snapshots__/HeaderTextViewSnapshotTests/testHeaderTextView_BasicStates_Dark.1.png"
        },
        {
          "category": "ContentVariants",
          "light": "HeaderTextView/__Snapshots__/HeaderTextViewSnapshotTests/testHeaderTextView_ContentVariants_Light.1.png",
          "dark": "HeaderTextView/__Snapshots__/HeaderTextViewSnapshotTests/testHeaderTextView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "HighlightedTextView": {
      "displayName": "HighlightedTextView",
      "category": "UIElements",
      "subcategory": "Text",
      "summary": "Rich text view with multiple highlighted ranges and link support",
      "description": "Attributed text label with support for multiple highlighted text ranges in different colors and styles. Features two highlight types: .highlight (bold 14pt) and .link (regular 12pt underlined). Supports configurable text alignment (left, center, right), customizable base font, per-highlight color, 4pt line spacing, and unlimited lines. Includes static findRanges() helper for locating substrings. Reactive updates via Combine dataPublisher. Heavily used in phone verification, registration, and password recovery flows for displaying USSD instructions with phone numbers, amounts, and clickable terms highlighted.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "text",
        "highlight",
        "attributed",
        "link",
        "underline",
        "formatting",
        "phone",
        "ussd",
        "terms"
      ],
      "states": [
        "left-aligned",
        "center-aligned",
        "right-aligned",
        "single-highlight",
        "multiple-highlights",
        "link-style"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "StepInstructionView",
        "TermsAcceptanceView",
        "TransactionVerificationView"
      ],
      "parents": [
        "StepInstructionView",
        "TermsAcceptanceView",
        "TransactionVerificationView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# HighlightedTextView\n\nA text view with support for multiple highlighted text ranges with customizable colors and styles.\n\n## Overview\n\nHighlightedTextView displays text with specific portions highlighted in different colors or styles. It supports multiple highlight types including bold highlights and underlined links, making it suitable for displaying text with emphasized elements, clickable terms, or formatted instructions.\n\n## Component Relationships\n\n### Used By (Parents)\n- `StepInstructionView` - instruction text with highlights\n- `TermsAcceptanceView` - terms text with highlighted links\n- `TransactionVerificationView` - verification text with highlights\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Multiple text highlight ranges\n- Two highlight types: bold highlights and underlined links\n- Configurable text alignment (left, center, right)\n- Customizable base font type and size\n- Per-highlight color customization\n- 4pt line spacing\n- Reactive updates via Combine publisher\n- Helper method to find text ranges\n- Attributed string rendering\n\n## Usage\n\n```swift\nlet viewModel = MockHighlightedTextViewModel.defaultMock()\nlet highlightedView = HighlightedTextView(viewModel: viewModel)\n\n// Create custom highlight data\nlet fullText = \"Transfer $500.00 to John Smith\"\nlet highlight = HighlightData(\n    text: \"$500.00\",\n    color: StyleProvider.Color.highlightPrimary,\n    ranges: HighlightedTextView.findRanges(of: \"$500.00\", in: fullText)\n)\n\nlet data = HighlightedTextData(\n    fullText: fullText,\n    highlights: [highlight],\n    textAlignment: .left\n)\nviewModel.configure(with: data)\n```\n\n## Data Model\n\n```swift\nenum HighlightType {\n    case highlight  // Bold, 14pt, no underline\n    case link       // Regular, 12pt, underlined\n}\n\nstruct HighlightData {\n    let text: String\n    let color: UIColor\n    let ranges: [NSRange]\n    let type: HighlightType\n}\n\nstruct HighlightedTextData {\n    let id: String\n    let fullText: String\n    let highlights: [HighlightData]\n    let textAlignment: NSTextAlignment\n    let baseFontType: StyleProvider.FontType\n    let baseFontSize: CGFloat\n}\n\nprotocol HighlightedTextViewModelProtocol {\n    var data: HighlightedTextData { get }\n    var dataPublisher: AnyPublisher<HighlightedTextData, Never> { get }\n\n    func configure(with data: HighlightedTextData)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.textPrimary` - base text color\n- `StyleProvider.fontWith(type:size:)` - configurable fonts\n\nLayout constants:\n- Line spacing: 4pt\n- Background: clear\n- Number of lines: unlimited (0)\n\nHighlight type styling:\n- `.highlight`: Bold font, 14pt, no underline\n- `.link`: Regular font, 12pt, underlined\n\n## Helper Methods\n\n```swift\n// Find all ranges of a substring in text\nstatic func findRanges(of substring: String, in text: String) -> [NSRange]\n```\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock()` - \"USSD Push interaction\" with phone number highlighted\n- `.centeredMock()` - \"24 hours\" highlighted, center-aligned\n- `.rightAlignedMock()` - \"$1,250.00\" highlighted, right-aligned\n- `.multipleHighlightsMock()` - multiple highlights (amount, name, phone)\n- `.linkMock()` - \"Terms and Conditions\" and \"Privacy Policy\" as underlined links\n",
      "snapshots": [
        {
          "category": "AlignmentStates",
          "light": "HighlightedTextView/__Snapshots__/HighlightedTextViewSnapshotTests/testHighlightedTextView_AlignmentStates_Light.1.png",
          "dark": "HighlightedTextView/__Snapshots__/HighlightedTextViewSnapshotTests/testHighlightedTextView_AlignmentStates_Dark.1.png"
        },
        {
          "category": "HighlightVariants",
          "light": "HighlightedTextView/__Snapshots__/HighlightedTextViewSnapshotTests/testHighlightedTextView_HighlightVariants_Light.1.png",
          "dark": "HighlightedTextView/__Snapshots__/HighlightedTextViewSnapshotTests/testHighlightedTextView_HighlightVariants_Dark.1.png"
        }
      ]
    },
    "ImageBlockView": {
      "displayName": "ImageBlockView",
      "category": "Promotions",
      "subcategory": "ContentBlocks",
      "summary": "Simple image display component for promotional content blocks",
      "description": "Centered image view for displaying promotional content images and banners. Features 8pt corner radius, scaleAspectFill content mode with clipping, 15pt minimum horizontal padding, and 5pt vertical padding. URL-based image source via imageUrl property. Currently uses placeholder system image pending integration with Kingfisher or similar image loading library. Used in promotion detail screens alongside other content blocks.",
      "complexity": "simple",
      "maturity": "maturing",
      "tags": [
        "image",
        "promo",
        "banner",
        "promotional",
        "block",
        "content"
      ],
      "states": [
        "valid-url",
        "invalid-url",
        "placeholder"
      ],
      "similarTo": [
        "ImageSectionView"
      ],
      "oftenUsedWith": [
        "DescriptionBlockView",
        "ActionButtonBlockView",
        "GradientHeaderView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# ImageBlockView\n\nA simple image display component for promotional content blocks.\n\n## Overview\n\nImageBlockView displays a single image with rounded corners, centered horizontally with padding. It's designed for promotional content, banner images, or any image that needs to be displayed within a content block with consistent styling.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone image block component)\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Centered image with horizontal padding\n- 8pt corner radius on image\n- Aspect fill content mode with clipping\n- Clear background\n- URL-based image source\n- 15pt horizontal padding (minimum)\n- 5pt vertical padding\n\n## Usage\n\n```swift\nlet viewModel = MockImageBlockViewModel.defaultMock\nlet imageBlockView = ImageBlockView(viewModel: viewModel)\n\n// With custom URL\nlet customViewModel = MockImageBlockViewModel(imageUrl: \"https://example.com/promo.jpg\")\nlet customView = ImageBlockView(viewModel: customViewModel)\n```\n\n## Data Model\n\n```swift\nprotocol ImageBlockViewModelProtocol {\n    var imageUrl: String { get }\n}\n```\n\n## Styling\n\nLayout constants:\n- Image corner radius: 8pt\n- Horizontal padding: 15pt (minimum, image centered)\n- Vertical padding: 5pt top and bottom\n- Content mode: scaleAspectFill\n- Background: clear\n\nNote: Currently uses placeholder system image. In production, integrate with Kingfisher or similar image loading library for URL-based images.\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - example promo image URL\n- `.validUrlMock` - picsum.photos test URL (400x200)\n- `.invalidUrlMock` - invalid URL for testing error states\n",
      "snapshots": []
    },
    "ImageSectionView": {
      "displayName": "ImageSectionView",
      "category": "Promotions",
      "subcategory": "ContentBlocks",
      "summary": "Full-width image section with dynamic aspect ratio preservation",
      "description": "Edge-to-edge image display that automatically adjusts height to preserve the original image aspect ratio. Uses Kingfisher for async image loading with dynamic constraint updates after image loads. Calculates aspect ratio from loaded image dimensions and creates height constraint based on width * (1/aspectRatio). Features scaleAspectFill content mode with clipping and clear background. No padding - designed for hero images and full-bleed promotional banners. Used in promotion detail screens for large imagery.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "image",
        "section",
        "full-width",
        "banner",
        "aspect-ratio",
        "kingfisher",
        "hero",
        "promotional"
      ],
      "states": [
        "loading",
        "loaded",
        "failed"
      ],
      "similarTo": [
        "ImageBlockView"
      ],
      "oftenUsedWith": [
        "DescriptionBlockView",
        "ActionButtonBlockView",
        "GradientHeaderView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# ImageSectionView\n\nA full-width image section with dynamic aspect ratio preservation.\n\n## Overview\n\nImageSectionView displays a full-width image that automatically adjusts its height to preserve the original image's aspect ratio. It uses Kingfisher for image loading and dynamically creates constraints based on the loaded image dimensions.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone image section component)\n\n### Uses (Children)\n- None (leaf component, uses Kingfisher)\n\n## Features\n\n- Full-width image display (edge to edge)\n- Dynamic height based on image aspect ratio\n- Automatic aspect ratio calculation after image loads\n- Kingfisher integration for async image loading\n- Aspect fill content mode with clipping\n- Clear background\n- Constraint updates on image load\n\n## Usage\n\n```swift\nlet viewModel = MockImageSectionViewModel.defaultMock\nlet imageSectionView = ImageSectionView(viewModel: viewModel)\n\n// With custom URL\nlet customViewModel = MockImageSectionViewModel(imageUrl: \"https://example.com/hero-image.jpg\")\nlet customView = ImageSectionView(viewModel: customViewModel)\n```\n\n## Data Model\n\n```swift\nprotocol ImageSectionViewModelProtocol {\n    var imageUrl: String { get }\n}\n```\n\n## Styling\n\nLayout constants:\n- Leading/trailing: 0 (full width)\n- Top/bottom: 0 (no padding)\n- Content mode: scaleAspectFill\n- Background: clear\n- Height: dynamic based on image aspect ratio\n\n## Implementation Details\n\nThe view calculates the aspect ratio when the image loads:\n```swift\naspectRatio = image.size.width / image.size.height\n```\n\nThen creates a constraint:\n```swift\nheight = width * (1 / aspectRatio)\n```\n\nThis ensures the image displays at its natural proportions regardless of the container width.\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - example section image URL\n- `.validUrlMock` - picsum.photos test URL (600x300)\n- `.invalidUrlMock` - invalid URL for testing error states\n",
      "snapshots": []
    },
    "InfoRowView": {
      "displayName": "InfoRowView",
      "category": "UIElements",
      "subcategory": "InfoDisplay",
      "summary": "Key-value information row with left and right labels in styled container",
      "description": "Horizontal row displaying label-value pairs in a rounded container. Left label uses semibold 12pt textPrimary, right label uses bold 12pt highlightPrimary with right alignment. Container features 4pt corner radius, backgroundSecondary, 16pt padding, and 12pt spacing between labels. Both text colors and background color are customizable for semantic styling (success green, warning yellow, etc.). Reactive updates via Combine dataPublisher. Used in deposit bonus success screens and responsible gaming limits confirmation displays for showing financial summaries like deposits, balances, and transaction amounts.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "info",
        "row",
        "key-value",
        "balance",
        "deposit",
        "financial",
        "summary",
        "label-value"
      ],
      "states": [
        "default",
        "custom-colors",
        "short-values",
        "long-values",
        "success-styling",
        "warning-styling"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "DepositBonusInfoView",
        "PrimaryButtonView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# InfoRowView\n\nA key-value information row with left and right labels in a styled container.\n\n## Overview\n\nInfoRowView displays a horizontal row with a label on the left and a value on the right, contained in a rounded background. It's designed for displaying financial information, balance summaries, or any key-value data pairs.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone info display component)\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Left-aligned label (semibold 12pt)\n- Right-aligned value (bold 12pt, highlight color)\n- Rounded container background (4pt corner radius)\n- Secondary background color\n- 16pt padding on all sides\n- 12pt spacing between labels\n- Customizable text colors for both labels\n- Customizable container background color\n- Reactive updates via Combine publisher\n\n## Usage\n\n```swift\nlet viewModel = MockInfoRowViewModel.defaultMock\nlet infoRow = InfoRowView(viewModel: viewModel)\n\n// Update with new data\nlet newData = InfoRowData(\n    leftText: \"Your Balance\",\n    rightText: \"XAF 5,000\"\n)\nviewModel.configure(with: newData)\n\n// With custom colors\nlet customData = InfoRowData(\n    leftText: \"Bonus Balance\",\n    rightText: \"XAF 500\",\n    leftTextColor: StyleProvider.Color.highlightTertiary,\n    rightTextColor: StyleProvider.Color.highlightSecondary,\n    backgroundColor: StyleProvider.Color.highlightSecondary.withAlphaComponent(0.1)\n)\n```\n\n## Data Model\n\n```swift\nstruct InfoRowData {\n    let id: String\n    let leftText: String\n    let rightText: String\n    let leftTextColor: UIColor?\n    let rightTextColor: UIColor?\n    let backgroundColor: UIColor?\n}\n\nprotocol InfoRowViewModelProtocol {\n    var data: InfoRowData { get }\n    var dataPublisher: AnyPublisher<InfoRowData, Never> { get }\n\n    func configure(with data: InfoRowData)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundSecondary` - container background (default)\n- `StyleProvider.Color.textPrimary` - left label text color (default)\n- `StyleProvider.Color.highlightPrimary` - right label text color (default)\n- `StyleProvider.fontWith(type: .semibold, size: 12)` - left label font\n- `StyleProvider.fontWith(type: .bold, size: 12)` - right label font\n\nLayout constants:\n- Container corner radius: 4pt\n- Container padding: 16pt (all sides)\n- Stack spacing: 12pt\n- Number of lines: unlimited (0)\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - \"Your Deposit\" / \"XAF 1000\"\n- `.balanceMock` - \"Account Balance\" / \"XAF 25,000\"\n- `.customBackgroundMock` - \"Bonus Balance\" / \"XAF 500\" with custom colors\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "InfoRowView/__Snapshots__/InfoRowViewSnapshotTests/testInfoRowView_BasicStates_Light.1.png",
          "dark": "InfoRowView/__Snapshots__/InfoRowViewSnapshotTests/testInfoRowView_BasicStates_Dark.1.png"
        },
        {
          "category": "StyleVariants",
          "light": "InfoRowView/__Snapshots__/InfoRowViewSnapshotTests/testInfoRowView_StyleVariants_Light.1.png",
          "dark": "InfoRowView/__Snapshots__/InfoRowViewSnapshotTests/testInfoRowView_StyleVariants_Dark.1.png"
        }
      ]
    },
    "InlineMatchCardView": {
      "displayName": "InlineMatchCardView",
      "category": "MatchCards",
      "subcategory": "Compact",
      "summary": "Compact inline match card with header, participants, scores, and betting outcomes",
      "description": "Compact horizontal match card combining header, participants with live scores, and betting outcomes in a space-efficient layout. Vertical structure: header row (CompactMatchHeaderView) + content row (participants/score left, CompactOutcomesLineView right). Home/away participant labels (semibold 14pt), optional InlineScoreView for live events, fixed 200pt outcomes width. Supports card tap navigation, outcome selection/deselection callbacks, and more markets tap. Includes InlineMatchCardTableViewCell wrapper with grouped corner radius handling. Full Combine reactive binding with synchronous currentDisplayState access. Designed for efficient list rendering with prepareForReuse() support.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "match",
        "card",
        "inline",
        "compact",
        "sports",
        "betting",
        "outcomes",
        "live",
        "prelive",
        "score"
      ],
      "states": [
        "pre-live-football",
        "pre-live-future-date",
        "live-tennis",
        "live-football",
        "live-basketball",
        "with-selected-outcome",
        "locked-market"
      ],
      "similarTo": [
        "TallOddsMatchCardView"
      ],
      "oftenUsedWith": [
        "CompactMatchHeaderView",
        "CompactOutcomesLineView",
        "InlineScoreView"
      ],
      "parents": [],
      "children": [
        "CompactMatchHeaderView",
        "CompactOutcomesLineView",
        "InlineScoreView",
        "ScoreView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# InlineMatchCardView\n\nA compact inline match card component that replaces TallOddsMatchCardView with a more streamlined layout for event display.\n\n## Overview\n\n`InlineMatchCardView` is a composite component that assembles:\n- **CompactMatchHeaderView** - Date/time or LIVE badge + icons\n- **Participant labels** - Home and away team/player names\n- **InlineScoreView** - Compact live scores (hidden for pre-live)\n- **CompactOutcomesLineView** - 2-3 outcome buttons\n\n## Architecture\n\n### Files\n```\nInlineMatchCardView/\n InlineMatchCardView.swift              # Main composite view\n InlineMatchCardViewModelProtocol.swift # Protocol + data models\n MockInlineMatchCardViewModel.swift     # Mock implementation\n Documentation/\n     README.md\n```\n\n### Component Structure\n```\nInlineMatchCardView\n containerStackView (vertical)\n    CompactMatchHeaderView\n       Left: Date/time OR LIVE badge\n       Right: Icons + market count\n   \n    contentStackView (horizontal)\n        participantsContainer (left)\n           participantsStackView\n              homeParticipantLabel\n              awayParticipantLabel\n           InlineScoreView (hidden when pre-live)\n       \n        CompactOutcomesLineView (right)\n            OutcomeItemView (1)\n            OutcomeItemView (X) - optional\n            OutcomeItemView (2)\n```\n\n## Usage\n\n### Basic Usage\n\n```swift\n// Pre-live football\nlet preLiveCard = InlineMatchCardView(\n    viewModel: MockInlineMatchCardViewModel.preLiveFootball\n)\n\n// Live tennis with scores\nlet liveCard = InlineMatchCardView(\n    viewModel: MockInlineMatchCardViewModel.liveTennis\n)\n```\n\n### Handle Callbacks\n\n```swift\ncardView.onCardTapped = { [weak self] in\n    self?.coordinator?.showMatchDetails(matchId: matchId)\n}\n\ncardView.onOutcomeSelected = { [weak self] outcomeId in\n    self?.coordinator?.addToBetslip(outcomeId: outcomeId)\n}\n\ncardView.onOutcomeDeselected = { [weak self] outcomeId in\n    self?.coordinator?.removeFromBetslip(outcomeId: outcomeId)\n}\n\ncardView.onMoreMarketsTapped = { [weak self] in\n    self?.coordinator?.showMoreMarkets(matchId: matchId)\n}\n```\n\n### Cell Reuse Pattern\n\n```swift\noverride func prepareForReuse() {\n    super.prepareForReuse()\n    cardView.prepareForReuse()\n}\n\nfunc configure(with viewModel: InlineMatchCardViewModelProtocol) {\n    cardView.configure(with: viewModel)\n\n    // Re-establish callbacks\n    cardView.onCardTapped = { ... }\n    cardView.onOutcomeSelected = { ... }\n}\n```\n\n## Data Models\n\n### InlineMatchCardDisplayState\n\n```swift\nstruct InlineMatchCardDisplayState {\n    let matchId: String\n    let homeParticipantName: String\n    let awayParticipantName: String\n    let isLive: Bool\n}\n```\n\n### InlineMatchData (Full Data)\n\n```swift\nstruct InlineMatchData {\n    let matchId: String\n    let homeParticipantName: String\n    let awayParticipantName: String\n    let isLive: Bool\n    let headerData: CompactMatchHeaderDisplayState\n    let outcomesData: CompactOutcomesLineDisplayState\n    let scoreData: InlineScoreDisplayState?\n}\n```\n\n## Protocol Requirements\n\n### Dual-Access Pattern\n\n```swift\nprotocol InlineMatchCardViewModelProtocol {\n    // Publishers (async updates)\n    var displayStatePublisher: AnyPublisher<...>\n    var headerViewModelPublisher: AnyPublisher<...>\n    var outcomesViewModelPublisher: AnyPublisher<...>\n    var scoreViewModelPublisher: AnyPublisher<...>\n\n    // Current values (sync access for UITableView sizing)\n    var currentDisplayState: InlineMatchCardDisplayState\n    var currentHeaderViewModel: CompactMatchHeaderViewModelProtocol\n    var currentOutcomesViewModel: CompactOutcomesLineViewModelProtocol\n    var currentScoreViewModel: InlineScoreViewModelProtocol?\n\n    // Actions\n    func onCardTapped()\n    func onOutcomeSelected(outcomeId: String)\n    func onOutcomeDeselected(outcomeId: String)\n    func onMoreMarketsTapped()\n}\n```\n\n## States\n\n| State | Header | Score | Outcomes |\n|-------|--------|-------|----------|\n| Pre-live Football | TODAY, 14:00 | Hidden | 1 X 2 |\n| Pre-live Tennis | 17/07, 11:00 | Hidden | 1 2 |\n| Live Football | LIVE 45' | 2-1 | 1 X 2 |\n| Live Tennis | LIVE 2ND SET | 30|6 4 | 1 2 |\n| Selected | Any | Any | One highlighted |\n| Locked | Any | Any | All locked |\n\n## Mock Configurations\n\n### Pre-Live\n```swift\nMockInlineMatchCardViewModel.preLiveFootball    // Football 1X2\nMockInlineMatchCardViewModel.preLiveFutureDate  // Future date\nMockInlineMatchCardViewModel.productionMode     // No icons\n```\n\n### Live\n```swift\nMockInlineMatchCardViewModel.liveTennis         // Tennis with sets\nMockInlineMatchCardViewModel.liveFootball       // Football with score\nMockInlineMatchCardViewModel.liveBasketball     // Basketball with quarters\n```\n\n### Special States\n```swift\nMockInlineMatchCardViewModel.withSelectedOutcome // Selection\nMockInlineMatchCardViewModel.lockedMarket       // All locked\n```\n\n## Comparison with TallOddsMatchCardView\n\n| Feature | InlineMatchCardView | TallOddsMatchCardView |\n|---------|--------------------|-----------------------|\n| Height | Compact | Taller |\n| Multi-line outcomes | No | Yes |\n| Market name pill | No | Yes |\n| Separator line | No | Yes |\n| Score position | Inline with names | Separate column |\n| Use case | BetssonCameroonApp | Legacy/other clients |\n\n## Styling\n\nAll styling via StyleProvider:\n- Background: `StyleProvider.Color.backgroundCards`\n- Participant text: `StyleProvider.fontWith(type: .semibold, size: 14)`\n- Text color: `StyleProvider.Color.textPrimary`\n\n## Constants\n\n```swift\ncontainerSpacing: 8.0pt   // Between header and content\ncontentSpacing: 12.0pt    // Between participants and outcomes\nhorizontalPadding: 12.0pt // Card horizontal padding\nverticalPadding: 10.0pt   // Card vertical padding\n```\n",
      "snapshots": []
    },
    "InlineScoreView": {
      "displayName": "InlineScoreView",
      "category": "MatchCards",
      "subcategory": "Scores",
      "summary": "Compact horizontal multi-column score display for live sports events",
      "description": "Horizontal score display with column-based architecture supporting various sports formats. Uses InlineScoreColumnView for individual columns with three highlighting modes: winnerLoser (winner highlighted, loser dimmed), bothHighlight (both in highlight color for active scores), and noHighlight (neutral informational display). Optional trailing separators divide score groups. Sport-specific layouts: football single column, tennis points + sets with separator after points, basketball total + quarters with separator after total. Hidden for pre-live events via isVisible toggle. Supports cleanupForReuse() for efficient cell recycling. Reactive updates via Combine displayStatePublisher.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "score",
        "live",
        "sports",
        "tennis",
        "football",
        "basketball",
        "columns",
        "highlighting",
        "match"
      ],
      "states": [
        "tennis-match",
        "tennis-second-set",
        "football-match",
        "football-tied",
        "basketball-match",
        "volleyball-match",
        "hidden",
        "empty"
      ],
      "similarTo": [
        "ScoreView"
      ],
      "oftenUsedWith": [
        "InlineMatchCardView",
        "InlineScoreColumnView"
      ],
      "parents": [
        "InlineMatchCardView"
      ],
      "children": [
        "InlineScoreColumnView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# InlineScoreView\n\nA compact inline score display component designed for live event cards. Displays scores horizontally with home scores on top row and away scores on bottom row.\n\n## Overview\n\n`InlineScoreView` provides a space-efficient way to display live scores inline with participant names. Unlike the full `ScoreView` component, this is designed for compact card layouts where vertical space is limited.\n\n## Architecture\n\n### Files\n```\nInlineScoreView/\n InlineScoreView.swift                 # Main container view\n InlineScoreColumnView.swift           # Individual score column\n InlineScoreViewModelProtocol.swift    # Protocol + data models\n MockInlineScoreViewModel.swift        # Mock implementation\n Documentation/\n     README.md\n```\n\n### Component Structure\n```\nInlineScoreView\n containerStackView (horizontal)\n    InlineScoreColumnView (points/score)\n    SeparatorView (optional)\n    InlineScoreColumnView (set1/q1)\n    InlineScoreColumnView (set2/q2)\n    ...\n```\n\n## Usage\n\n### Basic Usage\n\n```swift\n// Create with mock for testing\nlet scoreView = InlineScoreView(viewModel: MockInlineScoreViewModel.tennisMatch)\n\n// Or create empty and configure later\nlet scoreView = InlineScoreView()\nscoreView.configure(with: viewModel)\n```\n\n### In a Card Layout\n\n```swift\n// Inline with participant names\nparticipantsStackView.addArrangedSubview(homeLabel)\nparticipantsStackView.addArrangedSubview(awayLabel)\n\n// Score view positioned to the right\ncontainerView.addSubview(participantsStackView)\ncontainerView.addSubview(scoreView)\n\nNSLayoutConstraint.activate([\n    scoreView.leadingAnchor.constraint(equalTo: participantsStackView.trailingAnchor, constant: 8),\n    scoreView.centerYAnchor.constraint(equalTo: participantsStackView.centerYAnchor)\n])\n```\n\n### Cell Reuse\n\n```swift\noverride func prepareForReuse() {\n    super.prepareForReuse()\n    scoreView.cleanupForReuse()\n}\n\nfunc configure(with viewModel: InlineScoreViewModelProtocol) {\n    scoreView.configure(with: viewModel)\n}\n```\n\n## Data Models\n\n### InlineScoreColumnData\n\n```swift\nstruct InlineScoreColumnData {\n    let id: String                           // Unique identifier\n    let homeScore: String                    // Top row score\n    let awayScore: String                    // Bottom row score\n    let highlightingMode: HighlightingMode   // Visual highlighting\n    let showsTrailingSeparator: Bool         // Add separator after this column\n}\n```\n\n### Highlighting Modes\n\n| Mode | Description | Use Case |\n|------|-------------|----------|\n| `.winnerLoser` | Winner highlighted, loser dimmed | Completed sets/quarters |\n| `.bothHighlight` | Both scores in highlight color | Current game/points, totals |\n| `.noHighlight` | Both scores in default color | Neutral display |\n\n## Sport-Specific Formats\n\n### Tennis\n```swift\n// Points | Set1 Set2 Set3\n[30|15] | [6|4] [4|6] [2|1]\n```\n\n### Football\n```swift\n// Single score\n[2|1]\n```\n\n### Basketball\n```swift\n// Total | Q1 Q2 Q3 Q4\n[78|82] | [22|18] [19|24] [21|22] [16|18]\n```\n\n## Mock Configurations\n\n```swift\nMockInlineScoreViewModel.tennisMatch       // Tennis with sets\nMockInlineScoreViewModel.tennisSecondSet   // Tennis mid-match\nMockInlineScoreViewModel.footballMatch     // Football score\nMockInlineScoreViewModel.footballMatchTied // Tied football\nMockInlineScoreViewModel.basketballMatch   // Basketball with quarters\nMockInlineScoreViewModel.volleyballMatch   // Volleyball with sets\nMockInlineScoreViewModel.hidden            // Hidden state\nMockInlineScoreViewModel.empty             // Empty/no scores\n```\n\n## Styling\n\nAll colors and fonts use `StyleProvider`:\n- Score text: `StyleProvider.fontWith(type: .bold, size: 14)`\n- Highlight color: `StyleProvider.Color.highlightPrimary`\n- Secondary color: `StyleProvider.Color.textSecondary`\n- Separator: `StyleProvider.Color.textSecondary` at 30% opacity\n\n## Design Decisions\n\n1. **Compact Height**: Fixed 38pt height (18pt per row + 2pt spacing)\n2. **Flexible Width**: Content-hugging, expands based on score count\n3. **Separator Support**: Optional vertical separator between column groups\n4. **No Background**: Transparent to blend with card backgrounds\n",
      "snapshots": []
    },
    "LanguageSelectorView": {
      "displayName": "LanguageSelectorView",
      "category": "Profile",
      "subcategory": "Settings",
      "summary": "Language selection with radio button behavior and flag icons",
      "description": "Vertical list of selectable language options with radio button behavior (single selection). Each row displays flag icon (24x24), language name in native form, and radio button with orange fill/white dot when selected. Uses LanguageItemView for individual rows with 56pt height, grouped corner radius styling (first/last/middle/all), and tap feedback animation. Supports LanguageFlagImageResolver for custom flag images with globe fallback. Async loadLanguages() method, reactive updates via Combine languagesPublisher and selectedLanguagePublisher. LanguageModel provides predefined common languages (English, French, Spanish, German, Italian, Portuguese).",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "language",
        "selector",
        "radio",
        "profile",
        "settings",
        "flag",
        "localization",
        "i18n"
      ],
      "states": [
        "two-languages",
        "four-languages",
        "many-languages",
        "single-language",
        "french-selected",
        "empty"
      ],
      "similarTo": [],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# LanguageSelectorView\n\nA single-selection language picker component with radio buttons, flag icons, and reactive updates.\n\n## Overview\n\nLanguageSelectorView is a complete language selection solution that provides a clean, iOS-native interface for users to choose their preferred language. The component features radio button selection logic, flag icon support, and follows iOS accessibility guidelines.\n\n## Features\n\n- **Single Selection**: Only one language can be selected at a time\n- **Radio Button Interface**: Clean radio buttons with orange highlight for selected state\n- **Flag Support**: Emoji flags or custom assets for visual language identification\n- **Reactive Updates**: Real-time selection updates using Combine publishers\n- **Accessibility**: Full VoiceOver support with proper labels and hints\n- **Customizable**: Supports custom language lists and initial selections\n- **MVVM Architecture**: Protocol-driven with comprehensive mock implementations\n\n## Components Structure\n\nThe LanguageSelectorView consists of two main components:\n\n- **LanguageSelectorView**: Main container managing the list of language options\n- **LanguageItemView**: Individual language row with flag, name, and radio button (internal)\n\n## Usage\n\n### Basic Usage\n\n```swift\n\n\n// Create with default languages\nlet viewModel = MockLanguageSelectorViewModel.defaultMock\nlet languageSelector = LanguageSelectorView(viewModel: viewModel)\n\n// Add to view hierarchy\nview.addSubview(languageSelector)\n```\n\n### Custom Language List\n\n```swift\n// Define custom languages\nlet customLanguages = [\n    LanguageModel(id: \"en\", name: \"English\", flagIcon: \"\", isSelected: true),\n    LanguageModel(id: \"fr\", name: \"Franais\", flagIcon: \"\", isSelected: false)\n]\n\n// Create with custom callback\nlet viewModel = MockLanguageSelectorViewModel.customCallbackMock(\n    languages: customLanguages,\n    initialSelection: customLanguages[0]\n) { selectedLanguage in\n    print(\"Language selected: \\(selectedLanguage.displayName)\")\n    // Handle language change in your app\n}\n\nlet languageSelector = LanguageSelectorView(viewModel: viewModel)\n```\n\n### Production Implementation\n\n```swift\nclass AppLanguageSelectorViewModel: LanguageSelectorViewModelProtocol {\n    @Published private var languages: [LanguageModel] = []\n    @Published private var selectedLanguage: LanguageModel?\n    private let languageChangedSubject = PassthroughSubject<LanguageModel, Never>()\n    \n    var languagesPublisher: AnyPublisher<[LanguageModel], Never> {\n        $languages.eraseToAnyPublisher()\n    }\n    \n    var selectedLanguagePublisher: AnyPublisher<LanguageModel?, Never> {\n        $selectedLanguage.eraseToAnyPublisher()\n    }\n    \n    var languageChangedPublisher: AnyPublisher<LanguageModel, Never> {\n        languageChangedSubject.eraseToAnyPublisher()\n    }\n    \n    func selectLanguage(_ language: LanguageModel) {\n        // Update app language settings\n        UserDefaults.standard.set(language.languageCode, forKey: \"app_language\")\n        \n        // Update internal state\n        updateLanguageSelection(language)\n        \n        // Notify about change\n        languageChangedSubject.send(language)\n        \n        // Trigger app language change\n        applyLanguageChange(language)\n    }\n    \n    func loadLanguages() {\n        // Load supported languages from app configuration\n        languages = AppConfiguration.supportedLanguages\n    }\n    \n    // ... other protocol methods\n}\n```\n\n## Data Models\n\n### LanguageModel\n\nThe core data model representing a selectable language option:\n\n```swift\nstruct LanguageModel: Identifiable, Equatable, Codable {\n    let id: String              // Language identifier (e.g., \"en\", \"fr\")\n    let name: String            // Native language name (e.g., \"English\", \"Franais\")\n    let flagIcon: String        // Flag emoji or asset name\n    let isSelected: Bool        // Current selection state\n    let languageCode: String?   // Full language code (e.g., \"en-US\")\n    let englishName: String?    // English name for fallback\n}\n```\n\n### Predefined Languages\n\nCommon languages are available as static properties:\n\n```swift\n// Available predefined languages\nLanguageModel.english       //  English\nLanguageModel.french        //  Franais  \nLanguageModel.spanish       //  Espaol\nLanguageModel.german        //  Deutsch\nLanguageModel.italian       //  Italiano\nLanguageModel.portuguese    //  Portugus\n\n// Use predefined collection\nLanguageModel.commonLanguages // Array of all above languages\n```\n\n## Visual Specifications\n\n### Container\n- **Background**: `StyleProvider.Color.backgroundPrimary` (#e7e7e7)\n- **Corner Radius**: 16px for container\n- **Padding**: 8px around content\n\n### Language Items\n- **Background**: `StyleProvider.Color.backgroundTertiary` (#ffffff)\n- **Height**: 56px per item\n- **Padding**: 16px horizontal\n- **Separator**: 1px line using `StyleProvider.Color.separatorLine` (#d8d8d8)\n- **Corner Radius**: 8px for top/bottom items\n\n### Radio Buttons\n- **Size**: 20x20px\n- **Border Width**: 2px\n- **Selected State**:\n  - Background: `StyleProvider.Color.highlightPrimary` (#ff6600)\n  - Inner Dot: 12px white circle\n- **Unselected State**:\n  - Border: `StyleProvider.Color.iconSecondary` (#21222e)\n  - Background: Transparent\n\n### Typography\n- **Language Name**: Open Sans Regular 14px\n- **Color**: `StyleProvider.Color.textPrimary` (#252634)\n\n### Flags\n- **Size**: 24x24px container\n- **Support**: Emoji flags or custom image assets\n- **Fallback**: First 2 letters of language name\n\n## Interaction Behavior\n\n### Selection Logic\n1. User taps any part of a language row\n2. Previous selection is automatically deselected\n3. New language becomes selected with visual feedback\n4. `languageChangedPublisher` emits the new selection\n5. Callback function is triggered (if provided)\n\n### Visual Feedback\n- **Tap Animation**: Subtle scale down/up animation (98% scale)\n- **Radio Button**: Immediate visual state change\n- **Selection Indicator**: Orange fill with white inner dot\n\n### Accessibility\n- **VoiceOver Labels**: \"{Language} language option, {selected/not selected}\"\n- **Hints**: \"Tap to select this language\"\n- **Traits**: Button trait for each selectable item\n- **Dynamic Updates**: Selection state announced when changed\n\n## Mock ViewModels\n\n### Available Mocks\n\n```swift\n// Default configuration with 4 common languages, English selected\nMockLanguageSelectorViewModel.defaultMock\n\n// Two languages only (matches Figma design)\nMockLanguageSelectorViewModel.twoLanguagesMock  \n\n// Many languages for testing scrolling\nMockLanguageSelectorViewModel.manyLanguagesMock\n\n// French initially selected\nMockLanguageSelectorViewModel.frenchSelectedMock\n\n// Interactive demo with comprehensive feedback\nMockLanguageSelectorViewModel.interactiveMock\n\n// Custom configuration\nMockLanguageSelectorViewModel.customCallbackMock(\n    languages: customLanguages,\n    initialSelection: selectedLanguage,\n    onLanguageSelected: { language in\n        // Handle selection\n    }\n)\n```\n\n### Testing Configurations\n\n```swift\n// Empty state testing\nMockLanguageSelectorViewModel.emptyMock\n\n// Single language testing  \nMockLanguageSelectorViewModel.singleLanguageMock\n```\n\n## Integration Examples\n\n### SwiftUI Integration\n\n```swift\nstruct LanguageSettingsView: View {\n    @StateObject private var viewModel = AppLanguageSelectorViewModel()\n    \n    var body: some View {\n        VStack {\n            Text(\"Choose Language\")\n                .font(.title2)\n                .padding()\n            \n            PreviewUIView {\n                LanguageSelectorView(viewModel: viewModel)\n            }\n            .padding()\n        }\n    }\n}\n```\n\n### UIViewController Integration\n\n```swift\nclass LanguageSettingsViewController: UIViewController {\n    private let languageSelector: LanguageSelectorView\n    private let viewModel: AppLanguageSelectorViewModel\n    \n    init() {\n        self.viewModel = AppLanguageSelectorViewModel()\n        self.languageSelector = LanguageSelectorView(viewModel: viewModel)\n        super.init(nibName: nil, bundle: nil)\n    }\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupLanguageSelector()\n        bindToLanguageChanges()\n    }\n    \n    private func bindToLanguageChanges() {\n        viewModel.languageChangedPublisher\n            .sink { [weak self] newLanguage in\n                self?.handleLanguageChange(newLanguage)\n            }\n            .store(in: &cancellables)\n    }\n}\n```\n\n## Styling Customization\n\nAll visual properties use StyleProvider for consistent theming:\n\n```swift\n// Container colors\nStyleProvider.Color.backgroundPrimary    // Container background\nStyleProvider.Color.backgroundTertiary   // Item background  \n\n// Text and borders\nStyleProvider.Color.textPrimary         // Language names\nStyleProvider.Color.separatorLine       // Item separators\nStyleProvider.Color.iconSecondary       // Radio button borders\n\n// Highlights\nStyleProvider.Color.highlightPrimary    // Selected radio button\n```\n\n## Best Practices\n\n### Implementation Guidelines\n\n1. **Always use ViewModels**: Never create views directly, use protocol-based approach\n2. **Handle selection callbacks**: Implement proper language change handling in your app\n3. **Provide feedback**: Use the `languageChangedPublisher` to notify users of changes\n4. **Test all states**: Use different mock configurations to test various scenarios\n5. **Consider accessibility**: Test with VoiceOver enabled\n6. **Flag consistency**: Use consistent flag representation (all emoji or all assets)\n\n### Performance Considerations\n\n1. **Lazy loading**: Languages are loaded on-demand when `loadLanguages()` is called\n2. **Efficient updates**: Only changed items are updated during selection changes\n3. **Memory management**: Combine subscriptions are properly managed with cancellables\n4. **Reusable cells**: Internal item views are reused efficiently\n\n### Common Integration Patterns\n\n```swift\n// Pattern 1: Settings Screen\nclass LanguageSettingsViewController {\n    // Show as full-screen selection\n    private func presentLanguageSelector() {\n        let selector = LanguageSelectorView(viewModel: viewModel)\n        // Add to view hierarchy\n    }\n}\n\n// Pattern 2: Modal Selection\nfunc showLanguageSelectionModal() {\n    let modal = UIViewController()\n    let selector = LanguageSelectorView(viewModel: viewModel)\n    modal.view.addSubview(selector)\n    present(modal, animated: true)\n}\n\n// Pattern 3: Profile Menu Integration\n// Use with ProfileMenuListView for navigation to language selection\n```\n\n## Requirements\n\n- **iOS**: 13.0+\n- **Frameworks**: UIKit, Combine\n- **Dependencies**: GomaUI StyleProvider\n- **Accessibility**: iOS VoiceOver support\n\n## File Structure\n\n```\nLanguageSelectorView/\n LanguageSelectorView.swift              # Main container component\n LanguageItemView.swift                  # Individual language row  \n LanguageModel.swift                     # Data model and predefined languages\n LanguageSelectorViewModelProtocol.swift # Protocol definition\n MockLanguageSelectorViewModel.swift     # Mock implementation\n README.md                              # This documentation\n```\n\n## Demo Integration\n\nThe component is fully integrated into GomaUICatalog with:\n- **Interactive Demo**: Switch between different language configurations\n- **Real-time Selection**: See immediate feedback on language selection\n- **Action Logging**: Track all language selection events\n- **Multiple Scenarios**: Test two languages, default set, and many languages\n\nAccess through: *GomaUICatalog  Language Selector*\n\n---\n\n*This component provides a complete solution for language selection in iOS apps, following iOS design guidelines and accessibility standards while maintaining consistency with the GomaUI component library.*\n",
      "snapshots": []
    },
    "LeaguesFilterView": {
      "displayName": "LeaguesFilterView",
      "category": "Filters",
      "subcategory": "Panels",
      "summary": "Collapsible filter panel for league selection with animated expand/collapse",
      "description": "Vertical filter panel displaying list of league options with collapsible behavior. Header shows localized 'Leagues' title (bold 14pt) and chevron toggle button that rotates on collapse. Uses LeagueOptionRowView for each option row (56pt height) with icon (16x16), title, and event count. Selected row shows 4pt orange left indicator bar, bold text, and highlighted count. Animated 0.3s collapse/expand with alpha fade and height constraint toggle. Tertiary background color. Selection triggers onLeagueFilterSelected callback. Reactive state via Combine selectedFilter and isCollapsed subjects.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "leagues",
        "filter",
        "collapsible",
        "panel",
        "sports",
        "selection",
        "animated",
        "expand"
      ],
      "states": [
        "expanded",
        "collapsed",
        "all-selected",
        "league-selected",
        "many-leagues"
      ],
      "similarTo": [
        "CountryLeaguesFilterView",
        "GeneralFilterBarView"
      ],
      "oftenUsedWith": [
        "LeagueOptionRowView"
      ],
      "parents": [],
      "children": [
        "LeagueOptionRowView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# LeaguesFilterView\n\nA collapsible league filter component built with UIKit and Combine that allows users to select from available sports leagues. The component features an expandable/collapsible list of league options with visual selection indicators and event count displays.\n\n## Overview\n\nThe `LeaguesFilterView` is designed to display league filtering options in a vertical list format with a collapsible header. Each league option includes an icon (typically trophy), title, event count, and selection state. The component follows MVVM architecture and uses reactive programming with Combine for state management.\n\n## Architecture\n\n### Component Structure\n```\nLeaguesFilterView/\n LeaguesFilterView.swift                 # Main component view\n LeaguesFilterViewModelProtocol.swift    # View model protocol\n MockLeaguesFilterViewModel.swift        # Mock implementation\n LeagueOptionRowView.swift              # Individual row component\n Models/\n     LeaguesFilterViewModels.swift      # Data models\n```\n\n### MVVM Pattern\n- **View**: `LeaguesFilterView` - Main UI component\n- **ViewModel**: `LeaguesFilterViewModelProtocol` - Business logic and state management\n- **Model**: `LeagueOption` - Data structure for league options\n- **Sub-View**: `LeagueOptionRowView` - Individual league row component\n\n## Key Features\n\n### Interactive Elements\n- **Collapsible Header**: Tap chevron to expand/collapse the leagues list\n- **League Selection**: Single selection mode with visual feedback\n- **Visual States**: Selected state with color changes and left indicator\n- **Event Count Display**: Shows number of events for each league\n- **Full Row Tap**: Entire row is tappable for better user experience\n\n### Visual Design\n- **Left Indicator**: Orange accent line for selected leagues\n- **Icon Support**: League icons (typically trophy symbols)\n- **Typography**: Bold styling for selected league names\n- **Count Information**: Event count with \"No Events\" fallback\n- **Smooth Animations**: Collapse/expand transitions with chevron rotation\n\n### State Management\n- **Reactive Updates**: Combine-based state synchronization\n- **Selection Tracking**: Currently selected league management\n- **Collapse State**: Expandable/collapsible interface\n- **Event Callbacks**: Selection change notifications\n\n## Models\n\n### LeagueOption\n```swift\npublic struct LeagueOption: Equatable {\n    public let id: Int\n    public let icon: String?\n    public let title: String\n    public let count: Int\n}\n```\n\n**Properties:**\n- `id`: Unique identifier for the league\n- `icon`: Optional icon name (typically \"trophy.fill\")\n- `title`: Display name of the league (e.g., \"Premier League\")\n- `count`: Number of events/matches available in this league\n\n## Protocols\n\n### LeaguesFilterViewModelProtocol\n```swift\npublic protocol LeaguesFilterViewModelProtocol {\n    var leagueOptions: [LeagueOption] { get }\n    var selectedOptionId: CurrentValueSubject<Int, Never> { get }\n    var isCollapsed: CurrentValueSubject<Bool, Never> { get }\n    \n    func selectOption(withId id: Int)\n    func toggleCollapse()\n}\n```\n\n**Key Methods:**\n- `selectOption(withId:)`: Updates the selected league\n- `toggleCollapse()`: Expands/collapses the league list\n\n## Usage Examples\n\n### Basic Implementation\n```swift\nlet leagueOptions = [\n    LeagueOption(id: 1, icon: \"trophy.fill\", title: \"Premier League\", count: 32),\n    LeagueOption(id: 2, icon: \"trophy.fill\", title: \"La Liga\", count: 28),\n    LeagueOption(id: 3, icon: \"trophy.fill\", title: \"Bundesliga\", count: 25),\n    LeagueOption(id: 4, icon: \"trophy.fill\", title: \"Serie A\", count: 27),\n    LeagueOption(id: 5, icon: \"trophy.fill\", title: \"Ligue 1\", count: 0)\n]\n\nlet viewModel = MockLeaguesFilterViewModel(\n    leagueOptions: leagueOptions,\n    selectedId: 1\n)\n\nlet leaguesFilterView = LeaguesFilterView(viewModel: viewModel)\n\n// Handle selection changes\nleaguesFilterView.onLeagueFilterSelected = { selectedId in\n    print(\"Selected league ID: \\(selectedId)\")\n}\n```\n\n### Custom ViewModel Implementation\n```swift\nclass CustomLeaguesFilterViewModel: LeaguesFilterViewModelProtocol {\n    var leagueOptions: [LeagueOption] = []\n    var selectedOptionId = CurrentValueSubject<Int, Never>(1)\n    var isCollapsed = CurrentValueSubject<Bool, Never>(false)\n    \n    init(leagues: [LeagueOption]) {\n        self.leagueOptions = leagues\n    }\n    \n    func selectOption(withId id: Int) {\n        selectedOptionId.send(id)\n        // Custom selection logic (e.g., API calls, analytics)\n        updateLeagueData(for: id)\n    }\n    \n    func toggleCollapse() {\n        isCollapsed.send(!isCollapsed.value)\n        // Custom collapse logic\n    }\n    \n    private func updateLeagueData(for leagueId: Int) {\n        // Update related data when league is selected\n    }\n}\n```\n\n### Integration in Filter Interface\n```swift\nclass FiltersViewController: UIViewController {\n    private var leaguesFilterView: LeaguesFilterView!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupLeaguesFilter()\n    }\n    \n    private func setupLeaguesFilter() {\n        let viewModel = MockLeaguesFilterViewModel(\n            leagueOptions: fetchAvailableLeagues()\n        )\n        \n        leaguesFilterView = LeaguesFilterView(viewModel: viewModel)\n        leaguesFilterView.translatesAutoresizingMaskIntoConstraints = false\n        \n        view.addSubview(leaguesFilterView)\n        \n        NSLayoutConstraint.activate([\n            leaguesFilterView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),\n            leaguesFilterView.leadingAnchor.constraint(equalTo: view.leadingAnchor),\n            leaguesFilterView.trailingAnchor.constraint(equalTo: view.trailingAnchor)\n        ])\n        \n        leaguesFilterView.onLeagueFilterSelected = { [weak self] selectedId in\n            self?.applyLeagueFilter(selectedId)\n        }\n    }\n    \n    private func applyLeagueFilter(_ leagueId: Int) {\n        // Apply the selected league filter to your data source\n    }\n}\n```\n\n## Component Behavior\n\n### Selection Logic\n- Single selection mode (only one league can be selected at a time)\n- Visual feedback with background color, typography, and left indicator\n- Icon tint color changes to highlight color when selected\n- Event count styling updates for selected state\n\n### Collapse/Expand Animation\n- Smooth 0.3 second animation duration\n- Chevron icon rotation (180 when collapsed)\n- Height constraint management for smooth transitions\n- Alpha and visibility changes for smooth user experience\n\n### Row Interaction\n- Full row tap gesture for better accessibility\n- Visual feedback on selection\n- Callback execution for selection changes\n- Maintains selection state during view updates\n\n## LeagueOptionRowView Details\n\nThe individual row component (`LeagueOptionRowView`) handles:\n\n### Visual Elements\n- **Left Indicator**: 4pt wide orange accent line\n- **Icon**: 16x16pt league icon with tint color support\n- **Title Label**: League name with dynamic font weight\n- **Count Label**: Event count with styling variations\n- **Background**: Selection state background color\n\n### State Management\n- `isSelected` property with automatic visual updates\n- Configuration method for league option data\n- Tap gesture handling with callback execution\n- Dynamic styling based on selection state\n\n## Styling Integration\n\nThe component integrates with `StyleProvider` for consistent theming:\n\n- **Colors**: \n  - `highlightPrimary`: Orange accent color for selections\n  - `textPrimary`: Main text color\n  - `separatorLine`: Background color for selected rows\n- **Typography**: \n  - Regular and bold font variants\n  - Size 14 for titles, size 12 for counts\n- **Spacing**: Consistent 16pt margins and 12pt padding\n\n## League Data Examples\n\n### Popular Football Leagues\n```swift\nlet footballLeagues = [\n    LeagueOption(id: 1, icon: \"trophy.fill\", title: \"Premier League\", count: 32),\n    LeagueOption(id: 2, icon: \"trophy.fill\", title: \"La Liga\", count: 28),\n    LeagueOption(id: 3, icon: \"trophy.fill\", title: \"Bundesliga\", count: 25),\n    LeagueOption(id: 4, icon: \"trophy.fill\", title: \"Serie A\", count: 27),\n    LeagueOption(id: 5, icon: \"trophy.fill\", title: \"Champions League\", count: 16),\n    LeagueOption(id: 6, icon: \"trophy.fill\", title: \"Europa League\", count: 12)\n]\n```\n\n### Multi-Sport Leagues\n```swift\nlet multiSportLeagues = [\n    LeagueOption(id: 10, icon: \"trophy.fill\", title: \"NFL\", count: 42),\n    LeagueOption(id: 11, icon: \"trophy.fill\", title: \"NBA\", count: 38),\n    LeagueOption(id: 12, icon: \"trophy.fill\", title: \"MLB\", count: 65),\n    LeagueOption(id: 13, icon: \"trophy.fill\", title: \"NHL\", count: 28)\n]\n```\n\n## Accessibility Features\n\n- **Tap Targets**: Full row touch areas (56pt height minimum)\n- **Visual Hierarchy**: Clear typography and color distinctions\n- **State Communication**: Multiple visual indicators for selection\n- **Dynamic Type**: Font scaling support through StyleProvider\n- **Contrast**: Appropriate color contrasts for text readability\n\n## SwiftUI Preview Support\n\nThe component includes comprehensive SwiftUI preview with realistic data:\n\n```swift\n@available(iOS 17.0, *)\nstruct LeaguesFilterView_Preview: PreviewProvider {\n    static var previews: some View {\n        PreviewUIView {\n            // Preview with 10 sample leagues\n        }\n        .frame(height: 900)\n        .background(Color(uiColor: .systemGray6))\n    }\n}\n```\n\n## Technical Implementation\n\n### Memory Management\n- Weak references in closures to prevent retain cycles\n- Proper Combine cancellable storage with `Set<AnyCancellable>`\n- Automatic cleanup of gesture recognizers and observers\n\n### Performance Considerations\n- Efficient constraint management during animations\n- Lazy loading of row views in stack view\n- Optimized for large league lists (100+ leagues)\n- Minimal layout passes during state changes\n\n### Animation Performance\n- Hardware-accelerated transforms for chevron rotation\n- Efficient height constraint animations\n- Proper animation completion handling\n- Smooth 60fps animations on supported devices\n\n## Error Handling\n\n### Defensive Programming\n- Safe array access patterns\n- Graceful fallbacks for missing icons\n- Proper nil checking for optional league data\n- Safe state transitions during animations\n\n### Data Validation\n- Unique ID requirements for league options\n- Count value validation (non-negative)\n- Title validation (non-empty strings)\n- Icon existence verification\n\n## Dependencies\n\n- **UIKit**: Core UI framework and animations\n- **Combine**: Reactive programming and state management  \n- **StyleProvider**: Internal styling and theming system\n- **Foundation**: Basic data structures and utilities\n\n## Best Practices\n\n1. **Data Consistency**: Ensure all league options have unique IDs\n2. **Memory Management**: Always use weak references in closures\n3. **Animation Timing**: Don't interrupt ongoing collapse/expand animations\n4. **State Synchronization**: Keep view model and UI state in sync\n5. **Accessibility Testing**: Test with VoiceOver and Dynamic Type\n6. **Performance**: Monitor memory usage with large league datasets\n7. **Icon Management**: Provide fallbacks for missing league icons\n\n## Integration Patterns\n\n### With Other Filter Components\n```swift\n// Coordinate with other filters\nfunc setupMultipleFilters() {\n    let sportsFilter = SportGamesFilterView(viewModel: sportsViewModel)\n    let leaguesFilter = LeaguesFilterView(viewModel: leaguesViewModel)\n    let sortFilter = SortFilterView(viewModel: sortViewModel)\n    \n    // Stack them vertically\n    let stackView = UIStackView(arrangedSubviews: [\n        sportsFilter, leaguesFilter, sortFilter\n    ])\n    stackView.axis = .vertical\n    stackView.spacing = 16\n}\n```\n\n### With Data Sources\n```swift\n// Connect to data source\nleaguesFilterView.onLeagueFilterSelected = { [weak self] leagueId in\n    self?.dataSource.filterByLeague(id: leagueId)\n    self?.refreshUI()\n}\n```\n\n## Future Enhancements\n\n- Multi-selection support with checkboxes\n- Search functionality within leagues\n- Drag-to-reorder league preferences\n- Custom league grouping (by region, sport type)\n- League favorite/bookmark functionality\n- Dynamic league loading with pagination\n- League logos instead of generic trophy icons\n- Custom animation styles and durations ",
      "snapshots": []
    },
    "ListBlockView": {
      "displayName": "ListBlockView",
      "category": "Promotions",
      "subcategory": "ContentBlocks",
      "summary": "Numbered list block with icon or counter and vertical stack of child views",
      "description": "Block layout with left-side visual indicator (56x56pt) and vertical stack of child views on the right. Supports either URL-based icon image or circular numbered counter display. Counter shows semibold 24pt text in highlightSecondaryContrast color with 2pt circular border. Vertical stack accepts any UIView children, typically BulletItemBlockView instances. Clear background with 15pt horizontal padding, 10pt icon vertical offset, 5pt stack vertical padding. Designed for ordered lists, step-by-step instructions, and grouped content in promotional screens.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "list",
        "block",
        "numbered",
        "counter",
        "icon",
        "promotional",
        "instruction",
        "steps",
        "ordered"
      ],
      "states": [
        "with-icon",
        "with-counter",
        "single-item",
        "multiple-items"
      ],
      "similarTo": [
        "StackViewBlockView"
      ],
      "oftenUsedWith": [
        "BulletItemBlockView"
      ],
      "parents": [],
      "children": [
        "BulletItemBlockView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# ListBlockView\n\nA numbered list block with icon/counter and vertical stack of child views.\n\n## Overview\n\nListBlockView displays a block with an icon or numbered counter on the left and a vertical stack of child views on the right. It's designed for displaying ordered lists, step-by-step instructions, or grouped content with visual indicators.\n\n## Component Relationships\n\n### Used By (Parents)\n- None (standalone list block component)\n\n### Uses (Children)\n- `BulletItemBlockView` - bullet item content views\n\n## Features\n\n- Left-side icon (56x56pt) from URL or numbered counter\n- Circular border for counter display (when no icon)\n- Semibold 24pt counter text\n- Vertical stack of child views\n- Clear background\n- 15pt horizontal padding\n- 10pt vertical padding on icon\n- 5pt vertical padding on stack\n\n## Usage\n\n```swift\nlet bulletView1 = BulletItemBlockView(viewModel: MockBulletItemBlockViewModel.defaultMock)\nlet bulletView2 = BulletItemBlockView(viewModel: MockBulletItemBlockViewModel.shortMock)\n\nlet viewModel = MockListBlockViewModel(\n    iconUrl: \"\",\n    counter: \"1\",\n    views: [bulletView1, bulletView2]\n)\nlet listBlock = ListBlockView(viewModel: viewModel)\n\n// With icon from URL\nlet iconViewModel = MockListBlockViewModel(\n    iconUrl: \"https://example.com/icon.jpg\",\n    counter: nil,\n    views: [bulletView1]\n)\n```\n\n## Data Model\n\n```swift\nprotocol ListBlockViewModelProtocol {\n    var iconUrl: String { get }\n    var counter: String? { get }\n    var views: [UIView] { get }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.highlightSecondaryContrast` - counter text color, border color\n- `StyleProvider.fontWith(type: .semibold, size: 24)` - counter font\n\nLayout constants:\n- Icon/counter size: 56x56pt\n- Icon leading padding: 15pt\n- Icon top padding: 10pt\n- Stack leading (from icon): 10pt\n- Stack trailing padding: 15pt\n- Stack vertical padding: 5pt\n- Counter border width: 2pt\n- Counter corner radius: circular (28pt)\n- Stack spacing: 0pt\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - icon URL with 2 bullet views\n- `.withIconMock` - valid picsum URL with 2 bullet views\n- `.noIconMock` - empty icon URL (shows counter) with 1 bullet view\n",
      "snapshots": []
    },
    "MainFilterPillView": {
      "displayName": "MainFilterPillView",
      "category": "Filters",
      "subcategory": "Buttons",
      "summary": "Main filter pill button with selection counter badge",
      "description": "Pill-shaped button for accessing filter modal in filter bars. White fully-rounded container (40pt height) with horizontal stack: filter icon (22pt highlightPrimary), localized 'Filter' label (bold 12pt), and arrow icon (18pt). Optional red circular badge (16pt) positioned top-right shows active filter count. Two states via MainFilterStateType: notSelected (no badge) and selected(selections) showing badge with count. Tap triggers onFilterTapped callback with QuickLinkType. Reactive updates via Combine mainFilterState subject. Used as primary filter trigger in GeneralFilterBarView.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "filter",
        "pill",
        "button",
        "badge",
        "counter",
        "modal",
        "main",
        "trigger"
      ],
      "states": [
        "not-selected",
        "selected-1",
        "selected-3",
        "selected-12"
      ],
      "similarTo": [
        "PillItemView"
      ],
      "oftenUsedWith": [
        "GeneralFilterBarView"
      ],
      "parents": [
        "GeneralFilterBarView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# MainFilterPillView\n\nA compact, pill-shaped filter button component built with UIKit and Combine that provides a quick access point to main filtering functionality. The component features a customizable appearance with filter icons, text labels, selection counters, and interactive feedback.\n\n## Overview\n\nThe `MainFilterPillView` is designed as a prominent filter entry point, typically positioned in toolbars or navigation areas. It displays filter status through visual indicators and a selection counter badge. The component follows MVVM architecture and uses reactive programming with Combine for state management.\n\n## Architecture\n\n### Component Structure\n```\nMainFilterPillView/\n MainFilterPillView.swift                # Main component view\n MainFilterPillViewModelProtocol.swift   # View model protocol\n MockMainFilterPillViewModel.swift       # Mock implementation\n Models/\n     MainFilterPillViewModels.swift      # Data models\n```\n\n### MVVM Pattern\n- **View**: `MainFilterPillView` - Main UI component with pill-shaped design\n- **ViewModel**: `MainFilterPillViewModelProtocol` - Business logic and state management\n- **Model**: `MainFilterItem` & `MainFilterStateType` - Data structures\n\n## Key Features\n\n### Visual Design\n- **Pill Shape**: Rounded corners with 40pt height for optimal touch targets\n- **Filter Icon**: Customizable filter icon (default: horizontal decrease circle)\n- **Action Arrow**: Right-pointing chevron indicating interactive element\n- **Selection Counter**: Red badge displaying number of active filters\n- **Responsive Layout**: Adapts to content with proper spacing\n\n### Interactive Elements\n- **Full Tap Area**: Entire pill is tappable for better accessibility\n- **Visual Feedback**: Responds to user interaction\n- **Counter Badge**: Shows/hides based on filter selection state\n- **Quick Access**: Direct navigation to main filter interface\n\n### State Management\n- **Filter States**: Not selected vs selected with count\n- **Reactive Updates**: Combine-based state synchronization\n- **Dynamic Counters**: Real-time updates when filters change\n- **Type Safety**: Enum-based filter type system\n\n## Models\n\n### MainFilterItem\n```swift\npublic struct MainFilterItem: Equatable, Hashable {\n    public let type: QuickLinkType\n    public let title: String\n    public let icon: String?\n    public let actionIcon: String?\n}\n```\n\n**Properties:**\n- `type`: Filter type from `QuickLinkType` enum (`.mainFilter`)\n- `title`: Display text (typically \"Filter\")\n- `icon`: Optional custom filter icon name\n- `actionIcon`: Optional custom action icon name\n\n### MainFilterStateType\n```swift\npublic enum MainFilterStateType {\n    case notSelected\n    case selected(selections: String)\n}\n```\n\n**States:**\n- `notSelected`: No filters applied (hides counter)\n- `selected(selections)`: Filters applied with count string\n\n### QuickLinkType Integration\nThe component integrates with the `QuickLinkType` system:\n```swift\npublic enum QuickLinkType: String, Hashable {\n    // ... other types\n    case mainFilter  // Used by MainFilterPillView\n}\n```\n\n## Protocols\n\n### MainFilterPillViewModelProtocol\n```swift\npublic protocol MainFilterPillViewModelProtocol {\n    func didTapMainFilterItem() -> QuickLinkType\n    var mainFilterState: CurrentValueSubject<MainFilterStateType, Never> { get set }\n    var mainFilterSubject: CurrentValueSubject<MainFilterItem, Never> { get }\n}\n```\n\n**Key Methods:**\n- `didTapMainFilterItem()`: Handles tap events and returns filter type\n- `mainFilterState`: Current filter selection state\n- `mainFilterSubject`: Filter item configuration\n\n## Usage Examples\n\n### Basic Implementation\n```swift\nlet mainFilter = MainFilterItem(\n    type: .mainFilter,\n    title: \"Filter\",\n    icon: \"line.3.horizontal.decrease.circle.fill\",\n    actionIcon: \"chevron.right\"\n)\n\nlet viewModel = MockMainFilterPillViewModel(mainFilter: mainFilter)\nlet filterPillView = MainFilterPillView(viewModel: viewModel)\n\n// Handle filter taps\nfilterPillView.onFilterTapped = { filterType in\n    print(\"Filter tapped: \\(filterType)\")\n    // Navigate to filter interface\n}\n```\n\n### Custom ViewModel Implementation\n```swift\nclass CustomMainFilterPillViewModel: MainFilterPillViewModelProtocol {\n    var mainFilterState = CurrentValueSubject<MainFilterStateType, Never>(.notSelected)\n    let mainFilterSubject: CurrentValueSubject<MainFilterItem, Never>\n    \n    init(filterItem: MainFilterItem) {\n        self.mainFilterSubject = CurrentValueSubject(filterItem)\n    }\n    \n    func didTapMainFilterItem() -> QuickLinkType {\n        // Analytics tracking\n        trackFilterButtonTap()\n        \n        return mainFilterSubject.value.type\n    }\n    \n    private func trackFilterButtonTap() {\n        // Custom analytics implementation\n    }\n}\n```\n\n### Integration in Navigation Bar\n```swift\nclass NavigationViewController: UIViewController {\n    private var filterPillView: MainFilterPillView!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupFilterPill()\n    }\n    \n    private func setupFilterPill() {\n        let mainFilter = MainFilterItem(type: .mainFilter, title: \"Filter\")\n        let viewModel = MockMainFilterPillViewModel(mainFilter: mainFilter)\n        \n        filterPillView = MainFilterPillView(viewModel: viewModel)\n        filterPillView.translatesAutoresizingMaskIntoConstraints = false\n        \n        view.addSubview(filterPillView)\n        \n        NSLayoutConstraint.activate([\n            filterPillView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -16),\n            filterPillView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 8)\n        ])\n        \n        filterPillView.onFilterTapped = { [weak self] _ in\n            self?.presentFilterInterface()\n        }\n    }\n    \n    private func presentFilterInterface() {\n        // Present main filter view controller\n    }\n}\n```\n\n### State Management Example\n```swift\nclass FilterCoordinator {\n    private let filterPillView: MainFilterPillView\n    private var activeFiltersCount = 0\n    \n    init(filterPillView: MainFilterPillView) {\n        self.filterPillView = filterPillView\n    }\n    \n    func updateFilterCount(_ count: Int) {\n        activeFiltersCount = count\n        \n        let state: MainFilterStateType = count > 0 \n            ? .selected(selections: \"\\(count)\")\n            : .notSelected\n            \n        filterPillView.setFilterState(filterState: state)\n    }\n    \n    func clearAllFilters() {\n        updateFilterCount(0)\n    }\n}\n```\n\n## Component Behavior\n\n### Visual States\n- **Default State**: Filter icon, \"Filter\" text, chevron arrow\n- **With Selections**: Adds red counter badge with number\n- **No Selections**: Hides counter badge\n- **Interactive**: Responds to taps on entire pill area\n\n### Counter Badge\n- **Position**: Top-right corner with slight overlap\n- **Style**: Red circular badge with white text\n- **Size**: 16x16pt with 8pt corner radius\n- **Typography**: Semibold 10pt font\n- **Visibility**: Shown only when filters are applied\n\n### Layout Behavior\n- **Fixed Height**: 40pt for consistent touch targets\n- **Dynamic Width**: Adapts to content with 8pt padding\n- **Rounded Corners**: Pill shape with height/2 corner radius\n- **Center Alignment**: Vertical centering of all elements\n\n## Styling Integration\n\nThe component integrates with `StyleProvider` for consistent theming:\n\n- **Colors**:\n  - `backgroundColor`: Container background\n  - `highlightPrimary`: Icon and arrow tint color\n  - `textColor`: Label text color\n  - `buttonTextPrimary`: Counter text color\n- **Typography**:\n  - Bold 12pt for filter label\n  - Semibold 10pt for counter text\n- **Icons**:\n  - Default filter icon: `line.3.horizontal.decrease.circle.fill`\n  - Default action icon: `chevron.right`\n\n## Layout Structure\n\n### Component Hierarchy\n```\nMainFilterPillView\n containerView (pill-shaped background)\n     stackView (horizontal layout)\n        filterIconImageView (22x22pt)\n        filterLabel (\"Filter\" text)\n        arrowImageView (18x18pt)\n     counterView (badge overlay)\n         counterLabel (count text)\n```\n\n### Constraints\n- Container: Full bounds with 40pt height\n- Stack: 8pt margins with 4pt spacing\n- Counter: Top-right with slight offset (-4pt top, -4pt trailing)\n- Icons: Fixed sizes for consistent appearance\n\n## Integration Patterns\n\n### With QuickLinksTabBar\n```swift\nclass MainToolbarViewController: UIViewController {\n    private var quickLinksTabBar: QuickLinksTabBarView!\n    private var filterPillView: MainFilterPillView!\n    \n    private func setupToolbar() {\n        // Setup tab bar\n        quickLinksTabBar = QuickLinksTabBarView(viewModel: tabBarViewModel)\n        \n        // Setup filter pill\n        let filterItem = MainFilterItem(type: .mainFilter, title: \"Filter\")\n        let filterViewModel = MockMainFilterPillViewModel(mainFilter: filterItem)\n        filterPillView = MainFilterPillView(viewModel: filterViewModel)\n        \n        // Layout both components\n        layoutToolbarComponents()\n    }\n}\n```\n\n### With Filter State Management\n```swift\nclass FilterStateManager: ObservableObject {\n    @Published var sportsFilters: [Int] = []\n    @Published var leagueFilters: [Int] = []\n    @Published var sortFilters: [Int] = []\n    \n    var totalActiveFilters: Int {\n        sportsFilters.count + leagueFilters.count + sortFilters.count\n    }\n    \n    func updateMainFilterPill(_ pillView: MainFilterPillView) {\n        let state: MainFilterStateType = totalActiveFilters > 0\n            ? .selected(selections: \"\\(totalActiveFilters)\")\n            : .notSelected\n            \n        pillView.setFilterState(filterState: state)\n    }\n}\n```\n\n## Accessibility Features\n\n- **Touch Targets**: 40pt height meets minimum accessibility requirements\n- **Clear Labeling**: Descriptive text and icons\n- **Visual Feedback**: Color and badge changes for state communication\n- **Full Tap Area**: Entire pill is interactive, not just specific elements\n- **Dynamic Type**: Font scaling support through StyleProvider\n\n## SwiftUI Preview Support\n\nThe component includes SwiftUI preview for design-time visualization:\n\n```swift\n@available(iOS 17.0, *)\n#Preview(\"Main Filter View\") {\n    PreviewUIView {\n        let containerView = UIView()\n        containerView.backgroundColor = StyleProvider.Color.highlightPrimary\n        \n        let mainFilter = MainFilterItem(type: .mainFilter, title: \"Filter\")\n        let viewModel = MockMainFilterPillViewModel(mainFilter: mainFilter)\n        let filterView = MainFilterPillView(viewModel: viewModel)\n        \n        // Preview implementation\n    }\n}\n```\n\n## Technical Implementation\n\n### Memory Management\n- Weak references in closures to prevent retain cycles\n- Proper Combine cancellable storage with `Set<AnyCancellable>`\n- Automatic cleanup of gesture recognizers\n\n### Performance Considerations\n- Lightweight UI updates for state changes\n- Efficient constraint management\n- Minimal layout calculations with fixed sizing\n- Optimized for frequent state updates\n\n### Corner Radius Calculation\n- Dynamic corner radius based on container height\n- Updates in `layoutSubviews()` for proper pill shape\n- Maintains rounded appearance across different sizes\n\n## Error Handling\n\n### Defensive Programming\n- Safe unwrapping of optional icons\n- Graceful fallbacks for missing assets\n- Proper state validation\n- Safe type casting and enum handling\n\n## Dependencies\n\n- **UIKit**: Core UI framework and gesture handling\n- **Combine**: Reactive programming and state management\n- **SwiftUI**: Preview support (iOS 17.0+)\n- **StyleProvider**: Internal styling and theming system\n- **Foundation**: Basic data structures\n\n## Best Practices\n\n1. **State Consistency**: Keep filter count in sync with actual applied filters\n2. **Memory Management**: Use weak references in callback closures\n3. **Icon Assets**: Provide fallback icons for missing assets\n4. **Touch Targets**: Maintain 40pt minimum height for accessibility\n5. **Visual Feedback**: Provide clear indication of filter state\n6. **Performance**: Avoid unnecessary state updates during rapid changes\n\n## Usage Scenarios\n\n### Sports Betting Interface\n```swift\n// Toolbar with filter pill for sports betting filters\nlet sportsFilter = MainFilterItem(\n    type: .mainFilter,\n    title: \"Filters\",\n    icon: \"sportscourt.fill\"\n)\n```\n\n### Gaming Platform\n```swift\n// Filter pill for game filters\nlet gameFilter = MainFilterItem(\n    type: .mainFilter,\n    title: \"Game Filters\", \n    icon: \"gamecontroller.fill\"\n)\n```\n\n### E-commerce App\n```swift\n// Product filter pill\nlet productFilter = MainFilterItem(\n    type: .mainFilter,\n    title: \"Filter Products\",\n    icon: \"slider.horizontal.3\"\n)\n```\n\n## Future Enhancements\n\n- Custom color schemes for different themes\n- Animation effects for state transitions\n- Support for multiple counter types (e.g., different colors)\n- Long press gestures for quick filter actions\n- Accessibility voice-over improvements\n- Custom shapes beyond pill design\n- Integration with haptic feedback\n- Badge positioning customization\n- Support for text-only mode without icons\n``` \n",
      "snapshots": []
    },
    "MarketGroupSelectorTabView": {
      "displayName": "MarketGroupSelectorTabView",
      "category": "Betting",
      "subcategory": "MarketSelection",
      "summary": "Horizontal scrollable tab bar for market group selection with multiple layout modes",
      "description": "Sophisticated horizontal scrolling tab bar for selecting betting market groups in sports betting screens. Uses UICollectionViewCompositionalLayout with diffable data source for efficient updates. Supports two layout modes: automatic (tabs sized by content) and stretch (tabs fill available width equally). Features customizable background colors for bar and individual items (idle/selected states), auto-scroll to selected tab, selection event publisher for analytics, haptic feedback on selection (selectionChanged), loading state with centered activity indicator, and empty state with centered label. Each tab is a MarketGroupTabItemView showing market name with optional icon/badge. Includes programmatic selection via selectMarketGroup(id:), scrollToTab(id:animated:) for manual navigation, and scroll progress tracking (0.0-1.0). Minimum height 42pt, 16pt horizontal padding, 8pt vertical padding, 1pt tab spacing, 8pt corner radius. Heavily used in production across MyBets, InPlayEvents, SportsSearch, MatchDetails, NextUpEvents, and TransactionHistory screens.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "market",
        "group",
        "tabs",
        "selector",
        "scrollable",
        "horizontal",
        "layout",
        "betting",
        "selection",
        "haptic"
      ],
      "states": [
        "standard-sports-markets",
        "limited-markets",
        "mixed-state-markets",
        "empty",
        "loading",
        "disabled",
        "category-tabs"
      ],
      "similarTo": [
        "PillSelectorBarView",
        "BetslipTypeSelectorView",
        "AdaptiveTabBarView"
      ],
      "oftenUsedWith": [
        "MarketGroupTabItemView",
        "StatisticsWidgetView"
      ],
      "parents": [
        "StatisticsWidgetView"
      ],
      "children": [
        "MarketGroupTabItemView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# MarketGroupSelectorTabView\n\nA reusable horizontal scrollable tab bar component for displaying and managing multiple market group options in a betting interface. This container component automatically creates and manages `MarketGroupTabItemView` instances with coordinated selection handling.\n\n## Features\n\n- **Horizontal Scrolling**: Automatically scrolls when content exceeds view width\n- **Dynamic Content**: Supports adding, removing, and updating market groups\n- **Selection Coordination**: Ensures only one tab is selected at a time\n- **Visual States**: Loading, empty, disabled, and idle states with smooth transitions\n- **Accessibility**: Full VoiceOver support with proper navigation\n- **Selection Events**: Publishes selection changes with detailed event information\n- **Auto-scrolling**: Automatically scrolls to newly selected tabs\n\n## Visual States\n\n### Idle State\n- Normal interactive state with tabs visible\n- Horizontal scrolling enabled\n- Full user interaction\n\n### Loading State\n- Shows activity indicator\n- Hides tab content\n- Non-interactive during loading\n\n### Empty State\n- Shows \"No market groups available\" message\n- Hides scrolling content\n- Non-interactive\n\n### Disabled State\n- Shows tabs with reduced opacity (60%)\n- Disables all user interaction\n- Maintains visual layout\n\n## Usage\n\n### Basic Implementation\n\n```swift\n\n\n// Create a view model\nlet viewModel = MockMarketGroupSelectorTabViewModel.standardSportsMarkets\n\n// Create the tab view\nlet tabSelectorView = MarketGroupSelectorTabView(viewModel: viewModel)\n\n// Add to your view hierarchy\nparentView.addSubview(tabSelectorView)\n```\n\n### Handling Selection Events\n\n```swift\nviewModel.selectionEventPublisher\n    .sink { selectionEvent in\n        print(\"Selected: \\(selectionEvent.selectedId)\")\n        print(\"Previously selected: \\(selectionEvent.previouslySelectedId ?? \"None\")\")\n        // Handle market group change\n        loadContentForMarketGroup(selectionEvent.selectedId)\n    }\n    .store(in: &cancellables)\n```\n\n### Dynamic Market Group Management\n\n```swift\n// Add a new market group\nlet newMarketGroup = MarketGroupTabItemData(\n    id: \"new_market\",\n    title: \"New Market\",\n    visualState: .idle\n)\nviewModel.addMarketGroup(newMarketGroup)\n\n// Remove a market group\nviewModel.removeMarketGroup(id: \"unwanted_market\")\n\n// Update an existing market group\nlet updatedMarketGroup = MarketGroupTabItemData(\n    id: \"existing_id\",\n    title: \"Updated Title\",\n    visualState: .disabled\n)\nviewModel.updateMarketGroup(updatedMarketGroup)\n\n// Replace all market groups\nlet newMarketGroups = [/* new market group array */]\nviewModel.updateMarketGroups(newMarketGroups)\n```\n\n### Programmatic Selection\n\n```swift\n// Select a specific market group\nviewModel.selectMarketGroup(id: \"over_under\")\n\n// Clear selection\nviewModel.clearSelection()\n\n// Select first available market group\nviewModel.selectFirstAvailableMarketGroup()\n```\n\n### State Management\n\n```swift\n// Set loading state\nviewModel.setLoading(true)\n\n// Enable/disable the entire component\nviewModel.setEnabled(false)\n\n// Set custom visual state\nviewModel.setVisualState(.empty)\n```\n\n### Scrolling Control\n\n```swift\n// Scroll to a specific tab\ntabSelectorView.scrollToTab(id: \"target_tab\", animated: true)\n\n// Get current scroll progress (0.0 - 1.0)\nlet progress = tabSelectorView.scrollProgress\n```\n\n## Component Architecture\n\n### Container Data Model\n\n```swift\npublic struct MarketGroupSelectorTabData: Equatable, Hashable {\n    public let id: String                                    // Unique identifier\n    public let marketGroups: [MarketGroupTabItemData]        // Array of tab items\n    public let selectedMarketGroupId: String?                // Currently selected tab\n    public let visualState: MarketGroupSelectorTabVisualState\n}\n```\n\n### Visual State Enum\n\n```swift\npublic enum MarketGroupSelectorTabVisualState: Equatable {\n    case idle               // Normal state with tabs available\n    case loading            // Loading state while fetching market groups\n    case empty              // No market groups available\n    case disabled           // All tabs disabled/non-interactive\n}\n```\n\n### Selection Event Model\n\n```swift\npublic struct MarketGroupSelectionEvent: Equatable {\n    public let selectedId: String              // Newly selected tab ID\n    public let previouslySelectedId: String?   // Previously selected tab ID\n    public let timestamp: Date                 // When the selection occurred\n}\n```\n\n### Protocol Interface\n\n```swift\npublic protocol MarketGroupSelectorTabViewModelProtocol {\n    // Content publishers\n    var marketGroupsPublisher: AnyPublisher<[MarketGroupTabItemData], Never> { get }\n    var selectedMarketGroupIdPublisher: AnyPublisher<String?, Never> { get }\n    \n    // State management\n    var visualStatePublisher: AnyPublisher<MarketGroupSelectorTabVisualState, Never> { get }\n    var currentVisualState: MarketGroupSelectorTabVisualState { get }\n    \n    // Selection events\n    var selectionEventPublisher: AnyPublisher<MarketGroupSelectionEvent, Never> { get }\n    \n    // Actions\n    func selectMarketGroup(id: String)\n    func updateMarketGroups(_ marketGroups: [MarketGroupTabItemData])\n    func addMarketGroup(_ marketGroup: MarketGroupTabItemData)\n    func removeMarketGroup(id: String)\n    func updateMarketGroup(_ marketGroup: MarketGroupTabItemData)\n    \n    // Convenience methods\n    func clearSelection()\n    func selectFirstAvailableMarketGroup()\n    func setEnabled(_ enabled: Bool)\n    func setLoading(_ loading: Bool)\n}\n```\n\n## Layout and Styling\n\n### Constants\n\n- **Horizontal Padding**: 16pt\n- **Vertical Padding**: 8pt\n- **Tab Item Spacing**: 8pt\n- **Corner Radius**: 8pt\n- **Animation Duration**: 0.3s\n- **Minimum Height**: 50pt\n\n### Scrolling Behavior\n\n- **Horizontal Only**: Vertical scrolling disabled\n- **Auto-scroll**: Automatically scrolls to selected tabs\n- **No Scroll Indicators**: Clean appearance without scroll bars\n- **Content Inset**: Managed automatically\n\n## Accessibility\n\n### VoiceOver Support\n\n- **Container**: Not an accessibility element itself\n- **Navigation**: Properly ordered tab item accessibility elements\n- **States**: Each tab item announces its current state\n- **Selection**: Clear feedback when selection changes\n\n### Dynamic Type Support\n\nAll text elements respect user's preferred text size through StyleProvider integration.\n\n## Available Mock Configurations\n\n### Predefined Configurations\n\n```swift\nMockMarketGroupSelectorTabViewModel.standardSportsMarkets    // Standard 4-tab layout\nMockMarketGroupSelectorTabViewModel.limitedMarkets           // Minimal 2-tab layout  \nMockMarketGroupSelectorTabViewModel.mixedStateMarkets        // Includes disabled tabs\nMockMarketGroupSelectorTabViewModel.emptyMarkets             // Empty state\nMockMarketGroupSelectorTabViewModel.loadingMarkets           // Loading state\nMockMarketGroupSelectorTabViewModel.disabledMarkets          // All tabs disabled\n```\n\n### Custom Factory\n\n```swift\nMockMarketGroupSelectorTabViewModel.customMarkets(\n    id: \"unique_id\",\n    marketGroups: [/* your market groups */],\n    selectedMarketGroupId: \"selected_tab_id\"\n)\n```\n\n### Collections for Testing\n\n```swift\nMockMarketGroupSelectorTabViewModel.allDemoConfigurations   // All predefined configs\n```\n\n## Integration with Individual Tab Items\n\nThis component automatically creates and manages `MarketGroupTabItemView` instances:\n\n- **Automatic Creation**: Creates tab item views from data models\n- **Selection Coordination**: Ensures mutual exclusivity of selection\n- **Event Forwarding**: Routes individual tap events to container selection logic\n- **State Synchronization**: Keeps individual item states in sync with container state\n\n## Performance Considerations\n\n### Memory Management\n\n- **Automatic Cleanup**: Removes and deallocates tab views when updating content\n- **Reference Management**: Properly manages view model references to prevent retain cycles\n- **Combine Subscriptions**: Automatically manages cancellables for memory safety\n\n### Rendering Optimization\n\n- **Lazy Loading**: Tab items created only when needed\n- **Smooth Animations**: Uses optimized animation blocks for state transitions\n- **Scroll Performance**: Efficient horizontal scrolling with proper content sizing\n\n## Error Handling\n\n### Selection Validation\n\n- **Disabled Tabs**: Prevents selection of disabled market groups\n- **Missing Tabs**: Gracefully handles attempts to select non-existent tabs\n- **State Consistency**: Maintains consistent selection state even with dynamic content\n\n### Edge Cases\n\n- **Empty Arrays**: Handles empty market group arrays gracefully\n- **Duplicate IDs**: Automatically handles duplicate market group IDs\n- **Rapid Updates**: Manages rapid state changes without visual glitches\n\n## SwiftUI Preview Support\n\nThe component includes comprehensive SwiftUI previews for development:\n\n```swift\n#if DEBUG\nMarketGroupSelectorTabView_Previews.previews\n#endif\n```\n\nIncludes previews for:\n- Standard market configurations\n- Mixed state demonstrations\n- Loading and empty states\n- Different market group combinations\n\n## Best Practices\n\n### Selection Management\n\n```swift\n// Good: Use selection events for coordination\nviewModel.selectionEventPublisher\n    .sink { event in\n        updateContentForMarketGroup(event.selectedId)\n    }\n    .store(in: &cancellables)\n\n// Avoid: Directly accessing current selection repeatedly\n// let currentSelection = viewModel.currentSelectedMarketGroupId\n```\n\n### Dynamic Updates\n\n```swift\n// Good: Use atomic updates for multiple changes\nlet newMarketGroups = buildNewMarketGroupArray()\nviewModel.updateMarketGroups(newMarketGroups)\n\n// Avoid: Multiple individual updates\n// viewModel.addMarketGroup(group1)\n// viewModel.addMarketGroup(group2)  // Creates multiple animations\n```\n\n### State Transitions\n\n```swift\n// Good: Use convenience methods for common patterns\nviewModel.setLoading(true)\nloadMarketGroups { groups in\n    viewModel.updateMarketGroups(groups)\n    viewModel.setLoading(false)\n    viewModel.selectFirstAvailableMarketGroup()\n}\n``` \n",
      "snapshots": []
    },
    "MarketGroupTabItemView": {
      "displayName": "MarketGroupTabItemView",
      "category": "Betting",
      "subcategory": "MarketSelection",
      "summary": "Individual market group tab item with title, icons, badge, and selection underline",
      "description": "Single tab item for market group selection within MarketGroupSelectorTabView. Displays centered title label with optional prefix and suffix icons (via pluggable MarketGroupTabImageResolver), and optional circular badge counter (16pt, primary highlight background). Two visual states: idle (textPrimary color, regular font) and selected (highlightPrimary color, medium font, 2pt underline indicator). Animated state transitions (0.2s) with haptic feedback (light impact) on tap. Customizable idle/selected background colors at initialization. Icon tinting changes with selection state. Uses intrinsic content size for self-sizing in collection views. Tab tap emits ID via onTapPublisher. DefaultMarketGroupTabImageResolver provides system icons for betbuilder, popular, sets, games, players. Layout: 16pt horizontal padding, 2pt vertical padding, 42pt minimum height, 4pt stack spacing, 14pt icons. Used in production with custom AppMarketGroupTabImageResolver and MyBetsTabsImageResolver.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "tab",
        "item",
        "market",
        "group",
        "icon",
        "badge",
        "underline",
        "selectable",
        "haptic"
      ],
      "states": [
        "idle",
        "selected"
      ],
      "similarTo": [
        "PillItemView",
        "BetslipTypeTabItemView"
      ],
      "oftenUsedWith": [
        "MarketGroupSelectorTabView"
      ],
      "parents": [
        "MarketGroupSelectorTabView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# MarketGroupTabItemView\n\nA reusable tab item component for displaying individual market group options in a betting interface. Each tab item can display a title and visual state (idle, selected, or disabled) with smooth animations and proper accessibility support.\n\n## Features\n\n- **Visual States**: Supports idle, selected, and disabled states with smooth transitions\n- **Interactive**: Handles tap gestures with haptic feedback\n- **Accessible**: Full VoiceOver support with appropriate traits and hints\n- **Customizable**: Uses StyleProvider for consistent theming\n- **Responsive**: Calculates intrinsic content size based on content\n\n## Visual States\n\n### Idle State\n- Normal unselected appearance\n- Secondary text color\n- Regular font weight\n- No underline indicator\n- Fully interactive\n\n### Selected State\n- Primary text color indicating selection\n- Medium font weight for emphasis\n- Colored underline indicator\n- Fully interactive\n\n### Disabled State\n- Reduced opacity (60%)\n- Muted text color\n- No underline indicator\n- Non-interactive\n\n## Usage\n\n### Basic Implementation\n\n```swift\n\n\n// Create a view model\nlet viewModel = MockMarketGroupTabItemViewModel.oneXTwoTab\n\n// Create the view\nlet tabItemView = MarketGroupTabItemView(viewModel: viewModel)\n\n// Add to your view hierarchy\nparentView.addSubview(tabItemView)\n```\n\n### Using Factory Methods\n\n```swift\n// Predefined market types\nlet oneXTwoTab = MarketGroupTabItemView(viewModel: MockMarketGroupTabItemViewModel.oneXTwoTab)\nlet doubleChanceTab = MarketGroupTabItemView(viewModel: MockMarketGroupTabItemViewModel.doubleChanceTab)\nlet overUnderTab = MarketGroupTabItemView(viewModel: MockMarketGroupTabItemViewModel.overUnderTab)\n\n// Custom tab\nlet customTab = MarketGroupTabItemView(\n    viewModel: MockMarketGroupTabItemViewModel.customTab(\n        id: \"custom_market\",\n        title: \"Custom Market\",\n        selected: false\n    )\n)\n```\n\n### Handling Selection Events\n\n```swift\nviewModel.onTapPublisher\n    .sink { tabId in\n        print(\"Tab tapped: \\(tabId)\")\n        // Handle tab selection\n    }\n    .store(in: &cancellables)\n```\n\n### Dynamic State Changes\n\n```swift\n// Change selection state\nviewModel.setSelected(true)\n\n// Disable the tab\nviewModel.setEnabled(false)\n\n// Update the title\nviewModel.updateTitle(\"New Market Name\")\n\n// Set custom visual state\nviewModel.setVisualState(.error(\"Market unavailable\"))\n```\n\n## Component Architecture\n\n### Data Model\n\n```swift\npublic struct MarketGroupTabItemData: Equatable, Hashable {\n    public let id: String           // Unique identifier\n    public let title: String        // Display text\n    public let visualState: MarketGroupTabItemVisualState\n}\n```\n\n### Visual State Enum\n\n```swift\npublic enum MarketGroupTabItemVisualState: Equatable {\n    case idle           // Normal unselected state\n    case selected       // Tab is currently selected\n    case disabled       // Tab is disabled and non-interactive\n}\n```\n\n### Protocol Interface\n\n```swift\npublic protocol MarketGroupTabItemViewModelProtocol {\n    // Content publishers\n    var titlePublisher: AnyPublisher<String, Never> { get }\n    var idPublisher: AnyPublisher<String, Never> { get }\n    \n    // Visual state management\n    var visualStatePublisher: AnyPublisher<MarketGroupTabItemVisualState, Never> { get }\n    var currentVisualState: MarketGroupTabItemVisualState { get }\n    \n    // User interaction\n    var onTapPublisher: AnyPublisher<String, Never> { get }\n    func handleTap()\n    \n    // State management\n    func setVisualState(_ state: MarketGroupTabItemVisualState)\n    func setSelected(_ selected: Bool)\n    func setEnabled(_ enabled: Bool)\n    func updateTitle(_ title: String)\n}\n```\n\n## Styling\n\nThe component uses StyleProvider for consistent theming:\n\n```swift\n// Selected state styling\ntitleLabel.textColor = StyleProvider.Color.highlightPrimary\ntitleLabel.font = StyleProvider.fontWith(type: .medium, size: 14)\nunderlineView.backgroundColor = StyleProvider.Color.highlightPrimary\n\n// Idle state styling\ntitleLabel.textColor = StyleProvider.Color.highlightSecondary\ntitleLabel.font = StyleProvider.fontWith(type: .regular, size: 14)\n\n// Disabled state styling\ntitleLabel.textColor = StyleProvider.Color.highlightSecondary.withAlphaComponent(0.5)\nalpha = 0.6\n```\n\n## Layout and Sizing\n\n### Constants\n\n- **Horizontal Padding**: 16pt\n- **Vertical Padding**: 12pt\n- **Underline Height**: 2pt\n- **Corner Radius**: 8pt\n- **Animation Duration**: 0.2s\n\n### Intrinsic Content Size\n\nThe component automatically calculates its size based on:\n- Title label content size\n- Horizontal and vertical padding\n- Underline indicator height\n\n## Accessibility\n\n### VoiceOver Support\n\n- **Accessibility Element**: Yes\n- **Accessibility Traits**: Button (+ selected/notEnabled when applicable)\n- **Accessibility Label**: Uses the tab title\n- **Accessibility Hints**: State-specific guidance\n\n### Dynamic Type Support\n\nThe component respects user's preferred text size through StyleProvider font system.\n\n## Available Mock Data\n\n### Predefined Tabs\n\n```swift\nMockMarketGroupTabItemViewModel.oneXTwoTab          // \"1x2\" (selected)\nMockMarketGroupTabItemViewModel.doubleChanceTab     // \"Double Chance\" (idle)\nMockMarketGroupTabItemViewModel.overUnderTab        // \"Over/Under\" (idle)\nMockMarketGroupTabItemViewModel.anotherMarketTab    // \"Another market\" (idle)\nMockMarketGroupTabItemViewModel.disabledTab         // \"Disabled\" (disabled)\n```\n\n### Collections\n\n```swift\nMockMarketGroupTabItemViewModel.standardMarketTabs  // [1x2, Double Chance, Over/Under, Another market]\nMockMarketGroupTabItemViewModel.mixedStateTabs      // Mixed states including disabled\n```\n\n### Custom Factory\n\n```swift\nMockMarketGroupTabItemViewModel.customTab(\n    id: \"unique_id\",\n    title: \"Custom Title\",\n    selected: false\n)\n```\n\n## Integration with MarketGroupSelectorTabView\n\nThis component is designed to be used within `MarketGroupSelectorTabView` for creating complete tab bar interfaces:\n\n```swift\nlet tabBar = MarketGroupSelectorTabView(viewModel: tabBarViewModel)\n// TabBar automatically creates and manages MarketGroupTabItemView instances\n```\n\n## SwiftUI Preview Support\n\nThe component includes comprehensive SwiftUI previews for development:\n\n- Individual state previews\n- Multiple tab layout preview\n- Interactive state demonstrations\n\n```swift\n#if DEBUG\nMarketGroupTabItemView_Previews.previews\n#endif\n``` \n",
      "snapshots": []
    },
    "MarketInfoLineView": {
      "displayName": "MarketInfoLineView",
      "category": "Betting",
      "subcategory": "MarketDisplay",
      "summary": "Market information line with name pill, feature icons, and market count",
      "description": "Horizontal line displaying market information in sports betting interfaces. Shows market name in a pill label (left, truncates for long names via MarketNamePillLabelView child), feature icons (middle, horizontal stack with 4pt spacing), and market count (right, '+count' format in highlightPrimary color with semibold 12pt font). Supports 4 icon types: expressPickShort, mostPopular, statistics, and betBuilder (15pt height each). Fixed 17pt line height with minimum 16pt spacing between pill and icons. Icons have compression resistance priority to maintain visibility. Includes cleanupForReuse() and configure(with:) methods for efficient cell reuse. Uses displayStatePublisher and marketNamePillViewModelPublisher for reactive updates. Parent component is TallOddsMatchCardView. Has comprehensive snapshot tests covering default, many-icons, no-icons, no-count, and long-name variants.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "market",
        "info",
        "pill",
        "icons",
        "count",
        "betting",
        "line",
        "truncation"
      ],
      "states": [
        "default-with-icons",
        "many-icons",
        "no-icons",
        "no-count",
        "long-market-name"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "TallOddsMatchCardView",
        "MarketNamePillLabelView"
      ],
      "parents": [
        "TallOddsMatchCardView"
      ],
      "children": [
        "MarketNamePillLabelView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# MarketInfoLineView\n\nA **Tier 2 interactive component** that displays betting market information in a horizontal layout with market name pill, market count, and info icons.\n\n## Overview\n\nThe `MarketInfoLineView` combines three key elements:\n- **MarketNamePillLabelView** - Market name in pill format (left side)\n- **Market Count Label** - \"+1235\" format showing available markets (right side)\n- **Info Icons** - Visual indicators (EP, Popular, Stats, etc.) (right side)\n\n## Architecture\n\n### Component Structure\n```\nMarketInfoLineView (Horizontal StackView)\n MarketNamePillLabelView (market pill)\n Right Content StackView\n     Market Count Label (+1235)\n     Icons StackView\n         Icon 1 (EP)\n         Icon 2 (Popular)\n         Icon 3 (Stats)\n```\n\n### MVVM Pattern\n- **Protocol**: `MarketInfoLineViewModelProtocol`\n- **View**: `MarketInfoLineView`\n- **Mock**: `MockMarketInfoLineViewModel`\n\n## Usage\n\n### Basic Implementation\n\n```swift\n\n\n// Create market info data\nlet marketInfo = MarketInfoData(\n    marketName: \"1X2 TR\",\n    marketCount: 1235,\n    icons: [\n        MarketInfoIcon(iconName: \"erep_short_info\", isVisible: true),\n        MarketInfoIcon(iconName: \"most_popular_info\", isVisible: true),\n        MarketInfoIcon(iconName: \"stats_info\", isVisible: true)\n    ]\n)\n\n// Create view model\nlet viewModel = MockMarketInfoLineViewModel(marketInfoData: marketInfo)\n\n// Create view\nlet marketInfoView = MarketInfoLineView(viewModel: viewModel)\n```\n\n### Tap Handling\n\n```swift\n// Add tap gesture to the view\nlet tapGesture = UITapGestureRecognizer(target: self, action: #selector(marketInfoTapped))\nmarketInfoView.addGestureRecognizer(tapGesture)\nmarketInfoView.isUserInteractionEnabled = true\n```\n\n## Data Models\n\n### MarketInfoData\nMain data structure for the component:\n\n```swift\npublic struct MarketInfoData: Equatable, Hashable {\n    public let marketName: String     // \"1X2 TR\"\n    public let marketCount: Int       // 1235\n    public let icons: [MarketInfoIcon] // Info icons array\n}\n```\n\n### MarketInfoIcon\nIndividual icon configuration:\n\n```swift\npublic struct MarketInfoIcon: Equatable, Hashable {\n    public let iconName: String  // Asset name\n    public let isVisible: Bool   // Show/hide flag\n}\n```\n\n### MarketInfoLineDisplayState\nComputed display state:\n\n```swift\npublic struct MarketInfoLineDisplayState: Equatable {\n    public let marketName: String           // Pill text\n    public let marketCountText: String      // \"+1235\" format\n    public let visibleIcons: [MarketInfoIcon] // Filtered icons\n    public let shouldShowMarketCount: Bool  // Hide if count = 0\n}\n```\n\n## Available Icons\n\nLocated in `Resources/Icons.xcassets/info_card_line/`:\n\n### Standard Icons\n- **`erep_short_info`** - EP (Express Pick) indicator\n- **`most_popular_info`** - Popular markets indicator  \n- **`stats_info`** - Statistics available indicator\n- **`bet_builder_info`** - Bet Builder available indicator\n\n### Icon Specifications\n- **Size**: 20x20 points\n- **Format**: PNG with @2x and @3x variants\n- **Style**: Consistent with app design system\n\n## Layout & Spacing\n\n### Horizontal Layout\n```\n[MarketPill] 8pt [CountLabel] 8pt [Icon1] 4pt [Icon2] 4pt [Icon3]\n```\n\n### Spacing Configuration\n- **Main spacing**: 8pt between pill and right content\n- **Icon spacing**: 4pt between individual icons\n- **Label spacing**: 8pt between count and icons\n\n### Content Priorities\n- **Market Pill**: High compression resistance (always visible)\n- **Right Content**: Low compression resistance (can compress)\n- **Count Label**: High hugging priority (tight fit)\n\n## Mock Data\n\n### Available Mocks\n\n#### Default Mock\n```swift\nlet viewModel = MockMarketInfoLineViewModel.defaultMock\n```\n- Market: \"1X2 TR\"\n- Count: 1235 markets\n- Icons: EP, Popular, Stats\n\n#### Many Icons Mock\n```swift\nlet viewModel = MockMarketInfoLineViewModel.manyIconsMock\n```\n- Market: \"Both Teams To Score\"\n- Count: 2340 markets\n- Icons: EP, Popular, Stats, Bet Builder\n\n#### No Icons Mock\n```swift\nlet viewModel = MockMarketInfoLineViewModel.noIconsMock\n```\n- Market: \"Over/Under Goals\"\n- Count: 567 markets\n- Icons: None\n\n#### No Count Mock\n```swift\nlet viewModel = MockMarketInfoLineViewModel.noCountMock\n```\n- Market: \"Match Winner\"\n- Count: 0 (hidden)\n- Icons: Popular only\n\n## Integration with MarketNamePillLabelView\n\n### Dynamic Pill Updates\nThe component creates and manages its own `MarketNamePillLabelView`:\n\n```swift\n// View model provides pill configuration\nvar marketNamePillViewModelPublisher: AnyPublisher<MarketNamePillLabelViewModelProtocol, Never> { get }\n\n// Pill configuration for market info\nlet pillData = MarketNamePillData(\n    id: \"market_info_pill\",\n    text: marketInfoData.marketName,\n    style: .highlighted,           // Orange style\n    showFadingLine: true,         // Extends to right\n    isLoading: false,             // No loading state\n    isInteractive: false          // Read-only\n)\n```\n\n### Pill Styling\n- **Style**: Always highlighted (orange)\n- **Fading Line**: Always enabled (extends to right side)\n- **Interactive**: Disabled (handled by parent tap)\n\n## Responsive Behavior\n\n### Content Compression\nWhen space is limited:\n1. **Icons compress first** (may become clipped)\n2. **Count label compresses** (text may truncate)\n3. **Market pill maintains size** (highest priority)\n\n### Dynamic Visibility\n- **Count label hides** when `marketCount = 0`\n- **Icons filter** based on `isVisible` property\n- **Empty states** handle gracefully\n\n## Testing & Previews\n\n### SwiftUI Previews\nMultiple preview configurations:\n\n```swift\n#Preview(\"Default\") {\n    PreviewUIView {\n        MarketInfoLineView(viewModel: MockMarketInfoLineViewModel.defaultMock)\n    }\n    .frame(height: 40)\n}\n\n#Preview(\"Many Icons\") {\n    PreviewUIView {\n        MarketInfoLineView(viewModel: MockMarketInfoLineViewModel.manyIconsMock)\n    }\n    .frame(height: 40)\n}\n```\n\n## Best Practices\n\n### Icon Management\n```swift\n// Good: Use provided icon names\nMarketInfoIcon(iconName: \"erep_short_info\", isVisible: true)\n\n// Good: Conditional visibility\nMarketInfoIcon(iconName: \"stats_info\", isVisible: hasStats)\n\n// Avoid: Hardcoded icon paths\nMarketInfoIcon(iconName: \"custom_icon\", isVisible: true) // May not exist\n```\n\n### Market Count Formatting\n```swift\n// Automatic formatting in view model\nmarketCount: 1235  \"+1235\"\nmarketCount: 0     hidden\nmarketCount: 99    \"+99\"\n```\n\n### Performance\n- **Lazy icon creation**: Icons created only when visible\n- **Efficient updates**: Only visible elements recreated\n- **Memory management**: Icons removed when hidden\n\n## Common Use Cases\n\n### In Match Cards\n```swift\n// Part of PreLiveMatchCardView\nlet marketInfoView = MarketInfoLineView(viewModel: marketInfoViewModel)\n// Positioned between participants and outcomes\n```\n\n### In Market Lists\n```swift\n// Header for market groups\nlet marketInfoView = MarketInfoLineView(viewModel: marketHeaderViewModel)\n// Provides context for following outcome lists\n```\n\n### In Betslip\n```swift\n// Market summary in betslip items\nlet marketInfoView = MarketInfoLineView(viewModel: betslipMarketViewModel)\n// Shows market type and available alternatives\n```\n\n## Accessibility\n\n### Voice Over Support\n- **Market pill**: Announces market name\n- **Count label**: Announces available market count\n- **Icons**: Individual accessibility labels for each icon type\n\n### Semantic Configuration\n```swift\n// Accessibility labels for icons\nerep_short_info: \"Express Pick available\"\nmost_popular_info: \"Popular market\"\nstats_info: \"Statistics available\"\nbet_builder_info: \"Bet Builder available\"\n```\n\n## Troubleshooting\n\n### Common Issues\n\n#### Icons Not Displaying\n**Cause**: Icon name doesn't match asset bundle\n**Solution**: Verify icon exists in `Resources/Icons.xcassets/info_card_line/`\n\n#### Layout Compression Issues\n**Cause**: Incorrect constraint priorities\n**Solution**: Ensure market pill has highest compression resistance\n\n#### Count Not Updating\n**Cause**: View model not publishing new display state\n**Solution**: Check `publishNewState()` is called after data changes\n\n## Future Enhancements\n\n### Interactive Icons\n- Individual icon tap handling\n- Icon-specific actions\n- Tooltip/popover support\n\n### Animation Support\n- Count change animations\n- Icon appearance transitions\n- Pill style transitions\n\n### Customization\n- Icon size configuration\n- Spacing customization\n- Color theme support\n",
      "snapshots": [
        {
          "category": "InfoVariants",
          "light": "MarketInfoLineView/__Snapshots__/MarketInfoLineViewSnapshotTests/testMarketInfoLineView_InfoVariants_Light.1.png",
          "dark": "MarketInfoLineView/__Snapshots__/MarketInfoLineViewSnapshotTests/testMarketInfoLineView_InfoVariants_Dark.1.png"
        }
      ]
    },
    "MarketNamePillLabelView": {
      "displayName": "MarketNamePillLabelView",
      "category": "Betting",
      "subcategory": "MarketDisplay",
      "summary": "Pill-shaped label for market names with trailing fading line",
      "description": "Compact pill-shaped container displaying market names in betting interfaces. Features rounded border (1.2pt width, fully rounded via height/2 corner radius) with trailing horizontal fading line (FadingView child, 20pt width, 1.2pt height). Supports 4 visual styles: standard (highlightPrimary border/text), highlighted (highlightPrimary with 10% alpha background), disabled (50% alpha secondary colors), and custom (fully configurable UIColors). Interactive mode enables tap gesture with scale animation (0.95x spring), subtle shadow effect (0.1 opacity, 1pt offset, 2pt radius), and onInteraction callback. Text uses medium 10pt font, centered, with 6pt horizontal and 2pt vertical padding. Dynamic style updates via displayStatePublisher. Used as child of MarketInfoLineView for market name display.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "pill",
        "label",
        "market",
        "name",
        "fading",
        "line",
        "betting",
        "interactive",
        "animated"
      ],
      "states": [
        "standard",
        "highlighted",
        "disabled",
        "custom",
        "interactive"
      ],
      "similarTo": [
        "PillItemView"
      ],
      "oftenUsedWith": [
        "MarketInfoLineView",
        "FadingView"
      ],
      "parents": [
        "MarketInfoLineView"
      ],
      "children": [
        "FadingView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# MarketNamePillLabelView\n\nA pill-shaped label component designed specifically for displaying betting market names in sports betting applications. Provides a clean, modern appearance with customizable styling, optional fading line extension, and interactive capabilities.\n\n## Features\n\n- **Multiple Visual Styles**: Standard, highlighted, disabled, and fully customizable styling options\n- **Interactive Support**: Tap-to-select functionality with visual feedback and animations\n- **Loading States**: Built-in loading indicator with smooth transitions\n- **Fading Line Extension**: Optional gradient line extending from the pill for visual hierarchy\n- **Accessibility**: Full accessibility support with proper labels and traits\n- **StyleProvider Integration**: Consistent theming using centralized color and font management\n- **Reactive Updates**: Real-time UI updates via Combine publishers\n\n## Usage Example\n\n### Basic Implementation\n\n```swift\n\n\n// Create market data\nlet marketData = MarketNamePillData(\n    text: \"1X2\",\n    style: .standard,\n    lineConfiguration: .default,\n    isInteractive: false\n)\n\n// Create display state\nlet displayState = MarketNamePillDisplayState(\n    pillData: marketData,\n    isSelected: false,\n    isLoading: false\n)\n\n// Create view model (use your actual implementation)\nlet viewModel = YourMarketPillViewModel(displayState: displayState)\n\n// Create and configure the view\nlet pillView = MarketNamePillLabelView(viewModel: viewModel)\nparentView.addSubview(pillView)\n\n// Setup constraints\nNSLayoutConstraint.activate([\n    pillView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 16),\n    pillView.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor, constant: 20)\n])\n```\n\n### Interactive Market Selection\n\n```swift\nlet interactiveMarket = MarketNamePillData(\n    text: \"Over/Under 2.5\",\n    style: .highlighted,\n    lineConfiguration: .default,\n    isInteractive: true\n)\n\nlet displayState = MarketNamePillDisplayState(\n    pillData: interactiveMarket,\n    isSelected: false,\n    isLoading: false\n)\n\nlet viewModel = MockMarketNamePillLabelViewModel(displayState: displayState)\nlet pillView = MarketNamePillLabelView(viewModel: viewModel)\n\n// Handle market selection\npillView.onInteraction = {\n    print(\"Market selected: Over/Under 2.5\")\n    // Navigate to market details or update selection state\n}\n```\n\n### Custom Styling\n\n```swift\nlet customMarket = MarketNamePillData(\n    text: \"Asian Handicap\",\n    style: .custom(\n        borderColor: .systemPurple,\n        textColor: .systemPurple,\n        backgroundColor: UIColor.systemPurple.withAlphaComponent(0.1)\n    ),\n    lineConfiguration: FadingLineConfiguration(\n        isVisible: true,\n        width: 25,\n        color: .systemPurple\n    ),\n    isInteractive: true\n)\n\nlet viewModel = MockMarketNamePillLabelViewModel(displayState: \n    MarketNamePillDisplayState(pillData: customMarket)\n)\n```\n\n### Using Mock Data for Testing\n\n```swift\n// Use predefined mock examples\nlet pillView1 = MarketNamePillLabelView(viewModel: MockMarketNamePillLabelViewModel.standardPill)\nlet pillView2 = MarketNamePillLabelView(viewModel: MockMarketNamePillLabelViewModel.highlightedPill)\nlet pillView3 = MarketNamePillLabelView(viewModel: MockMarketNamePillLabelViewModel.interactivePill)\n\n// Simulate loading\nMockMarketNamePillLabelViewModel.loadingPill.simulateLoading {\n    print(\"Loading completed\")\n}\n```\n\n## Component Architecture\n\n### Data Models\n\n#### `MarketNamePillData`\nContains all information needed to display a market pill:\n- `text`: The market name text to display\n- `style`: Visual styling (.standard, .highlighted, .disabled, .custom)\n- `lineConfiguration`: Settings for the fading line extension\n- `isInteractive`: Whether the pill can be tapped\n\n#### `MarketNamePillStyle`\nDefines the visual appearance:\n- `.standard`: Default styling with secondary colors\n- `.highlighted`: Emphasized styling with primary colors\n- `.disabled`: Muted styling for inactive markets\n- `.custom`: Fully customizable border, text, and background colors\n\n#### `FadingLineConfiguration`\nControls the line extending from the pill:\n- `isVisible`: Whether to show the line\n- `width`: Line width in points\n- `color`: Line color (uses separator color if nil)\n- `fadeStartLocation`/`fadeEndLocation`: Gradient fade positions\n\n#### `MarketNamePillDisplayState`\nRepresents the complete visual state:\n- `pillData`: The market data and styling\n- `isSelected`: Selection state for interactive pills\n- `isLoading`: Loading state with spinner\n\n### Layout and Sizing\n\nThe component automatically sizes itself based on text content:\n- **Minimum Height**: 20 points\n- **Horizontal Padding**: 6 points on each side\n- **Vertical Padding**: 2 points top and bottom\n- **Rounded Corners**: Calculated as height / 2 for perfect pill shape\n\n## Visual States\n\n### Standard State\n```swift\n// Basic market pill with default styling\nlet standardPill = MockMarketNamePillLabelViewModel.standardPill\n```\n\n### Highlighted State\n```swift\n// Emphasized market with highlight colors\nlet highlightedPill = MockMarketNamePillLabelViewModel.highlightedPill\n```\n\n### Selected State\n```swift\n// Interactive pill in selected state with scale animation\nviewModel.setSelected(true)\n```\n\n### Loading State\n```swift\n// Shows spinner while hiding text\nviewModel.setLoading(true)\n```\n\n### Disabled State\n```swift\n// Muted appearance for inactive markets\nlet disabledPill = MockMarketNamePillLabelViewModel.disabledPill\n```\n\n## Customization Options\n\n### Line Configuration\n```swift\n// Custom line settings\nlet lineConfig = FadingLineConfiguration(\n    isVisible: true,\n    width: 30,\n    color: .systemBlue,\n    fadeStartLocation: 0.2,\n    fadeEndLocation: 0.8\n)\n\n// Hide line completely\nlet hiddenLineConfig = FadingLineConfiguration.hidden\n```\n\n### Interactive Behavior\n```swift\n// Enable interaction\nviewModel.updatePillData(MarketNamePillData(\n    text: \"Both Teams to Score\",\n    style: .standard,\n    lineConfiguration: .default,\n    isInteractive: true\n))\n\n// Handle interactions\npillView.onInteraction = {\n    // Custom interaction handling\n}\n```\n\n### Dynamic Updates\n```swift\n// Update text dynamically\nviewModel.updateText(\"New Market Name\")\n\n// Cycle through styles\nviewModel.cycleStyles()\n\n// Simulate loading\nviewModel.simulateLoading {\n    print(\"Loading finished\")\n}\n```\n\n## Mock View Models\n\nThe component includes comprehensive mock implementations for testing:\n\n### Basic Examples\n- `MockMarketNamePillLabelViewModel.standardPill`: Default appearance\n- `MockMarketNamePillLabelViewModel.highlightedPill`: Emphasized styling\n- `MockMarketNamePillLabelViewModel.disabledPill`: Inactive state\n- `MockMarketNamePillLabelViewModel.interactivePill`: Tappable pill\n- `MockMarketNamePillLabelViewModel.loadingPill`: Loading state\n\n### Real-World Markets\n- `MockMarketNamePillLabelViewModel.winDrawWinMarket`: \"1X2\" market\n- `MockMarketNamePillLabelViewModel.overUnderMarket`: \"Over/Under 2.5\" market\n- `MockMarketNamePillLabelViewModel.handicapMarket`: \"Asian Handicap\" market\n- `MockMarketNamePillLabelViewModel.bothTeamsToScoreMarket`: \"BTTS\" market\n\n### Edge Cases\n- `MockMarketNamePillLabelViewModel.longTextPill`: Test with long market names\n- `MockMarketNamePillLabelViewModel.shortTextPill`: Test with minimal text\n- `MockMarketNamePillLabelViewModel.pillWithoutLine`: No fading line\n- `MockMarketNamePillLabelViewModel.customStyledPill`: Custom colors\n\n## Accessibility\n\nThe component provides full accessibility support:\n- Proper accessibility labels for market names\n- Voice-over descriptions for interactive states\n- Support for accessibility font scaling\n- Appropriate accessibility traits for different states\n\n## Performance Considerations\n\n- **Efficient Updates**: Only renders changed elements when state updates\n- **Memory Management**: Proper cleanup of Combine subscriptions\n- **Layout Optimization**: Auto Layout constraints for smooth animations\n- **Preview Performance**: Lightweight mock data for SwiftUI previews\n\n## Integration with Existing Systems\n\n### Migration from Legacy PillLabelView\nThis component replaces the legacy `PillLabelView` with:\n- Improved data model design with clear separation of concerns\n- Better styling system integration with StyleProvider\n- Reactive programming patterns for state management\n- Enhanced testability with comprehensive mock implementations\n- More flexible customization options\n\n### Best Practices\n- Use `.standard` style for regular markets\n- Use `.highlighted` style for featured or popular markets\n- Use `.disabled` style for unavailable markets\n- Enable `isInteractive` for selectable markets\n- Provide meaningful market names for accessibility\n\n## Testing\n\nThe component includes extensive testing support:\n- Multiple mock scenarios for different market types\n- Edge cases (long names, empty states)\n- State transition testing (loading, selection, styling)\n- Interactive behavior validation\n\nUse the TestCase app to interactively test all component features and states.\n",
      "snapshots": []
    },
    "MarketOutcomesLineView": {
      "displayName": "MarketOutcomesLineView",
      "category": "Betting",
      "subcategory": "Outcomes",
      "summary": "Horizontal line of market outcome items with selection, odds change, and state handling",
      "description": "Horizontal row displaying 2-way or 3-way betting outcomes for a market. Uses OutcomeItemView children arranged in horizontal stack (fill equally distribution, 1pt spacing). Supports 5 display modes: triple (3 outcomes), double (2 outcomes), single (placeholder), suspended (centered text message), and seeAll (tap navigation). Features include outcome selection/deselection with callbacks (onOutcomeSelected, onOutcomeDeselected), live odds change direction indicators (up/down), long press gesture for details, position-based corner radius (first/middle/last), and position overrides for multi-line grid scenarios. Fixed 52pt height. Manages child OutcomeItemViewModels creation and coordinates selection states through parent VM. Reactive updates via marketStatePublisher, oddsChangeEventPublisher, outcomeSelectionDidChangePublisher. Supports betslip synchronization via updateSelectionStates(selectedOfferIds:). Used in production with custom MarketOutcomesLineViewModel and MatchBannerMarketOutcomesLineViewModel.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "outcome",
        "market",
        "line",
        "selection",
        "odds",
        "betting",
        "horizontal",
        "suspended",
        "see-all"
      ],
      "states": [
        "three-way-market",
        "two-way-market",
        "single-placeholder",
        "suspended",
        "see-all",
        "selected-outcome",
        "odds-up",
        "odds-down",
        "disabled-outcome"
      ],
      "similarTo": [
        "MarketOutcomesMultiLineView"
      ],
      "oftenUsedWith": [
        "OutcomeItemView",
        "MarketOutcomesMultiLineView",
        "MatchBannerView",
        "TallOddsMatchCardView"
      ],
      "parents": [
        "MarketOutcomesMultiLineView",
        "MatchBannerView"
      ],
      "children": [
        "OutcomeItemView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# MarketOutcomesLineView\n\nMarketOutcomesLineView is a flexible component designed for displaying betting market outcomes in a horizontal layout. It supports two-way and three-way markets with rich interaction capabilities including selection states, odds change indicators, and various display modes.\n\n## Features\n\n- **Multiple Market Types**: Support for 2-way and 3-way markets\n- **Interactive Selection**: Tap to select/deselect outcomes with visual feedback\n- **Regulatory-Compliant Odds Change Animations**: Automatic odds direction calculation with proper animation timing and interruption handling\n- **Multiple Display Modes**: Normal, suspended, and \"see all\" states\n- **Granular State Management**: Individual property updates for optimal performance\n- **Accessibility Support**: Full VoiceOver support with proper traits\n- **Haptic Feedback**: Success feedback on outcome selection\n\n## Use Cases\n\n- Sports betting outcome selection (1X2, Over/Under, etc.)\n- Market outcome displays in live betting\n- Suspended market notifications\n- \"See all markets\" navigation triggers\n- Any scenario requiring horizontal outcome selection\n\n## Usage Example\n\n### Basic Three-Way Market (1X2)\n\n```swift\n// Create a view model (or use a mock for testing)\nlet viewModel = MockMarketOutcomesLineViewModel.threeWayMarket\n\n// Create the component\nlet marketOutcomesView = MarketOutcomesLineView(viewModel: viewModel)\nmarketOutcomesView.translatesAutoresizingMaskIntoConstraints = false\n\n// Add to your view hierarchy\nparentView.addSubview(marketOutcomesView)\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    marketOutcomesView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 16),\n    marketOutcomesView.trailingAnchor.constraint(equalTo: parentView.trailingAnchor, constant: -16),\n    marketOutcomesView.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor, constant: 16),\n    marketOutcomesView.heightAnchor.constraint(equalToConstant: 40)\n])\n\n// Handle outcome selection\nmarketOutcomesView.onOutcomeSelected = { outcomeType in\n    print(\"Outcome selected: \\(outcomeType)\")\n    // Add to bet slip, update UI, etc.\n}\n\nmarketOutcomesView.onOutcomeDeselected = { outcomeType in\n    print(\"Outcome deselected: \\(outcomeType)\")\n    // Remove from bet slip, update UI, etc.\n}\n\nmarketOutcomesView.onOutcomeLongPress = { outcomeType in\n    print(\"Long press on: \\(outcomeType)\")\n    // Show additional options, quick bet, etc.\n}\n```\n\n### Two-Way Market (Over/Under)\n\n```swift\nlet viewModel = MockMarketOutcomesLineViewModel.twoWayMarket\nlet marketView = MarketOutcomesLineView(viewModel: viewModel)\n\n// The middle outcome will be automatically hidden\n// Only left and right outcomes will be displayed\n```\n\n### Suspended Market\n\n```swift\nlet viewModel = MockMarketOutcomesLineViewModel.suspendedMarket\nlet marketView = MarketOutcomesLineView(viewModel: viewModel)\n\n// Will display \"Market Suspended\" message\n// All outcome interactions are disabled\n```\n\n### Custom Market Configuration\n\n```swift\nlet customViewModel = MockMarketOutcomesLineViewModel.customMarket(\n    displayMode: .normal,\n    leftOutcome: MarketOutcomeData(\n        id: \"home\",\n        title: \"Barcelona\",\n        value: \"1.45\",\n        oddsChangeDirection: .up,\n        isSelected: false,\n        isDisabled: false\n    ),\n    middleOutcome: MarketOutcomeData(\n        id: \"draw\",\n        title: \"Draw\",\n        value: \"4.20\",\n        oddsChangeDirection: .none,\n        isSelected: false,\n        isDisabled: false\n    ),\n    rightOutcome: MarketOutcomeData(\n        id: \"away\",\n        title: \"Real Madrid\",\n        value: \"6.50\",\n        oddsChangeDirection: .down,\n        isSelected: true,\n        isDisabled: false\n    ),\n    showMiddleOutcome: true\n)\n\nlet marketView = MarketOutcomesLineView(viewModel: customViewModel)\n```\n\n## Configuration Options\n\n### MarketOutcomeData Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `id` | String | Unique identifier for the outcome |\n| `title` | String | Display text (e.g., \"Home\", \"Over 2.5\") |\n| `value` | String | Odds value (e.g., \"1.85\", \"2.50\") |\n| `oddsChangeDirection` | OddsChangeDirection | Visual indicator for odds movement |\n| `isSelected` | Bool | Whether the outcome is currently selected |\n| `isDisabled` | Bool | Whether the outcome can be interacted with |\n\n### Display Modes\n\n| Mode | Description |\n|------|-------------|\n| `.triple` | Three-way market with left, middle, and right outcomes |\n| `.double` | Two-way market with left and right outcomes only |\n| `.suspended(text: String)` | Shows custom suspension message, hides outcomes |\n| `.seeAll(text: String)` | Shows custom \"See All\" button for navigation |\n\n### Odds Change Directions\n\n| Direction | Visual Indicator |\n|-----------|------------------|\n| `.up` | Green up arrow |\n| `.down` | Red down arrow |\n| `.none` | No indicator |\n\n## Efficient State Management\n\nThe component uses a streamlined architecture with two publishers:\n\n```swift\n// Single state publisher for all market data\nviewModel.marketStatePublisher\n    .sink { state in\n        // Updates all market data in one efficient operation\n        // Only renders when actual data changes\n    }\n\n// Separate publisher for odds change animations (performance optimization)\nviewModel.oddsChangeEventPublisher\n    .sink { changeEvent in\n        // Triggers animations without re-rendering market data\n    }\n```\n\nThis approach provides optimal performance by:\n- **Single State Update**: All market data updates in one operation\n- **Animation Separation**: Odds change animations don't trigger data re-renders\n- **Smart Diffing**: Only updates UI elements that actually changed\n\n## Available Mock Data\n\n### Predefined Markets\n\n```swift\nMockMarketOutcomesLineViewModel.threeWayMarket      // 1X2 football market\nMockMarketOutcomesLineViewModel.twoWayMarket        // Over/Under market\nMockMarketOutcomesLineViewModel.selectedOutcome     // Market with selection\nMockMarketOutcomesLineViewModel.oddsChanges         // Market with odds movements\nMockMarketOutcomesLineViewModel.disabledOutcome     // Market with disabled outcome\nMockMarketOutcomesLineViewModel.suspendedMarket     // Suspended state\nMockMarketOutcomesLineViewModel.seeAllMarket        // See all state\nMockMarketOutcomesLineViewModel.doubleChanceMarket  // Double chance market\nMockMarketOutcomesLineViewModel.asianHandicapMarket // Asian handicap market\n```\n\n### Custom Factory\n\n```swift\nMockMarketOutcomesLineViewModel.customMarket(\n    displayMode: .normal,\n    leftOutcome: /* your outcome */,\n    middleOutcome: /* your outcome */,\n    rightOutcome: /* your outcome */,\n    showMiddleOutcome: true\n)\n```\n\n## Styling\n\nThe MarketOutcomesLineView uses StyleProvider for consistent theming:\n\n```swift\n// Customize colors\nStyleProvider.Color.customize(\n    primaryColor: UIColor(named: \"BrandPrimary\"),\n    backgroundColor: .systemBackground,\n    textColor: .label,\n    contrastTextColor: .white,\n    secondaryColor: .systemGray,\n    successColor: .systemGreen\n)\n\n// Customize fonts\nStyleProvider.setFontProvider { type, size in\n    // Return custom fonts based on type and size\n}\n```\n\n### Color Usage\n\n- **Primary Color**: Selected outcome background\n- **Background Color**: Unselected outcome background\n- **Text Color**: Outcome text in unselected state\n- **Contrast Text Color**: Outcome text in selected state\n- **Secondary Color**: Suspended state styling\n- **Success Color**: Up arrow indicator color\n\n## Accessibility\n\nThe component includes comprehensive accessibility support:\n\n- Each outcome is exposed as a button element\n- Selection state is properly announced\n- Disabled outcomes have appropriate traits\n- Long press actions are accessible\n- Descriptive labels include both title and odds value\n\n## Integration with Collection Views\n\nFor use in table/collection views:\n\n```swift\n// In cellForRowAt or similar\ncell.marketOutcomesView.cleanupForReuse()\n\nlet viewModel = createViewModelForIndexPath(indexPath)\ncell.marketOutcomesView.configure(with: viewModel)\n\n// Handle selections at cell level\ncell.marketOutcomesView.onOutcomeSelected = { [weak self] outcomeType in\n    self?.handleOutcomeSelection(at: indexPath, outcomeType: outcomeType)\n}\n```\n\n## Performance Considerations\n\n1. **Granular Updates**: Only affected UI elements update when state changes\n2. **Reuse Support**: `cleanupForReuse()` method for collection view cells\n3. **Lazy Loading**: UI elements are created lazily when first accessed\n4. **Efficient Constraints**: Constraints are set up once during initialization\n\n## Best Practices\n\n1. **Use Meaningful IDs**: Provide descriptive IDs for outcomes to enable proper tracking\n2. **Handle All Callbacks**: Implement selection, deselection, and long press handlers\n3. **Consistent Styling**: Use StyleProvider for consistent appearance across the app\n4. **Accessibility**: Test with VoiceOver to ensure proper accessibility\n5. **State Management**: Use the granular publishers for optimal performance\n6. **Error Handling**: Handle cases where outcomes might be nil or disabled\n\n## Advanced Usage\n\n### Dynamic Odds Updates\n\n```swift\n// Enhanced method with automatic direction calculation (recommended)\nviewModel.updateOddsValue(type: .left, newValue: \"1.95\")\nviewModel.updateOddsValue(type: .right, newValue: \"4.10\")\n\n// Legacy method for manual direction specification (for testing)\nviewModel.updateOddsValue(type: .left, value: \"1.95\", changeDirection: .up)\nviewModel.updateOddsValue(type: .right, value: \"4.10\", changeDirection: .down)\n```\n\n### Regulatory-Compliant Animation Features\n\nThe component includes sophisticated animation management for regulatory compliance:\n\n- **Automatic Direction Calculation**: Compares old vs new odds values to determine up/down direction\n- **Animation Interruption**: New odds updates immediately cancel and replace existing animations\n- **Consistent Timing**: All animations follow the same 3-second display duration\n- **Visual Feedback**: Border color changes (green for up, red for down) with arrow indicators\n- **Proper Cleanup**: Animations are properly cancelled during view reuse or deallocation\n\n### Market State Transitions\n\n```swift\n// Switch to suspended state with custom text\nviewModel.setDisplayMode(.suspended(text: \"Market temporarily unavailable\"))\n\n// Switch to see all state with custom text\nviewModel.setDisplayMode(.seeAll(text: \"View all 25+ markets\"))\n\n// Switch between market types\nviewModel.setDisplayMode(.triple)  // Three-way market\nviewModel.setDisplayMode(.double)  // Two-way market\n```\n\n### Selection Management\n\n```swift\n// Programmatically select/deselect outcomes\nviewModel.selectOutcome(type: .left)\nviewModel.deselectOutcome(type: .middle)\n```\n\nThis component provides a robust foundation for displaying betting market outcomes with excellent performance characteristics and comprehensive customization options. ",
      "snapshots": [
        {
          "category": "MarketVariants",
          "light": "MarketOutcomesLineView/__Snapshots__/MarketOutcomesLineViewSnapshotTests/testMarketOutcomesLineView_MarketVariants_Light.1.png",
          "dark": "MarketOutcomesLineView/__Snapshots__/MarketOutcomesLineViewSnapshotTests/testMarketOutcomesLineView_MarketVariants_Dark.1.png"
        },
        {
          "category": "StateVariants",
          "light": "MarketOutcomesLineView/__Snapshots__/MarketOutcomesLineViewSnapshotTests/testMarketOutcomesLineView_StateVariants_Light.1.png",
          "dark": "MarketOutcomesLineView/__Snapshots__/MarketOutcomesLineViewSnapshotTests/testMarketOutcomesLineView_StateVariants_Dark.1.png"
        }
      ]
    },
    "MarketOutcomesMultiLineView": {
      "displayName": "MarketOutcomesMultiLineView",
      "category": "Betting",
      "subcategory": "Outcomes",
      "summary": "Vertical container for multiple market outcome lines with group title and loading/empty states",
      "description": "Vertical stack aggregating multiple MarketOutcomesLineView instances for displaying market groups like 'Over/Under Goals'. Features optional group title label (medium 16pt font), loading state with activity indicator, error state with message, and empty state with customizable message. When empty, displays placeholder line with single disabled '-' button. Smart view reuse logic: reconfigures existing views when count matches, recreates when structure changes (cell recycling optimization). Multi-line corner radius logic creates grid appearance: top line gets top corners, bottom line gets bottom corners, middle lines have no corners. Supports both 2-column (twoColumn) and 3-column (threeColumn) line types. Synchronous configuration via currentDisplayState and lineViewModels for proper UITableView automatic dimension. Async updates via lineViewModelsPublisher and displayStatePublisher with dropFirst() to avoid double render. Used in production with custom MarketOutcomesMultiLineViewModel in MatchDetailsTextual and TallOddsMatchCard screens.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "outcome",
        "market",
        "multi-line",
        "group",
        "vertical",
        "stack",
        "betting",
        "loading",
        "empty",
        "grid"
      ],
      "states": [
        "over-under-group",
        "1x2-group",
        "suspended-line",
        "mixed-layout",
        "odds-changes",
        "empty-with-title",
        "empty",
        "loading"
      ],
      "similarTo": [
        "MarketOutcomesLineView"
      ],
      "oftenUsedWith": [
        "MarketOutcomesLineView",
        "TallOddsMatchCardView"
      ],
      "parents": [
        "TallOddsMatchCardView"
      ],
      "children": [
        "MarketOutcomesLineView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# MarketOutcomesMultiLineView\n\nMarketOutcomesMultiLineView is a flexible component designed for displaying multiple betting market outcome lines in a vertical layout. It supports both 2-column and 3-column layouts, independent line suspension, and all the rich interaction capabilities of the single-line component.\n\n## Features\n\n- **Multiple Market Lines**: Display multiple outcome lines in a vertical stack\n- **Mixed Layout Support**: Each line can independently be 2-column or 3-column\n- **Independent Line States**: Each line can be suspended, disabled, or active independently\n- **Interactive Selection**: Tap to select/deselect outcomes with visual feedback per line\n- **Regulatory-Compliant Odds Change Animations**: Automatic odds direction calculation with proper animation timing\n- **Group Management**: Optional group title and expansion/collapse functionality\n- **Loading & Error States**: Built-in loading indicator and error message display\n- **Accessibility Support**: Full VoiceOver support with proper traits for all lines\n- **Reusable Architecture**: Leverages existing MarketOutcomesLineView for each line\n\n## Use Cases\n\n- Over/Under markets with multiple goal thresholds (0.5, 1.0, 1.5, 2.5, 3.5)\n- Asian Handicap markets with multiple handicap lines\n- 1X2 markets for different time periods (Full Time, Half Time, etc.)\n- Mixed market groups combining different market types\n- Any scenario requiring multiple horizontal outcome lines\n\n## Usage Example\n\n### Basic Over/Under Market Group (2-Column Layout)\n\n```swift\n// Create a view model (or use a mock for testing)\nlet viewModel = MockMarketOutcomesMultiLineViewModel.overUnderMarketGroup\n\n// Create the component\nlet multiLineView = MarketOutcomesMultiLineView(viewModel: viewModel)\nmultiLineView.translatesAutoresizingMaskIntoConstraints = false\n\n// Add to your view hierarchy\nparentView.addSubview(multiLineView)\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    multiLineView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 16),\n    multiLineView.trailingAnchor.constraint(equalTo: parentView.trailingAnchor, constant: -16),\n    multiLineView.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor, constant: 16),\n    multiLineView.heightAnchor.constraint(greaterThanOrEqualToConstant: 100)\n])\n\n// Handle outcome selection across all lines\nmultiLineView.onOutcomeSelected = { lineId, outcomeType in\n    print(\"Outcome selected: \\(outcomeType) in line \\(lineId)\")\n    // Add to bet slip, update UI, etc.\n}\n\nmultiLineView.onOutcomeDeselected = { lineId, outcomeType in\n    print(\"Outcome deselected: \\(outcomeType) in line \\(lineId)\")\n    // Remove from bet slip, update UI, etc.\n}\n\n// Handle line-specific events\nmultiLineView.onLineSuspended = { lineId in\n    print(\"Line suspended: \\(lineId)\")\n    // Update UI to reflect suspension\n}\n\nmultiLineView.onOddsChanged = { lineId, outcomeType, oldValue, newValue in\n    print(\"Odds changed in line \\(lineId): \\(oldValue) -> \\(newValue)\")\n    // Handle odds change notifications\n}\n```\n\n### Home/Draw/Away Market Group (3-Column Layout)\n\n```swift\nlet viewModel = MockMarketOutcomesMultiLineViewModel.homeDrawAwayMarketGroup\nlet multiLineView = MarketOutcomesMultiLineView(viewModel: viewModel)\n\n// Each line will automatically display three columns (Home, Draw, Away)\n// The component handles the layout differences automatically\n```\n\n### Mixed Layout Market Group\n\n```swift\nlet viewModel = MockMarketOutcomesMultiLineViewModel.mixedLayoutMarketGroup\nlet multiLineView = MarketOutcomesMultiLineView(viewModel: viewModel)\n\n// This group contains both 3-column lines (Match Result) and 2-column lines (Both Teams to Score)\n// Each line uses its optimal layout while maintaining consistent spacing\n```\n\n### Market Group with Independent Line Suspension\n\n```swift\nlet viewModel = MockMarketOutcomesMultiLineViewModel.overUnderWithSuspendedLine\nlet multiLineView = MarketOutcomesMultiLineView(viewModel: viewModel)\n\n// Some lines are active while others are suspended\n// Suspended lines are visually grayed out and non-interactive\n```\n\n### Dynamic Line Management\n\n```swift\n// Suspend a specific line\nmultiLineView.suspendLine(lineId: \"over_under_2_5\", message: \"Market Temporarily Unavailable\")\n\n// Resume a suspended line\nmultiLineView.resumeLine(lineId: \"over_under_2_5\")\n\n// Simulate odds changes\nmultiLineView.simulateOddsChange(lineId: \"over_under_1_5\", outcomeType: .left, newValue: \"1.95\")\n\n// Toggle group expansion (if supported)\nmultiLineView.toggleExpansion()\n```\n\n## Configuration Options\n\n### MarketLineData Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `id` | String | Unique identifier for the market line |\n| `leftOutcome` | MarketOutcomeData? | Left outcome (e.g., \"Over 2.5\", \"Home\") |\n| `middleOutcome` | MarketOutcomeData? | Middle outcome (e.g., \"Draw\") - nil for 2-column |\n| `rightOutcome` | MarketOutcomeData? | Right outcome (e.g., \"Under 2.5\", \"Away\") |\n| `displayMode` | MarketDisplayMode | .double, .triple, .suspended(text), .seeAll(text) |\n| `lineType` | MarketLineType | .twoColumn or .threeColumn |\n| `isLineDisabled` | Bool | Whether the entire line is disabled/grayed out |\n\n### MarketLineType Options\n\n| Type | Description | Use Cases |\n|------|-------------|-----------|\n| `.twoColumn` | Left + Right outcomes only | Over/Under, Yes/No, Asian Handicap |\n| `.threeColumn` | Left + Middle + Right outcomes | 1X2, Double Chance, Draw No Bet |\n\n### MarketGroupData Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `id` | String | Unique identifier for the market group |\n| `groupTitle` | String? | Optional title displayed above all lines |\n| `marketLines` | [MarketLineData] | Array of market lines to display |\n| `defaultLineType` | MarketLineType | Default layout type for the group |\n| `isExpanded` | Bool | Whether the group is expanded (for future use) |\n| `maxVisibleLines` | Int? | Maximum lines to show before collapse (for future use) |\n\n## Available Mock Data\n\n### Predefined Market Groups\n\n```swift\n// Over/Under market group (matches the provided image)\nMockMarketOutcomesMultiLineViewModel.overUnderMarketGroup\n\n// 1X2 market group with group title\nMockMarketOutcomesMultiLineViewModel.homeDrawAwayMarketGroup\n\n// Market group with one suspended line\nMockMarketOutcomesMultiLineViewModel.overUnderWithSuspendedLine\n\n// Mixed layout group (3-column + 2-column lines)\nMockMarketOutcomesMultiLineViewModel.mixedLayoutMarketGroup\n\n// Market group with odds changes and selections\nMockMarketOutcomesMultiLineViewModel.marketGroupWithOddsChanges\n```\n\n### Custom Market Group Creation\n\n```swift\nlet customLines = [\n    MarketLineData(\n        id: \"custom_line_1\",\n        leftOutcome: MarketOutcomeData(id: \"left1\", title: \"Over 4.5\", value: \"3.20\"),\n        middleOutcome: nil,\n        rightOutcome: MarketOutcomeData(id: \"right1\", title: \"Under 4.5\", value: \"1.30\"),\n        displayMode: .double,\n        lineType: .twoColumn,\n        isLineDisabled: false\n    ),\n    // Add more lines...\n]\n\nlet customGroup = MarketGroupData(\n    id: \"custom_group\",\n    groupTitle: \"Custom Markets\",\n    marketLines: customLines,\n    defaultLineType: .twoColumn,\n    isExpanded: true,\n    maxVisibleLines: nil\n)\n\nlet customViewModel = MockMarketOutcomesMultiLineViewModel(marketGroup: customGroup)\nlet multiLineView = MarketOutcomesMultiLineView(viewModel: customViewModel)\n```\n\n## Styling\n\nThe MarketOutcomesMultiLineView uses StyleProvider for consistent theming:\n\n```swift\n// Customize colors for all lines\nStyleProvider.Color.customize(\n    primaryColor: UIColor(named: \"BrandPrimary\"),\n    secondaryColor: UIColor(named: \"SecondaryGray\"),\n    backgroundColor: .systemBackground,\n    textColor: .label\n)\n\n// The component automatically applies:\n// - Group title styling using textColor and medium font\n// - Line spacing and disabled states using disabledAlpha\n// - Loading and error states using appropriate colors\n```\n\n## Architecture\n\n### Component Hierarchy\n\n```\nMarketOutcomesMultiLineView\n containerStackView (vertical)\n    groupTitleLabel (optional, hidden if no title)\n    linesStackView (vertical)\n        MarketOutcomesLineView (line 1)\n        MarketOutcomesLineView (line 2)\n        MarketOutcomesLineView (line N)\n loadingIndicator (centered, hidden when not loading)\n errorLabel (centered, hidden when no error)\n```\n\n### Line Management\n\n- Each line is a separate `MarketOutcomesLineView` instance\n- Lines are dynamically added/removed based on data changes\n- Each line maintains its own view model for independent state management\n- Consistent 8pt spacing between lines\n- Disabled lines use 50% alpha and disabled interaction\n\n### State Management\n\nThe component uses reactive programming with two main publishers:\n\n```swift\n// Single state publisher for all market group data\nviewModel.marketStatePublisher\n    .sink { state in\n        // Updates all lines, group title, loading/error states\n    }\n\n// Separate publisher for odds change animations\nviewModel.oddsChangeEventPublisher\n    .sink { changeEvent in\n        // Triggers animations on specific lines without full re-render\n    }\n```\n\n## Accessibility\n\n### VoiceOver Support\n\n- **Group Title**: Properly announced when present\n- **Individual Lines**: Each line maintains full accessibility from MarketOutcomesLineView\n- **Line Identification**: Accessibility identifiers follow pattern \"marketLine.{lineId}\"\n- **State Announcements**: Loading, error, and suspension states are properly announced\n\n### Dynamic Type Support\n\nThe component respects user's preferred text size through StyleProvider font system.\n\n## Performance Considerations\n\n- **Efficient Updates**: Only updates lines that actually changed\n- **View Reuse**: Reuses existing line views when possible\n- **Animation Separation**: Odds change animations don't trigger full data re-renders\n- **Memory Management**: Properly cleans up removed lines and their view models\n\n## Integration with Existing Components\n\nThe MarketOutcomesMultiLineView seamlessly integrates with:\n\n- **MarketOutcomesLineView**: Reuses the existing single-line component\n- **StyleProvider**: Uses the same theming system\n- **Combine Framework**: Follows the same reactive patterns\n- **Accessibility System**: Maintains the same accessibility standards\n\n## Best Practices\n\n1. **Use Meaningful Line IDs**: Provide descriptive IDs for each line to enable proper updates\n2. **Consistent Line Types**: Use the same lineType for similar markets within a group\n3. **Handle Suspension Gracefully**: Always provide clear suspension messages\n4. **Optimize Updates**: Only update odds when values actually change\n5. **Proper Cleanup**: The component automatically handles view cleanup when lines are removed\n\n## Advanced Usage\n\n### Real-time Odds Updates\n\n```swift\n// Update odds for a specific line and outcome\nviewModel.updateOddsValue(lineId: \"over_under_2_5\", outcomeType: .left, newValue: \"2.10\")\n\n// The component will automatically:\n// 1. Calculate odds change direction\n// 2. Update the line view model\n// 3. Trigger appropriate animations\n// 4. Notify callbacks\n```\n\n### Group-level Operations\n\n```swift\n// Suspend entire group\nviewModel.suspendEntireGroup(message: \"Markets Temporarily Unavailable\")\n\n// Resume entire group\nviewModel.resumeEntireGroup()\n\n// Update group title\nviewModel.setGroupTitle(\"Updated Market Group\")\n```\n\nThis component provides a powerful and flexible solution for displaying multiple market outcome lines while maintaining the same interaction patterns and visual consistency as the single-line component. ",
      "snapshots": [
        {
          "category": "MarketGroupVariants",
          "light": "MarketOutcomesMultiLineView/__Snapshots__/MarketOutcomesMultiLineViewSnapshotTests/testMarketOutcomesMultiLineView_MarketGroupVariants_Light.1.png",
          "dark": "MarketOutcomesMultiLineView/__Snapshots__/MarketOutcomesMultiLineViewSnapshotTests/testMarketOutcomesMultiLineView_MarketGroupVariants_Dark.1.png"
        },
        {
          "category": "SpecialStates",
          "light": "MarketOutcomesMultiLineView/__Snapshots__/MarketOutcomesMultiLineViewSnapshotTests/testMarketOutcomesMultiLineView_SpecialStates_Light.1.png",
          "dark": "MarketOutcomesMultiLineView/__Snapshots__/MarketOutcomesMultiLineViewSnapshotTests/testMarketOutcomesMultiLineView_SpecialStates_Dark.1.png"
        }
      ]
    },
    "MatchBannerView": {
      "displayName": "MatchBannerView",
      "category": "MatchCards",
      "subcategory": "Banners",
      "summary": "Promotional match banner with background image, team names, scores, and betting outcomes",
      "description": "Featured match banner for promotional display in carousels and home pages. Shows customizable background image (Kingfisher async loading with backgroundGradientDark fallback), league header (date/time for prelive, matchTime + league for live), home/away team names (bold 14pt), and live scores (hidden for prelive). Integrates MarketOutcomesLineView child for 3-way betting outcomes in 48pt container. Conforms to TopBannerViewProtocol with type identifier, visibility state, and lifecycle methods (bannerDidBecomeVisible, bannerDidBecomeHidden). Banner tap gesture triggers userDidTapBanner() callback, outcome selection via onOutcomeSelected/onOutcomeDeselected callbacks. Synchronous configure(with:) for collection view sizing. Layout: 16pt content padding, 16pt header height, 16pt team label height, 4pt vertical gaps. Empty state hides all labels when id is empty. Used in production with custom MatchBannerViewModel and TopBannerSliderViewModel.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "banner",
        "match",
        "promotional",
        "image",
        "teams",
        "scores",
        "betting",
        "outcomes",
        "carousel",
        "kingfisher"
      ],
      "states": [
        "prelive-match",
        "live-match",
        "empty-state",
        "interactive-match"
      ],
      "similarTo": [
        "TallOddsMatchCardView"
      ],
      "oftenUsedWith": [
        "MarketOutcomesLineView",
        "TopBannersContainer"
      ],
      "parents": [],
      "children": [
        "MarketOutcomesLineView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# MatchBannerView\n\nA promotional banner for displaying match information with background image, team names, scores, and betting outcomes.\n\n## Overview\n\nMatchBannerView displays a featured match in a banner format with a customizable background image, league header, team names with optional live scores, and integrated betting outcomes. It conforms to TopBannerViewProtocol for use in banner carousels and supports both pre-live and live match states. The component uses Kingfisher for asynchronous image loading.\n\n## Component Relationships\n\n### Used By (Parents)\n- Banner carousel components\n- Home page featured matches\n\n### Uses (Children)\n- `MarketOutcomesLineView` - betting outcomes display\n\n## Features\n\n- Background image with Kingfisher loading\n- League/competition header text\n- Home and away team name labels\n- Live score display (hidden for pre-live)\n- Integrated betting outcomes (3-way market)\n- Banner tap gesture with callback\n- Outcome selection/deselection callbacks\n- TopBannerViewProtocol conformance\n- Visibility lifecycle methods\n- Empty state handling\n- Synchronous configuration for collection view sizing\n\n## Usage\n\n```swift\nlet viewModel = MockMatchBannerViewModel.liveMatch\nlet bannerView = MatchBannerView()\nbannerView.configure(with: viewModel)\n\nbannerView.onOutcomeSelected = { outcomeId in\n    print(\"Selected outcome: \\(outcomeId)\")\n}\n\nbannerView.onOutcomeDeselected = { outcomeId in\n    print(\"Deselected outcome: \\(outcomeId)\")\n}\n\n// ViewModel callbacks\nviewModel.onMatchTap = { matchId in\n    print(\"Navigate to match: \\(matchId)\")\n}\n\nviewModel.onOutcomeSelected = { outcomeId in\n    print(\"Add to betslip: \\(outcomeId)\")\n}\n```\n\n## Data Model\n\n```swift\nstruct MatchBannerModel {\n    let id: String\n    let isLive: Bool\n    let dateTime: Date\n    let leagueName: String\n    let homeTeam: String\n    let awayTeam: String\n    let backgroundImageURL: String?\n    let matchTime: String?\n    let homeScore: Int?\n    let awayScore: Int?\n    let outcomes: [MatchOutcome]\n\n    // Computed properties\n    var formattedDateTime: String\n    var headerText: String\n    var hasValidScore: Bool\n}\n\nstruct MatchOutcome {\n    let id: String\n    let displayName: String\n    let odds: Double\n    let isSelected: Bool\n    let isEnabled: Bool\n}\n\nprotocol MatchBannerViewModelProtocol {\n    var currentMatchData: MatchBannerModel { get }\n    var marketOutcomesViewModel: MarketOutcomesLineViewModelProtocol { get }\n\n    var onMatchTap: ((String) -> Void)? { get set }\n    var onOutcomeSelected: ((String) -> Void)? { get set }\n    var onOutcomeDeselected: ((String) -> Void)? { get set }\n\n    func userDidTapBanner()\n    func onOutcomeSelected(outcomeId: String)\n    func onOutcomeDeselected(outcomeId: String)\n}\n\nprotocol TopBannerViewProtocol {\n    var type: String { get }\n    var isVisible: Bool { get set }\n    func bannerDidBecomeVisible()\n    func bannerDidBecomeHidden()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.allWhite` - header, team, score text color\n- `StyleProvider.Color.backgroundGradientDark` - fallback background color\n- `StyleProvider.fontWith(type: .regular, size: 11)` - header label font\n- `StyleProvider.fontWith(type: .bold, size: 14)` - team/score label font\n\nLayout constants:\n- Content padding: 16pt (all sides)\n- Header height: 16pt\n- Team label height: 16pt\n- Header to home team gap: 4pt\n- Home to away team gap: 4pt\n- Away team to outcomes gap: 6pt\n- Outcomes container height: 48pt\n- Score label min width: 20pt\n\nDisplay modes:\n- **Pre-live**: Shows formatted date/time in header, scores hidden\n- **Live**: Shows match time + league in header, scores visible\n- **Empty**: All labels hidden when id is empty\n\n## Mock ViewModels\n\nAvailable presets:\n- `.emptyState` - Empty banner for cell reuse\n- `.preliveMatch` - Man City vs Arsenal, tomorrow, Premier League\n- `.liveMatch` - Man City vs Arsenal, 1-1, 1st Half 44 Min\n- `.interactiveMatch` - Barcelona vs Real Madrid, 2-1, 2nd Half 67 Min (El Clsico)\n",
      "snapshots": []
    },
    "MatchDateNavigationBar": {
      "displayName": "MatchDateNavigationBarView",
      "category": "MatchCards",
      "subcategory": "Navigation",
      "summary": "Navigation bar with back button and match date/live status display",
      "description": "Navigation bar for match detail screens showing back button on left and match status on right. Left side: back button with chevron icon (20pt, iconPrimary tint) and customizable localized text (bold 12pt). Right side switches between two states: pre-match shows formatted date with mixed font weights (bold date part, regular time part), live shows CapsuleView child with period and time (highlightSecondary background, bold 10pt). Supports customizable date format (default: 'HH:mm EEE dd/MM') and optional back button visibility. Fixed 47pt height, 16pt horizontal padding, 6pt icon-text spacing. Live capsule has 12pt horizontal/4pt vertical padding with 12pt corner radius. Period-only display when time is empty (e.g., 'Half Time'). onBackTapped callback for navigation. Reactive updates via dataPublisher. Used in production MatchDetailsTextual screens.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "navigation",
        "bar",
        "back",
        "date",
        "live",
        "status",
        "match",
        "capsule",
        "period"
      ],
      "states": [
        "pre-match",
        "live-1st-half",
        "live-2nd-half",
        "half-time",
        "extra-time",
        "no-back-button",
        "custom-date-format"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "CapsuleView"
      ],
      "parents": [],
      "children": [
        "CapsuleView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# MatchDateNavigationBar\n\nA navigation bar component that displays match timing information with support for both pre-match and live match states.\n\n## Overview\n\n`MatchDateNavigationBar` is designed for sports betting applications to show match timing at the top of match detail screens. It features:\n\n- **Pre-match state**: Displays the scheduled date and time\n- **Live match state**: Shows current period and elapsed time in a highlighted pill\n- Optional back navigation button\n- Customizable date formatting\n\n## Visual States\n\n### Pre-Match\n- Shows date/time in format: \"18:45 Tue 21/01\" (customizable)\n- Time displayed in regular weight, date in bold\n- Uses `textPrimary` color\n\n### Live Match\n- Green pill background (`highlightSecondary`)\n- White text (`buttonTextPrimary`) \n- Shows period and time: \"1st Half, 41mins\"\n- Bold font weight\n\n## Usage\n\n```swift\n// Pre-match state\nlet preMatchData = MatchDateNavigationBarData(\n    matchStatus: .preMatch(date: matchDate)\n)\nlet viewModel = MockMatchDateNavigationBarViewModel(data: preMatchData)\nlet navigationBar = MatchDateNavigationBarView(viewModel: viewModel)\n\n// Live match state\nlet liveData = MatchDateNavigationBarData(\n    matchStatus: .live(period: \"2nd Half\", time: \"67mins\")\n)\nviewModel.configure(with: liveData)\n\n// Handle back button tap\nnavigationBar.onBackTapped = {\n    // Navigate back\n}\n```\n\n## Customization\n\n### Date Format\n```swift\nlet data = MatchDateNavigationBarData(\n    matchStatus: .preMatch(date: date),\n    dateFormat: \"EEEE, MMM d 'at' h:mm a\" // \"Tuesday, Jan 21 at 6:45 PM\"\n)\n```\n\n### Hide Back Button\n```swift\nlet data = MatchDateNavigationBarData(\n    matchStatus: matchStatus,\n    isBackButtonHidden: true\n)\n```\n\n## Mock View Models\n\nThe component includes several pre-configured mocks:\n\n- `defaultPreMatchMock`: Shows a future match date\n- `liveMock`: First half at 41 minutes\n- `secondHalfMock`: Second half at 67 minutes\n- `halfTimeMock`: Half time break\n- `extraTimeMock`: Extra time period\n- `noBackButtonMock`: Live state without back button\n- `customDateFormatMock`: Alternative date formatting\n- `createAnimatedMock()`: Simulates match progression for demos\n\n## Design System Integration\n\nThe component uses StyleProvider for all visual attributes:\n\n- **Colors**:\n  - Background: `backgroundPrimary`\n  - Text: `textPrimary`\n  - Icons: `iconPrimary`\n  - Live pill background: `highlightSecondary`\n  - Live pill text: `buttonTextPrimary`\n\n- **Fonts**:\n  - Regular text: `footnoteRegular`\n  - Bold text: `footnoteBold`\n\n## Dimensions\n\n- Height: 44pt (standard navigation bar)\n- Horizontal padding: 16pt\n- Live pill corner radius: 12pt\n- Back icon size: 20pt\n\n## SwiftUI Previews\n\nThe component includes SwiftUI previews showing:\n- Pre-match state\n- Live match state\n- No back button variant\n\n## Example Match States\n\nCommon live match periods:\n- \"1st Half\", \"2nd Half\"\n- \"Half Time\", \"Full Time\"\n- \"Extra Time\", \"Penalties\"\n- \"1st Period\", \"2nd Period\", \"3rd Period\" (for other sports)\n\nTime can be:\n- Minutes: \"41mins\", \"90+3mins\"\n- Empty for breaks: \"Half Time\", \"\"\n- Other formats as needed",
      "snapshots": []
    },
    "MatchHeaderCompactView": {
      "displayName": "MatchHeaderCompactView",
      "category": "MatchCards",
      "subcategory": "Headers",
      "summary": "Compact match header with team names, score display, and tappable breadcrumb navigation",
      "description": "Compact match header component for match detail screens. Displays vertical stack of home/away team names (bold 16pt, gameHeaderTextPrimary, truncating) on left side, ScoreView child on right (hidden for prelive matches). Horizontal gradient background (GradientView child, gameHeader  backgroundGradient2 left-to-right). Below teams shows breadcrumb 'Sport / Country / League' (semibold 12pt, gameHeaderTextSecondary) with country and league underlined for tap interaction. handleCountryTap() and handleLeagueTap() methods trigger callbacks with countryId/leagueId. ScoreView has required compression resistance (teams truncate first to preserve scores). Layout: 12px container padding, 2px team label spacing, 4px breadcrumb-teams gap, 8px teams-score gap. 1pt bottom border (separatorLine). Supports multi-sport scores (football simple, tennis sets with serving indicator). Used in production MatchDetailsTextual screens.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "header",
        "match",
        "compact",
        "teams",
        "score",
        "breadcrumb",
        "gradient",
        "navigation",
        "tappable"
      ],
      "states": [
        "default-prelive",
        "long-names",
        "long-content",
        "live-football",
        "live-tennis",
        "live-tennis-tiebreak",
        "live-five-sets"
      ],
      "similarTo": [
        "MatchHeaderView"
      ],
      "oftenUsedWith": [
        "ScoreView",
        "GradientView"
      ],
      "parents": [],
      "children": [
        "ScoreView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# MatchHeaderCompactView\n\nA compact header component for displaying match information including team names, competition details, and an optional statistics button.\n\n## Overview\n\n`MatchHeaderCompactView` provides a clean, compact layout for match headers with:\n- Team names displayed vertically\n- Competition breadcrumb with tappable elements\n- Optional statistics button with icon\n- Responsive layout that adapts to content\n\n## Features\n\n- **Team Display**: Shows home and away team names in a vertical stack\n- **Competition Breadcrumb**: Displays sport, competition, and league with underlined tappable elements\n- **Statistics Button**: Optional button with text and icon for accessing match statistics\n- **Themeable**: Uses StyleProvider for consistent theming across light/dark modes\n- **Reactive**: Updates automatically based on view model data changes\n\n## Usage\n\n```swift\n// Create view model with match data\nlet matchData = MatchHeaderCompactData(\n    homeTeamName: \"Manchester United\",\n    awayTeamName: \"Glasgow Rangers\",\n    sport: \"Football\",\n    competition: \"International\",\n    league: \"UEFA Europa League\",\n    hasStatistics: true\n)\n\nlet viewModel = MockMatchHeaderCompactViewModel(headerData: matchData)\n\n// Set up callbacks\nviewModel.onStatisticsTapped = {\n    // Handle statistics tap\n}\n\nviewModel.onCompetitionTapped = {\n    // Handle competition tap\n}\n\nviewModel.onLeagueTapped = {\n    // Handle league tap\n}\n\n// Create the view\nlet headerView = MatchHeaderCompactView(viewModel: viewModel)\n```\n\n## Layout Structure\n\n```\n\n     \n  Manchester United        Statistics      \n  Glasgow Rangers          \n  Football / Intl / UEFA                       \n                          \n\n```\n\n## Data Model\n\n```swift\nstruct MatchHeaderCompactData {\n    let homeTeamName: String      // Home team name\n    let awayTeamName: String      // Away team name\n    let sport: String             // Sport category\n    let competition: String       // Competition name (tappable)\n    let league: String            // League name (tappable)\n    let hasStatistics: Bool       // Show/hide statistics button\n}\n```\n\n## Styling\n\nThe component uses StyleProvider colors:\n- `gameHeaderTextPrimary`: Team names\n- `gameHeaderTextSecondary`: Competition breadcrumb\n- `highlightTertiary`: Statistics button text and icon\n- `backgroundCards`: Component background\n- `separatorLine`: Bottom border\n\n## Customization\n\n### Hiding Statistics Button\n\n```swift\nlet matchData = MatchHeaderCompactData(\n    // ... other properties\n    hasStatistics: false  // Hides statistics button\n)\n```\n\n### Handling Taps\n\nThe view model provides three tap handlers:\n- `onStatisticsTapped`: Called when statistics button is tapped\n- `onCompetitionTapped`: Called when competition text is tapped\n- `onLeagueTapped`: Called when league text is tapped\n\n## Mock ViewModels\n\nSeveral preset mock view models are available for testing:\n- `.default`: Standard football match\n- `.withoutStatistics`: Match without statistics button\n- `.longNames`: Teams with long names\n- `.basketball`: NBA basketball match\n- `.tennis`: Tennis match example\n\n## Preview\n\nThe component includes SwiftUI previews for easy development:\n- Default view with statistics\n- View without statistics\n- View with long team names",
      "snapshots": [
        {
          "category": "BasicVariants",
          "light": "MatchHeaderCompactView/__Snapshots__/MatchHeaderCompactViewSnapshotTests/testMatchHeaderCompactView_BasicVariants_Light.1.png",
          "dark": "MatchHeaderCompactView/__Snapshots__/MatchHeaderCompactViewSnapshotTests/testMatchHeaderCompactView_BasicVariants_Dark.1.png"
        },
        {
          "category": "LiveMatchVariants",
          "light": "MatchHeaderCompactView/__Snapshots__/MatchHeaderCompactViewSnapshotTests/testMatchHeaderCompactView_LiveMatchVariants_Light.1.png",
          "dark": "MatchHeaderCompactView/__Snapshots__/MatchHeaderCompactViewSnapshotTests/testMatchHeaderCompactView_LiveMatchVariants_Dark.1.png"
        }
      ]
    },
    "MatchHeaderView": {
      "displayName": "MatchHeaderView",
      "category": "MatchCards",
      "subcategory": "Headers",
      "summary": "Single-line competition header with favorites, icons, flag, live indicator, and match time",
      "description": "Compact 17pt fixed-height match header displaying competition context. Left side shows tappable favorites star button (40pt touch area), sport type icon (template rendered), circular country flag with 0.5pt border, and truncating competition name label (medium 11pt, highlightPrimary). Right side displays match time (bold 10pt, highlightTertiary) and pill-shaped live indicator with 'LIVE' text and play icon (semibold 10pt). Uses pluggable MatchHeaderImageResolver protocol for custom icon loading with DefaultMatchHeaderImageResolver fallback using SF Symbols. Individual visibility controls via publishers for country flag, sport icon, and favorite button. Supports cell reuse via configure(with:) and cleanupForReuse() methods. Production usage in BetssonCameroonApp integrates with FavoritesManager for toggle persistence and includes factory method for Match domain model.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "header",
        "match",
        "favorites",
        "live",
        "competition",
        "flag",
        "sport-icon",
        "configurable",
        "image-resolver",
        "reusable"
      ],
      "states": [
        "default",
        "premierLeague",
        "laLigaFavorite-live",
        "serieABasketball",
        "disabledNBA",
        "minimalMode",
        "favoriteOnly",
        "longName",
        "basic-no-icons",
        "noCountryFlag",
        "noSportIcon",
        "noFavoriteButton",
        "minimalVisibility"
      ],
      "similarTo": [
        "CompactMatchHeaderView",
        "MatchHeaderCompactView"
      ],
      "oftenUsedWith": [
        "TallOddsMatchCardView"
      ],
      "parents": [
        "TallOddsMatchCardView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# MatchHeaderView\n\nA sports competition header component that displays competition name, country flag, sport icon, and favorite toggle functionality.\n\n## Overview\n\n`MatchHeaderView` is a horizontal layout component designed for sports applications that need to display competition information with interactive elements. It follows the GomaUI architecture with protocol-based design, reactive data flow, and unified visual state management.\n\n## Features\n\n- **Competition Display**: Shows competition name with proper text styling\n- **Country Flag**: Circular country flag image with border\n- **Sport Icon**: Circular sport-specific icon \n- **Favorite Toggle**: Interactive heart icon for favorite competitions\n- **Visual States**: Multiple display modes for different contexts\n- **Reactive Updates**: Real-time data updates through Combine publishers\n- **Accessibility**: Full accessibility support with proper labels\n- **Theming**: Consistent styling through StyleProvider integration\n\n## Visual States\n\n### Standard\nShows all elements (favorite icon, sport icon, country flag, competition name) with full interactivity.\n\n### Disabled  \nShows all elements but with reduced opacity (60%) and disabled interactions.\n\n### Favorite Only\nShows only the favorite icon and competition name, hiding country flag and sport icon.\n\n### Minimal\nShows only the competition name, hiding all icons for space-constrained layouts.\n\n## Basic Usage\n\n```swift\n\n\n// Create with mock data (uses default system icons)\nlet viewModel = MockMatchHeaderViewModel.premierLeagueHeader\nlet headerView = MatchHeaderView(viewModel: viewModel)\n\n// Create with custom image resolver\nlet customImageResolver = YourAppImageResolver()\nlet headerView = MatchHeaderView(viewModel: viewModel, imageResolver: customImageResolver)\n\n// Or configure existing view\nlet headerView = MatchHeaderView()\nheaderView.configure(with: viewModel)\n\n// Add to your view hierarchy\nview.addSubview(headerView)\nheaderView.translatesAutoresizingMaskIntoConstraints = false\nNSLayoutConstraint.activate([\n    headerView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 16),\n    headerView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -16),\n    headerView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 20)\n])\n```\n\n## Available Mock ViewModels\n\n```swift\n// Standard headers with different leagues\nMockMatchHeaderViewModel.premierLeagueHeader\nMockMatchHeaderViewModel.laLigaFavoriteHeader\nMockMatchHeaderViewModel.serieABasketballHeader\n\n// Different visual states\nMockMatchHeaderViewModel.disabledNBAHeader\nMockMatchHeaderViewModel.minimalModeHeader\nMockMatchHeaderViewModel.favoriteOnlyHeader\n\n// Edge cases\nMockMatchHeaderViewModel.longNameHeader\nMockMatchHeaderViewModel.basicHeader\n```\n\n## Custom Image Resolution\n\n```swift\n// Create your own image resolver\nstruct AppImageResolver: MatchHeaderImageResolver {\n    func countryFlagImage(for countryCode: String) -> UIImage? {\n        return UIImage(named: \"flag_\\(countryCode)\", in: .main, compatibleWith: nil)\n    }\n    \n    func sportIconImage(for sportId: String) -> UIImage? {\n        return UIImage(named: \"sport_\\(sportId)\", in: .main, compatibleWith: nil)\n    }\n    \n    func favoriteIcon(isFavorite: Bool) -> UIImage? {\n        let imageName = isFavorite ? \"star_filled\" : \"star_outline\"\n        return UIImage(named: imageName, in: .main, compatibleWith: nil)\n    }\n    \n    func liveIndicatorIcon() -> UIImage? {\n        return UIImage(named: \"live_play_icon\", in: .main, compatibleWith: nil)\n    }\n}\n\n// Use with custom resolver\nlet imageResolver = AppImageResolver()\nlet headerView = MatchHeaderView(viewModel: viewModel, imageResolver: imageResolver)\n```\n\n## Custom ViewModel Implementation\n\n```swift\n// Create your own view model\nclass CustomMatchHeaderViewModel: MatchHeaderViewModelProtocol {\n    private let competitionNameSubject = CurrentValueSubject<String, Never>(\"\")\n    // ... implement other publishers and methods (without UIKit dependencies)\n}\n\n// Configure with custom data\nlet customViewModel = CustomMatchHeaderViewModel()\ncustomViewModel.updateData(MatchHeaderData(\n    id: \"custom_league\",\n    competitionName: \"My Custom League\",\n    countryFlagImageName: \"GB\",  // String identifier, not UIImage\n    sportIconImageName: \"1\",     // String identifier, not UIImage\n    isFavorite: true,\n    visualState: .standard\n))\n```\n\n## Interactive Features\n\n```swift\n// Handle favorite toggle events\nlet viewModel = MockMatchHeaderViewModel.premierLeagueHeader\nviewModel.favoriteToggleCallback = { isFavorite in\n    print(\"Favorite toggled: \\(isFavorite)\")\n    // Update your data model\n    updateUserFavorites(competitionId: \"premier_league\", isFavorite: isFavorite)\n}\n\n// Programmatically toggle favorite\nviewModel.toggleFavorite()\n\n// Change visual state\nviewModel.setVisualState(.minimal)\nviewModel.setEnabled(false)\n```\n\n## Reactive Updates\n\n```swift\n// Listen to changes\nviewModel.isFavoritePublisher\n    .sink { isFavorite in\n        // React to favorite changes\n    }\n    .store(in: &cancellables)\n\nviewModel.visualStatePublisher\n    .sink { state in\n        // React to visual state changes\n    }\n    .store(in: &cancellables)\n\n// Update data dynamically\nviewModel.updateCompetitionName(\"New Competition Name\")\nviewModel.updateCountryFlag(\"GB\")\nviewModel.updateSportIcon(\"1\")\n```\n\n## Integration with Table/Collection Views\n\n```swift\n// In your cell configuration\nclass MatchCell: UITableViewCell {\n    private let imageResolver = AppImageResolver() // Reuse the same resolver\n    private lazy var matchHeaderView = MatchHeaderView(viewModel: MockMatchHeaderViewModel.defaultMock, imageResolver: imageResolver)\n    \n    override func configure(with competition: Competition) {\n        let viewModel = createViewModel(from: competition)\n        matchHeaderView.configure(with: viewModel)\n    }\n    \n    override func prepareForReuse() {\n        super.prepareForReuse()\n        matchHeaderView.cleanupForReuse() // ImageResolver is preserved\n    }\n    \n    private func createViewModel(from competition: Competition) -> MatchHeaderViewModelProtocol {\n        return MockMatchHeaderViewModel(\n            matchHeaderData: MatchHeaderData(\n                id: competition.id,\n                competitionName: competition.name,\n                countryFlagImageName: competition.countryCode,\n                sportIconImageName: competition.sportId,\n                isFavorite: competition.isFavorite,\n                visualState: .standard\n            )\n        )\n    }\n}\n```\n\n## Layout Considerations\n\n- **Fixed Height**: Component has a fixed height of 17 points\n- **Horizontal Layout**: Elements are arranged horizontally with 7pt spacing\n- **Touch Target**: Favorite button has 40x40pt touch area for accessibility\n- **Intrinsic Size**: Width expands to fill available space, height is fixed\n\n## Image Resolution\n\nThe component uses the `MatchHeaderImageResolver` protocol to resolve images. You have two options:\n\n### Default System Icons (DefaultMatchHeaderImageResolver)\n- Country flags: `globe` system icon\n- Sport icons: `soccerball` system icon  \n- Favorite icons: `star` and `star.fill` system icons\n- Live indicator: `play.fill` system icon\n\n### Custom Images (Your Implementation)\nImplement `MatchHeaderImageResolver` to provide your own images:\n- Country flag images (e.g., \"GB\", \"ES\", \"IT\", \"US\")\n- Sport icons (e.g., \"1\" for football, \"8\" for basketball, \"5\" for tennis)\n- Custom favorite and live indicator icons\n\n**Important**: The ViewModel protocol no longer includes UIKit dependencies. It only provides string identifiers that your ImageResolver converts to UIImages.\n\n## Styling Customization\n\n```swift\n// Customize colors through StyleProvider\nStyleProvider.Color.customize(\n    textColor: UIColor.label,\n    primaryColor: UIColor.systemBlue\n)\n\n// Customize fonts\nStyleProvider.setFontProvider { type, size in\n    switch type {\n    case .medium:\n        return UIFont(name: \"YourCustomFont-Medium\", size: size) ?? .systemFont(ofSize: size, weight: .medium)\n    default:\n        return .systemFont(ofSize: size, weight: type.systemWeight)\n    }\n}\n```\n\n## Testing\n\n```swift\nimport XCTest\n@testable \n\nclass MatchHeaderViewTests: XCTestCase {\n    func testFavoriteToggle() {\n        let viewModel = MockMatchHeaderViewModel.premierLeagueHeader\n        let expectation = XCTestExpectation(description: \"Favorite toggled\")\n        \n        viewModel.favoriteToggleCallback = { isFavorite in\n            XCTAssertTrue(isFavorite)\n            expectation.fulfill()\n        }\n        \n        viewModel.toggleFavorite()\n        wait(for: [expectation], timeout: 1.0)\n    }\n    \n    func testVisualStateChanges() {\n        let viewModel = MockMatchHeaderViewModel.premierLeagueHeader\n        viewModel.setVisualState(.disabled)\n        XCTAssertEqual(viewModel.currentVisualState, .disabled)\n    }\n}\n```\n\n## Migration from Legacy\n\nIf migrating from the legacy `MatchHeaderView`, follow these steps:\n\n1. **Replace ViewModel**: Replace concrete `MatchHeaderViewModel` with protocol-based approach\n2. **Update Styling**: Replace hardcoded colors with `StyleProvider` calls\n3. **Simplify State**: Replace individual visibility publishers with unified visual state\n4. **Update Bindings**: Use new publisher structure for reactive updates\n\n```swift\n// Legacy approach\nlet viewModel = MatchHeaderViewModel(\n    competitionName: \"Premier League\",\n    countryImageName: \"GB\",\n    isFavorite: false,\n    sportImageName: \"1\"\n)\n\n// New GomaUI approach\nlet viewModel = MockMatchHeaderViewModel(\n    matchHeaderData: MatchHeaderData(\n        id: \"premier_league\",\n        competitionName: \"Premier League\", \n        countryFlagImageName: \"GB\",\n        sportIconImageName: \"1\",\n        isFavorite: false,\n        visualState: .standard\n    )\n)\n``` \n",
      "snapshots": [
        {
          "category": "HeaderVariants",
          "light": "MatchHeaderView/__Snapshots__/MatchHeaderViewSnapshotTests/testMatchHeaderView_HeaderVariants_Light.1.png",
          "dark": "MatchHeaderView/__Snapshots__/MatchHeaderViewSnapshotTests/testMatchHeaderView_HeaderVariants_Dark.1.png"
        },
        {
          "category": "VisibilityVariants",
          "light": "MatchHeaderView/__Snapshots__/MatchHeaderViewSnapshotTests/testMatchHeaderView_VisibilityVariants_Light.1.png",
          "dark": "MatchHeaderView/__Snapshots__/MatchHeaderViewSnapshotTests/testMatchHeaderView_VisibilityVariants_Dark.1.png"
        }
      ]
    },
    "MatchParticipantsInfoView": {
      "displayName": "MatchParticipantsInfoView",
      "category": "MatchCards",
      "subcategory": "Participants",
      "summary": "Match participants display with horizontal/vertical layouts and match state info",
      "description": "Dual-layout match display showing home/away participant names with match state information. Horizontal mode (70pt min height) places participants left/right with centered date/time or score. Vertical mode (80pt height) stacks participants left with right-aligned ScoreView for detailed score breakdowns. Three match states: preLive (date + time), live (score + matchTime + 8pt red indicator dot), ended (final score). Serving indicators (9pt highlightPrimary dots) for tennis/volleyball. Multi-line participant names (bold 14pt, textPrimary), date (medium 12pt, textSecondary), time (bold 16pt), score (bold 17pt). Reactive Combine publishers for displayState and scoreViewModel. onParticipantTapped callback for navigation.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "match",
        "participants",
        "horizontal",
        "vertical",
        "live",
        "prelive",
        "ended",
        "score",
        "serving",
        "tennis",
        "volleyball",
        "basketball",
        "football"
      ],
      "states": [
        "default-preLive",
        "horizontal-preLive",
        "horizontal-live",
        "horizontal-ended",
        "vertical-tennis-live-serving",
        "vertical-basketball-live",
        "vertical-volleyball-live-serving",
        "vertical-football-preLive",
        "long-team-names",
        "live-without-time"
      ],
      "similarTo": [
        "MatchHeaderView",
        "MatchHeaderCompactView"
      ],
      "oftenUsedWith": [
        "ScoreView"
      ],
      "parents": [],
      "children": [
        "ScoreView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# MatchParticipantsInfoView\n\nA flexible, reusable UI component for displaying match participant information in sports betting applications. Supports both horizontal and vertical layouts with live scores, serving indicators, and detailed sport-specific scoring.\n\n## Features\n\n- **Dual Layout Modes**: Horizontal (compact) and vertical (detailed) display options\n- **Live Match States**: Pre-live, live with scores, and ended match support\n- **Serving Indicators**: Visual indicators for sports like tennis and volleyball\n- **Detailed Scoring**: Sport-specific score displays (tennis sets, basketball quarters, etc.)\n- **Reactive Updates**: Real-time UI updates via Combine publishers\n- **Accessibility**: Full accessibility support with proper labels and traits\n- **StyleProvider Integration**: Consistent theming across all visual elements\n\n## Usage Example\n\n### Basic Implementation\n\n```swift\n\n\n// Create match data\nlet matchData = MatchParticipantsData(\n    homeParticipantName: \"Real Madrid\",\n    awayParticipantName: \"Barcelona\",\n    matchState: .live(score: \"2 - 1\", matchTime: \"67'\"),\n    servingIndicator: .none\n)\n\n// Create display state\nlet displayState = MatchParticipantsDisplayState(\n    displayMode: .horizontal,\n    matchData: matchData\n)\n\n// Create view model (use your actual implementation)\nlet viewModel = YourMatchParticipantsViewModel(displayState: displayState)\n\n// Create and configure the view\nlet matchView = MatchParticipantsInfoView(viewModel: viewModel)\nparentView.addSubview(matchView)\n\n// Setup constraints\nNSLayoutConstraint.activate([\n    matchView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 16),\n    matchView.trailingAnchor.constraint(equalTo: parentView.trailingAnchor, constant: -16),\n    matchView.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor, constant: 20)\n])\n```\n\n### Tennis Match with Detailed Scoring\n\n```swift\nlet matchData = MatchParticipantsData(\n    homeParticipantName: \"Novak Djokovic\",\n    awayParticipantName: \"Rafael Nadal\",\n    matchState: .live(score: \"1 - 1\", matchTime: \"3rd Set\"),\n    servingIndicator: .home\n)\n\nlet displayState = MatchParticipantsDisplayState(\n    displayMode: .vertical,\n    matchData: matchData\n)\n\n// Create score display data for the ScoreView component\nlet tennisScores = [\n    ScoreDisplayData(id: \"set1\", homeScore: \"6\", awayScore: \"4\", style: .simple),\n    ScoreDisplayData(id: \"set2\", homeScore: \"3\", awayScore: \"6\", style: .simple),\n    ScoreDisplayData(id: \"set3\", homeScore: \"40\", awayScore: \"30\", style: .background)\n]\n\nlet scoreViewModel = MockScoreViewModel(scoreCells: tennisScores, visualState: .display)\n\n// Your view model should provide both the display state and score view model\n```\n\n### Using Mock Data for Testing\n\n```swift\n// Use predefined mock examples\nlet viewModel = MockMatchParticipantsInfoViewModel.verticalTennisLive\nlet matchView = MatchParticipantsInfoView(viewModel: viewModel)\n\n// Handle participant interactions\nmatchView.onParticipantTapped = { participantName in\n    print(\"Participant tapped: \\(participantName)\")\n    // Navigate to participant details or perform action\n}\n```\n\n## Component Architecture\n\n### Data Models\n\n#### `MatchParticipantsData`\nContains all information about the match participants and current state:\n- `homeParticipantName`: Name of the home team/player\n- `awayParticipantName`: Name of the away team/player  \n- `matchState`: Current state (pre-live, live, ended)\n- `servingIndicator`: Which participant is serving (if applicable)\n\n#### `MatchState`\nRepresents the current match status:\n- `.preLive(date: String, time: String)`: Match hasn't started yet\n- `.live(score: String, matchTime: String?)`: Match is in progress\n- `.ended(score: String)`: Match has finished\n\n#### `ServingIndicator`\nFor sports with serving (tennis, volleyball):\n- `.none`: No serving indication\n- `.home`: Home participant is serving\n- `.away`: Away participant is serving\n\n#### `ScoreView Integration`\nFor vertical layout mode, the component uses the existing `ScoreView` component:\n- Managed through `scoreViewModelPublisher` in the view model protocol\n- Supports all `ScoreDisplayData` formats (simple, border, background styles)\n- Automatically shown/hidden based on layout mode\n\n### Layout Modes\n\n#### Horizontal Layout\n- **Use Case**: Compact display in lists or cards\n- **Height**: ~70pt\n- **Content**: Participant names on sides, center shows date/time or score\n- **Features**: Live indicator dot, match time display\n\n#### Vertical Layout  \n- **Use Case**: Detailed match information display\n- **Height**: ~80pt\n- **Content**: Stacked participant names with serving indicators, detailed scores on right\n- **Features**: Serving indicators, detailed sport-specific scoring, enhanced information density\n\n## Customization Options\n\n### Layout Mode Switching\n```swift\n// Switch between horizontal and vertical layouts\nviewModel.setDisplayMode(.vertical)\nviewModel.setDisplayMode(.horizontal)\n```\n\n### Match State Updates\n```swift\n// Update match to live state\nlet newMatchData = MatchParticipantsData(\n    homeParticipantName: currentData.homeParticipantName,\n    awayParticipantName: currentData.awayParticipantName,\n    matchState: .live(score: \"1 - 0\", matchTime: \"23'\"),\n    servingIndicator: .home\n)\nviewModel.updateMatchData(newMatchData)\n```\n\n### Serving Indicator Updates\n```swift\n// Update who is serving (tennis, volleyball, etc.)\nlet updatedData = MatchParticipantsData(\n    homeParticipantName: \"Player 1\",\n    awayParticipantName: \"Player 2\", \n    matchState: .live(score: \"40 - 30\", matchTime: \"Game 5\"),\n    servingIndicator: .away // Away player now serving\n)\nviewModel.updateMatchData(updatedData)\n```\n\n## Mock View Models\n\nThe component includes comprehensive mock implementations for testing:\n\n- `MockMatchParticipantsInfoViewModel.defaultMock`: Basic horizontal layout\n- `MockMatchParticipantsInfoViewModel.horizontalLive`: Live football match\n- `MockMatchParticipantsInfoViewModel.verticalTennisLive`: Tennis with serving and detailed scores\n- `MockMatchParticipantsInfoViewModel.verticalBasketballLive`: Basketball with quarter scores\n- `MockMatchParticipantsInfoViewModel.longTeamNames`: Edge case with long names\n\n## Accessibility\n\nThe component provides full accessibility support:\n- Proper accessibility labels for all interactive elements\n- Voice-over descriptions for match states and scores\n- Dynamic accessibility updates as match state changes\n- Support for accessibility font scaling\n\n## Performance Considerations\n\n- **Efficient Updates**: Only renders changed elements when state updates\n- **Memory Management**: Proper cleanup of Combine subscriptions\n- **Layout Optimization**: Constraint-based layout for smooth animations\n- **Preview Performance**: Lightweight mock data for SwiftUI previews\n\n## Integration with Existing Systems\n\n### With ScoreView Component\n```swift\n// MatchParticipantsInfoView automatically integrates ScoreView for vertical layout\n// Your view model should implement scoreViewModelPublisher to provide score data\n\nprotocol YourMatchViewModelProtocol: MatchParticipantsInfoViewModelProtocol {\n    // Implement both required publishers\n    var displayStatePublisher: AnyPublisher<MatchParticipantsDisplayState, Never> { get }\n    var scoreViewModelPublisher: AnyPublisher<ScoreViewModelProtocol?, Never> { get }\n}\n```\n\n### Migration from Legacy Code\nThis component replaces the legacy `MatchInfoView`, `HorizontalMatchInfoView`, and `VerticalMatchInfoView` with:\n- Improved data model design\n- Better separation of concerns\n- Enhanced testability\n- StyleProvider integration\n- Reactive programming patterns\n\n## Testing\n\nThe component includes extensive testing support:\n- Multiple mock scenarios for different sports\n- Edge cases (long names, missing data)\n- Layout mode switching\n- State transition testing\n\nUse the TestCase app to interactively test all component features and states.\n",
      "snapshots": [
        {
          "category": "HorizontalVariants",
          "light": "MatchParticipantsInfoView/__Snapshots__/MatchParticipantsInfoViewSnapshotTests/testMatchParticipantsInfoView_HorizontalVariants_Light.1.png",
          "dark": "MatchParticipantsInfoView/__Snapshots__/MatchParticipantsInfoViewSnapshotTests/testMatchParticipantsInfoView_HorizontalVariants_Dark.1.png"
        },
        {
          "category": "VerticalVariants",
          "light": "MatchParticipantsInfoView/__Snapshots__/MatchParticipantsInfoViewSnapshotTests/testMatchParticipantsInfoView_VerticalVariants_Light.1.png",
          "dark": "MatchParticipantsInfoView/__Snapshots__/MatchParticipantsInfoViewSnapshotTests/testMatchParticipantsInfoView_VerticalVariants_Dark.1.png"
        }
      ]
    },
    "MultiWidgetToolbarView": {
      "displayName": "MultiWidgetToolbarView",
      "category": "Navigation",
      "subcategory": "Toolbar",
      "summary": "Configurable multi-line toolbar with dynamic widgets for logged-in/out states",
      "description": "JSON-configurable multi-line toolbar supporting various widget types in logged-in and logged-out layouts. Two layout modes: flex (content-sized with required hugging) and split (equal-width distribution). LoggedIn shows single line with logo, wallet, avatar. LoggedOut shows two lines: logo/support/language on top, login/register buttons below. Widget types: image (32pt logo with 6x secret tap for debug), wallet (WalletWidgetView child), avatar (32pt circle), support (32pt circle with question icon), languageSwitcher (32pt circle with locale code), button, loginButton (bordered outline), signUpButton (filled primary), space (flexible spacer). Callbacks: onWidgetSelected, onBalanceTapped, onDepositTapped, onLogoSecretTapped. Line height 40pt, button height 56pt, 16pt horizontal padding, 14pt line spacing. Production usage in BetssonCameroonApp TopBarContainerController.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "toolbar",
        "navigation",
        "multi-line",
        "widgets",
        "logged-in",
        "logged-out",
        "wallet",
        "avatar",
        "login",
        "register",
        "configurable",
        "json"
      ],
      "states": [
        "logged-in-single-line",
        "logged-out-two-lines",
        "complex-with-search-notifications"
      ],
      "similarTo": [
        "CustomNavigationView"
      ],
      "oftenUsedWith": [
        "WalletWidgetView"
      ],
      "parents": [],
      "children": [
        "WalletWidgetView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# MultiWidgetToolbarView\n\nA highly configurable and dynamic toolbar for displaying various widgets in a customizable layout.\n\n## Features\n\n- Support for multiple widget types: images, buttons, wallet, avatar, etc.\n- Dynamic layout that adapts to logged-in vs. logged-out states\n- Flexible arrangement of widgets (flex/split modes)\n- Customizable through JSON configuration\n- Combine-based reactive architecture\n\n## Usage\n\n### Basic Usage\n\n```swift\n// Create a view model (or use a mock for testing)\nlet viewModel = MockMultiWidgetToolbarViewModel.defaultMock\n\n// Create the toolbar view\nlet toolbarView = MultiWidgetToolbarView(viewModel: viewModel)\n\n// Add to your view hierarchy\nparentView.addSubview(toolbarView)\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    toolbarView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor),\n    toolbarView.trailingAnchor.constraint(equalTo: parentView.trailingAnchor),\n    toolbarView.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor)\n])\n\n// Handle widget selection\ntoolbarView.onWidgetSelected = { widgetID in\n    print(\"Widget selected: \\(widgetID)\")\n    // Perform navigation or other actions\n}\n\n// Change state based on user login\ntoolbarView.setLoggedInState(isUserLoggedIn)\n```\n\n### Configuration Format\n\nThe component uses a JSON-based configuration with this structure:\n\n```json\n{\n  \"name\": \"topbar\",\n  \"widgets\": [\n    {\n      \"id\": \"logo\",\n      \"type\": \"image\",\n      \"src\": \"https://example.com/logo.png\",\n      \"alt\": \"Company Logo\"\n    },\n    {\n      \"id\": \"loginButton\",\n      \"type\": \"button\",\n      \"label\": \"Login\",\n      \"route\": \"/login\"\n    }\n    // More widgets...\n  ],\n  \"layouts\": {\n    \"loggedIn\": {\n      \"lines\": [\n        {\n          \"mode\": \"flex\",\n          \"widgets\": [\"logo\", \"flexSpace\", \"wallet\", \"avatar\"]\n        }\n      ]\n    },\n    \"loggedOut\": {\n      \"lines\": [\n        {\n          \"mode\": \"flex\",\n          \"widgets\": [\"logo\", \"flexSpace\", \"support\"]\n        },\n        {\n          \"mode\": \"split\",\n          \"widgets\": [\"loginButton\", \"registerButton\"]\n        }\n      ]\n    }\n  }\n}\n```\n\n### Custom ViewModel Implementation\n\nTo create a custom ViewModel implementation:\n\n```swift\nclass MyMultiWidgetToolbarViewModel: MultiWidgetToolbarViewModelProtocol {\n    // Implement the required properties and methods\n    private let displayStateSubject: CurrentValueSubject<MultiWidgetToolbarDisplayState, Never>\n    \n    var displayStatePublisher: AnyPublisher<MultiWidgetToolbarDisplayState, Never> {\n        return displayStateSubject.eraseToAnyPublisher()\n    }\n    \n    // Load configuration from API, file, or other source\n    init(configURL: URL) {\n        // Load config\n        // Create initial state\n    }\n    \n    func selectWidget(id: String) {\n        // Handle widget selection\n    }\n    \n    func setLayoutState(_ state: LayoutState) {\n        // Update the layout state\n    }\n}\n```\n\n## Widget Types\n\nThe component supports these widget types:\n\n- **image**: Displays an image (logo, icon)\n- **wallet**: Shows balance with deposit button\n- **avatar**: User profile picture/icon\n- **support**: Support/help button\n- **languageSwitcher**: Language selection\n- **button**: Standard button with label\n- **space**: Flexible spacing element\n\n## Layout Modes\n\nTwo layout modes are available:\n\n- **flex**: Distributes widgets with flexible spacing (some take more space than others)\n- **split**: Distributes widgets equally across the available width ",
      "snapshots": []
    },
    "NavigationActionView": {
      "displayName": "NavigationActionView",
      "category": "Navigation",
      "subcategory": "Actions",
      "summary": "Tappable navigation action row with title and trailing icon",
      "description": "Simple navigation action row displaying left-aligned title and right-aligned icon. Container 48pt height with 8pt corner radius, backgroundPrimary fill. Title (semibold 12pt, textPrimary) with 16pt leading padding. Icon (22pt x 22pt, highlightPrimary tint) with 16pt trailing padding, 12pt gap from title. Icon resolution tries custom image first then falls back to SF Symbols. Enabled/disabled states (disabled shows alpha 0.5, userInteractionEnabled false). Tap gesture triggers viewModel.onNavigationTapped(). Common use cases: 'Open Betslip Details' with chevron.right, 'Share your Betslip' with square.and.arrow.up. Used in betslip screens, action sheets, menu lists.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "navigation",
        "action",
        "row",
        "tappable",
        "icon",
        "title",
        "betslip",
        "sf-symbols"
      ],
      "states": [
        "enabled-chevron",
        "enabled-share",
        "disabled",
        "short-title",
        "long-title",
        "settings-icon",
        "profile-icon"
      ],
      "similarTo": [
        "ActionRowView"
      ],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# NavigationActionView\n\nA tappable navigation action row with title and trailing icon.\n\n## Overview\n\nNavigationActionView displays a simple navigation action with a title on the left and an icon on the right. It's commonly used for actions like \"Open Betslip Details\" or \"Share your Betslip\". The component supports enabled/disabled states and uses either custom or SF Symbols icons.\n\n## Component Relationships\n\n### Used By (Parents)\n- Betslip screens\n- Action sheets\n- Menu lists\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Title label (left-aligned)\n- Trailing icon (right-aligned)\n- SF Symbols and custom image support\n- Enabled/disabled states (alpha 0.5 when disabled)\n- Tap gesture with callback\n- 48pt fixed height\n- Rounded container (8pt)\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockNavigationActionViewModel.openBetslipDetailsMock()\nlet actionView = NavigationActionView(viewModel: viewModel)\n\n// Note: Tap handling is done through the ViewModel\n// The view calls viewModel.onNavigationTapped() when tapped\n\n// Update title dynamically\nviewModel.updateTitle(\"View Details\")\n\n// Update icon\nviewModel.updateIcon(\"arrow.right\")\n\n// Disable the action\nviewModel.setEnabled(false)\n```\n\n## Data Model\n\n```swift\nstruct NavigationActionData: Equatable {\n    let title: String\n    let icon: String?        // SF Symbol name or custom image name\n    let isEnabled: Bool\n}\n\nprotocol NavigationActionViewModelProtocol {\n    var dataPublisher: AnyPublisher<NavigationActionData, Never> { get }\n    var currentData: NavigationActionData { get }\n\n    func updateTitle(_ title: String)\n    func updateIcon(_ icon: String?)\n    func setEnabled(_ isEnabled: Bool)\n    func onNavigationTapped()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundPrimary` - container background\n- `StyleProvider.Color.textPrimary` - title text color\n- `StyleProvider.Color.highlightPrimary` - icon tint color\n- `StyleProvider.fontWith(type: .semibold, size: 12)` - title font\n\nLayout constants:\n- Container height: 48pt\n- Container corner radius: 8pt\n- Horizontal padding: 16pt\n- Icon size: 22pt x 22pt\n- Title-to-icon gap: 12pt minimum\n\nIcon resolution:\n1. First tries custom image (UIImage(named:))\n2. Falls back to SF Symbol (UIImage(systemName:))\n\n## Mock ViewModels\n\nAvailable presets:\n- `.openBetslipDetailsMock()` - \"Open Betslip Details\" with chevron.right\n- `.shareBetslipMock()` - \"Share your Betslip\" with square.and.arrow.up\n- `.disabledMock()` - \"Disabled Action\" with chevron.right, disabled state\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "NavigationActionView/__Snapshots__/NavigationActionViewSnapshotTests/testNavigationActionView_BasicStates_Light.1.png",
          "dark": "NavigationActionView/__Snapshots__/NavigationActionViewSnapshotTests/testNavigationActionView_BasicStates_Dark.1.png"
        },
        {
          "category": "ContentVariants",
          "light": "NavigationActionView/__Snapshots__/NavigationActionViewSnapshotTests/testNavigationActionView_ContentVariants_Light.1.png",
          "dark": "NavigationActionView/__Snapshots__/NavigationActionViewSnapshotTests/testNavigationActionView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "NotificationListView": {
      "displayName": "NotificationListView",
      "category": "Status",
      "subcategory": "Lists",
      "summary": "Vertical scrollable list of notification cards with loading, empty, and error states",
      "description": "UICollectionView-based notification list with self-sizing cells. Four states: loading (activity indicator, highlightPrimary tint), loaded (NotificationCardView cells), empty (localized 'no_notifications' message, medium 16pt, textSecondary), error (localized 'failed_to_load_notifications'). Each NotificationCardView child shows timestamp (formatted 'Today/Yesterday/date, time'), bold 14pt title, regular 12pt description, optional action button (33pt height, primary/secondary styles). Position-based corner rounding on 16pt outer container: single (all 4), first (top 2), middle (none), last (bottom 2). Read/unread states: unread has highlightPrimary 1pt border and 8pt indicator dot, read has separatorLine border. Section insets 8pt, 0pt line spacing (cards touch). Height calculated dynamically from content. Actions: refresh(), loadMore(), markAsRead(), markAllAsRead(), deleteNotification(), clearAllNotifications().",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "notifications",
        "list",
        "collection",
        "cards",
        "loading",
        "empty",
        "error",
        "read",
        "unread",
        "inbox",
        "self-sizing"
      ],
      "states": [
        "default-mixed",
        "mixed-notification-types",
        "empty",
        "loading",
        "unread-only",
        "read-only",
        "long-content"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "NotificationCardView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# NotificationListView\n\nA vertical scrollable list of notification cards with loading, empty, and error states.\n\n## Overview\n\nNotificationListView displays a collection of notifications using UICollectionView with self-sizing cells. Each notification shows timestamp, title, description, and optional action button. Cards have position-based corner rounding (first/last/single/middle) and support read/unread visual states. The component handles loading, empty, and error states with appropriate UI feedback.\n\n## Component Relationships\n\n### Used By (Parents)\n- Notification center screens\n- Inbox views\n\n### Uses (Children)\n- `NotificationCardView` (via NotificationCardCollectionViewCell)\n\n## Features\n\n- Vertical scrolling collection view\n- Self-sizing cells based on content\n- Loading state with activity indicator\n- Empty state with localized message\n- Error state with error message\n- Position-based card corner rounding\n- Read/unread visual states\n- Optional action button per notification\n- Mark as read on tap\n- Refresh and load more support\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockNotificationListViewModel.defaultMock\nlet notificationList = NotificationListView(viewModel: viewModel)\n\n// Setup callbacks\nviewModel.onActionPerformed = { notification in\n    handleAction(notification)\n}\n\nviewModel.onNotificationRead = { notification in\n    updateUnreadCount()\n}\n\nviewModel.onRefreshCompleted = {\n    endRefreshing()\n}\n\nviewModel.onError = { error in\n    showError(error)\n}\n\n// Refresh the list\nnotificationList.refresh()\n\n// Mark specific notification as read\nnotificationList.markAsRead(notificationId: \"notif_1\")\n```\n\n## Data Model\n\n```swift\nenum NotificationListState {\n    case loading\n    case loaded([NotificationData])\n    case empty\n    case error(Error)\n}\n\nstruct NotificationData: Equatable, Hashable {\n    let id: String\n    let timestamp: Date\n    let title: String\n    let description: String\n    let state: NotificationState    // .read or .unread\n    let action: NotificationAction?\n\n    var isUnread: Bool { state == .unread }\n    var hasAction: Bool { action != nil }\n}\n\nstruct NotificationAction: Equatable, Hashable {\n    let id: String\n    let title: String\n    let style: ActionStyle  // .primary or .secondary\n}\n\nenum CardPosition {\n    case single  // All corners rounded\n    case first   // Top corners rounded\n    case middle  // No corners rounded\n    case last    // Bottom corners rounded\n}\n\nprotocol NotificationListViewModelProtocol {\n    var notificationListStatePublisher: AnyPublisher<NotificationListState, Never> { get }\n    var notificationsPublisher: AnyPublisher<[NotificationData], Never> { get }\n    var isLoadingPublisher: AnyPublisher<Bool, Never> { get }\n    var notifications: [NotificationData] { get }\n    var isLoading: Bool { get }\n    var unreadCount: Int { get }\n\n    func refresh()\n    func loadMore()\n    func markAsRead(notificationId: String)\n    func markAllAsRead()\n    func performAction(for notification: NotificationData)\n    func deleteNotification(notificationId: String)\n    func clearAllNotifications()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.textSecondary` - empty state text color\n- `StyleProvider.Color.highlightPrimary` - loading indicator color\n- `StyleProvider.fontWith(type: .medium, size: 16)` - empty state font\n- `StyleProvider.fontWith(type: .bold, size: 14)` - title font (for height calc)\n- `StyleProvider.fontWith(type: .regular, size: 12)` - description font (for height calc)\n\nLayout constants:\n- Section insets: 8pt all sides\n- Minimum line spacing: 0pt (cards touch)\n- Header height: 16pt + 16pt padding\n- Title-description gap: 3pt\n- Action button gap: 12pt\n- Action button height: 33pt\n- Minimum title height: 24pt\n- Minimum description height: 16pt\n\nHeight calculation:\n- Base: 16pt (top) + 16pt (header) + 16pt (bottom)\n- Plus: title height + 3pt + description height\n- Plus (if action): 12pt + 33pt\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - 4 notifications, mixed read/unread, with/without actions\n- `.mixedNotificationsMock` - Welcome, payment, promo, verification types\n- `.emptyMock` - Empty state\n- `.loadingMock` - Loading state\n- `.unreadOnlyMock` - 2 urgent unread notifications\n- `.readOnlyMock` - 2 old read notifications\n",
      "snapshots": []
    },
    "OddsAcceptanceView": {
      "displayName": "OddsAcceptanceView",
      "category": "Betting",
      "subcategory": "Controls",
      "summary": "Checkbox component for odds change acceptance with label and clickable link",
      "description": "Checkbox with acceptance label and tappable 'Learn More' link for betslip odds change acceptance. Horizontal stack with 12pt spacing: 24pt x 24pt checkbox (4pt corner radius, 1pt border) and multiline label. Accepted state: highlightPrimary background/border with centered 12pt checkmark icon (allWhite tint). NotAccepted state: clear background with backgroundBorder border, no checkmark. Label shows regular 12pt textPrimary text with underlined link portion. Link detection uses NSLayoutManager to calculate character index from tap location. Enabled/disabled states (disabled shows alpha 0.5). ViewModel handles onCheckboxTapped (toggles accepted/notAccepted) and onLinkTapped callbacks. Default texts localized: 'accept_odds_change' + 'learn_more'. Production usage in BetssonCameroonApp betslip screens.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "checkbox",
        "odds",
        "acceptance",
        "betslip",
        "link",
        "toggle",
        "clickable",
        "localized"
      ],
      "states": [
        "accepted",
        "not-accepted",
        "disabled"
      ],
      "similarTo": [],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# OddsAcceptanceView\n\nA checkbox component for odds change acceptance with label and clickable link.\n\n## Overview\n\nOddsAcceptanceView displays a checkbox with an acceptance label and a tappable \"Learn More\" link. It's used in betslip interfaces to let users accept odds changes during bet placement. The checkbox toggles between accepted/not accepted states, and the link text is tappable for more information.\n\n## Component Relationships\n\n### Used By (Parents)\n- Betslip submission views\n- Bet placement forms\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Checkbox with checkmark icon\n- Acceptance label text\n- Underlined clickable link text\n- Accepted/not accepted visual states\n- Enabled/disabled states (alpha 0.5)\n- Checkbox toggle on tap\n- Link detection with tap gesture\n- ViewModel replacement support\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockOddsAcceptanceViewModel.notAcceptedMock()\nlet acceptanceView = OddsAcceptanceView(viewModel: viewModel)\n\n// Toggle acceptance state programmatically\nviewModel.updateState(.accepted)\n\n// Custom label text\nviewModel.updateLabelText(\"I accept changes to\")\nviewModel.updateLinkText(\"odds\")\n\n// Disable the component\nviewModel.setEnabled(false)\n\n// Handle link tap (done in ViewModel)\n// viewModel.onLinkTapped() is called when link is tapped\n```\n\n## Data Model\n\n```swift\nenum OddsAcceptanceState: Equatable {\n    case accepted\n    case notAccepted\n}\n\nstruct OddsAcceptanceData: Equatable {\n    let state: OddsAcceptanceState\n    let labelText: String      // Default: \"Accept odds change\"\n    let linkText: String       // Default: \"Learn more\"\n    let isEnabled: Bool\n}\n\nprotocol OddsAcceptanceViewModelProtocol {\n    var dataPublisher: AnyPublisher<OddsAcceptanceData, Never> { get }\n    var currentData: OddsAcceptanceData { get }\n\n    func updateState(_ state: OddsAcceptanceState)\n    func updateLabelText(_ text: String)\n    func updateLinkText(_ text: String)\n    func setEnabled(_ isEnabled: Bool)\n    func onCheckboxTapped()\n    func onLinkTapped()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundBorder` - checkbox border (unchecked)\n- `StyleProvider.Color.highlightPrimary` - checkbox background/border (checked)\n- `StyleProvider.Color.allWhite` - checkmark icon color\n- `StyleProvider.Color.textPrimary` - label and link text color\n- `StyleProvider.fontWith(type: .regular, size: 14)` - label font (init)\n- `StyleProvider.fontWith(type: .regular, size: 12)` - label font (render)\n\nLayout constants:\n- Stack spacing: 12pt\n- Checkbox size: 24pt x 24pt\n- Checkbox corner radius: 4pt\n- Checkbox border width: 1pt\n- Checkmark icon size: 12pt x 12pt\n\nVisual states:\n- **Accepted**: Primary highlight background, checkmark visible\n- **Not Accepted**: Clear background, border only, no checkmark\n- **Disabled**: Alpha 0.5, interactions disabled\n\nLink detection:\n- Uses NSLayoutManager for precise tap location\n- Calculates character index from tap point\n- Checks if tap falls within link text range\n\n## Mock ViewModels\n\nAvailable presets:\n- `.acceptedMock()` - Checkbox checked state\n- `.notAcceptedMock()` - Checkbox unchecked state\n- `.disabledMock()` - Unchecked, disabled state\n",
      "snapshots": []
    },
    "OutcomeItemView": {
      "displayName": "OutcomeItemView",
      "category": "Betting",
      "subcategory": "Outcomes",
      "summary": "Individual betting outcome button with odds, selection state, and animated odds changes",
      "description": "A single betting outcome item displaying title (e.g., 'Home', 'Over 2.5') and odds value with multiple display states. Supports loading (activity indicator), locked (lock icon), unavailable ('-'), and normal states with optional selection and boost indicators. Features animated odds change indicators (green up arrow, red down arrow) with colored backgrounds that auto-hide after 3 seconds. Position-based corner rounding via OutcomePosition enum enables seamless grid layouts. Provides haptic feedback on tap and supports long-press callbacks for market details.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "outcome",
        "odds",
        "betting",
        "selection",
        "animated",
        "haptic",
        "boost",
        "locked",
        "leaf-component"
      ],
      "states": [
        "loading",
        "locked",
        "unavailable",
        "normal-selected",
        "normal-unselected",
        "boosted",
        "boosted-selected",
        "odds-up",
        "odds-down"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "MarketOutcomesLineView",
        "CompactOutcomesLineView"
      ],
      "parents": [
        "CompactOutcomesLineView",
        "MarketOutcomesLineView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# OutcomeItemView\n\nOutcomeItemView is a reusable component designed for displaying individual betting market outcomes. It provides a clean, interactive interface for outcome selection with visual feedback, odds change animations, and accessibility support.\n\n## Features\n\n- **Interactive Selection**: Tap to select/deselect outcomes with visual feedback\n- **Odds Change Animations**: Regulatory-compliant animations for odds increases/decreases\n- **Accessibility Support**: Full VoiceOver and accessibility trait support\n- **Haptic Feedback**: Provides tactile feedback for user interactions\n- **Customizable Styling**: Uses StyleProvider for consistent theming\n- **State Management**: Reactive state updates using Combine publishers\n- **Long Press Support**: Additional interaction for extended functionality\n\n## Usage Example\n\n```swift\n// Create a view model (or use a mock for testing)\nlet outcomeData = OutcomeItemData(\n    id: \"home\",\n    title: \"Home\",\n    value: \"1.85\",\n    isSelected: false,\n    isDisabled: false\n)\nlet viewModel = MockOutcomeItemViewModel(outcomeData: outcomeData)\n\n// Create the component\nlet outcomeView = OutcomeItemView(viewModel: viewModel)\n\n// Add to your view hierarchy\nparentView.addSubview(outcomeView)\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    outcomeView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor),\n    outcomeView.topAnchor.constraint(equalTo: parentView.topAnchor),\n    outcomeView.widthAnchor.constraint(equalToConstant: 100),\n    outcomeView.heightAnchor.constraint(equalToConstant: 50)\n])\n\n// Handle interactions\noutcomeView.onTap = {\n    print(\"Outcome tapped\")\n    // Handle selection logic\n}\n\noutcomeView.onLongPress = {\n    print(\"Outcome long pressed\")\n    // Handle additional actions\n}\n```\n\n## Configuration Options\n\n### OutcomeItemData Properties\n\n- **id**: Unique identifier for the outcome\n- **title**: Display title (e.g., \"Home\", \"Over 2.5\")\n- **value**: Odds value (e.g., \"1.85\", \"2.50\")\n- **oddsChangeDirection**: Visual indicator for odds changes (.up, .down, .none)\n- **isSelected**: Whether the outcome is currently selected\n- **isDisabled**: Whether the outcome is disabled/grayed out\n- **previousValue**: Previous odds value for change tracking\n- **changeTimestamp**: When the odds change occurred\n\n### View Model Methods\n\n```swift\n// Toggle selection state\nlet isNowSelected = viewModel.toggleSelection()\n\n// Update odds value with automatic direction calculation\nviewModel.updateValue(\"2.10\")\n\n// Update odds with specific direction\nviewModel.updateValue(\"2.10\", changeDirection: .up)\n\n// Set selection state\nviewModel.setSelected(true)\n\n// Set disabled state\nviewModel.setDisabled(true)\n\n// Clear odds change indicators\nviewModel.clearOddsChangeIndicator()\n```\n\n### Public View Methods\n\n```swift\n// Simulate odds change for testing\noutcomeView.simulateOddsChange(newValue: \"2.25\")\n\n// Programmatically set selection\noutcomeView.setSelected(true)\n\n// Programmatically set disabled state\noutcomeView.setDisabled(true)\n```\n\n## Visual States\n\n### Selection States\n- **Unselected**: Default background with standard text colors\n- **Selected**: Primary color background with contrast text colors\n- **Disabled**: Reduced opacity (50%) with disabled interaction\n\n### Odds Change Indicators\n- **Odds Increase**: Green up arrow with green border animation\n- **Odds Decrease**: Red down arrow with red border animation\n- **No Change**: No indicators visible\n\n### Animations\n- **Odds Change**: 3-second regulatory-compliant animation with auto-hide\n- **Selection**: Immediate visual feedback with haptic response\n- **Border Animation**: Smooth color transition for odds changes\n\n## Accessibility\n\nThe component provides comprehensive accessibility support:\n\n- **VoiceOver**: Announces title and value as a single element\n- **Accessibility Traits**: Marked as button with selection state\n- **Disabled State**: Properly marked when disabled\n- **Accessibility Label**: Combines title and value for clear context\n\n## Mock Data Factory\n\nThe component includes several pre-configured mock view models:\n\n```swift\n// Basic outcomes\nMockOutcomeItemViewModel.homeOutcome      // Selected home outcome\nMockOutcomeItemViewModel.drawOutcome      // Unselected draw outcome\nMockOutcomeItemViewModel.awayOutcome      // Unselected away outcome\n\n// Odds change examples\nMockOutcomeItemViewModel.overOutcomeUp    // Over outcome with odds increase\nMockOutcomeItemViewModel.underOutcomeDown // Under outcome with odds decrease\n\n// Special states\nMockOutcomeItemViewModel.disabledOutcome  // Disabled outcome\n\n// Custom factory\nMockOutcomeItemViewModel.customOutcome(\n    id: \"custom\",\n    title: \"Custom\",\n    value: \"3.50\",\n    oddsChangeDirection: .up,\n    isSelected: false,\n    isDisabled: false\n)\n```\n\n## Integration with Other Components\n\nOutcomeItemView is designed to be used within larger components like:\n\n- **MarketOutcomesLineView**: For single-line market displays\n- **MarketOutcomesMultiLineView**: For multi-line market groups\n- **Custom Market Components**: Any component needing outcome display\n\n## Styling Customization\n\n### Font Customization (OutcomeItemConfiguration)\n\nThe component supports per-instance font customization via `OutcomeItemConfiguration`:\n\n```swift\n// Create custom configuration\nlet compactConfig = OutcomeItemConfiguration(\n    titleFontSize: 10.0,\n    titleFontType: .regular,\n    valueFontSize: 14.0,\n    valueFontType: .bold\n)\n\n// Option 1: Pass configuration at initialization\nlet outcomeView = OutcomeItemView(\n    viewModel: viewModel,\n    configuration: compactConfig\n)\n\n// Option 2: Apply configuration after initialization\noutcomeView.setCustomization(compactConfig)\n\n// Option 3: Use predefined configurations\nlet defaultView = OutcomeItemView(viewModel: viewModel)  // Uses .default\nlet compactView = OutcomeItemView(viewModel: viewModel, configuration: .compact)\n\n// Reset to default configuration\noutcomeView.setCustomization(nil)\n```\n\n#### Available Configurations\n\n| Configuration | Title Font | Value Font | Use Case |\n|--------------|------------|------------|----------|\n| `.default` | 12pt regular | 16pt bold | Standard outcome buttons |\n| `.compact` | 10pt regular | 14pt bold | Inline match cards, compact layouts |\n\n#### Custom Configuration Properties\n\n| Property | Type | Default | Description |\n|----------|------|---------|-------------|\n| `titleFontSize` | `CGFloat` | 12.0 | Font size for outcome title |\n| `titleFontType` | `StyleProvider.FontType` | `.regular` | Font weight for title |\n| `valueFontSize` | `CGFloat` | 16.0 | Font size for odds value |\n| `valueFontType` | `StyleProvider.FontType` | `.bold` | Font weight for odds value |\n\n### Global Theme Customization\n\nThe component also uses StyleProvider for global theming:\n\n```swift\n// Customize colors\nStyleProvider.Color.customize(\n    primaryColor: .systemBlue,        // Selected background\n    backgroundColor: .systemGray6,    // Unselected background\n    textColor: .label,               // Text color\n    contrastTextColor: .white,       // Selected text color\n    successColor: .systemGreen       // Odds increase color\n)\n\n// Customize fonts globally\nStyleProvider.setFontProvider { type, size in\n    switch type {\n    case .regular:\n        return UIFont.systemFont(ofSize: size, weight: .regular)\n    case .bold:\n        return UIFont.systemFont(ofSize: size, weight: .bold)\n    // ... other cases\n    }\n}\n```\n\n## Performance Considerations\n\n- **Reactive Updates**: Only updates UI elements that actually changed\n- **Animation Management**: Cancels previous animations to prevent conflicts\n- **Memory Management**: Uses weak references to prevent retain cycles\n- **Efficient Rendering**: Minimal view hierarchy for optimal performance\n\n## Testing\n\nThe component is designed for easy testing:\n\n```swift\n// Create test view model\nlet testData = OutcomeItemData(\n    id: \"test\",\n    title: \"Test\",\n    value: \"2.00\",\n    isSelected: false,\n    isDisabled: false\n)\nlet testViewModel = MockOutcomeItemViewModel(outcomeData: testData)\n\n// Test selection\nlet wasSelected = testViewModel.toggleSelection()\nXCTAssertTrue(wasSelected)\n\n// Test odds change\ntestViewModel.updateValue(\"2.50\")\n// Verify odds change event was emitted\n\n// Test disabled state\ntestViewModel.setDisabled(true)\n// Verify UI reflects disabled state\n```\n\n## Requirements\n\n- iOS 16.0+\n- Swift 5.7+\n- Combine framework\n- UIKit framework ",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "OutcomeItemView/__Snapshots__/OutcomeItemViewSnapshotTests/testOutcomeItemView_BasicStates_Light.1.png",
          "dark": "OutcomeItemView/__Snapshots__/OutcomeItemViewSnapshotTests/testOutcomeItemView_BasicStates_Dark.1.png"
        },
        {
          "category": "DisplayStates",
          "light": "OutcomeItemView/__Snapshots__/OutcomeItemViewSnapshotTests/testOutcomeItemView_DisplayStates_Light.1.png",
          "dark": "OutcomeItemView/__Snapshots__/OutcomeItemViewSnapshotTests/testOutcomeItemView_DisplayStates_Dark.1.png"
        },
        {
          "category": "FontCustomization",
          "light": "OutcomeItemView/__Snapshots__/OutcomeItemViewSnapshotTests/testOutcomeItemView_FontCustomization_Light.1.png",
          "dark": "OutcomeItemView/__Snapshots__/OutcomeItemViewSnapshotTests/testOutcomeItemView_FontCustomization_Dark.1.png"
        },
        {
          "category": "OddsChange",
          "light": "OutcomeItemView/__Snapshots__/OutcomeItemViewSnapshotTests/testOutcomeItemView_OddsChange_Light.1.png",
          "dark": "OutcomeItemView/__Snapshots__/OutcomeItemViewSnapshotTests/testOutcomeItemView_OddsChange_Dark.1.png"
        },
        {
          "category": "SizeVariants",
          "light": "OutcomeItemView/__Snapshots__/OutcomeItemViewSnapshotTests/testOutcomeItemView_SizeVariants_Light.1.png",
          "dark": "OutcomeItemView/__Snapshots__/OutcomeItemViewSnapshotTests/testOutcomeItemView_SizeVariants_Dark.1.png"
        }
      ]
    },
    "PendingWithdrawView": {
      "displayName": "PendingWithdrawView",
      "category": "Wallet",
      "subcategory": "Transactions",
      "summary": "Pending withdrawal card with date, status badge, amount, and copyable transaction ID",
      "description": "Displays withdrawal transaction information in a rounded card. Shows formatted date, colored status badge (customizable via PendingWithdrawStatusStyle for text/background/border colors), amount row, and transaction ID row with copy icon button. Copy button triggers handleCopyTransactionID() for clipboard integration with haptic feedback. Uses 8pt container corner radius and 12pt status badge corner radius.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "wallet",
        "withdrawal",
        "transaction",
        "pending",
        "copy",
        "clipboard",
        "status",
        "badge"
      ],
      "states": [
        "in-progress",
        "completed",
        "custom-status"
      ],
      "similarTo": [
        "TransactionRowView"
      ],
      "oftenUsedWith": [
        "WalletDetailView"
      ],
      "parents": [
        "WalletDetailView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# PendingWithdrawView\n\nA card displaying pending withdrawal transaction details with date, status badge, amount, and transaction ID.\n\n## Overview\n\nPendingWithdrawView shows information about a pending withdrawal transaction including the date/time, status with a styled badge, amount value, and a copyable transaction ID. The component is typically used in wallet detail views to display withdrawal requests that are still being processed.\n\n## Component Relationships\n\n### Used By (Parents)\n- `WalletDetailView`\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Date/time label\n- Status badge with customizable colors and border\n- Amount display with title and value\n- Transaction ID with copy button\n- Copy to clipboard functionality\n- SF Symbols and custom image support for copy icon\n- Rounded container with secondary background\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockPendingWithdrawViewModel()\nlet pendingView = PendingWithdrawView(viewModel: viewModel)\n\n// Handle copy action\nviewModel.onCopyRequested = { transactionId in\n    UIPasteboard.general.string = transactionId\n    showCopiedToast()\n}\n\n// Update with new state\nviewModel.update(displayState: PendingWithdrawViewDisplayState(\n    dateText: \"05/08/2025, 11:17\",\n    statusText: \"In Progress\",\n    statusStyle: PendingWithdrawStatusStyle(\n        textColor: .systemGreen,\n        backgroundColor: .systemGreen.withAlphaComponent(0.2),\n        borderColor: .systemGreen\n    ),\n    amountValueText: \"XAF 200,000\",\n    transactionIdValueText: \"HFD90230NRF\"\n))\n```\n\n## Data Model\n\n```swift\nstruct PendingWithdrawViewDisplayState {\n    let dateText: String\n    let statusText: String\n    let statusStyle: PendingWithdrawStatusStyle\n    let amountTitleText: String      // Default: \"Amount\"\n    let amountValueText: String\n    let transactionIdTitleText: String // Default: \"Transaction ID\"\n    let transactionIdValueText: String\n    let copyIconName: String?        // Default: \"doc.on.doc\"\n}\n\nstruct PendingWithdrawStatusStyle {\n    let textColor: UIColor\n    let backgroundColor: UIColor\n    let borderColor: UIColor?\n}\n\nprotocol PendingWithdrawViewModelProtocol: AnyObject {\n    var currentDisplayState: PendingWithdrawViewDisplayState { get }\n    var displayStatePublisher: AnyPublisher<PendingWithdrawViewDisplayState, Never> { get }\n\n    func handleCopyTransactionID()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundSecondary` - container background\n- `StyleProvider.Color.backgroundPrimary` - view background (via parent)\n- `StyleProvider.Color.textPrimary` - date, amount title/value, transaction title/value\n- `StyleProvider.Color.buttonActiveHoverPrimary` - default status text color\n- `StyleProvider.Color.myTicketsWonFaded` - default status badge background\n- `StyleProvider.Color.highlightPrimary` - copy button tint\n- `StyleProvider.fontWith(type: .regular, size: 12)` - date, amount title, transaction title\n- `StyleProvider.fontWith(type: .semibold, size: 12)` - status label\n- `StyleProvider.fontWith(type: .bold, size: 12)` - amount value, transaction value\n\nLayout constants:\n- Container corner radius: 8pt\n- Container padding: 8pt all sides\n- Content stack spacing: 8pt\n- Header/amount/transaction stack spacing: 6pt\n- Status badge height: 24pt\n- Status badge insets: 4pt vertical, 12pt horizontal\n- Status badge corner radius: 12pt\n- Copy button size: 24pt x 24pt\n- Copy button padding: 4pt\n\nIcon resolution:\n1. First tries custom image (UIImage(named:))\n2. Falls back to SF Symbol (UIImage(systemName:))\n\n## Mock ViewModels\n\nAvailable presets:\n- `MockPendingWithdrawViewModel()` - Default with sample pending state\n- `.samplePending` - Static sample state: \"05/08/2025, 11:17\", \"In Progress\", XAF 200,000\n",
      "snapshots": []
    },
    "PillItemView": {
      "displayName": "PillItemView",
      "category": "Filters",
      "subcategory": "Pills",
      "summary": "Selectable rounded pill button with optional icon and expand indicator for filters",
      "description": "A pill-shaped filter/chip component with title, optional left icon (SF Symbols or custom), and optional expand indicator. Supports three types: informative (simple), expansible (with dropdown icon), and countable (displays count in parentheses). Full theming control via dual-configuration pattern (PillItemCustomization with PillItemStyle for selected/unselected states). Features read-only mode, tap callback, and fully rounded corners (height/2). Uses 40pt min height, 12pt padding, 22pt icons.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "pill",
        "chip",
        "filter",
        "selectable",
        "icon",
        "expand",
        "countable",
        "theming",
        "customizable"
      ],
      "states": [
        "selected",
        "unselected",
        "read-only",
        "informative",
        "expansible",
        "countable"
      ],
      "similarTo": [
        "AmountPillView"
      ],
      "oftenUsedWith": [
        "PillSelectorBarView"
      ],
      "parents": [
        "PillSelectorBarView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# PillItemView\n\nPillItemView is a flexible, pill-shaped component designed for use in navigation and filter interfaces. It features a customizable appearance with support for text, icons, and selection states.\n\n## Features\n\n- **Customizable Appearance**: Show or hide left icon and expand icon\n- **Selection State**: Visual styling changes based on selection state\n- **User Interaction**: Built-in tap handling with callback support\n- **Accessibility**: Full accessibility support for screen readers\n\n## Use Cases\n\n- Category or filter selection in content feeds\n- Segmented navigation controls\n- Tag-based filtering systems\n- Dropdown menu triggers\n\n## Usage Example\n\n```swift\n// Create a view model (or use a mock for testing)\nlet viewModel = MockPillItemViewModel(\n    pillData: PillData(\n        id: \"sports\",\n        title: \"Sports\",\n        leftIconName: \"sportscourt.fill\",\n        showExpandIcon: true,\n        isSelected: false\n    )\n)\n\n// Create the component\nlet pillItemView = PillItemView(viewModel: viewModel)\npillItemView.translatesAutoresizingMaskIntoConstraints = false\n\n// Add to your view hierarchy\nparentView.addSubview(pillItemView)\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    pillItemView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 16),\n    pillItemView.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor, constant: 16),\n    pillItemView.heightAnchor.constraint(equalToConstant: 40),\n    pillItemView.widthAnchor.constraint(greaterThanOrEqualToConstant: 100)\n])\n\n// Handle selection\npillItemView.onPillSelected = {\n    print(\"Pill was selected\")\n    // Perform navigation or other actions\n}\n```\n\n## Multiple Pills Example\n\n```swift\n// Create a horizontal stack to hold multiple pills\nlet pillsStackView = UIStackView()\npillsStackView.axis = .horizontal\npillsStackView.spacing = 8\npillsStackView.distribution = .fillProportionally\npillsStackView.alignment = .center\npillsStackView.translatesAutoresizingMaskIntoConstraints = false\n\n// Add to your view hierarchy\nparentView.addSubview(pillsStackView)\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    pillsStackView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 16),\n    pillsStackView.trailingAnchor.constraint(equalTo: parentView.trailingAnchor, constant: -16),\n    pillsStackView.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor, constant: 16),\n    pillsStackView.heightAnchor.constraint(equalToConstant: 50)\n])\n\n// Create and add multiple pills\nlet footballPill = PillItemView(viewModel: MockPillItemViewModel.footballPill)\nlet popularPill = PillItemView(viewModel: MockPillItemViewModel.popularPill)\nlet allPill = PillItemView(viewModel: MockPillItemViewModel.allPill)\n\npillsStackView.addArrangedSubview(footballPill)\npillsStackView.addArrangedSubview(popularPill)\npillsStackView.addArrangedSubview(allPill)\n\n// Handle selections\nfootballPill.onPillSelected = {\n    // Handle football selection\n}\n\npopularPill.onPillSelected = {\n    // Handle popular selection\n}\n\nallPill.onPillSelected = {\n    // Handle all selection\n}\n```\n\n## Configuration Options\n\n### PillData Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `id` | String | Unique identifier for the pill |\n| `title` | String | Text displayed in the pill |\n| `leftIconName` | String? | Optional name of image/SF Symbol for left icon |\n| `showExpandIcon` | Bool | Whether to show the expand chevron icon |\n| `isSelected` | Bool | Whether the pill is in selected state |\n\n### Styling\n\nThe PillItemView uses the StyleProvider for consistent styling:\n\n```swift\n// Customize colors for pills\nStyleProvider.Color.customize(\n    primaryColor: UIColor(named: \"BrandPrimary\"),\n    secondaryColor: UIColor(named: \"SecondaryGray\"),\n    contrastTextColor: .white\n)\n```\n\n## Accessibility\n\nThe PillItemView component includes proper accessibility support:\n\n- The entire pill is exposed as a single accessible element\n- Appropriate button and selected traits are applied\n- The pill's title is used as the accessibility label\n\n## Implementation Notes\n\n- The component automatically adjusts its layout based on which optional elements are shown\n- Icons are tinted according to the pill's selection state\n- A tap gesture recognizer handles user interaction\n- The view model controls the pill's state through Combine publishers",
      "snapshots": []
    },
    "PillSelectorBarView": {
      "displayName": "PillSelectorBarView",
      "category": "Filters",
      "subcategory": "Pills",
      "summary": "Horizontally scrollable bar of selectable pill items for filtering and categories",
      "description": "A horizontal scrolling collection of PillItemView components for sports categories, market filters, and time periods. Manages single selection state, auto-scrolls to selected pill, and supports read-only mode (allowsVisualStateChanges: false). Features edge fade overlays with CAGradientLayer masks, haptic feedback, selection event publishing for analytics, custom pill styling via PillItemCustomization, and custom background color. Uses 60pt minimum height, 16pt horizontal padding, 12pt pill spacing.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "pill",
        "selector",
        "filter",
        "scrollable",
        "horizontal",
        "categories",
        "sports",
        "markets",
        "haptic",
        "fade-overlay"
      ],
      "states": [
        "interactive",
        "read-only",
        "visible",
        "hidden",
        "empty"
      ],
      "similarTo": [
        "QuickLinksTabBar"
      ],
      "oftenUsedWith": [
        "PillItemView"
      ],
      "parents": [],
      "children": [
        "PillItemView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# PillSelectorBarView\n\nA horizontal scrollable bar that displays multiple selectable pill-shaped items. Perfect for category filters, market selection, time period selection, and other filtering scenarios in sports betting applications.\n\n## Features\n\n- **Horizontal scrolling** with multiple pill items\n- **Selection state management** with visual feedback\n- **Optional left icons** and expand indicators on pills\n- **Reactive updates** via Combine publishers\n- **StyleProvider integration** for consistent theming\n- **Haptic feedback** on selection\n- **Auto-scrolling** to selected pills\n- **Configurable spacing** and layout\n- **Dynamic height** support for collection view integration\n\n## Usage Example\n\n### Basic Implementation\n\n```swift\n// Create a view model (or use a mock for testing)\nlet viewModel = MockPillSelectorBarViewModel.sportsCategories\n\n// Create the component\nlet pillSelectorBar = PillSelectorBarView(viewModel: viewModel)\n\n// Add to your view hierarchy\nparentView.addSubview(pillSelectorBar)\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    pillSelectorBar.leadingAnchor.constraint(equalTo: parentView.leadingAnchor),\n    pillSelectorBar.trailingAnchor.constraint(equalTo: parentView.trailingAnchor),\n    pillSelectorBar.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor),\n    pillSelectorBar.heightAnchor.constraint(equalToConstant: 60)\n])\n\n// Handle pill selection\npillSelectorBar.onPillSelected = { pillId in\n    print(\"Pill selected: \\(pillId)\")\n    // Perform filtering, navigation, or other actions\n}\n```\n\n### Read-Only Display Mode\n\n```swift\n// Create pills with their individual states (some selected, some not)\nlet pills = [\n    PillData(id: \"live\", title: \"Live\", isSelected: true),\n    PillData(id: \"popular\", title: \"Popular\", isSelected: false),\n    PillData(id: \"trending\", title: \"Trending\", isSelected: true)\n]\n\nlet barData = PillSelectorBarData(\n    id: \"filter_status\",\n    pills: pills,\n    selectedPillId: nil,  // No single selection\n    allowsVisualStateChanges: false  // States don't change on tap\n)\n\nlet viewModel = YourCustomViewModel(barData: barData)\nlet pillSelectorBar = PillSelectorBarView(viewModel: viewModel)\n\n// Taps trigger callbacks but don't change visual states\npillSelectorBar.onPillSelected = { pillId in\n    print(\"Filter \\(pillId) tapped - navigate to filter details\")\n    // Handle navigation or show filter details\n}\n```\n\n### Integration in Collection View Cell\n\n```swift\nfinal class PillSelectorBarCollectionViewCell: UICollectionViewCell {\n    static let identifier = \"PillSelectorBarCollectionViewCell\"\n    \n    private var pillSelectorBar: PillSelectorBarView?\n    \n    func configure(\n        with viewModel: PillSelectorBarViewModelProtocol,\n        onPillSelected: @escaping (String) -> Void = { _ in }\n    ) {\n        // Remove existing view\n        pillSelectorBar?.removeFromSuperview()\n        \n        // Create new pill selector bar\n        let selectorBar = PillSelectorBarView(viewModel: viewModel)\n        selectorBar.translatesAutoresizingMaskIntoConstraints = false\n        \n        // Handle events\n        selectorBar.onPillSelected = onPillSelected\n        \n        // Add to content view\n        contentView.addSubview(selectorBar)\n        pillSelectorBar = selectorBar\n        \n        // Setup constraints for dynamic height\n        NSLayoutConstraint.activate([\n            selectorBar.topAnchor.constraint(equalTo: contentView.topAnchor),\n            selectorBar.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),\n            selectorBar.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),\n            selectorBar.bottomAnchor.constraint(equalTo: contentView.bottomAnchor)\n        ])\n    }\n}\n```\n\n### Custom View Model Implementation\n\n```swift\nclass CustomPillSelectorBarViewModel: PillSelectorBarViewModelProtocol {\n    private let displayStateSubject: CurrentValueSubject<PillSelectorBarDisplayState, Never>\n    private let selectionEventSubject = PassthroughSubject<PillSelectionEvent, Never>()\n    \n    // ... implement protocol requirements\n    \n    func selectPill(id: String) {\n        // Update your data source\n        // Notify UI of changes\n        // Trigger selection events\n    }\n}\n```\n\n## Configuration Options\n\n### PillSelectorBarData Properties\n\n- **`id`**: Unique identifier for the bar\n- **`pills`**: Array of `PillData` items to display\n- **`selectedPillId`**: Currently selected pill ID (optional)\n- **`isScrollEnabled`**: Whether horizontal scrolling is enabled\n- **`allowsVisualStateChanges`**: Whether pills visually change state when tapped (default: true)\n\n### PillData Properties (from existing PillItemView)\n\n- **`id`**: Unique identifier for the pill\n- **`title`**: Display text\n- **`leftIconName`**: Optional SF Symbol name for left icon\n- **`showExpandIcon`**: Whether to show chevron down icon\n- **`isSelected`**: Selection state\n\n### Display State Options\n\n- **`isVisible`**: Controls visibility of the entire bar\n- **`isUserInteractionEnabled`**: Controls touch interaction\n\n## Mock View Models\n\nSeveral pre-configured mock view models are available for testing and previews:\n\n### Sports Categories\n```swift\nMockPillSelectorBarViewModel.sportsCategories\n// Contains: All, Football, Basketball, Baseball, Soccer, Tennis\n// With appropriate sports icons and some expandable options\n```\n\n### Market Filters\n```swift\nMockPillSelectorBarViewModel.marketFilters\n// Contains: Popular, Moneyline, Spread, Totals, Player Props, Live\n// Mix of text-only and icon pills for betting markets\n```\n\n### Time Periods\n```swift\nMockPillSelectorBarViewModel.timePeriods\n// Contains: Today, Tomorrow, This Week, This Month\n// Simple time-based filtering options\n```\n\n### Limited Pills\n```swift\nMockPillSelectorBarViewModel.limitedPills\n// Contains: Live, Upcoming\n// For cases where scrolling isn't needed\n```\n\n### Read-Only States\n```swift\nMockPillSelectorBarViewModel.readOnlyMarketFilters\n// Contains: Mixed selected/unselected states\n// Pills don't change visual state when tapped - useful for displaying existing filter states\n```\n\n## Styling\n\nThe component uses StyleProvider for consistent theming:\n\n- **Background**: `StyleProvider.Color.backgroundPrimary`\n- **Pill styling**: Handled by individual `PillItemView` components\n- **Spacing**: 12pt between pills, 16pt horizontal margins\n- **Height**: Minimum 60pt, adjusts to content\n\n## Selection Behavior\n\n### Interactive Mode (allowsVisualStateChanges: true)\n- **Single selection**: Only one pill can be selected at a time\n- **Visual feedback**: Selected pills show border and updated styling\n- **Haptic feedback**: Selection changes trigger haptic feedback\n- **Auto-scroll**: Bar automatically scrolls to show selected pill\n- **Events**: Selection changes trigger both view model updates and callback closures\n\n### Read-Only Mode (allowsVisualStateChanges: false)\n- **Fixed states**: Pills display their individual states without changing on tap\n- **Multiple selected**: Multiple pills can show as selected simultaneously\n- **Tap events**: Pills still trigger tap callbacks for external handling\n- **No visual changes**: Pill states remain as defined in the data model\n- **Use cases**: Displaying existing filter states, showing applied filters, status indicators\n\n## Performance Considerations\n\n- **Efficient updates**: Only rebuilds pill views when the pill set changes\n- **Memory management**: Proper cleanup of pill view references\n- **Smooth scrolling**: Optimized for horizontal scrolling performance\n- **Lazy loading**: Pills are created only when needed\n\n## Accessibility\n\n- **VoiceOver support**: Each pill is accessible with descriptive labels\n- **Traits**: Selected pills are marked with `.selected` trait\n- **Navigation**: Supports focus-based navigation\n- **Actions**: Pills respond to accessibility tap actions\n\n## Best Practices\n\n1. **Keep pill titles short** (1-2 words) for better layout\n2. **Use icons consistently** - either all pills have icons or none do\n3. **Limit pill count** - consider pagination for many options\n4. **Provide selection feedback** in your view model\n5. **Test on different screen sizes** to ensure proper scrolling\n6. **Use expand icons** sparingly for pills that lead to sub-menus\n\n## Integration with Existing Components\n\nThis component is designed to work seamlessly with:\n\n- **TopBannerSliderView**: Use together for rich filtering interfaces\n- **TallOddsMatchCardView**: Pills can filter match cards\n- **Collection View Cells**: Perfect for dynamic height cells\n- **Existing StyleProvider**: Consistent with app theming\n\nThe PillSelectorBarView provides a comprehensive solution for horizontal pill-based selection interfaces, following GomaUI's architectural patterns and design principles.\n",
      "snapshots": []
    },
    "PinDigitEntryView": {
      "displayName": "PinDigitEntryView",
      "category": "Forms",
      "subcategory": "Validation",
      "summary": "PIN code entry with individual digit boxes for verification codes and 2FA",
      "description": "A series of individual digit boxes for entering PIN codes. Supports configurable digit counts (4, 6, 8), hidden text field for number pad input, and visual states per field (empty/focused/filled). Features pin completion callback, clear pin functionality, programmatic focus control. Uses PinDigitField internal helper with 8pt corner radius, focus indicator bar, and state-based border colors. Fixed 60pt height, 12pt spacing between fields.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "pin",
        "code",
        "verification",
        "otp",
        "2fa",
        "digit",
        "numeric",
        "security",
        "input"
      ],
      "states": [
        "empty-all",
        "focused",
        "partial-filled",
        "complete"
      ],
      "similarTo": [],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# PinDigitEntryView\n\nA PIN code entry component with individual digit fields for secure input.\n\n## Overview\n\nPinDigitEntryView provides a series of individual digit boxes for entering PIN codes. It supports configurable digit counts (4, 6, 8, etc.), shows visual states for empty/focused/filled fields, and handles numeric keyboard input through a hidden text field. The component is commonly used for verification codes, security PINs, and two-factor authentication.\n\n## Component Relationships\n\n### Used By (Parents)\n- Verification screens\n- Security PIN entry forms\n- Two-factor authentication views\n\n### Uses (Children)\n- `PinDigitField` (internal helper component)\n\n## Features\n\n- Configurable digit count (4, 6, 8, etc.)\n- Individual digit display fields\n- Hidden text field for keyboard input\n- Empty/focused/filled visual states\n- Number pad keyboard\n- Tap anywhere to focus\n- Pin completion callback\n- Clear pin functionality\n- Programmatic focus control\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockPinDigitEntryViewModel.defaultMock\nlet pinEntry = PinDigitEntryView(viewModel: viewModel)\n\n// Handle PIN completion\npinEntry.onPinCompleted = { pin in\n    verifyPin(pin)\n}\n\n// Clear the PIN\npinEntry.clearPin()\n\n// Focus/unfocus\npinEntry.focusInput()\npinEntry.resignFocus()\n\n// 6-digit PIN with partial input\nlet sixDigitVM = MockPinDigitEntryViewModel.sixDigitMock\nlet sixDigitEntry = PinDigitEntryView(viewModel: sixDigitVM)\n```\n\n## Data Model\n\n```swift\nstruct PinDigitEntryData {\n    let id: String\n    let digitCount: Int       // Default: 4\n    let currentPin: String    // Current entered digits\n}\n\nprotocol PinDigitEntryViewModelProtocol {\n    var data: PinDigitEntryData { get }\n    var dataPublisher: AnyPublisher<PinDigitEntryData, Never> { get }\n    var isPinComplete: CurrentValueSubject<Bool, Never> { get set }\n\n    func configure(with data: PinDigitEntryData)\n    func addDigit(_ digit: String)\n    func removeLastDigit()\n    func clearPin()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.textPrimary` - title label (preview)\n- `StyleProvider.fontWith(type: .bold, size: 18)` - title font (preview)\n- PinDigitField styling (internal):\n  - Empty state: border only\n  - Focused state: highlighted border\n  - Filled state: background with digit text\n\nLayout constants:\n- Stack spacing: 12pt between digit fields\n- Field height: 60pt\n- Equal width distribution for all fields\n\nKeyboard configuration:\n- Type: `.numberPad`\n- Hidden text field syncs with digit fields\n\nVisual states per field:\n- **Empty**: Border outline, no content\n- **Focused**: Highlighted border, cursor indicator\n- **Filled**: Solid background, digit displayed (or masked)\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - 4-digit PIN, empty\n- `.sixDigitMock` - 6-digit PIN, partially filled with \"123\"\n- `.eightDigitMock` - 8-digit PIN, empty\n- `MockPinDigitEntryViewModel(data:)` - Custom configuration\n",
      "snapshots": [
        {
          "category": "DigitCount",
          "light": "PinDigitEntryView/__Snapshots__/PinDigitEntryViewSnapshotTests/testPinDigitEntryView_DigitCount_Light.1.png",
          "dark": "PinDigitEntryView/__Snapshots__/PinDigitEntryViewSnapshotTests/testPinDigitEntryView_DigitCount_Dark.1.png"
        },
        {
          "category": "FillStates",
          "light": "PinDigitEntryView/__Snapshots__/PinDigitEntryViewSnapshotTests/testPinDigitEntryView_FillStates_Light.1.png",
          "dark": "PinDigitEntryView/__Snapshots__/PinDigitEntryViewSnapshotTests/testPinDigitEntryView_FillStates_Dark.1.png"
        }
      ]
    },
    "ProfileMenuListView": {
      "displayName": "ProfileMenuListView",
      "category": "Profile",
      "subcategory": "Menu",
      "summary": "Configurable profile menu with navigation, action, and language selection items",
      "description": "A profile menu container displaying ActionRowView items in a vertical stack. Supports navigation items (with chevron), action items (no chevron, e.g., logout), and selection items (showing current value like language). Features JSON configuration loading, reactive language updates via currentLanguagePublisher, tap scale animation feedback, and MVVM architecture. Uses 16pt container corner radius, 48pt row height, 8pt stack spacing.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "profile",
        "menu",
        "settings",
        "navigation",
        "action",
        "language",
        "json-config",
        "logout"
      ],
      "states": [
        "default",
        "language-changed"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "ActionRowView"
      ],
      "parents": [],
      "children": [
        "ActionRowView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# ProfileMenuListView\n\nA configurable profile menu component that displays a list of interactive menu items with different types and behaviors.\n\n## Overview\n\nProfileMenuListView is a comprehensive profile menu solution that supports multiple item types, JSON configuration, and reactive updates. It consists of two main components:\n\n- **ProfileMenuListView**: Main container that manages the list of menu items\n- **ProfileMenuItemView**: Individual menu item with icon, title, optional value, and chevron\n\n## Features\n\n- **Multiple Item Types**: Navigation, Action, and Selection items\n- **JSON Configuration**: Load menu structure from external JSON files\n- **Reactive Updates**: Real-time language selection updates\n- **Interactive Feedback**: Visual tap feedback and callbacks\n- **StyleProvider Integration**: Full theming support\n- **MVVM Architecture**: Protocol-driven with comprehensive mocks\n\n## Item Types\n\n### Navigation Items\n- Shows chevron arrow\n- Used for items that navigate to other screens\n- Examples: Notifications, Transaction History, Help Center\n\n### Action Items  \n- No chevron arrow\n- Used for immediate actions\n- Examples: Logout\n\n### Selection Items\n- Shows current value + chevron arrow\n- Used for settings with current state display\n- Examples: Language selection showing \"English\"\n\n## Usage\n\n### Basic Usage\n\n```swift\n\n\n// Create with default configuration\nlet viewModel = MockProfileMenuListViewModel.defaultMock\nlet profileMenu = ProfileMenuListView(viewModel: viewModel)\n\n// Add to view hierarchy\nview.addSubview(profileMenu)\n```\n\n### JSON Configuration\n\n```swift\n// Load from custom JSON file\nlet viewModel = MockProfileMenuListViewModel.jsonConfigurationMock(fileName: \"CustomMenuConfig\")\nlet profileMenu = ProfileMenuListView(viewModel: viewModel)\n```\n\n### Custom Implementation\n\n```swift\nclass MyProfileMenuViewModel: ProfileMenuListViewModelProtocol {\n    @Published private var menuItems: [ProfileMenuItem] = []\n    @Published private var currentLanguage: String = \"English\"\n    \n    var menuItemsPublisher: AnyPublisher<[ProfileMenuItem], Never> {\n        $menuItems.eraseToAnyPublisher()\n    }\n    \n    var currentLanguagePublisher: AnyPublisher<String, Never> {\n        $currentLanguage.eraseToAnyPublisher()\n    }\n    \n    func didSelectItem(_ item: ProfileMenuItem) {\n        // Handle item selection\n        switch item.action {\n        case .notifications:\n            // Navigate to notifications\n        case .logout:\n            // Perform logout\n        case .changeLanguage:\n            // Show language picker\n        default:\n            break\n        }\n    }\n    \n    func loadConfiguration(from jsonFileName: String?) {\n        // Load menu configuration\n    }\n    \n    func updateCurrentLanguage(_ language: String) {\n        currentLanguage = language\n    }\n}\n```\n\n## JSON Configuration Format\n\n```json\n{\n  \"menuItems\": [\n    {\n      \"id\": \"notifications\",\n      \"icon\": \"bell\",\n      \"title\": \"Notifications\",\n      \"type\": \"navigation\",\n      \"action\": \"notifications\"\n    },\n    {\n      \"id\": \"change_language\",\n      \"icon\": \"globe\", \n      \"title\": \"Change Language\",\n      \"type\": \"selection\",\n      \"value\": \"English\",\n      \"action\": \"changeLanguage\"\n    },\n    {\n      \"id\": \"logout\",\n      \"icon\": \"rectangle.portrait.and.arrow.right\",\n      \"title\": \"Logout\",\n      \"type\": \"action\",\n      \"action\": \"logout\"\n    }\n  ]\n}\n```\n\n## Data Models\n\n### ProfileMenuItem\n\n```swift\nstruct ProfileMenuItem: Codable, Identifiable {\n    let id: String              // Unique identifier\n    let icon: String            // SF Symbol or custom icon name\n    let title: String           // Display title\n    let type: ProfileMenuItemType  // Item behavior type\n    let action: ProfileMenuAction  // Action identifier\n}\n```\n\n### ProfileMenuItemType\n\n```swift\nenum ProfileMenuItemType: Codable {\n    case navigation             // Shows chevron, navigates\n    case action                // No chevron, immediate action\n    case selection(String)     // Shows value + chevron\n}\n```\n\n### ProfileMenuAction\n\n```swift\nenum ProfileMenuAction: String, Codable {\n    case notifications\n    case transactionHistory\n    case changeLanguage\n    case responsibleGaming\n    case helpCenter\n    case changePassword\n    case logout\n}\n```\n\n## Styling\n\nThe component uses StyleProvider for consistent theming:\n\n- **Container Background**: `StyleProvider.Color.backgroundPrimary` (#03061b)\n- **Item Background**: `StyleProvider.Color.backgroundSecondary` (#1f2147) \n- **Text Color**: `StyleProvider.Color.textPrimary` (white)\n- **Icon Tint**: `StyleProvider.Color.highlightPrimary` (#ff6600)\n- **Chevron Tint**: `StyleProvider.Color.iconSecondary`\n\n## Layout Specifications\n\n- **Container**: 8px padding, 16px corner radius\n- **Item Height**: 48px with 8px spacing between items\n- **Item Padding**: 12px horizontal, 9px vertical\n- **Icon Size**: 22x22px container with up to 18x18px icon\n- **Chevron Size**: 18x18px\n\n## Mock ViewModels\n\n### Available Mocks\n\n```swift\n// Default configuration with all menu items\nMockProfileMenuListViewModel.defaultMock\n\n// Load from JSON configuration\nMockProfileMenuListViewModel.jsonConfigurationMock(fileName: \"ProfileMenuConfiguration\")\n\n// French language preset\nMockProfileMenuListViewModel.frenchLanguageMock\n\n// Interactive demo with logging\nMockProfileMenuListViewModel.interactiveMock\n\n// Custom callback handling\nMockProfileMenuListViewModel.customCallbackMock { item in\n    print(\"Selected: \\(item.title)\")\n}\n```\n\n## Interactive Features\n\n### Language Selection\n- Tapping \"Change Language\" cycles through available languages\n- Value display updates reactively\n- All instances update when language changes\n\n### Visual Feedback\n- Scale animation on tap (95% scale)\n- Immediate callback execution\n- Console logging in mock implementations\n\n### Action Handling\nDifferent actions trigger different behaviors:\n- **Navigation**: Typically shows new screen\n- **Action**: Performs immediate operation (e.g., logout)\n- **Selection**: Shows picker or cycles through options\n\n## Demo Integration\n\nThe component is integrated into GomaUICatalog with:\n- Interactive configuration switching\n- Real-time language updates\n- Action logging display\n- Multiple mock scenarios\n\n## Requirements\n\n- iOS 13.0+\n- UIKit framework\n- Combine framework\n- GomaUI StyleProvider\n\n## File Structure\n\n```\nProfileMenuListView/\n ProfileMenuListView.swift              # Main container component\n ProfileMenuItemView.swift              # Individual menu item\n ProfileMenuListViewModelProtocol.swift # Protocol definition\n MockProfileMenuListViewModel.swift     # Mock implementation\n README.md                             # This documentation\n```\n\n## Best Practices\n\n1. **Always use ViewModels**: Don't create views directly, use the protocol-based approach\n2. **Handle all actions**: Implement proper callbacks for all menu actions\n3. **Update language reactively**: Use the currentLanguagePublisher for dynamic updates\n4. **Use JSON for flexibility**: External configuration allows easy menu customization\n5. **Test all item types**: Ensure navigation, action, and selection items work correctly\n6. **Follow StyleProvider**: Never hardcode colors or fonts\n\n## Example Implementation\n\nSee `ProfileMenuListViewController` in the GomaUICatalog app for a complete implementation example with interactive features and real-time updates.\n",
      "snapshots": []
    },
    "ProgressInfoCheckView": {
      "displayName": "ProgressInfoCheckView",
      "category": "Status",
      "subcategory": "Progress",
      "summary": "Progress card with icon, header, title, subtitle, and segmented progress bar for gamification",
      "description": "A card component for gamification progress like win boosts or achievement tracking. Displays header label (highlight color), icon (24pt, SF Symbols or custom), title, subtitle, and segmented progress bar with filled/empty segments. Supports incomplete state (custom segment count) and complete state (all segments filled). Features enabled/disabled states (alpha 0.5 when disabled). Uses 8pt container corner radius, 16pt vertical padding, 8pt segment height with 4pt corner radius.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "progress",
        "gamification",
        "win-boost",
        "achievement",
        "segments",
        "reward",
        "card",
        "status"
      ],
      "states": [
        "incomplete",
        "complete",
        "enabled",
        "disabled"
      ],
      "similarTo": [],
      "oftenUsedWith": [],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# ProgressInfoCheckView\n\nA card component displaying progress information with icon, title, subtitle, and segmented progress bar.\n\n## Overview\n\nProgressInfoCheckView shows progress-related information in a card format with an icon, header text, title, subtitle, and a segmented progress bar. It's commonly used to display gamification features like win boosts or achievement progress, showing users how close they are to unlocking rewards.\n\n## Component Relationships\n\n### Used By (Parents)\n- Betslip screens\n- Bonus progress displays\n- Achievement trackers\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Header label with highlight color\n- Icon display (SF Symbols or custom images)\n- Title and subtitle labels\n- Segmented progress bar (filled/empty segments)\n- Complete and incomplete states\n- Enabled/disabled states (alpha 0.5 when disabled)\n- Rounded card container\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockProgressInfoCheckViewModel.winBoostMock()\nlet progressView = ProgressInfoCheckView(viewModel: viewModel)\n\n// Update progress state\nviewModel.updateState(.incomplete(completedSegments: 2, totalSegments: 3))\n\n// Show complete state\nviewModel.updateState(.complete)\n\n// Update text content\nviewModel.updateHeaderText(\"Almost there!\")\nviewModel.updateTitle(\"Get a 5% Win Boost\")\nviewModel.updateSubtitle(\"Add 1 more selection\")\n\n// Disable the component\nviewModel.setEnabled(false)\n```\n\n## Data Model\n\n```swift\nenum ProgressInfoCheckState: Equatable {\n    case incomplete(completedSegments: Int, totalSegments: Int)\n    case complete\n}\n\nstruct ProgressInfoCheckData: Equatable {\n    let state: ProgressInfoCheckState\n    let headerText: String\n    let title: String\n    let subtitle: String\n    let icon: String?\n    let isEnabled: Bool\n}\n\nprotocol ProgressInfoCheckViewModelProtocol {\n    var dataPublisher: AnyPublisher<ProgressInfoCheckData, Never> { get }\n    var currentData: ProgressInfoCheckData { get }\n\n    func updateState(_ state: ProgressInfoCheckState)\n    func updateHeaderText(_ text: String)\n    func updateTitle(_ title: String)\n    func updateSubtitle(_ subtitle: String)\n    func updateIcon(_ icon: String?)\n    func setEnabled(_ isEnabled: Bool)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundSecondary` - container background\n- `StyleProvider.Color.highlightPrimary` - header label, icon tint\n- `StyleProvider.Color.highlightSecondary` - completed segment fill\n- `StyleProvider.Color.backgroundPrimary` - empty segment fill\n- `StyleProvider.Color.textPrimary` - title, subtitle text\n- `StyleProvider.fontWith(type: .bold, size: 12)` - header font\n- `StyleProvider.fontWith(type: .bold, size: 16)` - title font\n- `StyleProvider.fontWith(type: .regular, size: 12)` - subtitle font\n\nLayout constants:\n- Container corner radius: 8pt\n- Container padding: 16pt vertical, 12pt horizontal\n- Main stack spacing: 16pt\n- Content stack spacing: 12pt\n- Text stack spacing: 4pt\n- Icon size: 24pt x 24pt\n- Progress segment height: 8pt\n- Progress segment corner radius: 4pt\n- Progress segment spacing: 4pt\n\nProgress bar:\n- Segments fill equally within container width\n- Completed segments use highlight secondary color\n- Empty segments use background primary color\n- Default 3 segments for complete state\n\n## Mock ViewModels\n\nAvailable presets:\n- `.winBoostMock()` - 1/3 segments complete, \"Get a 3% Win Boost\"\n- `.completeMock()` - All segments complete, \"Win Boost Activated\"\n- `.disabledMock()` - 0/3 segments, disabled state\n",
      "snapshots": [
        {
          "category": "EnabledStates",
          "light": "ProgressInfoCheckView/__Snapshots__/ProgressInfoCheckViewSnapshotTests/testProgressInfoCheckView_EnabledStates_Light.1.png",
          "dark": "ProgressInfoCheckView/__Snapshots__/ProgressInfoCheckViewSnapshotTests/testProgressInfoCheckView_EnabledStates_Dark.1.png"
        },
        {
          "category": "ProgressStates",
          "light": "ProgressInfoCheckView/__Snapshots__/ProgressInfoCheckViewSnapshotTests/testProgressInfoCheckView_ProgressStates_Light.1.png",
          "dark": "ProgressInfoCheckView/__Snapshots__/ProgressInfoCheckViewSnapshotTests/testProgressInfoCheckView_ProgressStates_Dark.1.png"
        }
      ]
    },
    "ProgressSegments": {
      "displayName": "ProgressSegmentView",
      "category": "Status",
      "subcategory": "Progress",
      "summary": "Individual progress bar segment with animated fill/empty state transitions",
      "description": "A single segment view for progress bars with animated fill state transitions. Uses 4pt corner radius, backgroundBorder color when empty, and highlightSecondary when filled. Features 0.3s easeInOut animation between states via setFilled(_:animated:) method. Designed to be used in horizontal stacks for segmented progress bars.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "progress",
        "segment",
        "animated",
        "fill",
        "bar",
        "leaf-component"
      ],
      "states": [
        "filled",
        "empty"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "ProgressInfoCheckView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": null,
      "snapshots": []
    },
    "PromotionCardView": {
      "displayName": "PromotionCardView",
      "category": "Promotions",
      "subcategory": "Cards",
      "summary": "Promotional content card with image, tag badge, title, description, and CTA buttons",
      "description": "A marketing card for promotions and bonus offers. Features header image (131pt, Kingfisher async loading), optional tag badge (right-corner rounded), title, description, CTA button, and Read More button. Supports card tap gesture for navigation. Uses ButtonView for action buttons. Layout: 8pt container corner radius, 1pt border, 24pt content padding. Tag badge positioned top-left with right-corner-only rounding.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "promotion",
        "card",
        "marketing",
        "bonus",
        "offer",
        "image",
        "cta",
        "badge",
        "tag"
      ],
      "states": [
        "with-tag",
        "without-tag",
        "with-cta",
        "without-cta",
        "with-read-more"
      ],
      "similarTo": [],
      "oftenUsedWith": [
        "ButtonView"
      ],
      "parents": [],
      "children": [
        "ButtonView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# PromotionCardView\n\nA comprehensive promotion card component designed for displaying promotional content with image, tag, title, description, call-to-action button, and read more functionality.\n\n## Overview\n\nThe `PromotionCardView` is a versatile component that displays promotional information in a card format. It's perfect for promotion listings, marketing campaigns, and promotional content display across the application.\n\n## Features\n\n- **Image Display**: Shows promotional images with proper aspect ratio and loading\n- **Tag Support**: Optional tag overlay on the image (e.g., \"Limited\", \"Casino\", \"Sportsbook\")\n- **Rich Content**: Title and description with proper text wrapping\n- **Interactive Elements**: Call-to-action button and read more link\n- **Flexible Layout**: Adapts to different content lengths and screen sizes\n- **Theme Support**: Fully integrated with StyleProvider for consistent theming\n\n## Visual Structure\n\n```\n\n  [IMAGE AREA - 131px height]        \n                          \n     TAG                           \n                          \n\n  Title of the promotion             \n                                     \n  Description text that can wrap     \n  to multiple lines as needed...     \n                                     \n   \n           CTA BUTTON               \n   \n                                     \n            Read more                \n\n```\n\n## Usage\n\n### Basic Implementation\n\n```swift\n// Create view model with promotion data\nlet viewModel = MockPromotionCardViewModel.defaultMock\n\n// Initialize the view\nlet cardView = PromotionCardView(viewModel: viewModel)\n\n// Add to view hierarchy\nview.addSubview(cardView)\n```\n\n### With Custom Data\n\n```swift\n// Create custom promotion data\nlet promotionData = PromotionCardData(\n    id: \"promo_123\",\n    title: \"Welcome Bonus\",\n    description: \"Get a 100% match bonus up to $500 on your first deposit.\",\n    imageURL: \"https://example.com/promo-image.jpg\",\n    tag: \"Limited\",\n    ctaText: \"Claim Bonus\",\n    ctaURL: \"https://example.com/claim\",\n    showReadMoreButton: true\n)\n\n// Create view model\nlet viewModel = MockPromotionCardViewModel(cardData: promotionData)\n\n// Initialize view\nlet cardView = PromotionCardView(viewModel: viewModel)\n```\n\n### In Table View Cell\n\nThe `PromotionTableViewCell` in `BetssonCameroonApp` shows how to integrate the component:\n\n```swift\nclass PromotionTableViewCell: UITableViewCell {\n    private var promotionCardView: PromotionCardView?\n    \n    func configure(viewModel: PromotionCellViewModel) {\n        // Convert PromotionInfo to PromotionCardData\n        let cardData = PromotionCardData(\n            id: String(viewModel.promotionInfo.id),\n            title: viewModel.promotionInfo.title,\n            description: viewModel.promotionInfo.listDisplayDescription ?? \"\",\n            imageURL: viewModel.promotionInfo.listDisplayImageUrl,\n            tag: viewModel.promotionInfo.tag,\n            ctaText: viewModel.promotionInfo.ctaText,\n            ctaURL: viewModel.promotionInfo.ctaUrl,\n            showReadMoreButton: viewModel.promotionInfo.hasReadMoreButton\n        )\n        \n        // Create ViewModel with callback setup\n        let cardViewModel = MockPromotionCardViewModel(cardData: cardData)\n        \n        // Setup callbacks for button actions\n        if let ctaButtonViewModel = cardViewModel.ctaButtonViewModel as? MockButtonViewModel {\n            ctaButtonViewModel.onButtonTapped = { [weak self] in\n                self?.didTapPromotionAction?()\n            }\n        }\n        \n        // Create and configure the card view\n        let cardView = PromotionCardView(viewModel: cardViewModel)\n        // ... setup constraints and add to view hierarchy\n    }\n}\n```\n\n## Data Models\n\n### PromotionCardData\n\n```swift\npublic struct PromotionCardData: Equatable, Hashable {\n    public let id: String\n    public let title: String\n    public let description: String\n    public let imageURL: String\n    public let tag: String?\n    public let ctaText: String?\n    public let ctaURL: String?\n    public let showReadMoreButton: Bool\n}\n```\n\n### PromotionCardDisplayState\n\n```swift\npublic struct PromotionCardDisplayState: Equatable {\n    public let cardData: PromotionCardData\n    public let isVisible: Bool\n}\n```\n\n## Protocols\n\n### PromotionCardViewModelProtocol\n\n```swift\npublic protocol PromotionCardViewModelProtocol {\n    var displayStatePublisher: AnyPublisher<PromotionCardDisplayState, Never> { get }\n    \n    /// Button ViewModels for CTA and Read More buttons\n    var ctaButtonViewModel: ButtonViewModelProtocol { get }\n    var readMoreButtonViewModel: ButtonViewModelProtocol { get }\n    \n    func didTapCTAButton()\n    func didTapReadMoreButton()\n    func configure(with cardData: PromotionCardData)\n}\n```\n\n## Mock Implementations\n\nThe component includes several mock implementations for testing and development:\n\n- `MockPromotionCardViewModel.defaultMock` - Standard promotion card\n- `MockPromotionCardViewModel.casinoMock` - Casino-themed promotion\n- `MockPromotionCardViewModel.sportsbookMock` - Sports betting promotion\n- `MockPromotionCardViewModel.noCTAMock` - Information-only promotion\n- `MockPromotionCardViewModel.longTitleMock` - Long title test case\n- `MockPromotionCardViewModel.noTagMock` - Promotion without tag\n\n## Architecture\n\n### MVVM with ButtonView Integration\n\nThe component follows GomaUI's MVVM pattern with proper ButtonView integration:\n\n- **PromotionCardView**: Main UIView component\n- **PromotionCardViewModelProtocol**: Defines the interface with ButtonView ViewModels\n- **MockPromotionCardViewModel**: Creates and manages ButtonView ViewModels internally\n- **ButtonView Integration**: Both CTA and Read More buttons use ButtonView with their own ViewModels\n\n### ButtonView ViewModels\n\nThe component creates two ButtonView ViewModels:\n\n1. **CTA Button**: `ButtonStyle.solidBackground` for primary actions\n2. **Read More Button**: `ButtonStyle.transparent` for secondary actions\n\nBoth buttons are fully integrated with the PromotionCardViewModel's callback system.\n\n## Styling\n\nThe component uses StyleProvider for all styling:\n\n- **Colors**: `StyleProvider.Color.backgroundColor`, `StyleProvider.Color.primaryColor`, etc.\n- **Fonts**: `StyleProvider.fontWith(type:size:)`\n- **Layout**: Programmatic AutoLayout with consistent spacing\n\n## Layout Specifications\n\n- **Card Height**: Dynamic based on content (minimum ~300pt)\n- **Image Area**: 40% of total card height\n- **Content Area**: 60% of total card height\n- **Margins**: 16pt horizontal, 8-20pt vertical\n- **Tag**: 24pt height, 60pt minimum width\n- **CTA Button**: 44pt height (ButtonView with solidBackground style)\n- **Read More Button**: Auto height (ButtonView with transparent style)\n\n## Accessibility\n\n- Supports VoiceOver navigation\n- Proper accessibility labels for interactive elements\n- High contrast support through StyleProvider\n- Dynamic Type support for text elements\n\n## Integration with PromotionInfo\n\nThe component is designed to work seamlessly with the `PromotionInfo` model from the ServicesProvider:\n\n```swift\nextension PromotionInfo {\n    func toPromotionCardData() -> PromotionCardData {\n        return PromotionCardData(\n            id: String(self.id),\n            title: self.title,\n            description: self.listDisplayDescription ?? \"\",\n            imageURL: self.listDisplayImageUrl,\n            tag: self.tag,\n            ctaText: self.ctaText,\n            ctaURL: self.ctaUrl,\n            showReadMoreButton: self.hasReadMoreButton\n        )\n    }\n}\n```\n\n## Best Practices\n\n1. **Always use the ViewModel pattern** - Never bypass the protocol interface\n2. **Handle image loading gracefully** - The component uses Kingfisher for async image loading\n3. **Test with different content lengths** - Use the provided mock implementations\n4. **Respect the card aspect ratio** - Allow the component to determine its own height\n5. **Use consistent spacing** - Follow the 16pt margin pattern in your layouts\n\n## Dependencies\n\n- **UIKit**: Core UI framework\n- **Combine**: Reactive programming for state management\n- **Kingfisher**: Async image loading and caching\n- **GomaUI**: StyleProvider for theming\n\n## Testing\n\nUse the demo app to test different states:\n1. Navigate to \"Promotional\" category\n2. Select \"Promotion Card\"\n3. Test different mock implementations\n4. Verify interactions and layout behavior\n\nThe component includes comprehensive SwiftUI previews for development and testing.\n",
      "snapshots": []
    },
    "PromotionItemView": {
      "displayName": "PromotionItemView",
      "category": "Promotions",
      "subcategory": "Filters",
      "summary": "Selectable promotion category pill for filtering promotional content",
      "description": "A rounded pill button for selecting promotion categories (Welcome, Sports, Casino, Bonuses). Supports selected/unselected visual states with 0.2s animated transitions. Features read-only mode support and category metadata for accessibility. Uses 40pt min height, 20pt corner radius (fully rounded), 16pt horizontal and 10pt vertical padding. Selected: highlightPrimary background + white text. Unselected: backgroundSecondary + textPrimary.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "promotion",
        "filter",
        "pill",
        "selectable",
        "category",
        "animated",
        "leaf-component"
      ],
      "states": [
        "selected",
        "unselected",
        "read-only"
      ],
      "similarTo": [
        "PillItemView"
      ],
      "oftenUsedWith": [
        "PromotionSelectorBarView"
      ],
      "parents": [
        "PromotionSelectorBarView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# PromotionItemView\n\nA pill-shaped button component designed for promotion category selection, following the GomaUI MVVM architecture pattern.\n\n## Overview\n\n`PromotionItemView` is a reusable UI component that displays a single promotion category as a pill-shaped button. It supports selection states, animations, and integrates seamlessly with the GomaUI design system.\n\n## Visual Structure\n\n```\n\n    [Promotion Title]    \n\n```\n\n- **Container**: Pill-shaped background with rounded corners\n- **Title Label**: Centered text with medium font weight\n- **Selection State**: Orange background when selected, light grey when unselected\n\n## Protocols\n\n### PromotionItemViewModelProtocol\nDefines the interface for managing promotion item state and actions:\n\n```swift\npublic protocol PromotionItemViewModelProtocol {\n    var idPublisher: AnyPublisher<String, Never> { get }\n    var titlePublisher: AnyPublisher<String, Never> { get }\n    var isSelectedPublisher: AnyPublisher<Bool, Never> { get }\n    var categoryPublisher: AnyPublisher<String?, Never> { get }\n    \n    var isReadOnly: Bool { get }\n    \n    func selectPromotion()\n    func updateTitle(_ title: String)\n    func updateCategory(_ category: String?)\n}\n```\n\n## Data Models\n\n### PromotionItemData\n```swift\npublic struct PromotionItemData: Equatable, Hashable {\n    public let id: String\n    public let title: String\n    public let isSelected: Bool\n    public let category: String?\n}\n```\n\n## Usage Examples\n\n### Basic Usage\n```swift\nlet data = PromotionItemData(id: \"1\", title: \"Welcome\", isSelected: true)\nlet viewModel = MockPromotionItemViewModel(promotionItemData: data)\nlet promotionItemView = PromotionItemView(viewModel: viewModel)\n\npromotionItemView.onPromotionSelected = {\n    print(\"Promotion item tapped!\")\n}\n```\n\n### With Category\n```swift\nlet data = PromotionItemData(\n    id: \"2\", \n    title: \"Sports\", \n    isSelected: false, \n    category: \"Sports Betting\"\n)\nlet viewModel = MockPromotionItemViewModel(promotionItemData: data)\nlet promotionItemView = PromotionItemView(viewModel: viewModel)\n```\n\n## Architecture\n\n### MVVM Pattern\n- **View**: `PromotionItemView` - Handles UI rendering and user interactions\n- **ViewModel**: `PromotionItemViewModelProtocol` - Manages state and business logic\n- **Model**: `PromotionItemData` - Contains data structure\n\n### State Management\n- Uses Combine publishers for reactive state updates\n- Supports read-only mode to prevent selection changes\n- Automatic UI updates when state changes\n\n## Layout Specifications\n\n- **Minimum Height**: 40pt\n- **Horizontal Padding**: 16pt\n- **Vertical Padding**: 10pt\n- **Corner Radius**: 20pt (pill shape)\n- **Border Width**: 1pt\n- **Animation Duration**: 0.2s\n\n## Styling\n\n### Selected State\n- Background: `StyleProvider.Color.highlightPrimary` (Orange)\n- Text: White\n- Border: `StyleProvider.Color.highlightPrimary`\n\n### Unselected State\n- Background: `StyleProvider.Color.backgroundSecondary` (Light Grey)\n- Text: `StyleProvider.Color.textPrimary` (Dark)\n- Border: `StyleProvider.Color.backgroundBorder`\n\n## Accessibility\n\n- Supports accessibility labels that include category information\n- Responds to tap gestures\n- Proper contrast ratios in both states\n\n## Integration\n\nThis component is designed to work with `PromotionSelectorBarView` to create a horizontal scrolling list of promotion categories, similar to the existing `PillSelectorBarView` pattern.\n",
      "snapshots": []
    },
    "PromotionSelectorBarView": {
      "displayName": "PromotionSelectorBarView",
      "category": "Promotions",
      "subcategory": "Filters",
      "summary": "Horizontal scrolling bar of selectable promotion category items for filtering",
      "description": "A horizontal scrolling collection of PromotionItemView components for filtering promotions by category. Manages single selection state, publishes selection events with timestamp, and preserves scroll position during selection updates. Supports read-only mode (allowsVisualStateChanges: false). Features 60pt min height, 16pt horizontal padding, 12pt item spacing. Used on Promotions and Bonus screens.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "promotion",
        "filter",
        "horizontal",
        "scrollable",
        "selector",
        "category",
        "selection-events"
      ],
      "states": [
        "interactive",
        "read-only",
        "visible",
        "hidden",
        "scroll-enabled",
        "scroll-disabled"
      ],
      "similarTo": [
        "PillSelectorBarView"
      ],
      "oftenUsedWith": [
        "PromotionItemView"
      ],
      "parents": [],
      "children": [
        "PromotionItemView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# PromotionSelectorBarView\n\nA horizontal scrolling container for `PromotionItemView` components, following the GomaUI MVVM architecture pattern.\n\n## Overview\n\n`PromotionSelectorBarView` provides a horizontal scrolling interface for promotion category selection. It manages multiple `PromotionItemView` instances and handles selection state coordination across all items.\n\n## Visual Structure\n\n```\n\n [Welcome] [Sports] [Casino] [Bonuses]       \n\n```\n\n- **Scroll View**: Horizontal scrolling container\n- **Stack View**: Manages horizontal arrangement of promotion items\n- **Promotion Items**: Individual `PromotionItemView` components\n\n## Protocols\n\n### PromotionSelectorBarViewModelProtocol\nDefines the interface for managing the selector bar state and actions:\n\n```swift\npublic protocol PromotionSelectorBarViewModelProtocol {\n    var displayStatePublisher: AnyPublisher<PromotionSelectorBarDisplayState, Never> { get }\n    var selectionEventPublisher: AnyPublisher<PromotionSelectionEvent, Never> { get }\n    \n    func selectPromotion(id: String)\n    func updatePromotionItems(_ items: [PromotionItemData])\n    func updateSelectedPromotion(_ id: String?)\n    func updateVisibility(_ isVisible: Bool)\n    func updateUserInteraction(_ isEnabled: Bool)\n    \n    func getCurrentDisplayState() -> PromotionSelectorBarDisplayState\n    func isPromotionSelected(_ id: String) -> Bool\n    func getSelectedPromotionId() -> String?\n}\n```\n\n## Data Models\n\n### PromotionSelectorBarData\n```swift\npublic struct PromotionSelectorBarData: Equatable, Hashable {\n    public let id: String\n    public let promotionItems: [PromotionItemData]\n    public let selectedPromotionId: String?\n    public let isScrollEnabled: Bool\n    public let allowsVisualStateChanges: Bool\n}\n```\n\n### PromotionSelectionEvent\n```swift\npublic struct PromotionSelectionEvent: Equatable {\n    public let selectedId: String\n    public let previouslySelectedId: String?\n    public let timestamp: Date\n}\n```\n\n## Usage Examples\n\n### Basic Usage\n```swift\nlet items = [\n    PromotionItemData(id: \"1\", title: \"Welcome\", isSelected: true),\n    PromotionItemData(id: \"2\", title: \"Sports\", isSelected: false),\n    PromotionItemData(id: \"3\", title: \"Casino\", isSelected: false)\n]\n\nlet barData = PromotionSelectorBarData(\n    id: \"main\", \n    promotionItems: items, \n    selectedPromotionId: \"1\"\n)\n\nlet viewModel = MockPromotionSelectorBarViewModel(barData: barData)\nlet selectorBar = PromotionSelectorBarView(viewModel: viewModel)\n\nselectorBar.onPromotionSelected = { selectedId in\n    print(\"Selected promotion: \\(selectedId)\")\n}\n```\n\n### Read-Only Mode\n```swift\nlet barData = PromotionSelectorBarData(\n    id: \"readonly\",\n    promotionItems: items,\n    selectedPromotionId: \"1\",\n    allowsVisualStateChanges: false\n)\n```\n\n### Disabled Scrolling\n```swift\nlet barData = PromotionSelectorBarData(\n    id: \"fixed\",\n    promotionItems: items,\n    selectedPromotionId: \"1\",\n    isScrollEnabled: false\n)\n```\n\n## Architecture\n\n### MVVM Pattern\n- **View**: `PromotionSelectorBarView` - Manages UI layout and user interactions\n- **ViewModel**: `PromotionSelectorBarViewModelProtocol` - Coordinates state across all promotion items\n- **Model**: `PromotionSelectorBarData` - Contains configuration and item data\n\n### State Management\n- Centralized selection state management\n- Reactive updates via Combine publishers\n- Event-driven architecture for selection handling\n\n### Component Integration\n- Automatically creates and manages `PromotionItemView` instances\n- Coordinates selection state across all items\n- Handles individual item tap events\n\n## Layout Specifications\n\n- **Minimum Height**: 60pt\n- **Horizontal Padding**: 16pt\n- **Item Spacing**: 12pt\n- **Animation Duration**: 0.3s\n\n## Features\n\n### Horizontal Scrolling\n- Smooth horizontal scrolling for many items\n- Scroll indicator can be disabled\n\n### Selection Management\n- Single selection mode (only one item can be selected)\n- Automatic state coordination across items\n- Selection event publishing\n\n### Visual States\n- Supports visibility toggling\n- User interaction can be disabled\n- Read-only mode prevents state changes\n\n## Styling\n\n- Uses `StyleProvider` for consistent theming\n- Clean, simple design without visual effects\n- Automatic item state management\n\n## Accessibility\n\n- Proper accessibility support through individual `PromotionItemView` components\n- Clear selection state indication\n- Touch target optimization\n\n## Integration\n\nThis component is designed to work with the existing GomaUI architecture and follows the same patterns as `PillSelectorBarView`. It can be easily integrated into promotion screens that need category filtering or navigation.\n",
      "snapshots": []
    },
    "PromotionalBonusCardView": {
      "displayName": "PromotionalBonusCardView",
      "category": "Promotions",
      "subcategory": "Cards",
      "summary": "Large promotional bonus card with background image, gradient, avatars, and claim button",
      "description": "A promotional card for bonus offers with background image, diagonal gradient overlay (70% alpha), header text, main title, overlapping user avatar indicators (max 4, -8pt spacing), players count label, Claim Bonus button (solid), and Terms button (transparent). Fixed 415pt height, 16pt corner radius. Avatars show 40pt circular images with white border. Used to highlight available bonuses on home/promo screens.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "promotion",
        "bonus",
        "card",
        "background-image",
        "gradient",
        "avatars",
        "claim",
        "terms",
        "large"
      ],
      "states": [
        "with-gradient",
        "without-gradient"
      ],
      "similarTo": [
        "PromotionCardView"
      ],
      "oftenUsedWith": [
        "ButtonView",
        "GradientView",
        "PromotionalBonusCardsScrollView"
      ],
      "parents": [
        "PromotionalBonusCardsScrollView"
      ],
      "children": [
        "ButtonView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# PromotionalBonusCardView\n\nA promotional bonus card with background image, gradient overlay, user avatars, and action buttons.\n\n## Overview\n\nPromotionalBonusCardView displays a large promotional card for bonus offers with a customizable background image, gradient overlay, header text, main title, user avatar indicators showing how many players have claimed the bonus, and two action buttons (Claim Bonus and Terms & Conditions). It's used on home screens and promotion pages to highlight available bonuses.\n\n## Component Relationships\n\n### Used By (Parents)\n- `PromotionalBonusCardsScrollView`\n\n### Uses (Children)\n- `ButtonView` - Claim and Terms buttons\n- `GradientView` - Background gradient overlay\n\n## Features\n\n- Background image with async loading\n- Gradient overlay (diagonal, 70% alpha)\n- Header text label\n- Main title label (multi-line)\n- User avatars stack with overlap effect\n- Players count label (e.g., \"12.6k players chose this bonus\")\n- Claim Bonus button (solid style)\n- Terms & Conditions button (transparent style)\n- Fixed card height (415pt)\n- Rounded corners (16pt)\n- Button tap callbacks\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet cardData = PromotionalBonusCardData(\n    id: \"welcome_bonus\",\n    headerText: \"The Betsson Double\",\n    mainTitle: \"Deposit XAF 1000 and play with XAF 2000\",\n    userAvatars: [\n        UserAvatar(id: \"user1\", imageName: \"avatar1\"),\n        UserAvatar(id: \"user2\", imageName: \"avatar2\")\n    ],\n    playersCount: \"12.6k\",\n    backgroundImageName: \"promo_background\",\n    bonusAmount: 1000\n)\nlet viewModel = MockPromotionalBonusCardViewModel(cardData: cardData)\nlet cardView = PromotionalBonusCardView(viewModel: viewModel)\n\n// Handle button taps\ncardView.onClaimBonus = {\n    processBonus()\n}\n\ncardView.onTermsTapped = {\n    showTermsAndConditions()\n}\n```\n\n## Data Model\n\n```swift\nstruct UserAvatar: Equatable, Hashable {\n    let id: String\n    let imageUrl: String?\n    let imageName: String?\n}\n\nstruct PromotionalBonusCardData: Equatable, Hashable {\n    let id: String\n    let headerText: String\n    let mainTitle: String\n    let userAvatars: [UserAvatar]\n    let playersCount: String\n    let backgroundImageName: String?\n    let hasGradientView: Bool\n    let claimButtonTitle: String\n    let termsButtonTitle: String\n    let bonusAmount: Double\n}\n\nprotocol PromotionalBonusCardViewModelProtocol {\n    var cardDataPublisher: AnyPublisher<PromotionalBonusCardData, Never> { get }\n\n    func claimBonusTapped()\n    func termsTapped()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.topBarGradient1/2/3` - gradient overlay colors\n- `StyleProvider.Color.buttonTextPrimary` - header, title, players label text\n- `StyleProvider.Color.backgroundSecondary` - avatar placeholder background\n- `StyleProvider.Color.textSecondary` - avatar placeholder icon tint\n- `StyleProvider.fontWith(type: .regular, size: 12)` - header, players label font\n- `StyleProvider.fontWith(type: .bold, size: 20)` - title font\n\nLayout constants:\n- Card height: 415pt\n- Corner radius: 16pt\n- Container padding: 16pt horizontal, 24pt top, 20pt bottom\n- Header-title gap: 20pt\n- Title-avatars gap: 20pt\n- Avatar size: 40pt x 40pt\n- Avatar corner radius: 20pt\n- Avatar overlap: -8pt spacing\n- Avatar border: 2pt white\n- Avatars-count gap: 12pt\n- Button stack spacing: 6pt\n\nGradient configuration:\n- Direction: Inverted diagonal\n- Colors: topBarGradient1 (33%), topBarGradient2 (66%), topBarGradient3 (100%)\n- Alpha: 0.7\n\nAvatar display:\n- Maximum 4 avatars displayed\n- Overlapping stack effect\n- System person icon placeholder\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - \"The Betsson Double\" with 4 avatars, 12.6k players\n- `.noGradientMock` - Same content without gradient overlay\n",
      "snapshots": []
    },
    "PromotionalBonusCardsScrollView": {
      "displayName": "PromotionalBonusCardsScrollView",
      "category": "Promotions",
      "subcategory": "Carousels",
      "summary": "Horizontal scrolling carousel of promotional bonus cards (85% width peek effect)",
      "description": "A horizontal scrolling container for multiple PromotionalBonusCardView components. Cards are 85% of screen width for peek-at-next effect. Features fast deceleration for card-like scroll feel, 16pt card spacing, 16pt horizontal content insets. Per-card claim and terms callbacks are forwarded to parent. Dynamic card creation and cleanup from PromotionalBonusCardsData.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "carousel",
        "horizontal",
        "scrollable",
        "promotion",
        "bonus",
        "cards",
        "peek",
        "fast-deceleration"
      ],
      "states": [
        "scrolling",
        "idle"
      ],
      "similarTo": [
        "HomeBannersCarouselView"
      ],
      "oftenUsedWith": [
        "PromotionalBonusCardView"
      ],
      "parents": [],
      "children": [
        "PromotionalBonusCardView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# PromotionalBonusCardsScrollView\n\nA horizontal scrolling carousel of promotional bonus cards.\n\n## Overview\n\nPromotionalBonusCardsScrollView displays multiple PromotionalBonusCardView components in a horizontally scrolling container. Each card takes up 85% of the screen width, allowing users to peek at the next card and encouraging horizontal scrolling. The component manages card creation, callbacks, and cleanup automatically.\n\n## Component Relationships\n\n### Used By (Parents)\n- Home screens\n- Bonus listing pages\n\n### Uses (Children)\n- `PromotionalBonusCardView`\n\n## Features\n\n- Horizontal scrolling carousel\n- Fast deceleration for card-like snapping\n- 85% screen width cards (peek at next)\n- Multiple card support\n- Per-card claim and terms callbacks\n- Dynamic card creation from data\n- Card spacing (16pt)\n- Content insets (16pt horizontal)\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet cardsData = PromotionalBonusCardsData(\n    id: \"promo_carousel\",\n    cards: [card1, card2, card3, card4]\n)\nlet viewModel = MockPromotionalBonusCardsScrollViewModel(cardsData: cardsData)\nlet scrollView = PromotionalBonusCardsScrollView(viewModel: viewModel)\n\n// Handle card actions\nscrollView.onCardClaimBonus = { cardData in\n    processBonus(cardData)\n}\n\nscrollView.onCardTermsTapped = { cardData in\n    showTerms(for: cardData)\n}\n```\n\n## Data Model\n\n```swift\nstruct PromotionalBonusCardsData: Equatable {\n    let id: String\n    let cards: [PromotionalBonusCardData]\n}\n\nprotocol PromotionalBonusCardsScrollViewModelProtocol {\n    var cardsDataPublisher: AnyPublisher<PromotionalBonusCardsData, Never> { get }\n\n    func cardClaimBonusTapped(cardId: String)\n    func cardTermsTapped(cardId: String)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- Background: clear (inherits from parent)\n\nLayout constants:\n- Card width: 85% of screen width\n- Card spacing: 16pt\n- Content insets: 16pt leading/trailing\n- Scroll indicators: hidden\n- Deceleration rate: fast\n\nScroll behavior:\n- No paging (continuous scroll)\n- Fast deceleration for card-like feel\n- Horizontal scroll only\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - 4 cards (Betsson Double, Welcome Bonus, Weekend Special, VIP Bonus)\n- `.shortListMock` - 2 cards (Quick Start, Daily Special)\n",
      "snapshots": []
    },
    "PromotionalHeaderView": {
      "displayName": "PromotionalHeaderView",
      "category": "Promotions",
      "subcategory": "Headers",
      "summary": "Section header with icon, title, and optional subtitle for promotional areas",
      "description": "A simple horizontal header row with leading icon (24pt, SF Symbols or custom), bold title, and optional regular subtitle. Used above bonus cards and promo lists. Features 8pt container padding, 8pt icon-text spacing, 4pt title-subtitle spacing. Custom background color via setCustomBackgroundColor(). Icon tries SF Symbol first, falls back to custom image.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "header",
        "section",
        "icon",
        "title",
        "subtitle",
        "promotional",
        "leaf-component"
      ],
      "states": [
        "with-subtitle",
        "without-subtitle"
      ],
      "similarTo": [
        "SectionHeaderView"
      ],
      "oftenUsedWith": [
        "PromotionalBonusCardView",
        "PromotionCardView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# PromotionalHeaderView\n\nA clean, information-only promotional header component built with UIKit and Combine that displays promotional content with an icon, title, and optional subtitle. The component is designed for showcasing promotional information, announcements, and informational messages in a visually appealing header format.\n\n## Overview\n\nThe `PromotionalHeaderView` is designed to display promotional and informational content in a prominent, card-like header format. It features an icon on the left, title text (required), and optional subtitle text, all within a rounded container with customizable background colors. The component follows MVVM architecture and uses reactive programming with Combine for state management. This is a purely informational component with no interactive actions.\n\n## Architecture\n\n### Component Structure\n```\nPromotionalHeaderView/\n PromotionalHeaderView.swift                # Main component view\n PromotionalHeaderViewModelProtocol.swift   # View model protocol and data models\n MockPromotionalHeaderViewModel.swift       # Mock implementation\n Documentation/\n     README.md                              # This documentation\n```\n\n### MVVM Pattern\n- **View**: `PromotionalHeaderView` - Main UI component with header layout\n- **ViewModel**: `PromotionalHeaderViewModelProtocol` - State management\n- **Model**: `PromotionalHeaderData` & `PromotionalHeaderDisplayState` - Data structures\n\n## Key Features\n\n### Visual Design\n- **Rounded Container**: 12pt corner radius for modern card appearance\n- **Icon Support**: System icons or custom images with orange tint color\n- **Typography Hierarchy**: Bold 16pt title, regular 14pt subtitle\n- **Flexible Layout**: Adapts to content with or without subtitle\n- **Custom Background**: Customizable background colors for different promotions\n\n### Display Properties\n- **Information Only**: Pure display component with no user interactions\n- **Responsive Design**: Adapts to different content lengths\n- **Optional Elements**: Subtitle can be hidden when not provided\n- **Visibility Control**: Can be shown or hidden programmatically\n\n### Layout Structure\n- **Horizontal Layout**: Icon and text content arranged horizontally\n- **Vertical Text Stack**: Title and subtitle stacked vertically\n- **Consistent Spacing**: Proper spacing between elements\n- **Auto-sizing**: Height adjusts based on content\n\n## Models\n\n### PromotionalHeaderData\n```swift\npublic struct PromotionalHeaderData: Equatable, Hashable {\n    public let id: String\n    public let icon: String\n    public let title: String\n    public let subtitle: String?\n    public let backgroundColor: UIColor?\n}\n```\n\n**Properties:**\n- `id`: Unique identifier for the header\n- `icon`: System icon name or custom image name\n- `title`: Main promotional message (required)\n- `subtitle`: Secondary description text (optional)\n- `backgroundColor`: Custom background color (optional)\n\n### PromotionalHeaderDisplayState\n```swift\npublic struct PromotionalHeaderDisplayState: Equatable {\n    public let headerData: PromotionalHeaderData\n    public let isVisible: Bool\n}\n```\n\n**Properties:**\n- `headerData`: The header content and styling information\n- `isVisible`: Controls header visibility\n\n## Protocols\n\n### PromotionalHeaderViewModelProtocol\n```swift\npublic protocol PromotionalHeaderViewModelProtocol {\n    var displayStatePublisher: AnyPublisher<PromotionalHeaderDisplayState, Never> { get }\n    \n    func setHeaderVisibility(_ isVisible: Bool)\n}\n```\n\n**Key Methods:**\n- `setHeaderVisibility(_:)`: Controls header visibility\n\n## Usage Examples\n\n### Basic Implementation\n```swift\n// Create header data\nlet headerData = PromotionalHeaderData(\n    id: \"deposit_bonus\",\n    icon: \"dollarsign.circle.fill\",\n    title: \"Claim a first deposit bonus!\",\n    subtitle: \"Select a first deposit bonus of your choosing...\",\n    backgroundColor: UIColor.systemOrange.withAlphaComponent(0.1)\n)\n\n// Create view model\nlet viewModel = MockPromotionalHeaderViewModel(headerData: headerData)\n\n// Create header view\nlet headerView = PromotionalHeaderView(viewModel: viewModel)\n\n// Add to view hierarchy\nparentView.addSubview(headerView)\nheaderView.translatesAutoresizingMaskIntoConstraints = false\n\nNSLayoutConstraint.activate([\n    headerView.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor, constant: 16),\n    headerView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 16),\n    headerView.trailingAnchor.constraint(equalTo: parentView.trailingAnchor, constant: -16)\n])\n```\n\n### Header Without Subtitle\n```swift\nlet headerData = PromotionalHeaderData(\n    id: \"welcome_bonus\",\n    icon: \"gift.fill\",\n    title: \"Welcome Bonus Available!\",\n    subtitle: nil,  // No subtitle\n    backgroundColor: UIColor.systemBlue.withAlphaComponent(0.1)\n)\n\nlet viewModel = MockPromotionalHeaderViewModel(headerData: headerData)\nlet headerView = PromotionalHeaderView(viewModel: viewModel)\n```\n\n### Custom ViewModel Implementation\n```swift\nclass InfoHeaderViewModel: PromotionalHeaderViewModelProtocol {\n    private let displayStateSubject: CurrentValueSubject<PromotionalHeaderDisplayState, Never>\n    var displayStatePublisher: AnyPublisher<PromotionalHeaderDisplayState, Never> {\n        return displayStateSubject.eraseToAnyPublisher()\n    }\n    \n    private let analyticsService: AnalyticsService\n    \n    init(headerData: PromotionalHeaderData, analyticsService: AnalyticsService) {\n        self.analyticsService = analyticsService\n        \n        let initialState = PromotionalHeaderDisplayState(headerData: headerData)\n        self.displayStateSubject = CurrentValueSubject(initialState)\n        \n        // Track header display\n        analyticsService.track(\"promotional_header_displayed\", properties: [\n            \"header_id\": headerData.id,\n            \"header_title\": headerData.title\n        ])\n    }\n    \n    func setHeaderVisibility(_ isVisible: Bool) {\n        let currentState = displayStateSubject.value\n        let newState = PromotionalHeaderDisplayState(\n            headerData: currentState.headerData,\n            isVisible: isVisible\n        )\n        displayStateSubject.send(newState)\n        \n        // Track visibility changes\n        analyticsService.track(\"promotional_header_visibility_changed\", properties: [\n            \"header_id\": currentState.headerData.id,\n            \"is_visible\": isVisible\n        ])\n    }\n}\n```\n\n### Multiple Header Types\n```swift\nclass PromotionHeaderFactory {\n    static func createDepositHeader() -> PromotionalHeaderView {\n        let data = PromotionalHeaderData(\n            id: \"deposit_bonus\",\n            icon: \"dollarsign.circle.fill\",\n            title: \"Claim a first deposit bonus!\",\n            subtitle: \"Select a first deposit bonus of your choosing...\",\n            backgroundColor: UIColor.systemOrange.withAlphaComponent(0.1)\n        )\n        let viewModel = MockPromotionalHeaderViewModel(headerData: data)\n        return PromotionalHeaderView(viewModel: viewModel)\n    }\n    \n    static func createTournamentHeader() -> PromotionalHeaderView {\n        let data = PromotionalHeaderData(\n            id: \"tournament_info\",\n            icon: \"trophy.fill\",\n            title: \"Weekly Tournament\",\n            subtitle: \"Join our weekly poker tournament for a chance to win big!\",\n            backgroundColor: UIColor.systemIndigo.withAlphaComponent(0.1)\n        )\n        let viewModel = MockPromotionalHeaderViewModel(headerData: data)\n        return PromotionalHeaderView(viewModel: viewModel)\n    }\n    \n    static func createGameUpdateHeader() -> PromotionalHeaderView {\n        let data = PromotionalHeaderData(\n            id: \"game_update\",\n            icon: \"gamecontroller.fill\",\n            title: \"New Games Added\",\n            subtitle: \"Check out our latest slot games with exciting themes!\",\n            backgroundColor: UIColor.systemMint.withAlphaComponent(0.1)\n        )\n        let viewModel = MockPromotionalHeaderViewModel(headerData: data)\n        return PromotionalHeaderView(viewModel: viewModel)\n    }\n}\n```\n\n### Dynamic Header Updates\n```swift\nclass DynamicHeaderViewController: UIViewController {\n    private var headerView: PromotionalHeaderView!\n    private var viewModel: MockPromotionalHeaderViewModel!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        viewModel = MockPromotionalHeaderViewModel.defaultMock\n        headerView = PromotionalHeaderView(viewModel: viewModel)\n        \n        setupHeaderConstraints()\n        \n        // Update header content after a delay\n        DispatchQueue.main.asyncAfter(deadline: .now() + 3.0) {\n            self.updateHeaderContent()\n        }\n    }\n    \n    private func updateHeaderContent() {\n        let newData = PromotionalHeaderData(\n            id: \"updated_promo\",\n            icon: \"star.fill\",\n            title: \"Special Weekend Offer!\",\n            subtitle: \"Limited time promotion available now.\",\n            backgroundColor: UIColor.systemPurple.withAlphaComponent(0.1)\n        )\n        \n        viewModel.updateHeaderData(newData)\n    }\n}\n```\n\n## Component Behavior\n\n### Layout Behavior\n- **Icon Size**: Fixed 40x40pt for consistent appearance\n- **Container Padding**: 16pt padding around content\n- **Text Stack Spacing**: 4pt between title and subtitle\n- **Horizontal Spacing**: 12pt between icon and text\n- **Corner Radius**: 12pt for modern card appearance\n\n### Optional Subtitle Handling\n- **With Subtitle**: Both title and subtitle are displayed\n- **Without Subtitle**: Only title is shown, subtitle label is hidden\n- **Dynamic Updates**: Subtitle visibility updates reactively\n\n### Visual States\n- **Visible State**: Component is displayed normally\n- **Hidden State**: Component is completely hidden\n- **Custom Background**: Supports various background colors\n\n## Styling Integration\n\nThe component integrates with `StyleProvider` for consistent theming:\n\n- **Colors**:\n  - `highlightPrimary`: Icon tint color\n  - `textPrimary`: Title text color\n  - `textSecondary`: Subtitle text color\n  - `backgroundColor`: Default background color\n- **Typography**:\n  - Bold 16pt for header titles\n  - Regular 14pt for subtitles\n- **Layout**:\n  - 12pt corner radius\n  - Consistent padding and spacing\n\n## Accessibility Features\n\n- **Clear Content**: Descriptive titles and subtitles\n- **Visual Hierarchy**: Clear typography distinction between title and subtitle\n- **Screen Reader Support**: Proper accessibility labels\n- **Optional Content**: Graceful handling of missing subtitle\n- **Semantic Structure**: Proper use of headings and content structure\n\n## Use Cases\n\n### Promotional Information\n```swift\nlet promoHeader = PromotionalHeaderData(\n    id: \"weekend_bonus\",\n    icon: \"percent\",\n    title: \"Weekend Bonus Active\",\n    subtitle: \"Get 25% extra on all deposits this weekend!\",\n    backgroundColor: UIColor.systemOrange.withAlphaComponent(0.1)\n)\n```\n\n### Tournament Announcements\n```swift\nlet tournamentHeader = PromotionalHeaderData(\n    id: \"poker_tournament\",\n    icon: \"trophy.fill\",\n    title: \"Poker Tournament Starting\",\n    subtitle: \"Buy-in: $50 | Prize Pool: $10,000\",\n    backgroundColor: UIColor.systemIndigo.withAlphaComponent(0.1)\n)\n```\n\n### Game Updates\n```swift\nlet gameUpdateHeader = PromotionalHeaderData(\n    id: \"new_slots\",\n    icon: \"gamecontroller.fill\",\n    title: \"New Slot Games\",\n    subtitle: nil,\n    backgroundColor: UIColor.systemMint.withAlphaComponent(0.1)\n)\n```\n\n### Account Information\n```swift\nlet accountHeader = PromotionalHeaderData(\n    id: \"loyalty_status\",\n    icon: \"crown.fill\",\n    title: \"VIP Gold Member\",\n    subtitle: \"Enjoy exclusive benefits and higher limits.\",\n    backgroundColor: UIColor.systemYellow.withAlphaComponent(0.1)\n)\n```\n\n### System Announcements\n```swift\nlet maintenanceHeader = PromotionalHeaderData(\n    id: \"maintenance_notice\",\n    icon: \"wrench.fill\",\n    title: \"Scheduled Maintenance\",\n    subtitle: \"System will be offline from 2:00 AM - 4:00 AM PST.\",\n    backgroundColor: UIColor.systemGray.withAlphaComponent(0.1)\n)\n```\n\n## Technical Implementation\n\n### Memory Management\n- Weak references in closures to prevent retain cycles\n- Proper Combine cancellable storage\n- Efficient view hierarchy with minimal nesting\n\n### Performance Considerations\n- Lightweight view structure for smooth scrolling\n- Efficient constraint setup\n- Optimized for dynamic content updates\n- Small memory footprint\n\n### State Management\n- Reactive updates with Combine\n- Clean separation of concerns\n- Predictable state changes\n\n## Error Handling\n\n### Defensive Programming\n- Safe unwrapping of optional subtitle\n- Graceful fallbacks for missing icons\n- Proper handling of empty content\n- Safe background color handling\n\n### Data Validation\n- Non-empty title validation\n- Valid icon name verification\n- Proper state management\n\n## Dependencies\n\n- **UIKit**: Core UI framework\n- **Combine**: Reactive programming and state management\n- **StyleProvider**: Internal styling and theming system\n- **Foundation**: Basic data structures\n\n## Best Practices\n\n1. **Content Quality**: Use clear, descriptive messages\n2. **Icon Selection**: Choose appropriate system icons for each content type\n3. **Background Colors**: Use subtle, branded colors that enhance readability\n4. **Subtitle Usage**: Keep subtitles concise and informative\n5. **Consistent Styling**: Follow the design system guidelines\n6. **Performance**: Keep headers lightweight for list performance\n7. **Accessibility**: Ensure proper content structure and labeling\n\n## Integration Patterns\n\n### With Content Management System\n```swift\nclass ContentHeaderViewController: UIViewController {\n    private var headerView: PromotionalHeaderView?\n    private let contentService: ContentService\n    \n    func displayFeaturedContent() {\n        contentService.getFeaturedPromotion { [weak self] content in\n            guard let content = content else { return }\n            \n            let headerData = PromotionalHeaderData(\n                id: content.id,\n                icon: content.iconName,\n                title: content.title,\n                subtitle: content.description,\n                backgroundColor: content.brandColor\n            )\n            \n            let viewModel = MockPromotionalHeaderViewModel(headerData: headerData)\n            self?.headerView = PromotionalHeaderView(viewModel: viewModel)\n            self?.setupHeaderConstraints()\n        }\n    }\n}\n```\n\n### In Table View Headers\n```swift\nclass PromotionalTableViewController: UITableViewController {\n    private var headerViewModel: MockPromotionalHeaderViewModel!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // Create header\n        headerViewModel = MockPromotionalHeaderViewModel.defaultMock\n        let headerView = PromotionalHeaderView(viewModel: headerViewModel)\n        \n        // Set as table header\n        tableView.tableHeaderView = headerView\n        \n        // Configure constraints\n        headerView.translatesAutoresizingMaskIntoConstraints = false\n        NSLayoutConstraint.activate([\n            headerView.widthAnchor.constraint(equalTo: tableView.widthAnchor),\n            headerView.centerXAnchor.constraint(equalTo: tableView.centerXAnchor)\n        ])\n        \n        // Update table header view layout\n        tableView.tableHeaderView = headerView\n        tableView.tableHeaderView?.layoutIfNeeded()\n        tableView.tableHeaderView = tableView.tableHeaderView\n    }\n}\n```\n\n### In Collection View Supplementary Views\n```swift\nclass PromotionalCollectionViewController: UICollectionViewController {\n    override func collectionView(_ collectionView: UICollectionView, viewForSupplementaryElementOfKind kind: String, at indexPath: IndexPath) -> UICollectionReusableView {\n        \n        if kind == UICollectionView.elementKindSectionHeader {\n            let headerView = collectionView.dequeueReusableSupplementaryView(\n                ofKind: kind,\n                withReuseIdentifier: \"PromotionalHeader\",\n                for: indexPath\n            ) as! PromotionalCollectionHeader\n            \n            let viewModel = MockPromotionalHeaderViewModel.defaultMock\n            headerView.configure(with: viewModel)\n            \n            return headerView\n        }\n        \n        return UICollectionReusableView()\n    }\n}\n```\n\n## Future Enhancements\n\n- Support for custom fonts and typography scales\n- Animation effects for content changes\n- Support for action buttons within the header\n- Timer display for time-sensitive information\n- Progress indicators for ongoing promotions\n- Image support alongside or instead of icons\n- Custom corner radius and shadow options\n- Rich text support for formatted content\n- Swipe gestures for additional interactions\n- Localization support for multi-language content\n- Dark mode optimization\n- Dynamic type support for accessibility\n\nThis component provides a clean, flexible solution for displaying informational and promotional content throughout the application while maintaining consistency with the GomaUI design system and focusing purely on information display without any interactive complexity. ",
      "snapshots": [
        {
          "category": "HeaderVariants",
          "light": "PromotionalHeaderView/__Snapshots__/PromotionalHeaderViewSnapshotTests/testPromotionalHeaderView_HeaderVariants_Light.1.png",
          "dark": "PromotionalHeaderView/__Snapshots__/PromotionalHeaderViewSnapshotTests/testPromotionalHeaderView_HeaderVariants_Dark.1.png"
        }
      ]
    },
    "QuickAddButtonView": {
      "displayName": "QuickAddButtonView",
      "category": "Betting",
      "subcategory": "BetSlip",
      "summary": "Quick-add amount button for betslip stake entry",
      "description": "Compact button that adds a preset amount to the current bet stake. Displays '+' prefix followed by amount value (e.g., +100, +250, +500). Features inputBackground styling, 4pt rounded corners, bold 12pt font, and alpha-based disabled state (0.5 opacity). Used in betslip stake entry for quick stake additions. Leaf component with no children.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "quick-add",
        "stake",
        "betslip",
        "amount",
        "button",
        "bet-entry",
        "leaf-component"
      ],
      "states": [
        "enabled",
        "disabled"
      ],
      "similarTo": [
        "AmountPillsView"
      ],
      "oftenUsedWith": [
        "BetInfoSubmissionView",
        "BorderedTextFieldView"
      ],
      "parents": [
        "BetInfoSubmissionView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": null,
      "snapshots": []
    },
    "QuickLinksTabBar": {
      "displayName": "QuickLinksTabBar",
      "category": "Navigation",
      "subcategory": "TabBars",
      "summary": "Horizontal quick access tab bar with icons and titles",
      "description": "Horizontal bar displaying quick navigation links (e.g., Aviator, Virtual, Slots, Crash, Promos) with icon + title per item. Items are equally distributed using fillEqually distribution. Supports multiple link type categories: gaming (bundle icons), sports (SF Symbols), and account (SF Symbols). Fixed 48pt height with 2pt stack spacing. Uses QuickLinkTabBarItemView as internal helper. Provides onQuickLinkSelected callback with QuickLinkType enum.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "navigation",
        "tab-bar",
        "quick-links",
        "horizontal",
        "icons",
        "gaming",
        "sports",
        "account"
      ],
      "states": [
        "gaming-links",
        "sports-links",
        "account-links"
      ],
      "similarTo": [
        "AdaptiveTabBarView",
        "MarketGroupSelectorTabView"
      ],
      "oftenUsedWith": [
        "CasinoCategoriesListView",
        "InPlayEventsView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# QuickLinksTabBar Component Documentation\n\nWelcome to the documentation for the `QuickLinksTabBar` component, a simple and flexible horizontal bar of actionable links for iOS applications developed within the GomaUI framework.\n\n## Overview\n\nThe `QuickLinksTabBar` provides a customizable horizontal bar of tappable items, each consisting of an icon and a title. It's designed for quick access to common features or destinations within your app.\n\n**Key Features:**\n\n* **ViewModel-Driven**: All UI state (link items) is managed by a ViewModel, making the view itself a passive renderer.\n* **Simple Structure**: A straightforward horizontal layout of identical items, each with an icon and title.\n* **Type-Safe Actions**: Uses an enum-based approach for item types, ensuring type safety when handling tap actions.\n* **Flexible Content**: Easily customizable with different sets of quick links for various contexts.\n* **Lightweight Design**: Fixed height of 40pts and minimal complexity, perfect for space-efficient navigation.\n* **Callback-Based Interaction**: Simple callback mechanism for handling user taps on links.\n\n## Documentation Index\n\nTo help you understand and use the `QuickLinksTabBar` effectively, the documentation is organized into the following sections:\n\n* **[Architecture](./ARCHITECTURE.md)**: Understand the design principles and structure of the component.\n* **[Usage Guide](./USAGE_GUIDE.md)**: Learn how to integrate and use the component in your application.\n* **[Data Structures](./DATA_STRUCTURES.md)**: Explore the data models that define the links and their behavior.\n* **[View Components](./VIEW_COMPONENTS.md)**: Information about the `QuickLinksTabBarView` and `QuickLinkTabBarItemView` Swift classes.\n* **[Testing and Previews](./TESTING_AND_PREVIEWS.md)**: How to use the mock ViewModel for testing and SwiftUI Previews.\n\n## When to Use\n\nThe `QuickLinksTabBar` is ideal for:\n\n* Providing access to frequently used features at the top of a screen\n* Creating category shortcuts in a browsing interface\n* Building a compact navigation row for related sections\n* Implementing feature highlights or promotional links\n\nUnlike the more complex `AdaptiveTabBarView`, the `QuickLinksTabBar` is not designed for primary app navigation or for maintaining selected states. It's a simple action bar where each item triggers a callback when tapped.",
      "snapshots": [
        {
          "category": "LinkTypes",
          "light": "QuickLinksTabBar/__Snapshots__/QuickLinksTabBarSnapshotTests/testQuickLinksTabBar_LinkTypes_Light.1.png",
          "dark": "QuickLinksTabBar/__Snapshots__/QuickLinksTabBarSnapshotTests/testQuickLinksTabBar_LinkTypes_Dark.1.png"
        }
      ]
    },
    "RecentSearchView": {
      "displayName": "RecentSearchView",
      "category": "Forms",
      "subcategory": "Search",
      "summary": "Recent search term row with tap and delete actions",
      "description": "Displays a recent search term with magnifying glass icon (16x16pt) on the left, search text in the middle, and X delete button (40x40pt) on the right. Fixed 50pt height with bottom separator line. Tap gesture on entire view triggers onTap callback for re-searching. Delete button triggers onDelete callback for removal. Uses backgroundSecondary background and highlightPrimary icon tints.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "search",
        "recent",
        "history",
        "delete",
        "tap",
        "row",
        "leaf-component"
      ],
      "states": [
        "default"
      ],
      "similarTo": [
        "SearchResultView"
      ],
      "oftenUsedWith": [
        "BorderedTextFieldView",
        "SportsSearchView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# RecentSearchView\n\nA reusable UIKit component for displaying recent search terms with tap and delete functionality.\n\n## Overview\n\nThe `RecentSearchView` component displays a search term in a styled container with a delete button. It supports tap gestures for selecting the search term and a delete button for removing it from recent searches.\n\n## Features\n\n- **Search Icon**: Magnifying glass icon on the left\n- **Tap Handling**: Tap anywhere on the view to trigger the `onTap` callback\n- **Delete Functionality**: X button triggers the `onDelete` callback\n- **Separator Line**: Bottom border line for visual separation\n- **Theming**: Uses `StyleProvider` for consistent styling\n- **ViewModel Pattern**: Follows GomaUI MVVM architecture\n- **SwiftUI Preview**: Includes preview for rapid development\n\n## Usage\n\n```swift\n// Create view model with callbacks\nlet viewModel = MockRecentSearchViewModel(\n    searchText: \"Liverpool\",\n    onTap: {\n        // Handle tap - perform search with this term\n        print(\"Searching for: Liverpool\")\n    },\n    onDelete: {\n        // Handle delete - remove from recent searches\n        print(\"Deleting recent search\")\n    }\n)\n\n// Create and configure the view\nlet recentSearchView = RecentSearchView(viewModel: viewModel)\nrecentSearchView.configure()\n```\n\n## Architecture\n\n### ViewModel Protocol\n- `searchText: String` - The search term to display\n- `onTap: (() -> Void)?` - Callback triggered when view is tapped\n- `onDelete: (() -> Void)?` - Callback triggered when delete button is pressed\n\n### Component Structure\n- **Container View**: Rounded background container\n- **Stack View**: Horizontal layout for icon, text and button\n- **Search Icon**: Magnifying glass icon (16x16pt)\n- **Search Text Label**: Displays the search term\n- **Delete Button**: X button for deletion (20x20pt)\n- **Separator Line**: Bottom border line (1pt height)\n\n## Theming\n\nThe component uses `StyleProvider` for consistent theming:\n\n- **Text Color**: `StyleProvider.Color.textPrimary`\n- **Search Icon Color**: `StyleProvider.Color.textSecondary`\n- **Delete Button Color**: `StyleProvider.Color.highlightPrimary`\n- **Background**: `StyleProvider.Color.backgroundTertiary`\n- **Separator Line**: `StyleProvider.Color.borderPrimary`\n- **Font**: `StyleProvider.fontWith(type: .regular, size: 16)`\n\n## Layout\n\n- **Corner Radius**: 8pt rounded corners\n- **Padding**: 12pt horizontal, 8pt vertical\n- **Spacing**: 12pt between icon, text and delete button\n- **Search Icon Size**: 16x16pt magnifying glass\n- **Button Size**: 20x20pt square delete button\n- **Separator Height**: 1pt bottom border line\n\n## Callbacks\n\n### onTap\nTriggered when the user taps anywhere on the view. Use this to:\n- Perform a new search with the displayed term\n- Navigate to search results\n- Update the search input field\n\n### onDelete\nTriggered when the user taps the X button. Use this to:\n- Remove the search term from recent searches\n- Update the recent searches list\n- Persist changes to storage\n\n## SwiftUI Preview\n\nThe component includes a SwiftUI preview showing multiple recent search examples for rapid development and testing.\n",
      "snapshots": []
    },
    "RecentlyPlayedGamesView": {
      "displayName": "RecentlyPlayedGamesView",
      "category": "Casino",
      "subcategory": "Games",
      "summary": "Horizontal carousel of recently played casino games with header pill",
      "description": "Displays a section for recently played casino games with a highlighted pill header ('Recently Played') and horizontally scrollable collection of game cards. Each RecentlyPlayedGamesCellView (210x56pt) shows game thumbnail, name, and optional provider. Collection has 12pt cell spacing and 16pt horizontal section insets. Header pill uses highlightPrimary background with 32pt height and 16pt corner radius. Supports placeholder state with 3 empty cards when no games loaded. Provides onGameSelected callback and refreshGames() action.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "casino",
        "games",
        "recently-played",
        "horizontal-scroll",
        "collection",
        "carousel",
        "header-pill"
      ],
      "states": [
        "with-games",
        "placeholder-empty"
      ],
      "similarTo": [
        "CasinoGamesSectionView"
      ],
      "oftenUsedWith": [
        "CasinoCategoriesListView",
        "CasinoGameCardView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# RecentlyPlayedGamesView\n\nA horizontal collection view component for displaying recently played casino games with a selectable pill header.\n\n## Overview\n\nThe `RecentlyPlayedGamesView` provides a clean, scrollable interface for displaying recently played casino games. It features a \"Recently Played\" pill header using the existing `PillItemView` component and a horizontal collection view displaying game tiles with images, titles, and provider information.\n\n## Features\n\n- **PillView Header**: Uses existing `PillItemView` component in selected state without icon\n- **Horizontal Collection**: Smooth scrolling collection view with custom cell layout\n- **Separate Cell Component**: `RecentlyPlayedGamesCellView` for reusable game tile UI\n- **Image Loading**: Smart image loading supporting both bundle images and network URLs\n- **Optional ViewModel**: Can be initialized with or without a viewModel\n- **Runtime Configuration**: Supports changing viewModel after initialization\n- **Reactive Updates**: Uses Combine publishers for real-time UI updates\n- **Game Selection**: Interactive tiles with selection callbacks\n- **Placeholder States**: Shows placeholder tiles when no games are available\n\n## Architecture\n\n### MVVM Pattern\nThe component follows the MVVM (Model-View-ViewModel) architectural pattern:\n\n- **Model**: `RecentlyPlayedGameData` - Contains game information\n- **View**: `RecentlyPlayedGamesView` - Main container with collection view\n- **Cell View**: `RecentlyPlayedGamesCellView` - Individual game tile component\n- **ViewModel**: `RecentlyPlayedGamesViewModelProtocol` - Business logic and data binding\n\n### Components Structure\n```\nRecentlyPlayedGamesView/\n RecentlyPlayedGamesViewModelProtocol.swift    # Protocol and data models\n RecentlyPlayedGamesView.swift                 # Main UI component with collection view\n RecentlyPlayedGamesCellView.swift             # Separate cell component\n MockRecentlyPlayedGamesViewModel.swift        # Mock implementation\n Documentation/\n     README.md                                 # This file\n```\n\n## Usage\n\n### Basic Usage\n```swift\n\n\n// With viewModel\nlet viewModel = MockRecentlyPlayedGamesViewModel.defaultRecentlyPlayed\nlet recentlyPlayedView = RecentlyPlayedGamesView(viewModel: viewModel)\n\n// Without viewModel (shows placeholder)\nlet recentlyPlayedView = RecentlyPlayedGamesView()\n```\n\n### Runtime Configuration\n```swift\nlet recentlyPlayedView = RecentlyPlayedGamesView()\n\n// Configure with viewModel\nrecentlyPlayedView.configure(with: viewModel)\n\n// Clear viewModel (shows placeholder)\nrecentlyPlayedView.configure(with: nil)\n```\n\n### Game Selection Handling\n```swift\nrecentlyPlayedView.onGameSelected = { gameId in\n    print(\"Game selected: \\(gameId)\")\n    // Handle navigation to game or launch game\n}\n```\n\n## Data Models\n\n### RecentlyPlayedGameData\n```swift\npublic struct RecentlyPlayedGameData: Equatable, Hashable, Identifiable {\n    public let id: String           // game identifier\n    public let name: String         // game name (e.g., \"Gonzo's Quest\")\n    public let provider: String     // provider name (e.g., \"Netent\")\n    public let imageURL: String?    // game image URL or bundle name\n    public let gameURL: String      // URL for launching the game\n}\n```\n\n## ViewModel Protocol\n\n### RecentlyPlayedGamesViewModelProtocol\n```swift\npublic protocol RecentlyPlayedGamesViewModelProtocol: AnyObject {\n    // Publishers for reactive updates\n    var gamesPublisher: AnyPublisher<[RecentlyPlayedGameData], Never> { get }\n    var titlePublisher: AnyPublisher<String, Never> { get }\n    \n    // Read-only properties\n    var sectionId: String { get }\n    \n    // Actions\n    func gameSelected(_ gameId: String)\n    func refreshGames()\n}\n```\n\n## Cell Component\n\n### RecentlyPlayedGamesCellView\nThe separate cell component (`RecentlyPlayedGamesCellView`) provides:\n\n- **Fixed dimensions**: 21056pt following Figma specifications\n- **Game image**: 5656pt with rounded corners and loading states\n- **Content area**: Game title (bold 12pt) and provider (regular 12pt)\n- **Interactive**: Tap gesture with selection callback\n- **Image loading**: Supports bundle images and network URLs with loading/error states\n\n```swift\nlet cellView = RecentlyPlayedGamesCellView()\ncellView.configure(with: gameData)\ncellView.onGameSelected = { gameId in\n    // Handle game selection\n}\n```\n\n## Mock ViewModel\n\nThe `MockRecentlyPlayedGamesViewModel` provides several factory methods for different scenarios:\n\n```swift\n// Predefined scenarios\nlet defaultGames = MockRecentlyPlayedGamesViewModel.defaultRecentlyPlayed      // 5 games\nlet fewGames = MockRecentlyPlayedGamesViewModel.fewGames                      // 2 games\nlet longNames = MockRecentlyPlayedGamesViewModel.longGameNames                // Long text testing\nlet emptyGames = MockRecentlyPlayedGamesViewModel.emptyRecentlyPlayed         // No games\n\n// Custom scenario\nlet custom = MockRecentlyPlayedGamesViewModel.customRecentlyPlayed(\n    sectionId: \"custom-id\",\n    title: \"Custom Title\",\n    games: customGamesArray\n)\n```\n\n## Visual Design\n\nThe component follows the Figma design specifications:\n\n### Header (PillView)\n- **Component**: Uses existing `PillItemView` from GomaUI\n- **State**: Selected (orange background)\n- **Text**: \"Recently Played\" \n- **Icon**: None\n- **Padding**: 16px horizontal from screen edges\n\n### Collection View\n- **Layout**: Horizontal scrolling\n- **Cell size**: 21056pt\n- **Spacing**: 12pt between cells\n- **Content insets**: 16pt horizontal\n\n### Game Tiles\n- **Background**: `primaryInteractionLow` color (#FFF0E7)\n- **Corner radius**: 12pt\n- **Image**: 5656pt, left-aligned with 8pt corner radius\n- **Title**: Bold 12pt, `textPrimary` color\n- **Provider**: Regular 12pt, `textSecondary` color\n- **Content padding**: 12pt horizontal\n\n## States\n\n### Normal State\n- Displays games from viewModel\n- Collection scrolls horizontally\n- Tiles are interactive\n- Publishers provide real-time updates\n\n### Placeholder State\n- Shows when no viewModel is provided or games array is empty\n- Displays 3 placeholder tiles with generic content\n- Tiles still interactive but return empty IDs\n\n### Loading State\n- Individual game images show loading indicators\n- Graceful fallback to placeholder images on load failure\n\n## Integration\n\n### With Existing Components\n- **PillItemView**: Uses existing GomaUI component for header\n- **StyleProvider**: Follows GomaUI color and typography system\n- **Collection patterns**: Follows established GomaUI collection view patterns\n\n### Performance Considerations\n- **Image caching**: Images are cached by URLSession\n- **Reusable cells**: Collection view cells are reused efficiently\n- **Memory management**: Weak references prevent retain cycles\n\n## Accessibility\n\nThe component supports:\n- VoiceOver navigation for header and individual games\n- Dynamic type scaling for text elements\n- High contrast support through StyleProvider\n- Proper touch target sizing (minimum 44pt)\n\n## Collection View Integration\n\nFor use within UICollectionView layouts, use the provided wrapper cell:\n\n### RecentlyPlayedGamesCollectionViewCell\n\n```swift\n\n\n// Register the cell\ncollectionView.register(RecentlyPlayedGamesCollectionViewCell.self, forCellWithReuseIdentifier: \"RecentlyPlayedCell\")\n\n// Configure in cellForItemAt\nfunc collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"RecentlyPlayedCell\", for: indexPath) as! RecentlyPlayedGamesCollectionViewCell\n    \n    // Configure with your view model\n    cell.configure(with: recentlyPlayedGamesViewModel)\n    \n    // Setup callbacks\n    cell.onGameSelected = { gameId in\n        print(\"Recently played game selected: \\(gameId)\")\n        // Handle game selection navigation\n    }\n    \n    return cell\n}\n\n// Size for collection view layout\nfunc collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {\n    return CGSize(width: collectionView.bounds.width, height: 100)\n}\n```\n\n### Collection View Cell Features\n\n- **Automatic cleanup**: Properly handles reuse and memory management\n- **Callback forwarding**: All RecentlyPlayedGamesView callbacks are available\n- **Configuration support**: Works with any RecentlyPlayedGamesViewModelProtocol\n- **Placeholder handling**: Falls back to placeholder state when no viewModel provided\n\n## Demo\n\nSee `RecentlyPlayedGamesViewController` in the GomaUI Demo app for interactive examples showcasing:\n- Different game collections (default, few games, long names, empty)\n- Runtime configuration switching\n- Game selection handling\n- Refresh functionality\n- Placeholder state demonstration\n",
      "snapshots": []
    },
    "ResendCodeView": {
      "displayName": "ResendCodeCountdownView",
      "category": "Forms",
      "subcategory": "Verification",
      "summary": "Countdown timer label for resend verification code",
      "description": "Displays a countdown timer showing when a user can request a new verification code. Formats remaining time as 'Resend Code in MM:SS' and automatically counts down every second. Timer starts automatically on init and stops at 00:00. Used in SMS verification, email verification, and 2FA flows. Simple label with regular 14pt font, left-aligned, fills parent container. Provides startCountdown() and resetCountdown() actions.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "countdown",
        "timer",
        "resend",
        "verification",
        "code",
        "sms",
        "2fa",
        "leaf-component"
      ],
      "states": [
        "counting-down",
        "expired"
      ],
      "similarTo": [
        "CountdownView"
      ],
      "oftenUsedWith": [
        "PinDigitEntryView",
        "BorderedTextFieldView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# ResendCodeView (ResendCodeCountdownView)\n\nA countdown timer label for resend code functionality in verification flows.\n\n## Overview\n\nResendCodeCountdownView displays a countdown timer showing when a user can request a new verification code. It formats the remaining time as \"Resend Code in MM:SS\" and automatically counts down. When the timer reaches zero, the user typically becomes eligible to resend the code. The component is used in SMS verification, email verification, and two-factor authentication flows.\n\n## Component Relationships\n\n### Used By (Parents)\n- Verification screens\n- PIN entry views\n- Two-factor authentication forms\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Countdown timer with MM:SS format\n- Automatic timer start on initialization\n- Reset countdown functionality\n- Localized countdown text\n- Left-aligned label\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockResendCodeCountdownViewModel(startSeconds: 60)\nlet countdownView = ResendCodeCountdownView(viewModel: viewModel)\n\n// Timer starts automatically on init\n// Display shows: \"Resend Code in 00:59\"\n\n// Reset the countdown\nviewModel.resetCountdown()\n\n// Start countdown manually after reset\nviewModel.startCountdown()\n```\n\n## Data Model\n\n```swift\nprotocol ResendCodeCountdownViewModelProtocol {\n    var countdownTextPublisher: AnyPublisher<String, Never> { get }\n\n    func startCountdown()\n    func resetCountdown()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.textPrimary` - label text color\n- `StyleProvider.fontWith(type: .regular, size: 14)` - label font\n\nLayout constants:\n- Label fills parent container\n- Text alignment: left\n\nTimer behavior:\n- Updates every 1 second\n- Format: \"Resend Code in MM:SS\"\n- Stops at 00:00\n- Timer invalidated on deinit\n\n## Mock ViewModels\n\nAvailable presets:\n- `MockResendCodeCountdownViewModel(startSeconds: 59)` - Default 59 seconds\n- `MockResendCodeCountdownViewModel(startSeconds: 60)` - 1 minute countdown\n- `MockResendCodeCountdownViewModel(startSeconds: 5)` - Short 5 second countdown\n\nMethods:\n- `startCountdown()` - Starts/restarts the timer\n- `resetCountdown()` - Resets to initial value and updates display\n",
      "snapshots": [
        {
          "category": "CountdownStates",
          "light": "ResendCodeView/__Snapshots__/ResendCodeViewSnapshotTests/testResendCodeView_CountdownStates_Light.1.png",
          "dark": "ResendCodeView/__Snapshots__/ResendCodeViewSnapshotTests/testResendCodeView_CountdownStates_Dark.1.png"
        }
      ]
    },
    "ScoreView": {
      "displayName": "ScoreView",
      "category": "MatchCards",
      "subcategory": "Scores",
      "summary": "Horizontal sports score display with multiple cell styles and serving indicators",
      "description": "Displays a horizontal series of score cells for sports matches (tennis, basketball, football, volleyball, hockey). Supports three cell styles (simple 26pt/border 26pt/background 29pt) combined with three highlighting modes (winnerLoser/bothHighlight/noHighlight). Features serving indicator column for tennis with home/away dots, trailing separators between cells, and visual states (idle/loading/display/empty). Fixed 42pt height, 4pt cell spacing, right-aligned. Children: ScoreCellView, ServingIndicatorView. Used by: MatchHeaderCompactView, MatchParticipantsInfoView, TallOddsMatchCardView, InlineMatchCardView.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "score",
        "sports",
        "tennis",
        "basketball",
        "football",
        "live",
        "serving-indicator",
        "highlighting",
        "multi-sport"
      ],
      "states": [
        "idle",
        "loading",
        "display",
        "empty"
      ],
      "similarTo": [
        "InlineScoreView"
      ],
      "oftenUsedWith": [
        "MatchHeaderCompactView",
        "MatchParticipantsInfoView",
        "TallOddsMatchCardView"
      ],
      "parents": [
        "InlineMatchCardView",
        "MatchHeaderCompactView",
        "MatchParticipantsInfoView",
        "TallOddsMatchCardView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# ScoreView\n\nA flexible, protocol-based UI component for displaying sports match scores in a horizontal layout. Supports multiple score cells with different visual styles and reactive state management.\n\n## Overview\n\nThe `ScoreView` displays an array of score cells, each showing home and away scores with customizable styling. The component follows GomaUI architectural patterns with protocol-based ViewModels, reactive publishers, and StyleProvider integration.\n\n## Key Features\n\n- **Multiple Score Cells**: Display series of scores (sets, quarters, periods, etc.)\n- **Three Visual Styles**: Simple, border, and background styling options\n- **Reactive Updates**: Real-time score updates through Combine publishers\n- **State Management**: Loading, empty, and display states\n- **StyleProvider Integration**: Consistent theming across the app\n- **Winner Highlighting**: Automatic highlighting for winning scores in simple style\n\n## Architecture\n\n### Protocol-Based Design\n```swift\npublic protocol ScoreViewModelProtocol {\n    var scoreCellsPublisher: AnyPublisher<[ScoreDisplayData], Never> { get }\n    var visualStatePublisher: AnyPublisher<ScoreViewVisualState, Never> { get }\n\n    func updateScoreCells(_ cells: [ScoreDisplayData])\n    func setVisualState(_ state: ScoreViewVisualState)\n}\n```\n\n### Data Models\n```swift\npublic struct ScoreDisplayData: Equatable, Hashable {\n    public let id: String           // Unique identifier for updates\n    public let homeScore: String    // Home team/player score\n    public let awayScore: String    // Away team/player score\n    public let style: ScoreCellStyle // Visual presentation style\n}\n\npublic enum ScoreCellStyle: Equatable {\n    case simple     // Plain text with winner highlighting\n    case border     // Text with border outline\n    case background // Text with background fill\n}\n\npublic enum ScoreViewVisualState: Equatable {\n    case idle       // Initial state\n    case loading    // Showing loading indicator\n    case display    // Showing score cells\n    case empty      // Showing empty state message\n}\n```\n\n## Basic Usage\n\n### 1. Create ScoreView\n```swift\nlet scoreView = ScoreView()\nview.addSubview(scoreView)\n\n// Add constraints\nNSLayoutConstraint.activate([\n    scoreView.topAnchor.constraint(equalTo: container.topAnchor),\n    scoreView.leadingAnchor.constraint(equalTo: container.leadingAnchor),\n    scoreView.trailingAnchor.constraint(equalTo: container.trailingAnchor),\n    scoreView.heightAnchor.constraint(equalToConstant: 50)\n])\n```\n\n### 2. Configure with ViewModel\n```swift\n// Using mock for testing/previews\nlet viewModel = MockScoreViewModel.tennisMatch\nscoreView.configure(with: viewModel)\n\n// Using custom implementation\nlet customViewModel = MyScoreViewModel()\nscoreView.configure(with: customViewModel)\n```\n\n### 3. Update Scores Dynamically\n```swift\nlet updatedScores = [\n    ScoreDisplayData(id: \"set1\", homeScore: \"6\", awayScore: \"4\", style: .simple),\n    ScoreDisplayData(id: \"set2\", homeScore: \"4\", awayScore: \"6\", style: .simple),\n    ScoreDisplayData(id: \"current\", homeScore: \"3\", awayScore: \"2\", style: .border)\n]\n\nviewModel.updateScoreCells(updatedScores)\n```\n\n## Sport-Specific Examples\n\n### Tennis Match\n```swift\nlet tennisScores = [\n    ScoreDisplayData(id: \"set1\", homeScore: \"6\", awayScore: \"4\", style: .simple),    // Previous set\n    ScoreDisplayData(id: \"set2\", homeScore: \"4\", awayScore: \"6\", style: .simple),    // Previous set\n    ScoreDisplayData(id: \"set3\", homeScore: \"6\", awayScore: \"7\", style: .border),    // Current set\n    ScoreDisplayData(id: \"game\", homeScore: \"15\", awayScore: \"30\", style: .background) // Current game\n]\n```\n\n### Basketball Game\n```swift\nlet basketballScores = [\n    ScoreDisplayData(id: \"q1\", homeScore: \"25\", awayScore: \"22\", style: .simple),\n    ScoreDisplayData(id: \"q2\", homeScore: \"18\", awayScore: \"28\", style: .simple),\n    ScoreDisplayData(id: \"q3\", homeScore: \"31\", awayScore: \"24\", style: .simple),\n    ScoreDisplayData(id: \"q4\", homeScore: \"26\", awayScore: \"30\", style: .border),    // Current quarter\n    ScoreDisplayData(id: \"total\", homeScore: \"100\", awayScore: \"104\", style: .background) // Final score\n]\n```\n\n### Simple Football Match\n```swift\nlet footballScores = [\n    ScoreDisplayData(id: \"final\", homeScore: \"2\", awayScore: \"1\", style: .background)\n]\n```\n\n### Tennis with Advantage\n```swift\nlet tennisAdvantage = [\n    ScoreDisplayData(id: \"set1\", homeScore: \"6\", awayScore: \"3\", style: .simple),\n    ScoreDisplayData(id: \"set2\", homeScore: \"5\", awayScore: \"6\", style: .border),\n    ScoreDisplayData(id: \"current\", homeScore: \"A\", awayScore: \"40\", style: .background)\n]\n```\n\n## Cell Styles\n\n### Simple Style\n- Plain text display\n- Winner highlighting (alpha transparency for losing score)\n- Secondary text color from StyleProvider\n- Used for: Previous sets/quarters/periods\n\n### Border Style\n- Text with border outline\n- No winner highlighting\n- Primary text color from StyleProvider\n- Used for: Current active period\n\n### Background Style\n- Text with background fill\n- No winner highlighting\n- Primary color text on background color fill\n- Used for: Final/total scores, current game scores\n\n## State Management\n\n### Visual States\n```swift\n// Show loading spinner\nviewModel.setLoading()\n\n// Show score cells\nviewModel.setVisualState(.display)\n\n// Show empty message\nviewModel.setEmpty()\n\n// Clear all and show empty\nviewModel.clearScores()\n```\n\n### Reactive Updates\nThe component automatically updates when publishers emit new values:\n```swift\n// ViewModel publishes new scores\nviewModel.scoreCellsPublisher\n    .sink { scores in\n        // UI automatically updates\n    }\n```\n\n## Implementation Guidelines\n\n### Creating Score Data\nWhen implementing your own ViewModels, simply create `ScoreDisplayData` arrays directly from your domain models:\n\n```swift\nclass MyScoreViewModel: ScoreViewModelProtocol {\n\n    func loadTennisMatch() {\n        let scores = [\n            ScoreDisplayData(id: \"set1\", homeScore: \"6\", awayScore: \"4\", style: .simple),\n            ScoreDisplayData(id: \"set2\", homeScore: \"4\", awayScore: \"6\", style: .simple),\n            ScoreDisplayData(id: \"current_set\", homeScore: \"3\", awayScore: \"2\", style: .border),\n            ScoreDisplayData(id: \"current_game\", homeScore: \"30\", awayScore: \"15\", style: .background)\n        ]\n        updateScoreCells(scores)\n    }\n\n    func handleLiveScoreUpdate(newGameScore: String) {\n        // Update just the current game score\n        var currentScores = scoreCellsSubject.value\n        if let gameIndex = currentScores.firstIndex(where: { $0.id == \"current_game\" }) {\n            currentScores[gameIndex] = ScoreDisplayData(\n                id: \"current_game\",\n                homeScore: newGameScore,\n                awayScore: \"15\",\n                style: .background\n            )\n            updateScoreCells(currentScores)\n        }\n    }\n}\n```\n\n### Business Logic Guidelines\nThe ScoreView component is UI-focused. Your application should handle:\n\n1. **Data Conversion**: Transform your domain models into `ScoreDisplayData`\n2. **Sport-Specific Formatting**: Handle tennis \"A\" for advantage, etc.\n3. **User Authentication**: Determine when to show/hide scores\n4. **Real-time Updates**: Manage live score updates from your data layer\n\n## Mock ViewModels\n\nThe component includes extensive mock implementations for testing and previews:\n\n```swift\n// Pre-built scenarios\nMockScoreViewModel.tennisMatch      // Tennis with multiple sets\nMockScoreViewModel.tennisAdvantage  // Tennis with advantage scoring\nMockScoreViewModel.basketballMatch  // Basketball with quarters\nMockScoreViewModel.footballMatch    // Simple football score\nMockScoreViewModel.loading          // Loading state\nMockScoreViewModel.empty           // Empty state\n\n// Test edge cases\nMockScoreViewModel.maxCells        // Maximum score cells\nMockScoreViewModel.mixedStyles     // Different style combinations\nMockScoreViewModel.tiedMatch       // Tied scores\n```\n\n## Styling Customization\n\nThe component uses StyleProvider for consistent theming:\n\n```swift\n// Customize colors\nStyleProvider.Color.customize(\n    primaryColor: .systemBlue,\n    secondaryColor: .systemGray,\n    backgroundColor: .systemGray6,\n    textColor: .label\n)\n\n// Customize fonts\nStyleProvider.setFontProvider { type, size in\n    // Return your custom fonts\n}\n```\n\n## Accessibility\n\nThe component includes accessibility support:\n- Score labels are automatically accessible\n- Loading states announce properly\n- Empty states provide context\n\n## Best Practices\n\n1. **Use Meaningful IDs**: Provide descriptive IDs for each score cell to enable proper updates\n2. **Consistent Styling**: Use style conventions consistently across your app\n3. **Handle Empty States**: Always provide feedback when no scores are available\n4. **Optimize Updates**: Only update scores when values actually change\n5. **Proper Cleanup**: Call `cleanupForReuse()` when using in collection views\n\n## Advanced Usage\n\n### Custom ViewModel Implementation\n```swift\nclass LiveTennisScoreViewModel: ScoreViewModelProtocol {\n    private let scoreCellsSubject = CurrentValueSubject<[ScoreDisplayData], Never>([])\n    private let visualStateSubject = CurrentValueSubject<ScoreViewVisualState, Never>(.idle)\n\n    var scoreCellsPublisher: AnyPublisher<[ScoreDisplayData], Never> {\n        scoreCellsSubject.eraseToAnyPublisher()\n    }\n\n    var visualStatePublisher: AnyPublisher<ScoreViewVisualState, Never> {\n        visualStateSubject.eraseToAnyPublisher()\n    }\n\n    var currentVisualState: ScoreViewVisualState {\n        visualStateSubject.value\n    }\n\n    func connectToLiveData() {\n        setLoading()\n\n        // Your live data connection logic\n        liveDataService.connect { [weak self] matchData in\n            let scores = self?.convertMatchDataToScores(matchData) ?? []\n            self?.updateScoreCells(scores)\n        }\n    }\n\n    private func convertMatchDataToScores(_ matchData: MatchData) -> [ScoreDisplayData] {\n        // Convert your domain model to ScoreDisplayData\n        var scores: [ScoreDisplayData] = []\n\n        // Add previous sets\n        for (index, set) in matchData.completedSets.enumerated() {\n            scores.append(ScoreDisplayData(\n                id: \"set\\(index)\",\n                homeScore: \"\\(set.homeScore)\",\n                awayScore: \"\\(set.awayScore)\",\n                style: .simple\n            ))\n        }\n\n        // Add current set if in progress\n        if let currentSet = matchData.currentSet {\n            scores.append(ScoreDisplayData(\n                id: \"current_set\",\n                homeScore: \"\\(currentSet.homeScore)\",\n                awayScore: \"\\(currentSet.awayScore)\",\n                style: .border\n            ))\n        }\n\n        // Add current game score\n        scores.append(ScoreDisplayData(\n            id: \"current_game\",\n            homeScore: formatTennisScore(matchData.currentGame.homeScore),\n            awayScore: formatTennisScore(matchData.currentGame.awayScore),\n            style: .background\n        ))\n\n        return scores\n    }\n\n    private func formatTennisScore(_ score: Int) -> String {\n        switch score {\n        case 0: return \"0\"\n        case 1: return \"15\"\n        case 2: return \"30\"\n        case 3: return \"40\"\n        case 4: return \"A\"  // Advantage\n        default: return \"\\(score)\"\n        }\n    }\n\n    // Required protocol methods\n    func updateScoreCells(_ cells: [ScoreDisplayData]) {\n        scoreCellsSubject.send(cells)\n        visualStateSubject.send(cells.isEmpty ? .empty : .display)\n    }\n\n    func setVisualState(_ state: ScoreViewVisualState) {\n        visualStateSubject.send(state)\n    }\n\n    func clearScores() {\n        scoreCellsSubject.send([])\n        visualStateSubject.send(.empty)\n    }\n\n    func setLoading() {\n        visualStateSubject.send(.loading)\n    }\n\n    func setEmpty() {\n        scoreCellsSubject.send([])\n        visualStateSubject.send(.empty)\n    }\n}\n```",
      "snapshots": [
        {
          "category": "SportVariants",
          "light": "ScoreView/__Snapshots__/ScoreViewSnapshotTests/testScoreView_SportVariants_Light.1.png",
          "dark": "ScoreView/__Snapshots__/ScoreViewSnapshotTests/testScoreView_SportVariants_Dark.1.png"
        },
        {
          "category": "StyleVariants",
          "light": "ScoreView/__Snapshots__/ScoreViewSnapshotTests/testScoreView_StyleVariants_Light.1.png",
          "dark": "ScoreView/__Snapshots__/ScoreViewSnapshotTests/testScoreView_StyleVariants_Dark.1.png"
        },
        {
          "category": "VisualStates",
          "light": "ScoreView/__Snapshots__/ScoreViewSnapshotTests/testScoreView_VisualStates_Light.1.png",
          "dark": "ScoreView/__Snapshots__/ScoreViewSnapshotTests/testScoreView_VisualStates_Dark.1.png"
        }
      ]
    },
    "SearchHeaderInfoView": {
      "displayName": "SearchHeaderInfoView",
      "category": "Forms",
      "subcategory": "Search",
      "summary": "Search status header with loading animation and results count",
      "description": "Displays search status information with three states: loading (animated ellipsis 'Searching for X in category...'), results (shows count in bold 'Showing Results for X in category (N)'), and no results (orange warning triangle icon with 'No Results for X'). Search term and count displayed in semibold 16pt, rest in regular 16pt. Different backgrounds: tertiary for loading/results, secondary for no results. Uses 16pt horizontal / 12pt vertical padding, 8pt icon spacing. 20x20pt warning icon for no results state.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "search",
        "status",
        "loading",
        "results",
        "no-results",
        "header",
        "animated-ellipsis",
        "warning-icon",
        "leaf-component"
      ],
      "states": [
        "loading",
        "results",
        "noResults"
      ],
      "similarTo": [
        "LoadingStateView"
      ],
      "oftenUsedWith": [
        "BorderedTextFieldView",
        "SearchView",
        "RecentSearchView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# SearchHeaderInfoView\n\nA reusable UI component that displays search status information with three distinct states: loading, results, and no results.\n\n## Overview\n\nThe `SearchHeaderInfoView` provides a consistent way to show users the current state of their search operation, including animated loading indicators and appropriate messaging for different scenarios.\n\n## Features\n\n- **Three States**: Loading, Results, and No Results\n- **Animated Loading**: Ellipsis animation during search operations\n- **Dynamic Content**: Search term and category are dynamically inserted\n- **Attributed Text**: Search term and count are displayed in bold, rest in regular font\n- **Warning Icon**: Displays warning icon for no results state\n- **Theme Support**: Uses StyleProvider for consistent theming\n\n## Usage\n\n### Basic Implementation\n\n```swift\nlet searchHeaderView = SearchHeaderInfoView()\n\n// Loading state\nsearchHeaderView.configure(\n    searchTerm: \"Liverpool\", \n    category: \"Sports\", \n    state: .loading\n)\n\n// Results state\nsearchHeaderView.configure(\n    searchTerm: \"Liverpool\", \n    category: \"Sports\", \n    state: .results, \n    count: 3\n)\n\n// No results state\nsearchHeaderView.configure(\n    searchTerm: \"Liverpool\", \n    category: \"Sports\", \n    state: .noResults\n)\n```\n\n### With ViewModel Pattern\n\n```swift\nclass SearchViewModel: SearchHeaderInfoViewModelProtocol {\n    @Published var searchTerm: String = \"\"\n    @Published var category: String = \"Sports\"\n    @Published var state: SearchState = .loading\n    @Published var count: Int? = nil\n    \n    func updateSearch(term: String, category: String, state: SearchState, count: Int?) {\n        self.searchTerm = term\n        self.category = category\n        self.state = state\n        self.count = count\n    }\n}\n\n// In your view controller\nlet viewModel = SearchViewModel()\nlet searchHeaderView = SearchHeaderInfoView()\n\n// Bind to view model\nviewModel.$state\n    .sink { [weak self] state in\n        self?.searchHeaderView.configure(\n            searchTerm: viewModel.searchTerm,\n            category: viewModel.category,\n            state: state,\n            count: viewModel.count\n        )\n    }\n    .store(in: &cancellables)\n```\n\n## States\n\n### Loading State\n- **Text**: \"Searching for \\\"[term]\\\" in [category]...\"\n- **Background**: Tertiary background color\n- **Animation**: Animated ellipsis\n- **Icon**: Hidden\n\n### Results State\n- **Text**: \"Showing Results for \\\"[term]\\\" in [category] ([count])\"\n- **Background**: Tertiary background color\n- **Formatting**: Search term and count (including parentheses) in bold, rest in regular font\n- **Icon**: Hidden\n- **Animation**: None\n\n### No Results State\n- **Text**: \"No Results for \\\"[term]\\\" in [category]\"\n- **Background**: Secondary background color (different from other states)\n- **Formatting**: Search term in bold, rest in regular font\n- **Icon**: Orange warning triangle\n- **Animation**: None\n\n## Customization\n\n### Theming\nThe component uses StyleProvider for consistent theming:\n\n```swift\n// Colors\nStyleProvider.Color.backgroundTertiary  // Container background (loading/results states)\nStyleProvider.Color.backgroundSecondary // Container background (no results state)\nStyleProvider.Color.textPrimary        // Text color\nStyleProvider.Color.highlightPrimary   // Warning icon color\n\n// Fonts\nStyleProvider.fontWith(type: .regular, size: 16)  // Regular text\nStyleProvider.fontWith(type: .semibold, size: 16) // Bold text (search term and count)\n```\n\n### Layout\n- **Height**: Auto-sizing based on content\n- **Padding**: 16pt horizontal, 12pt vertical\n- **Spacing**: 8pt between icon and text\n- **Corner Radius**: Small corner radius applied\n\n## Animation Details\n\nThe loading state includes a subtle ellipsis animation that cycles through \"\", \".\", \"..\", \"...\" to indicate ongoing search operations. The animation:\n- Duration: 1.5 seconds per cycle\n- Repeats: Indefinitely\n- Stops: Automatically when state changes\n\n## Integration Notes\n\n- **UIKit Only**: This is a UIKit component with SwiftUI preview support\n- **Auto Layout**: Uses NSLayoutConstraint for responsive layout\n- **Memory Efficient**: Lazy initialization of UI components\n- **Protocol Driven**: Supports both direct configuration and ViewModel pattern\n\n## Testing\n\nUse the provided mock implementation for testing:\n\n```swift\nlet mockViewModel = MockSearchHeaderInfoViewModel(\n    searchTerm: \"Test\",\n    category: \"Sports\", \n    state: .results,\n    count: 5\n)\n```\n\n## Preview\n\nThe component includes SwiftUI previews showing all three states. Use Xcode's preview canvas to see the component in action during development.\n",
      "snapshots": []
    },
    "SearchView": {
      "displayName": "SearchView",
      "category": "Forms",
      "subcategory": "Search",
      "summary": "Styled search text input with magnifying glass and clear button",
      "description": "Lightweight search input with leading magnifying-glass icon (18pt) and trailing clear button (18pt) that appears when text is entered. Features two-layer containers with inputBackgroundSecondary outer and inputBackground inner (4pt corner radius). Supports plain and attributed placeholder text with automatic bold emphasis on last word (brand name). Fixed 40pt container height, 12pt horizontal padding, 8pt spacing. Keyboard return key type is 'search'. Reactive updates via Combine for text changes, focus state, and enabled state (0.5 alpha when disabled).",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "search",
        "input",
        "text-field",
        "magnifying-glass",
        "clear-button",
        "placeholder",
        "leaf-component"
      ],
      "states": [
        "empty",
        "with-text",
        "focused",
        "disabled"
      ],
      "similarTo": [
        "BorderedTextFieldView"
      ],
      "oftenUsedWith": [
        "SearchHeaderInfoView",
        "RecentSearchView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# SearchView\n\nA lightweight search input with a leading magnifying-glass icon and a trailing clear button.\n\n## Overview\n\nSearchView provides a styled text input field with a magnifying-glass search icon, placeholder text support, and a clear button that appears when text is entered. The component supports both plain and attributed placeholder text, with automatic emphasis styling on the last word (commonly a brand name). It integrates with reactive publishers for text changes, focus state, and enabled state.\n\n## Component Relationships\n\n### Used By (Parents)\n- Search screens\n- Header navigation areas\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Search icon (magnifying glass) in left position\n- Clear button appears when text is entered\n- Plain or attributed placeholder text support\n- Last word emphasis styling in placeholder\n- Focus state tracking\n- Enabled/disabled state support\n- Keyboard search button return type\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockSearchViewModel.default\nlet searchView = SearchView(viewModel: viewModel)\n\n// With custom placeholder\nlet customVM = MockSearchViewModel.withPlaceholder(\"Search in Casino\")\nlet customSearchView = SearchView(viewModel: customVM)\n\n// Update placeholder at runtime\nviewModel.updatePlaceholder(\"Search for games...\")\n\n// React to text changes\nviewModel.textPublisher\n    .sink { text in\n        performSearch(text)\n    }\n    .store(in: &cancellables)\n```\n\n## Data Model\n\n```swift\nprotocol SearchViewModelProtocol: AnyObject {\n    // Content\n    var placeholderTextPublisher: AnyPublisher<String, Never> { get }\n    var attributedPlaceholderPublisher: AnyPublisher<NSAttributedString?, Never> { get }\n    var textPublisher: AnyPublisher<String, Never> { get }\n\n    // UI State\n    var isClearButtonVisiblePublisher: AnyPublisher<Bool, Never> { get }\n    var isEnabledPublisher: AnyPublisher<Bool, Never> { get }\n    var isFocusedPublisher: AnyPublisher<Bool, Never> { get }\n\n    // Inputs\n    func updateText(_ text: String)\n    func clearText()\n    func setFocused(_ isFocused: Bool)\n    func submit()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.inputBackgroundSecondary` - outer container background\n- `StyleProvider.Color.inputBackground` - inner container background\n- `StyleProvider.Color.textPrimary` - text field text color\n- `StyleProvider.Color.inputText` - placeholder text color\n- `StyleProvider.Color.highlightPrimary` - icon and clear button tint\n- `StyleProvider.fontWith(type: .regular, size: 14)` - text field font\n- `StyleProvider.fontWith(type: .bold, size: 14)` - placeholder emphasis font\n\nLayout constants:\n- Container height: 40pt\n- Horizontal padding: 12pt\n- Spacing: 8pt\n- Corner radius: 4pt\n- Icon size: 18pt\n- Clear button size: 18pt\n\nPlaceholder styling:\n- Regular 14pt for most text\n- Bold 14pt for last word (brand emphasis)\n\nIcons:\n- Search: Bundle \"search_icon\" or SF Symbol \"magnifyingglass\"\n- Clear: Bundle \"cancel_search_icon\" or SF Symbol \"xmark\"\n\n## Mock ViewModels\n\nAvailable presets:\n- `.default` - Standard \"Search in Sportsbook\" placeholder\n- `.withPlaceholder(_ text:)` - Custom placeholder text\n\nMethods:\n- `updateText(_ text:)` - Updates text and clear button visibility\n- `clearText()` - Clears text and hides clear button\n- `setFocused(_ isFocused:)` - Tracks focus state\n- `updatePlaceholder(_ text:)` - Updates placeholder at runtime\n",
      "snapshots": [
        {
          "category": "SearchVariants",
          "light": "SearchView/__Snapshots__/SearchViewSnapshotTests/testSearchView_SearchVariants_Light.1.png",
          "dark": "SearchView/__Snapshots__/SearchViewSnapshotTests/testSearchView_SearchVariants_Dark.1.png"
        }
      ]
    },
    "SeeMoreButtonView": {
      "displayName": "SeeMoreButtonView",
      "category": "Status",
      "subcategory": "Loading",
      "summary": "Load more button with loading indicator and remaining count display",
      "description": "Reusable button for 'Load More' functionality with loading states. Shows activity indicator when fetching data and optionally displays remaining count ('Load X more games'). Supports two visual styles: solidBackground (highlightPrimary fill) and bordered (2pt border, transparent fill). Fixed 44pt height (standard touch target), 8pt corner radius, 16pt horizontal padding. Disabled state uses 0.6 alpha with disabled color palette. Medium 13pt font. Provides onButtonTapped callback and configure(with:) for cell reuse. Full accessibility support.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "load-more",
        "pagination",
        "button",
        "loading",
        "count",
        "casino",
        "games",
        "leaf-component"
      ],
      "states": [
        "normal",
        "loading",
        "disabled",
        "with-count"
      ],
      "similarTo": [
        "ActionButtonView",
        "LoadingStateView"
      ],
      "oftenUsedWith": [
        "CasinoGamesSectionView",
        "CasinoCategorySectionView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# SeeMoreButtonView\n\nA reusable button component for \"Load More\" functionality with loading states, designed for pagination in collection views and table views.\n\n## Features\n\n- **Loading States**: Shows spinner and disables interaction during loading\n- **Flexible Text**: Supports both static text and dynamic remaining count display\n- **StyleProvider Integration**: Uses centralized theming for consistent appearance\n- **Collection View Ready**: Includes dedicated collection view cell wrapper\n- **Accessibility**: Full accessibility support with appropriate labels and hints\n- **Reactive**: Uses Combine publishers for state management\n\n## Usage Example\n\n### Basic Usage\n\n```swift\n// Create a view model (or use a mock for testing)\nlet buttonData = SeeMoreButtonData(\n    id: \"load-more-games\",\n    title: \"Load More Games\",\n    remainingCount: 25\n)\n\nlet viewModel = MockSeeMoreButtonViewModel(buttonData: buttonData)\n\n// Create the component\nlet seeMoreButtonView = SeeMoreButtonView(viewModel: viewModel)\n\n// Add to your view hierarchy\nparentView.addSubview(seeMoreButtonView)\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    seeMoreButtonView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 16),\n    seeMoreButtonView.trailingAnchor.constraint(equalTo: parentView.trailingAnchor, constant: -16),\n    seeMoreButtonView.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor),\n    seeMoreButtonView.heightAnchor.constraint(equalToConstant: 44)\n])\n\n// Handle button tap\nseeMoreButtonView.onButtonTapped = {\n    print(\"Load more button tapped!\")\n    // Perform pagination logic\n}\n```\n\n### Collection View Usage\n\n```swift\n// Register the collection view cell\ncollectionView.register(SeeMoreButtonCollectionViewCell.self, forCellWithReuseIdentifier: \"SeeMoreButtonCell\")\n\n// In cellForItemAt\nfunc collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"SeeMoreButtonCell\", for: indexPath) as! SeeMoreButtonCollectionViewCell\n    \n    // Configure with button data\n    let buttonData = SeeMoreButtonData(\n        id: \"load-more-category\",\n        title: \"Load More Games\",\n        remainingCount: remainingGamesCount\n    )\n    \n    cell.configure(\n        with: buttonData,\n        isLoading: isLoadingMore,\n        isEnabled: !isLoadingMore\n    )\n    \n    // Handle tap\n    cell.onSeeMoreTapped = { [weak self] in\n        self?.loadMoreGames()\n    }\n    \n    return cell\n}\n```\n\n### State Management\n\n```swift\n// Using Mock ViewModel for testing\nlet viewModel = MockSeeMoreButtonViewModel.defaultMock\n\n// Control loading state\nviewModel.setLoading(true)  // Shows spinner, disables button\nviewModel.setLoading(false) // Hides spinner, enables button\n\n// Update remaining count\nviewModel.updateRemainingCount(15) // Shows \"Load 15 more games\"\nviewModel.updateRemainingCount(nil) // Shows default title\n\n// Enable/disable button\nviewModel.setEnabled(false) // Grays out button, disables interaction\nviewModel.setEnabled(true)  // Normal appearance, enables interaction\n```\n\n## Configuration Options\n\n### SeeMoreButtonData\n\n- **id**: Unique identifier for the button\n- **title**: Default button text (e.g., \"Load More Games\")\n- **remainingCount**: Optional count to display (e.g., \"Load 15 more games\")\n\n### SeeMoreButtonDisplayState\n\n- **isLoading**: Whether to show loading spinner\n- **isEnabled**: Whether button is enabled for interaction\n- **buttonData**: The button configuration\n\n## Design Specifications\n\n- **Height**: 44pt (iOS standard button height)\n- **Corner Radius**: 8pt\n- **Font**: StyleProvider.fontWith(type: .medium, size: 13)\n- **Background**: StyleProvider.Color.highlightPrimary\n- **Text Color**: StyleProvider.Color.buttonTextPrimary\n- **Loading Indicator**: Medium size, same color as text\n\n## Mock Implementations\n\nThe component includes several pre-configured mock implementations:\n\n- `MockSeeMoreButtonViewModel.defaultMock` - Basic \"Load More\" button\n- `MockSeeMoreButtonViewModel.loadingMock` - Button in loading state\n- `MockSeeMoreButtonViewModel.withCountMock` - Button with remaining count\n- `MockSeeMoreButtonViewModel.disabledMock` - Disabled button state\n- `MockSeeMoreButtonViewModel.interactiveMock` - Interactive demo version\n\n## Integration with Pagination\n\nThe component is designed to work seamlessly with pagination systems:\n\n1. **Initial State**: Show button with total remaining count\n2. **Loading State**: Show spinner, disable interaction\n3. **Success State**: Update remaining count, hide if no more items\n4. **Error State**: Show retry button, enable interaction\n\n## Accessibility\n\nThe component provides comprehensive accessibility support:\n\n- **Dynamic Labels**: Updates based on loading/enabled state\n- **Appropriate Hints**: Provides context for screen readers\n- **State Changes**: Announces state changes to assistive technologies\n- **Touch Targets**: Meets minimum 44pt touch target requirements\n\nThis component follows GomaUI patterns and integrates seamlessly with existing iOS applications using UICollectionView or UITableView pagination.",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "SeeMoreButtonView/__Snapshots__/SeeMoreButtonViewSnapshotTests/testSeeMoreButtonView_BasicStates_Light.1.png",
          "dark": "SeeMoreButtonView/__Snapshots__/SeeMoreButtonViewSnapshotTests/testSeeMoreButtonView_BasicStates_Dark.1.png"
        },
        {
          "category": "DisplayVariants",
          "light": "SeeMoreButtonView/__Snapshots__/SeeMoreButtonViewSnapshotTests/testSeeMoreButtonView_DisplayVariants_Light.1.png",
          "dark": "SeeMoreButtonView/__Snapshots__/SeeMoreButtonViewSnapshotTests/testSeeMoreButtonView_DisplayVariants_Dark.1.png"
        }
      ]
    },
    "SelectOptionsView": {
      "displayName": "SelectOptionsView",
      "category": "Forms",
      "subcategory": "Selection",
      "summary": "Vertical list of selectable options with optional title header",
      "description": "Displays a vertical stack of radio-button-style options allowing single selection. Each option is rendered using SimpleOptionRowView (child component) with selection state tracking. Supports optional semibold 12pt title above options list. Uses 12pt stack spacing, backgroundTertiary background. Provides onOptionSelected callback when selection changes. Selection state managed via CurrentValueSubject for reactive updates. Commonly used in settings, preferences, and filter screens.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "selection",
        "radio",
        "options",
        "form",
        "settings",
        "preferences",
        "single-select"
      ],
      "states": [
        "with-title",
        "without-title"
      ],
      "similarTo": [
        "RadioGroupView",
        "PillSelectorBarView"
      ],
      "oftenUsedWith": [
        "SimpleOptionRowView",
        "ResponsibleGamingView"
      ],
      "parents": [],
      "children": [
        "SimpleOptionRowView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# SelectOptionsView\n\nA vertical list of selectable options with an optional title header.\n\n## Overview\n\nSelectOptionsView displays a vertical stack of radio-button-style options allowing single selection. Each option is rendered using SimpleOptionRowView with selection state tracking. The component supports an optional title above the options list and provides selection callbacks. It is commonly used for settings, preferences, and filter selections.\n\n## Component Relationships\n\n### Used By (Parents)\n- Settings screens\n- Preference forms\n- Filter panels\n\n### Uses (Children)\n- `SimpleOptionRowView` (for each option)\n\n## Features\n\n- Vertical option list layout\n- Single selection with visual feedback\n- Optional title header\n- Dynamic option rendering\n- Selection callback\n- Reactive selection updates via Combine\n- Background color theming\n\n## Usage\n\n```swift\n// Create options\nlet options = [\n    MockSimpleOptionRowViewModel.sampleSelected,\n    MockSimpleOptionRowViewModel.sampleUnselected\n]\nlet viewModel = MockSelectOptionsViewModel(\n    title: \"Notification Preferences\",\n    options: options,\n    selectedOption: \"all\"\n)\nlet selectView = SelectOptionsView(viewModel: viewModel)\n\n// Handle selection\nselectView.onOptionSelected = { optionId in\n    savePreference(optionId)\n}\n\n// Without title\nlet noTitleVM = MockSelectOptionsViewModel.withoutTitle\nlet noTitleView = SelectOptionsView(viewModel: noTitleVM)\n```\n\n## Data Model\n\n```swift\nprotocol SelectOptionsViewModelProtocol {\n    var title: String? { get }\n    var options: [SimpleOptionRowViewModelProtocol] { get }\n    var selectedOptionId: CurrentValueSubject<String?, Never> { get }\n    func selectOption(withId id: String)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundTertiary` - stack view background\n- `StyleProvider.Color.textPrimary` - title text color\n- `StyleProvider.fontWith(type: .semibold, size: 12)` - title font\n\nLayout constants:\n- Stack spacing: 12pt\n- Title hidden if nil or empty\n\nOption styling:\n- Handled by SimpleOptionRowView component\n- Selection state passed to each option\n\n## Mock ViewModels\n\nAvailable presets:\n- `.withTitle` - \"Notification Preferences\" with All/Promotions/None options\n- `.withoutTitle` - Options list without header title\n\nParameters:\n- `title: String?` - Optional header title\n- `options: [SimpleOptionRowViewModelProtocol]` - List of option view models\n- `selectedOption: String?` - Initially selected option ID\n\nMethods:\n- `selectOption(withId:)` - Selects an option and triggers callback\n",
      "snapshots": []
    },
    "ShareChannelsGridView": {
      "displayName": "ShareChannelsGridView",
      "category": "Profile",
      "subcategory": "Sharing",
      "summary": "Grid layout of social sharing channel buttons in two rows",
      "description": "Displays a grid of sharing channel buttons (WhatsApp, Facebook, Twitter, Telegram, Messenger, Viber, SMS, Email) organized in up to two rows of 5 buttons each. Each ShareChannelButtonView shows a branded icon with channel name and brand-specific background colors. Supports availability states (enabled/disabled). Layout: 12pt container padding, 12pt row spacing, 16pt button spacing, fillEqually distribution. Provides onChannelSelected callback with ShareChannelType enum. Social icons from bundle assets, SMS/Email use SF Symbols.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "share",
        "social",
        "grid",
        "whatsapp",
        "facebook",
        "twitter",
        "telegram",
        "referral"
      ],
      "states": [
        "all-channels",
        "social-only",
        "messaging-only",
        "with-disabled",
        "empty"
      ],
      "similarTo": [
        "ProfileMenuListView"
      ],
      "oftenUsedWith": [
        "ShareSheetView",
        "ReferralView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# ShareChannelsGridView\n\nA grid layout of social sharing channel buttons organized in two rows.\n\n## Overview\n\nShareChannelsGridView displays a grid of sharing channel buttons (WhatsApp, Facebook, Twitter, Telegram, etc.) organized in up to two rows of 5 buttons each. Each button shows a branded icon with the channel name and supports availability states. The component is used for share sheets and social sharing functionality throughout the app.\n\n## Component Relationships\n\n### Used By (Parents)\n- Share sheets\n- Referral screens\n- Social sharing dialogs\n\n### Uses (Children)\n- `ShareChannelButtonView` (internal helper)\n\n## Features\n\n- Two-row grid layout (5 buttons per row max)\n- Social channel icons with brand colors\n- Channel availability states (enabled/disabled)\n- Channel selection callback\n- Dynamic channel configuration\n- Empty row hiding\n- Spacer views for consistent layout\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockShareChannelsGridViewModel.allChannelsMock\nlet shareGrid = ShareChannelsGridView(viewModel: viewModel)\n\n// Handle channel selection\nviewModel.onChannelSelected = { channelType in\n    switch channelType {\n    case .whatsApp: shareToWhatsApp()\n    case .facebook: shareToFacebook()\n    case .twitter: shareToTwitter()\n    default: break\n    }\n}\n\n// Social channels only\nlet socialVM = MockShareChannelsGridViewModel.socialOnlyMock\nlet socialGrid = ShareChannelsGridView(viewModel: socialVM)\n\n// With disabled channels\nlet disabledVM = MockShareChannelsGridViewModel.withDisabledMock\n```\n\n## Data Model\n\n```swift\nenum ShareChannelType: String, CaseIterable, Identifiable {\n    case twitter, whatsApp, facebook, telegram, messenger, viber, sms, email\n\n    var title: String\n    var iconName: String\n    var backgroundColor: UIColor\n    var urlScheme: String?\n}\n\nstruct ShareChannel: Identifiable, Equatable {\n    let id: String\n    let type: ShareChannelType\n    let title: String\n    let iconName: String\n    let isAvailable: Bool\n\n    static func allChannels() -> [ShareChannel]\n    static func socialChannels() -> [ShareChannel]\n    static func messagingChannels() -> [ShareChannel]\n}\n\nstruct ShareChannelsGridData {\n    let channels: [ShareChannel]\n}\n\nprotocol ShareChannelsGridViewModelProtocol {\n    var dataPublisher: AnyPublisher<ShareChannelsGridData, Never> { get }\n    var onChannelSelected: ((ShareChannelType) -> Void)? { get set }\n}\n```\n\n## Styling\n\nLayout constants:\n- Container horizontal padding: 12pt\n- Container vertical padding: 8pt\n- Row spacing: 12pt\n- Button spacing: 16pt\n- Distribution: fillEqually\n\nRow behavior:\n- Top row: First 5 channels\n- Bottom row: Remaining channels (up to 5)\n- Empty rows hidden\n\nChannel colors (per type):\n- Twitter: #1DA1F2\n- WhatsApp: #25D366\n- Facebook: #1877F2\n- Telegram: #22ADE1\n- Messenger: #0084FF\n- Viber: #734F96\n- SMS: #52C41A\n- Email: #58A6FF\n\nIcons:\n- Social: Bundle assets (twitter_icon, whatsapp_icon, etc.)\n- SMS: SF Symbol \"message.circle.fill\"\n- Email: SF Symbol \"envelope.circle.fill\"\n\n## Mock ViewModels\n\nAvailable presets:\n- `.allChannelsMock` - All 8 channels\n- `.socialOnlyMock` - Twitter, WhatsApp, Facebook, Telegram, Messenger\n- `.messagingOnlyMock` - Viber, SMS, Email\n- `.limitedMock` - WhatsApp, Facebook, SMS, Email only\n- `.withDisabledMock` - Channels with some disabled\n- `.emptyMock` - No channels\n",
      "snapshots": []
    },
    "SimpleNavigationBarView": {
      "displayName": "SimpleNavigationBarView",
      "category": "Navigation",
      "subcategory": "NavBars",
      "summary": "Simple navigation bar with back button and optional centered title",
      "description": "Clean navigation bar for screens needing basic back navigation with optional centered title. Features back button with chevron icon (20pt, optional text label), centered title with proper truncation (never overlaps back button), and bottom separator line (1pt). Fixed 56pt height, 44pt back button container (iOS HIG touch target), 16pt horizontal padding. Title centered by default (priority 750) but shifts left for long titles. Supports style customization via SimpleNavigationBarStyle (defaultStyle, darkOverlay). Callback-based navigation, immutable after init.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "navigation",
        "back-button",
        "title",
        "header",
        "nav-bar",
        "chevron",
        "leaf-component"
      ],
      "states": [
        "icon-only",
        "with-back-text",
        "with-title",
        "with-back-text-and-title",
        "title-only"
      ],
      "similarTo": [
        "CustomNavigationView"
      ],
      "oftenUsedWith": [
        "SettingsView",
        "DetailScreens"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# SimpleNavigationBarView\n\nA simple navigation bar with back button and optional centered title.\n\n## Overview\n\nSimpleNavigationBarView provides a clean, consistent navigation bar for screens that need basic back navigation with an optional centered title. It features a back button with chevron icon (and optional text label), a centered title that properly truncates for long text, and a bottom separator line. The component supports style customization for special cases like dark overlays.\n\n## Component Relationships\n\n### Used By (Parents)\n- Detail screens\n- Settings screens\n- Modal presentations\n- Transaction history screens\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Back button with chevron icon\n- Optional back button text label\n- Optional centered title with truncation\n- Title respects back button space\n- Bottom separator line\n- Custom style support (dark overlay, etc.)\n- 44pt minimum touch target\n- Callback-based navigation\n- Immutable after initialization\n\n## Usage\n\n```swift\n// Icon only\nlet navBar = SimpleNavigationBarView(\n    viewModel: MockSimpleNavigationBarViewModel.iconOnly\n)\n\n// With back text and title\nlet fullNavBar = SimpleNavigationBarView(\n    viewModel: MockSimpleNavigationBarViewModel.withBackTextAndTitle\n)\n\n// Custom view model\nlet viewModel = MockSimpleNavigationBarViewModel(\n    backButtonText: \"Back\",\n    title: \"Transaction History\",\n    onBackTapped: { [weak self] in\n        self?.coordinator?.popViewController()\n    }\n)\nlet customNavBar = SimpleNavigationBarView(viewModel: viewModel)\n\n// Apply dark overlay style\nnavBar.setCustomization(.darkOverlay())\n\n// Update title dynamically\nnavBar.updateTitle(\"New Title\")\n```\n\n## Data Model\n\n```swift\nprotocol SimpleNavigationBarViewModelProtocol {\n    var backButtonText: String? { get }      // nil = icon only\n    var title: String? { get }               // nil = no title\n    var showBackButton: Bool { get }         // false = title only\n    var onBackTapped: () -> Void { get }     // navigation callback\n}\n\nstruct SimpleNavigationBarStyle: Equatable {\n    let backgroundColor: UIColor\n    let textColor: UIColor\n    let iconColor: UIColor\n    let separatorColor: UIColor\n\n    static func defaultStyle() -> SimpleNavigationBarStyle\n    static func darkOverlay() -> SimpleNavigationBarStyle\n}\n```\n\n## Styling\n\nStyleProvider properties used (default style):\n- `StyleProvider.Color.backgroundTertiary` - bar background\n- `StyleProvider.Color.textPrimary` - text color\n- `StyleProvider.Color.iconPrimary` - back icon tint\n- `StyleProvider.Color.separatorLine` - separator color\n- `StyleProvider.fontWith(type: .bold, size: 12)` - back label font\n- `StyleProvider.fontWith(type: .bold, size: 16)` - title font\n\nLayout constants:\n- Bar height: 56pt\n- Back button container height: 44pt (iOS HIG minimum)\n- Back icon size: 20pt\n- Back icon leading: 16pt\n- Back label spacing: 6pt\n- Title horizontal padding: 16pt\n- Separator height: 1pt\n\nTitle behavior:\n- Centered by default (priority 750)\n- Shifts left for long titles\n- Never overlaps back button (priority 1000)\n- Truncates with trailing ellipsis\n\nBuilt-in styles:\n- `.defaultStyle()` - Standard theme colors\n- `.darkOverlay()` - White text on transparent (for image overlays)\n\n## Mock ViewModels\n\nAvailable presets:\n- `.iconOnly` - Chevron icon only\n- `.withBackText` - Icon + \"Back\" text\n- `.withTitle` - Icon + centered title\n- `.withBackTextAndTitle` - Icon + text + title\n- `.titleOnly` - Title only, no back button\n- `.longTitle` - Long title for truncation testing\n\nParameters:\n- `backButtonText: String?` - Optional text next to icon\n- `title: String?` - Optional centered title\n- `showBackButton: Bool` - Whether to show back button\n- `onBackTapped: () -> Void` - Navigation callback\n",
      "snapshots": []
    },
    "SimpleOptionRowView": {
      "displayName": "SimpleOptionRowView",
      "category": "UIElements",
      "subcategory": "Forms",
      "summary": "Radio button row with title label and circular selection indicator",
      "description": "Single-selection option row displaying title label on left and radio button indicator on right. Features a 20pt circular button with 12pt white dot when selected, orange fill on selection, and gray border when unselected. Used as child component within SelectOptionsView for building single-selection option lists in settings, preferences, and filter interfaces. Handles tap gestures on entire row with callback for option selection.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "radio-button",
        "option",
        "selection",
        "form",
        "settings",
        "preferences",
        "single-select",
        "leaf-component"
      ],
      "states": [
        "selected",
        "unselected"
      ],
      "similarTo": [
        "InfoRowView",
        "SettingsItemRowView"
      ],
      "oftenUsedWith": [
        "SelectOptionsView"
      ],
      "parents": [
        "SelectOptionsView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# SimpleOptionRowView\n\nA single-selection option row with title and radio button indicator.\n\n## Overview\n\nSimpleOptionRowView displays a horizontally-arranged row with a title label on the left and a radio button indicator on the right. The radio button shows a filled dot when selected. This component is used as a child view within SelectOptionsView for building single-selection option lists in settings, preferences, and filter interfaces.\n\n## Component Relationships\n\n### Used By (Parents)\n- `SelectOptionsView`\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Title label on left side\n- Radio button indicator on right side\n- Selected/unselected visual states\n- Filled dot indicator when selected\n- Tap gesture on entire row\n- Option selection callback\n- Configurable via SortOption data\n\n## Usage\n\n```swift\nlet option = SortOption(\n    id: \"notifications\",\n    icon: nil,\n    title: \"Enable notifications\",\n    count: -1,\n    iconTintChange: false\n)\nlet viewModel = MockSimpleOptionRowViewModel(option: option)\nlet rowView = SimpleOptionRowView(viewModel: viewModel)\nrowView.isSelected = true\nrowView.configure()\n\n// Handle selection\nrowView.didTapOption = { selectedOption in\n    handleSelection(selectedOption.id)\n}\n```\n\n## Data Model\n\n```swift\nprotocol SimpleOptionRowViewModelProtocol {\n    var option: SortOption { get }\n}\n\n// SortOption is defined in SharedModels\nstruct SortOption {\n    let id: String\n    let icon: String?\n    let title: String\n    let count: Int\n    let iconTintChange: Bool\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundTertiary` - row background\n- `StyleProvider.Color.textPrimary` - title text color\n- `StyleProvider.Color.highlightPrimary` - selected radio button fill/border\n- `StyleProvider.Color.iconSecondary` - unselected radio button border\n- `StyleProvider.Color.allWhite` - radio button background, selected dot\n- `StyleProvider.fontWith(type: .regular, size: 12)` - title font\n\nLayout constants:\n- Title leading: 0pt (no padding)\n- Radio button trailing: 0pt (no padding)\n- Vertical padding: 8pt\n- Radio button size: 20pt\n- Selected dot size: 12pt\n- Radio button border width: 2pt\n- Radio button corner radius: 10pt (circular)\n\nRadio button states:\n- Unselected: white background, gray border\n- Selected: orange fill, orange border, white dot center\n\n## Mock ViewModels\n\nAvailable presets:\n- `.sampleSelected` - \"Enable notifications\" option\n- `.sampleUnselected` - \"Receive personalized offers\" option\n\nParameters:\n- `option: SortOption` - The option data to display\n",
      "snapshots": []
    },
    "SimpleSquaredFilterBar": {
      "displayName": "SimpleSquaredFilterBarView",
      "category": "Filters",
      "subcategory": "SelectionBars",
      "summary": "Horizontal filter bar with squared buttons for time/status/category selection",
      "description": "Horizontal row of equally-distributed squared filter buttons (48x40pt each) in a fixed 40pt height container. Single-selection mode with visual feedback on tap. Buttons show tertiary background with highlight text when selected, clear background with primary text when unselected. Supports time ranges (All, 1D, 1W, 1M, 3M), status filters, category filters. Uses data-model-based configuration via SimpleSquaredFilterBarData rather than MVVM protocol pattern.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "filter",
        "time-range",
        "status",
        "category",
        "horizontal",
        "single-select",
        "squared-buttons",
        "transaction-history"
      ],
      "states": [
        "default",
        "selected-first",
        "selected-middle",
        "selected-last"
      ],
      "similarTo": [
        "PillSelectorBarView",
        "FilterBarView",
        "MarketGroupSelectorTabView"
      ],
      "oftenUsedWith": [
        "TransactionHistoryView",
        "ActivityListView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# SimpleSquaredFilterBar\n\nA horizontal filter bar with squared buttons for time range, status, or category selection.\n\n## Overview\n\nSimpleSquaredFilterBarView displays a horizontal row of equally-distributed squared filter buttons. When a button is tapped, it becomes selected and the callback notifies the parent. Commonly used for time range filters (All, 1D, 1W, 1M, 3M), status filters (Active, Pending, Completed), or category filters.\n\n## Component Relationships\n\n### Used By (Parents)\n- Transaction history screens\n- Activity filter sections\n- Status filter bars\n\n### Uses (Children)\n- `SimpleSquaredFilterBarButton` - individual filter button\n\n## Features\n\n- Horizontal equal-spacing layout\n- Single selection mode\n- Tap callback with filter ID\n- Selected state styling\n- Dynamic button creation from data\n- Programmatic selection support\n- Fixed 40pt height\n\n## Usage\n\n```swift\n// Time range filters\nlet data = SimpleSquaredFilterBarData(\n    items: [\n        (\"all\", \"All\"),\n        (\"1d\", \"1D\"),\n        (\"1w\", \"1W\"),\n        (\"1m\", \"1M\"),\n        (\"3m\", \"3M\")\n    ],\n    selectedId: \"all\"\n)\nlet filterBar = SimpleSquaredFilterBarView(data: data)\n\n// Handle selection\nfilterBar.onFilterSelected = { filterId in\n    print(\"Selected: \\(filterId)\")\n}\n\n// Programmatic selection\nfilterBar.setSelected(\"1w\")\n\n// Reconfigure with new data\nfilterBar.configure(with: newData)\n```\n\n## Data Model\n\n```swift\nstruct SimpleSquaredFilterBarData: Equatable {\n    let items: [(id: String, title: String)]\n    let selectedId: String?\n\n    init(items: [(String, String)], selectedId: String? = nil)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundSecondary` - bar background\n\nLayout constants:\n- Bar height: 40pt (fixed)\n- Horizontal padding: 16pt\n- Stack distribution: equal spacing\n- Stack spacing: 0pt (handled by distribution)\n\nButton styling (handled by SimpleSquaredFilterBarButton):\n- Selected: highlight background with contrasting text\n- Unselected: secondary background with primary text\n\n## Callbacks\n\n- `onFilterSelected: ((String) -> Void)?` - Called with filter ID when selection changes\n\n## Mock ViewModels\n\nAvailable presets (via `MockSimpleSquaredFilterBarViewModel`):\n- `.defaultMock` - Same as timeFilters\n- `.timeFilters` - All, 1D, 1W, 1M, 3M\n- `.statusFilters` - Active, Pending, Completed, Cancelled\n- `.priorityFilters` - Low, Medium, High, Urgent\n- `.categoryFilters` - All, Payments, Games, Bonuses\n- `.gameTypeFilters` - Live, Upcoming, Finished\n",
      "snapshots": []
    },
    "SingleButtonBannerView": {
      "displayName": "SingleButtonBannerView",
      "category": "Promotions",
      "subcategory": "Banners",
      "summary": "Promotional banner with background image, message text, and optional CTA button",
      "description": "Full-bleed promotional banner displaying background image (async via Kingfisher), multiline message text (bold 22pt white for overlay), and optional action button with customizable styling. Button supports custom background/text colors, corner radius, and enabled/disabled states. Conforms to TopBannerViewProtocol for slider integration. Includes cell reuse support via clearContent() and configure() methods. Uses Combine publishers with CurrentValueSubject for reactive updates.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "banner",
        "promotion",
        "cta",
        "image-background",
        "kingfisher",
        "top-banner",
        "marketing",
        "call-to-action"
      ],
      "states": [
        "with-button",
        "no-button",
        "button-enabled",
        "button-disabled",
        "visible",
        "hidden",
        "empty"
      ],
      "similarTo": [
        "TopBannerSliderView",
        "PromotionalCardView"
      ],
      "oftenUsedWith": [
        "TopBannerSliderView",
        "HomeView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# SingleButtonBannerView\n\nA customizable banner component with a full-width background image, message text, and an optional action button. Designed to be used in horizontal scroll views and implements the `TopBannerProtocol` for banner management.\n\n## Features\n\n- **Full-width background image** - Customizable background with aspect fill scaling\n- **Customizable message text** - Multi-line support with configurable styling\n- **Optional action button** - Highly customizable button with optional styling overrides\n- **TopBanner protocol compliance** - Can be used in banner carousel/scroll views\n- **Visibility control** - Can be shown/hidden dynamically\n- **MVVM architecture** - Clean separation of concerns with reactive updates\n- **StyleProvider integration** - Consistent styling with theme support\n\n## Usage Example\n\n```swift\n\n\n// Create button configuration\nlet buttonConfig = ButtonConfig(\n    title: \"Get Started\",\n    backgroundColor: .systemBlue,\n    textColor: .white,\n    cornerRadius: 12\n)\n\n// Create banner data\nlet bannerData = SingleButtonBannerData(\n    type: \"welcome_banner\",\n    isVisible: true,\n    backgroundImage: UIImage(named: \"banner_background\"),\n    messageText: \"Get 2X the action,\\ndouble your first\\ndeposit!\",\n    buttonConfig: buttonConfig\n)\n\n// Create view model (or use a mock for testing)\nlet viewModel = MockSingleButtonBannerViewModel(bannerData: bannerData)\n\n// Create the banner view\nlet bannerView = SingleButtonBannerView(viewModel: viewModel)\n\n// Add to your view hierarchy\nparentView.addSubview(bannerView)\nbannerView.translatesAutoresizingMaskIntoConstraints = false\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    bannerView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor),\n    bannerView.trailingAnchor.constraint(equalTo: parentView.trailingAnchor),\n    bannerView.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor),\n    bannerView.heightAnchor.constraint(equalToConstant: 200)\n])\n\n// Handle button taps\nbannerView.onButtonTapped = {\n    print(\"Banner button tapped!\")\n    // Perform navigation or other actions\n}\n```\n\n## Configuration Options\n\n### SingleButtonBannerData\n\nThe main data model for configuring the banner:\n\n```swift\nlet bannerData = SingleButtonBannerData(\n    type: \"unique_banner_id\",           // Identifier for the banner type\n    isVisible: true,                    // Whether the banner should be visible\n    backgroundImage: myImage,           // Background image (optional)\n    messageText: \"Your message here\",   // Main message text\n    buttonConfig: buttonConfiguration   // Button configuration (optional)\n)\n```\n\n### ButtonConfig\n\nConfigure the optional action button:\n\n```swift\nlet buttonConfig = ButtonConfig(\n    title: \"Button Text\",                      // Button title\n    backgroundColor: UIColor.systemBlue,       // Custom background color (optional)\n    textColor: UIColor.white,                  // Custom text color (optional)\n    cornerRadius: 12.0                         // Custom corner radius (optional)\n)\n```\n\n### TopBannerProtocol Compliance\n\nThe component implements `TopBannerProtocol` for use in banner carousels:\n\n```swift\n// Access banner properties\nlet bannerType = bannerData.type        // \"welcome_banner\"\nlet isVisible = bannerData.isVisible    // true/false\n```\n\n## Layout Behavior\n\n- **Background Image**: Scales to fill the entire banner area using `scaleAspectFill`\n- **Message Label**: Positioned in the top-left with multi-line support\n- **Action Button**: Positioned in the bottom-left, automatically hidden if no `buttonConfig` is provided\n- **Content Padding**: 20pt padding on all sides for content within the banner\n\n## Mock View Models\n\nSeveral mock implementations are provided for testing and previews:\n\n### Available Mocks\n\n```swift\n// Default banner with gradient background and button\nlet defaultMock = MockSingleButtonBannerViewModel.defaultMock\n\n// Banner without button (message only)\nlet noButtonMock = MockSingleButtonBannerViewModel.noButtonMock\n\n// Banner with custom button styling\nlet customStyledMock = MockSingleButtonBannerViewModel.customStyledMock\n\n// Banner with disabled button\nlet disabledMock = MockSingleButtonBannerViewModel.disabledMock\n\n// Hidden banner\nlet hiddenMock = MockSingleButtonBannerViewModel.hiddenMock\n```\n\n### Creating Custom Mocks\n\n```swift\nlet customBannerData = SingleButtonBannerData(\n    type: \"custom_banner\",\n    isVisible: true,\n    backgroundImage: myCustomImage,\n    messageText: \"Custom message text\",\n    buttonConfig: myButtonConfig\n)\n\nlet customMock = MockSingleButtonBannerViewModel(\n    bannerData: customBannerData,\n    isButtonEnabled: true\n)\n```\n\n## Styling Customization\n\nThe component uses StyleProvider for consistent theming:\n\n```swift\n// The component will automatically use:\nStyleProvider.Color.backgroundPrimary     // For fallback background\nStyleProvider.Color.primaryTextColor    // For message text\nStyleProvider.Color.highlightPrimary        // For default button background\nStyleProvider.fontWith(type: .bold, size: 24)      // For message text\nStyleProvider.fontWith(type: .medium, size: 16)    // For button text\n```\n\nOverride button styling through `ButtonConfig` properties when needed.\n\n## Integration with Horizontal Scroll Views\n\nWhen using in banner carousels, the component's `TopBannerProtocol` compliance allows for easy management:\n\n```swift\nfunc displayBanner(_ bannerData: any TopBannerProtocol) {\n    if bannerData.isVisible {\n        // Add banner to scroll view based on type\n        switch bannerData.type {\n        case \"welcome_banner\":\n            // Handle welcome banner\n        case \"promo_banner\":\n            // Handle promotional banner\n        default:\n            break\n        }\n    }\n}\n```\n\n## Accessibility\n\nThe component includes built-in accessibility support:\n\n- Message label is automatically accessible\n- Button includes proper accessibility labels and hints\n- VoiceOver navigation works seamlessly\n\n## Requirements\n\n- iOS 15.0+\n- Swift 5.7+\n- UIKit framework \n",
      "snapshots": [
        {
          "category": "BannerVariants",
          "light": "SingleButtonBannerView/__Snapshots__/SingleButtonBannerViewSnapshotTests/testSingleButtonBannerView_BannerVariants_Light.1.png",
          "dark": "SingleButtonBannerView/__Snapshots__/SingleButtonBannerViewSnapshotTests/testSingleButtonBannerView_BannerVariants_Dark.1.png"
        }
      ]
    },
    "SortFilterView": {
      "displayName": "SortFilterView",
      "category": "Filters",
      "subcategory": "Panels",
      "summary": "Collapsible sort/filter panel with header and vertical option list",
      "description": "Expandable/collapsible panel displaying 'Sort By' header with animated chevron and vertical list of sort options. Each option row (56pt height) shows icon, title, and optional count via SortOptionRowView children. Chevron rotates 180 with 0.3s animation, content fades in/out. Single-selection with LeagueFilterIdentifier. Supports dynamic option updates via updateSortOptions() method. Two filter types: regular and league.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "sort",
        "filter",
        "collapsible",
        "panel",
        "options",
        "single-select",
        "animated",
        "chevron"
      ],
      "states": [
        "expanded",
        "collapsed",
        "option-selected"
      ],
      "similarTo": [
        "SelectOptionsView",
        "ExpandableHeaderView"
      ],
      "oftenUsedWith": [
        "ListingScreens",
        "SearchResultsView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# SortFilterView\n\nA collapsible sort filter component built with UIKit and Combine that provides users with sortable options in a clean, interactive interface. The component features an expandable/collapsible list of sort options with visual indicators and customizable styling.\n\n## Overview\n\nThe `SortFilterView` is designed to display sorting options in a vertical list format with a collapsible header. Each option includes an icon, title, count indicator, and selection state. The component follows MVVM architecture and uses reactive programming with Combine for state management.\n\n## Architecture\n\n### Component Structure\n```\nSortFilterView/\n SortFilterView.swift                    # Main component view\n SortFilterViewModelProtocol.swift       # View model protocol\n MockSortFilterViewModel.swift          # Mock implementation\n SortOptionRowView/\n    SortOptionRowView.swift            # Individual row component\n    SortOptionRowViewModelProtocol.swift # Row view model protocol\n    MockSortOptionRowViewModel.swift   # Row mock implementation\n Models/\n     SortFilterModels.swift             # Data models\n```\n\n### MVVM Pattern\n- **View**: `SortFilterView` - Main UI component\n- **ViewModel**: `SortFilterViewModelProtocol` - Business logic and state management\n- **Model**: `SortOption` - Data structure for sort options\n\n## Key Features\n\n### Interactive Elements\n- **Collapsible Header**: Tap to expand/collapse the options list\n- **Option Selection**: Single selection with visual feedback\n- **Visual States**: Selected state with color changes and indicators\n- **Count Display**: Shows number of items for each option\n\n### Visual Design\n- **Left Indicator**: Orange accent line for selected options\n- **Radio Button**: Traditional radio button selection interface\n- **Icon Support**: Optional icons with tint color changes\n- **Typography**: Bold styling for selected items\n- **Smooth Animations**: Collapse/expand transitions with rotation effects\n\n### State Management\n- **Reactive Updates**: Combine-based state synchronization\n- **Selection Tracking**: Currently selected option management\n- **Collapse State**: Expandable/collapsible interface\n- **Dynamic Updates**: Support for refreshing sort options\n\n## Models\n\n### SortOption\n```swift\npublic struct SortOption: Equatable {\n    public var id: Int\n    public var icon: String?\n    public var title: String\n    public var count: Int\n    public var iconTintChange: Bool\n}\n```\n\n**Properties:**\n- `id`: Unique identifier for the sort option\n- `icon`: Optional system or custom icon name\n- `title`: Display text for the option\n- `count`: Number of items associated with this option\n- `iconTintChange`: Whether icon should change color when selected\n\n## Protocols\n\n### SortFilterViewModelProtocol\n```swift\npublic protocol SortFilterViewModelProtocol {\n    var title: String { get }\n    var sortOptions: [SortOption] { get }\n    var selectedOptionId: CurrentValueSubject<Int, Never> { get }\n    var isCollapsed: CurrentValueSubject<Bool, Never> { get }\n    var shouldRefreshData: PassthroughSubject<Void, Never> { get }\n\n    func selectOption(withId id: Int)\n    func toggleCollapse()\n    func updateSortOptions(_ newSortOptions: [SortOption])\n}\n```\n\n### SortOptionRowViewModelProtocol\n```swift\npublic protocol SortOptionRowViewModelProtocol {\n    var sortOption: SortOption { get }\n}\n```\n\n## Usage Examples\n\n### Basic Implementation\n```swift\nlet sortOptions: [SortOption] = [\n    SortOption(id: 1, icon: \"flame.fill\", title: \"Popular\", count: 25),\n    SortOption(id: 2, icon: \"clock.fill\", title: \"Upcoming\", count: 15),\n    SortOption(id: 3, icon: \"heart.fill\", title: \"Favourites\", count: 0)\n]\n\nlet viewModel = MockSortFilterViewModel(\n    title: \"Sort By\", \n    sortOptions: sortOptions,\n    selectedId: 1\n)\n\nlet sortFilterView = SortFilterView(viewModel: viewModel)\n\n// Handle selection changes\nsortFilterView.onSortFilterSelected = { selectedId in\n    print(\"Selected option: \\(selectedId)\")\n}\n```\n\n### Custom ViewModel Implementation\n```swift\nclass CustomSortFilterViewModel: SortFilterViewModelProtocol {\n    let title: String = \"Custom Sort\"\n    var sortOptions: [SortOption] = []\n    var selectedOptionId = CurrentValueSubject<Int, Never>(1)\n    var isCollapsed = CurrentValueSubject<Bool, Never>(false)\n    var shouldRefreshData = PassthroughSubject<Void, Never>()\n    \n    func selectOption(withId id: Int) {\n        selectedOptionId.send(id)\n        // Custom selection logic\n    }\n    \n    func toggleCollapse() {\n        isCollapsed.send(!isCollapsed.value)\n    }\n    \n    func updateSortOptions(_ newSortOptions: [SortOption]) {\n        self.sortOptions = newSortOptions\n        shouldRefreshData.send()\n    }\n}\n```\n\n### Integration in Container View\n```swift\nclass FilterViewController: UIViewController {\n    private var sortFilterView: SortFilterView!\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupSortFilter()\n    }\n    \n    private func setupSortFilter() {\n        let viewModel = MockSortFilterViewModel(\n            title: \"Sort By\",\n            sortOptions: getSortOptions()\n        )\n        \n        sortFilterView = SortFilterView(viewModel: viewModel)\n        sortFilterView.translatesAutoresizingMaskIntoConstraints = false\n        \n        view.addSubview(sortFilterView)\n        \n        NSLayoutConstraint.activate([\n            sortFilterView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),\n            sortFilterView.leadingAnchor.constraint(equalTo: view.leadingAnchor),\n            sortFilterView.trailingAnchor.constraint(equalTo: view.trailingAnchor)\n        ])\n        \n        sortFilterView.onSortFilterSelected = { [weak self] selectedId in\n            self?.handleSortSelection(selectedId)\n        }\n    }\n}\n```\n\n## Component Behavior\n\n### Selection Logic\n- Single selection mode (radio button behavior)\n- Visual feedback with color changes and typography\n- Left indicator appears for selected items\n- Radio button fills with accent color when selected\n\n### Collapse/Expand Animation\n- Smooth 0.3 second animation duration\n- Chevron icon rotation (180 when collapsed)\n- Height constraint management for smooth transitions\n- Alpha and visibility changes for content\n\n### Data Updates\n- Reactive updates through `shouldRefreshData` publisher\n- Automatic UI refresh when sort options change\n- Preserves selection state during updates\n- Maintains collapse state across data refreshes\n\n## Styling Integration\n\nThe component integrates with `StyleProvider` for consistent theming:\n\n- **Colors**: Primary text, highlight colors, separator lines\n- **Typography**: Regular and bold font variants\n- **Spacing**: Consistent padding and margins\n- **Corner Radius**: Rounded elements following design system\n\n## Accessibility Features\n\n- **Tap Targets**: Appropriately sized interactive elements\n- **Visual Hierarchy**: Clear typography and color distinctions\n- **State Communication**: Visual indicators for selection states\n- **Touch Accessibility**: Full row tap handling for better UX\n\n## SwiftUI Preview Support\n\nThe component includes SwiftUI preview support for design-time visualization:\n\n```swift\n@available(iOS 17.0, *)\nstruct SortByView_Preview: PreviewProvider {\n    static var previews: some View {\n        PreviewUIView {\n            // Preview implementation\n        }\n    }\n}\n```\n\n## Technical Implementation\n\n### Memory Management\n- Weak references to prevent retain cycles\n- Proper Combine cancellable storage\n- Automatic cleanup of observers and subscriptions\n\n### Performance Considerations\n- Efficient constraint management during animations\n- Minimal layout passes during state changes\n- Optimized for frequent selection updates\n\n### Error Handling\n- Graceful fallbacks for missing icons\n- Safe array access patterns\n- Defensive programming for state transitions\n\n## Dependencies\n\n- **UIKit**: Core UI framework\n- **Combine**: Reactive programming and state management\n- **StyleProvider**: Internal styling system\n- **Foundation**: Basic data structures and utilities\n\n## Best Practices\n\n1. **View Model Lifecycle**: Always properly store view model references\n2. **Combine Subscriptions**: Use `store(in: &cancellables)` for memory management\n3. **Animation States**: Avoid interrupting ongoing animations\n4. **Data Consistency**: Ensure sort options have unique IDs\n5. **Accessibility**: Test with VoiceOver and Dynamic Type\n6. **Performance**: Minimize frequent data updates during animations\n\n## Future Enhancements\n\n- Multi-selection support\n- Custom animation durations\n- Drag-to-reorder functionality\n- Search/filter within options\n- Custom row layouts and styling\n- Keyboard navigation support ",
      "snapshots": []
    },
    "SportGamesFilterView": {
      "displayName": "SportGamesFilterView",
      "category": "Filters",
      "subcategory": "Panels",
      "summary": "Collapsible 2-column grid of sport filter cards for game filtering",
      "description": "Collapsible section displaying title header and 2-column grid of sport cards (8pt spacing). Each SportCardView shows sport icon and name with single-selection. Panel has 8pt corner radius and 16pt padding. Chevron rotates 180 with 0.3s animation on collapse/expand. Grid fades and bottom padding adjusts (16pt to 0pt). Handles odd number of sports via empty spacer view. Uses FilterIdentifier for selection tracking.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "sports",
        "filter",
        "grid",
        "cards",
        "collapsible",
        "2-column",
        "games",
        "single-select"
      ],
      "states": [
        "expanded",
        "collapsed",
        "sport-selected"
      ],
      "similarTo": [
        "SortFilterView",
        "CasinoCategoryBarView"
      ],
      "oftenUsedWith": [
        "GameListingView",
        "SportsNavigationView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# SportGamesFilterView\n\nA customizable sports filter component for iOS that allows users to select from different sports using an interactive grid layout with collapsible functionality.\n\n![SportGamesFilterView Preview](./preview.png)\n\n## Overview\n\nSportGamesFilterView is a UIKit-based component that provides an intuitive grid interface for sports selection. It displays sport options as interactive cards in a 2-column grid layout, supports expand/collapse functionality, and provides visual feedback for the currently selected sport.\n\n## Features\n\n-  **Grid Layout**: 2-column responsive grid for sport cards\n-  **Interactive Cards**: Tap-to-select sport cards with visual feedback\n-  **Collapsible Interface**: Expand/collapse functionality with smooth animations\n-  **Visual Selection**: Selected sport highlighted with accent color\n-  **Reactive Design**: Uses Combine framework for reactive state management\n-  **Custom Styling**: Integrates with StyleProvider for consistent theming\n-  **Icon Support**: System icons for each sport type\n-  **Preview Support**: Includes SwiftUI preview for development\n\n## Architecture\n\nThe component follows MVVM architecture pattern with a nested card component:\n\n```\nSportGamesFilterView (UIView)\n    \nSportGamesFilterViewModelProtocol\n    \nMockSportGamesFilterViewModel (Concrete Implementation)\n    \nSportFilter (Data Model)\n    \nSportCardView (Sub-component)\n    \nSportCardViewModelProtocol\n    \nMockSportCardViewModel\n```\n\n## Files Structure\n\n```\nSportGamesFilterView/\n SportGamesFilterView.swift                    # Main UI component\n SportGamesFilterViewModelProtocol.swift       # View model protocol\n MockSportGamesFilterViewModel.swift           # Mock implementation\n Models/\n    SportGamesFilterModels.swift             # Data models\n SportCard/\n    SportCardView.swift                      # Individual sport card UI\n    SportCardViewModelProtocol.swift         # Sport card view model protocol\n    MockSportCardViewModel.swift             # Sport card mock implementation\n README.md                                    # This file\n```\n\n## Usage\n\n### Basic Implementation\n\n```swift\n\n\n// 1. Create sport filter options\nlet sportFilters = [\n    SportFilter(id: 1, title: \"Football\", icon: \"sportscourt.fill\"),\n    SportFilter(id: 2, title: \"Basketball\", icon: \"basketball.fill\"),\n    SportFilter(id: 3, title: \"Tennis\", icon: \"tennis.racket\"),\n    SportFilter(id: 4, title: \"Cricket\", icon: \"figure.cricket\")\n]\n\n// 2. Create view model\nlet viewModel = MockSportGamesFilterViewModel(\n    title: \"Sports\",\n    sportFilters: sportFilters,\n    selectedId: 1\n)\n\n// 3. Create and configure the view\nlet sportGamesFilterView = SportGamesFilterView(viewModel: viewModel)\nsportGamesFilterView.translatesAutoresizingMaskIntoConstraints = false\n\n// 4. Handle sport selection\nsportGamesFilterView.onSportSelected = { selectedSportId in\n    print(\"Selected sport ID: \\(selectedSportId)\")\n    // Handle sport selection logic\n}\n\n// 5. Add to your view hierarchy\nview.addSubview(sportGamesFilterView)\nNSLayoutConstraint.activate([\n    sportGamesFilterView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 20),\n    sportGamesFilterView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 16),\n    sportGamesFilterView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -16)\n])\n```\n\n### Reactive Implementation with Combine\n\n```swift\nimport Combine\n\nclass FilterViewController: UIViewController {\n    private var cancellables = Set<AnyCancellable>()\n    private let sportGamesFilterView: SportGamesFilterView\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // Subscribe to selection changes\n        sportGamesFilterView.viewModel.selectedId\n            .sink { [weak self] selectedId in\n                self?.handleSportSelection(selectedId)\n            }\n            .store(in: &cancellables)\n        \n        // Subscribe to collapse/expand state\n        sportGamesFilterView.viewModel.sportFilterState\n            .sink { [weak self] state in\n                self?.handleStateChange(state)\n            }\n            .store(in: &cancellables)\n    }\n    \n    private func handleSportSelection(_ sportId: Int) {\n        // Handle sport selection\n    }\n    \n    private func handleStateChange(_ state: SportGamesFilterStateType) {\n        switch state {\n        case .expanded:\n            print(\"Filter expanded\")\n        case .collapsed:\n            print(\"Filter collapsed\")\n        }\n    }\n}\n```\n\n### Programmatic State Control\n\n```swift\n// Programmatically select a sport\nviewModel.selectOption(withId: 2)\n\n// Programmatically toggle collapse state\nviewModel.didTapCollapseButton()\n\n// Check current state\nlet isExpanded = viewModel.sportFilterState.value == .expanded\n```\n\n## API Reference\n\n### SportGamesFilterView\n\nThe main UI component that displays the sports filter interface.\n\n#### Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `onSportSelected` | `((Int) -> Void)?` | Callback triggered when a sport is selected |\n\n#### Methods\n\n| Method | Description |\n|--------|-------------|\n| `init(viewModel: SportGamesFilterViewModelProtocol)` | Initializes the view with a view model |\n\n### SportGamesFilterViewModelProtocol\n\nProtocol defining the interface for sport games filter view models.\n\n#### Required Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `title` | `String` | The title displayed at the top of the component |\n| `sportFilters` | `[SportFilter]` | Array of available sport options |\n| `selectedId` | `CurrentValueSubject<Int, Never>` | Reactive property for selected sport ID |\n| `sportFilterState` | `CurrentValueSubject<SportGamesFilterStateType, Never>` | Reactive property for collapse/expand state |\n\n#### Required Methods\n\n| Method | Description |\n|--------|-------------|\n| `selectOption(withId id: Int)` | Selects a sport by ID |\n| `didTapCollapseButton()` | Toggles the collapse/expand state |\n\n### MockSportGamesFilterViewModel\n\nConcrete implementation of `SportGamesFilterViewModelProtocol` for testing and development.\n\n#### Initializer\n\n```swift\npublic init(\n    title: String, \n    sportFilters: [SportFilter], \n    selectedId: Int = 1\n)\n```\n\n### SportFilter\n\nData model representing a sport option in the filter.\n\n#### Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `id` | `Int` | Unique identifier for the sport |\n| `title` | `String` | Display name for the sport |\n| `icon` | `String?` | System icon name for the sport |\n\n#### Initializer\n\n```swift\npublic init(id: Int, title: String, icon: String?)\n```\n\n### SportGamesFilterStateType\n\nEnum representing the expand/collapse state of the filter.\n\n#### Cases\n\n| Case | Description |\n|------|-------------|\n| `.expanded` | Filter is expanded showing all sport cards |\n| `.collapsed` | Filter is collapsed hiding sport cards |\n\n### SportCardView\n\nIndividual sport card component used within the grid.\n\n#### Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `isSelected` | `Bool` | Whether the card is currently selected |\n| `onTap` | `((Int) -> Void)?` | Callback triggered when card is tapped |\n\n#### Methods\n\n| Method | Description |\n|--------|-------------|\n| `configure()` | Configures the card with view model data |\n\n## Customization\n\n### Styling\n\nThe component uses `StyleProvider` for consistent theming. You can customize:\n\n- **Colors**: Background, accent, text colors\n- **Fonts**: Title and label fonts\n- **Spacing**: Margins, padding, and grid spacing\n- **Corner Radius**: Card and container corner radius\n\n### Custom Sport Options\n\nCreate custom sport configurations based on your needs:\n\n```swift\n// Traditional sports\nlet traditionalSports = [\n    SportFilter(id: 1, title: \"Football\", icon: \"sportscourt.fill\"),\n    SportFilter(id: 2, title: \"Basketball\", icon: \"basketball.fill\"),\n    SportFilter(id: 3, title: \"Baseball\", icon: \"baseball.fill\"),\n    SportFilter(id: 4, title: \"Hockey\", icon: \"hockey.puck.fill\")\n]\n\n// eSports\nlet eSports = [\n    SportFilter(id: 1, title: \"League of Legends\", icon: \"gamecontroller.fill\"),\n    SportFilter(id: 2, title: \"CS:GO\", icon: \"target\"),\n    SportFilter(id: 3, title: \"Dota 2\", icon: \"shield.fill\"),\n    SportFilter(id: 4, title: \"Valorant\", icon: \"scope\")\n]\n\n// Olympics\nlet olympicSports = [\n    SportFilter(id: 1, title: \"Swimming\", icon: \"figure.pool.swim\"),\n    SportFilter(id: 2, title: \"Athletics\", icon: \"figure.run\"),\n    SportFilter(id: 3, title: \"Gymnastics\", icon: \"figure.gymnastics\"),\n    SportFilter(id: 4, title: \"Cycling\", icon: \"bicycle\")\n]\n```\n\n### Custom View Model\n\nImplement your own view model for advanced functionality:\n\n```swift\nclass NetworkSportGamesFilterViewModel: SportGamesFilterViewModelProtocol {\n    let title: String = \"Available Sports\"\n    let sportFilters: [SportFilter]\n    let selectedId: CurrentValueSubject<Int, Never>\n    let sportFilterState: CurrentValueSubject<SportGamesFilterStateType, Never>\n    \n    init(sports: [SportFilter]) {\n        self.sportFilters = sports\n        self.selectedId = .init(sports.first?.id ?? 1)\n        self.sportFilterState = .init(.expanded)\n    }\n    \n    func selectOption(withId id: Int) {\n        selectedId.send(id)\n        \n        // Trigger network request or analytics\n        trackSportSelection(id)\n        fetchDataForSport(id)\n    }\n    \n    func didTapCollapseButton() {\n        let newState: SportGamesFilterStateType = sportFilterState.value == .expanded ? .collapsed : .expanded\n        sportFilterState.send(newState)\n        \n        // Track collapse/expand analytics\n        trackFilterStateChange(newState)\n    }\n    \n    private func trackSportSelection(_ sportId: Int) {\n        // Analytics implementation\n    }\n    \n    private func trackFilterStateChange(_ state: SportGamesFilterStateType) {\n        // Analytics implementation\n    }\n    \n    private func fetchDataForSport(_ sportId: Int) {\n        // Network request implementation\n    }\n}\n```\n\n### Custom Card Appearance\n\nCustomize individual sport cards:\n\n```swift\nclass CustomSportCardViewModel: SportCardViewModelProtocol {\n    let sportFilter: SportFilter\n    let customBackgroundColor: UIColor\n    let customTextColor: UIColor\n    \n    init(sportFilter: SportFilter, backgroundColor: UIColor = .systemBlue, textColor: UIColor = .white) {\n        self.sportFilter = sportFilter\n        self.customBackgroundColor = backgroundColor\n        self.customTextColor = textColor\n    }\n}\n```\n\n## Integration Examples\n\n### Filter Screen Integration\n\n```swift\nclass FiltersViewController: UIViewController {\n    private let sportGamesFilterView: SportGamesFilterView\n    private let stackView: UIStackView\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupSportFilter()\n    }\n    \n    private func setupSportFilter() {\n        // Add to stack view\n        stackView.addArrangedSubview(sportGamesFilterView)\n        \n        // Configure height constraint for collapsed state\n        let heightConstraint = sportGamesFilterView.heightAnchor.constraint(greaterThanOrEqualToConstant: 60)\n        heightConstraint.isActive = true\n    }\n}\n```\n\n### Tab-based Sports Navigation\n\n```swift\nclass SportsTabViewController: UIViewController {\n    private let sportGamesFilterView: SportGamesFilterView\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        sportGamesFilterView.onSportSelected = { [weak self] sportId in\n            self?.navigateToSport(sportId)\n        }\n    }\n    \n    private func navigateToSport(_ sportId: Int) {\n        let sportDetailVC = SportDetailViewController(sportId: sportId)\n        navigationController?.pushViewController(sportDetailVC, animated: true)\n    }\n}\n```\n\n### Dynamic Sports Loading\n\n```swift\nclass DynamicSportsViewController: UIViewController {\n    private var viewModel: MockSportGamesFilterViewModel\n    \n    func loadSportsFromAPI() {\n        APIManager.fetchAvailableSports { [weak self] sports in\n            DispatchQueue.main.async {\n                self?.updateSports(sports)\n            }\n        }\n    }\n    \n    private func updateSports(_ sports: [SportFilter]) {\n        // Update view model with new sports\n        viewModel.sportFilters = sports\n        \n        // Refresh the view\n        sportGamesFilterView.configureData()\n    }\n}\n```\n\n## Animation and Interaction\n\n### Collapse/Expand Animation\n\nThe component includes smooth animations for state transitions:\n\n- **Duration**: 0.3 seconds\n- **Curve**: UIView default animation curve\n- **Elements**: Grid opacity, height constraints, chevron rotation\n\n### Selection Feedback\n\nVisual feedback for sport selection:\n\n- **Background Color**: Changes to accent color when selected\n- **Icon Tint**: White when selected, black when unselected\n- **Text Color**: White when selected, black when unselected\n\n## Best Practices\n\n1. **Limit Sports**: Keep sport options to 6-8 items for optimal UX\n2. **Clear Icons**: Use recognizable system icons for each sport\n3. **Logical Grouping**: Group related sports together\n4. **Default Selection**: Set a sensible default sport selection\n5. **State Persistence**: Remember user's collapse/expand preference\n6. **Loading States**: Show loading indicators during data fetching\n\n## Accessibility\n\nThe component includes accessibility features:\n\n- **VoiceOver Support**: Proper accessibility labels and hints\n- **Touch Targets**: Minimum 44pt touch targets for cards\n- **Color Contrast**: High contrast colors through StyleProvider\n- **Semantic Content**: Proper content hierarchy and navigation\n\n## Performance Considerations\n\n- **Grid Layout**: Efficient UIStackView-based grid implementation\n- **Memory Management**: Weak references to prevent retain cycles\n- **View Reuse**: Minimal view allocation and efficient updates\n- **Animation Performance**: Hardware-accelerated animations\n\n## Requirements\n\n- iOS 13.0+\n- Swift 5.0+\n- UIKit\n- Combine framework\n\n## Dependencies\n\n- `StyleProvider`: For consistent theming and colors\n- `Combine`: For reactive programming\n\n## Notes\n\n- The grid automatically handles odd numbers of sports with empty spacer views\n- Sport cards maintain 1:1 aspect ratio for consistent appearance\n- Component automatically adapts to different screen sizes\n- Collapse state affects only the grid visibility, not the header\n\n## Troubleshooting\n\n### Common Issues\n\n1. **Cards not displaying**: Ensure `SportFilter` objects have valid `icon` values\n2. **Selection not working**: Verify `onSportSelected` callback is set\n3. **Layout issues**: Check Auto Layout constraints in parent view\n4. **Animation glitches**: Ensure view is added to hierarchy before configuring\n\n### Debug Tips\n\n```swift\n// Debug sport filter data\nprint(\"Available sports: \\(viewModel.sportFilters)\")\nprint(\"Selected sport: \\(viewModel.selectedId.value)\")\nprint(\"Current state: \\(viewModel.sportFilterState.value)\")\n\n// Monitor state changes\nviewModel.selectedId\n    .sink { id in print(\"Sport selected: \\(id)\") }\n    .store(in: &cancellables)\n```\n\n## Contributing\n\nWhen contributing to this component:\n\n1. Maintain the existing MVVM architecture\n2. Add unit tests for new functionality\n3. Update this README with any API changes\n4. Follow the established naming conventions\n5. Ensure backward compatibility\n6. Test on different device sizes\n\n## License\n\nThis component is part of the GomaUI library. See the main library license for details. \n",
      "snapshots": []
    },
    "SportSelectorCell": {
      "displayName": "SportSelectorCell",
      "category": "Filters",
      "subcategory": "Cells",
      "summary": "Pill-shaped collection cell with sport icon, title, and dropdown indicator",
      "description": "UICollectionViewCell displaying sport filter option with icon (22x22pt), title (bold 12pt), and dropdown arrows (12x16pt) in horizontal stack. Pill-shaped container with 21pt corner radius, 2pt highlight border, and white background. Uses FilterOptionItem model for configuration. Icon rendered as template with highlight tint. Used as child cell within GeneralFilterBarView for sport category selection.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "cell",
        "sport",
        "selector",
        "dropdown",
        "pill",
        "icon",
        "filter-bar",
        "collection-cell"
      ],
      "states": [
        "default"
      ],
      "similarTo": [
        "FilterBarItemView",
        "PillItemView"
      ],
      "oftenUsedWith": [
        "GeneralFilterBarView"
      ],
      "parents": [
        "GeneralFilterBarView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# SportSelectorCell\n\nA specialized collection view cell built with UIKit that displays a sport selection option with an orange-bordered, pill-shaped design. The component is specifically designed for sport filtering interfaces and features an icon, title, and selector arrows to indicate its interactive nature.\n\n## Overview\n\nThe `SportSelectorCell` is a custom `UICollectionViewCell` designed to be the first item in filter selection interfaces, specifically for sport filtering. It provides a distinctive orange-bordered appearance that stands out from other filter options and clearly indicates its role as a primary selector. The component follows a simple view-model pattern for data binding.\n\n## Architecture\n\n### Component Structure\n```\nSportSelectorCell/\n SportSelectorCell.swift           # Main collection view cell\n SportSelectorCellViewModel.swift  # View model for data binding\n```\n\n### Design Pattern\n- **View**: `SportSelectorCell` - Custom collection view cell with distinctive styling\n- **ViewModel**: `SportSelectorCellViewModel` - Simple data container for filter option\n- **Model**: `FilterOptionItem` - Shared data structure for filter options\n\n## Key Features\n\n### Visual Design\n- **Orange Border**: Distinctive 2pt orange border using `StyleProvider.Color.highlightPrimary`\n- **Pill Shape**: Rounded corners (21pt radius) for modern appearance\n- **White Background**: Clean white background for contrast\n- **Compact Layout**: Optimized for horizontal collection view usage\n- **Icon Support**: System icon display with tint color matching theme\n\n### Interactive Elements\n- **Sport Icon**: Displays sport-specific system icon\n- **Title Label**: Bold sport name display\n- **Selector Arrows**: Visual indicator showing interactive/expandable nature\n- **Touch Feedback**: Standard collection view cell selection behavior\n\n### Layout Structure\n- **Horizontal Stack**: Icon, title, and arrows arranged horizontally\n- **Center Alignment**: All elements vertically centered\n- **Consistent Spacing**: 8pt spacing between stack elements\n- **Flexible Width**: Adapts to content with proper padding\n\n## Models\n\n### FilterOptionItem Integration\nThe component uses the shared `FilterOptionItem` model:\n```swift\npublic struct FilterOptionItem {\n    public let type: FilterOptionType\n    public let title: String\n    public let icon: String\n}\n```\n\n**Properties:**\n- `type`: Filter type (`.sport` for SportSelectorCell)\n- `title`: Sport name (e.g., \"Football\", \"Basketball\")\n- `icon`: System icon name for the sport\n\n### FilterOptionType\n```swift\npublic enum FilterOptionType {\n    case sport\n    case sortBy\n    case league\n}\n```\n\nThe `SportSelectorCell` specifically handles `.sport` type options.\n\n## View Model\n\n### SportSelectorCellViewModel\n```swift\npublic class SportSelectorCellViewModel {\n    let filterOptionItem: FilterOptionItem\n    \n    public init(filterOptionItem: FilterOptionItem) {\n        self.filterOptionItem = filterOptionItem\n    }\n}\n```\n\n**Purpose:**\n- Simple data container for filter option information\n- Provides clean separation between data and view\n- Enables easy testing and mocking\n\n## Usage Examples\n\n### Basic Collection View Implementation\n```swift\nclass FilterCollectionViewController: UIViewController {\n    @IBOutlet weak var collectionView: UICollectionView!\n    \n    private var filterOptions: [FilterOptionItem] = []\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupCollectionView()\n        setupFilterData()\n    }\n    \n    private func setupCollectionView() {\n        collectionView.register(\n            SportSelectorCell.self,\n            forCellWithReuseIdentifier: \"SportSelectorCell\"\n        )\n        \n        // Setup layout for horizontal scrolling\n        if let layout = collectionView.collectionViewLayout as? UICollectionViewFlowLayout {\n            layout.scrollDirection = .horizontal\n            layout.minimumInteritemSpacing = 8\n        }\n    }\n    \n    private func setupFilterData() {\n        filterOptions = [\n            FilterOptionItem(type: .sport, title: \"Football\", icon: \"soccerball\"),\n            FilterOptionItem(type: .sport, title: \"Basketball\", icon: \"basketball\"),\n            FilterOptionItem(type: .sport, title: \"Tennis\", icon: \"tennis.racket\")\n        ]\n    }\n}\n\nextension FilterCollectionViewController: UICollectionViewDataSource {\n    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {\n        return filterOptions.count\n    }\n    \n    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n        let cell = collectionView.dequeueReusableCell(\n            withReuseIdentifier: \"SportSelectorCell\",\n            for: indexPath\n        ) as! SportSelectorCell\n        \n        let filterOption = filterOptions[indexPath.item]\n        let viewModel = SportSelectorCellViewModel(filterOptionItem: filterOption)\n        cell.configure(with: viewModel)\n        \n        return cell\n    }\n}\n```\n\n### Integration with GeneralFilterViewController\n```swift\nclass GeneralFilterViewController: UIViewController {\n    private var sportSelectorCell: SportSelectorCell!\n    \n    func setupSportSelector() {\n        let sportOption = FilterOptionItem(\n            type: .sport,\n            title: \"All Sports\",\n            icon: \"sportscourt\"\n        )\n        \n        let viewModel = SportSelectorCellViewModel(filterOptionItem: sportOption)\n        \n        // Configure as first item in collection view\n        sportSelectorCell.configure(with: viewModel)\n    }\n    \n    func handleSportSelectorTap() {\n        // Present sport selection interface\n        presentSportSelectionModal()\n    }\n}\n```\n\n### Custom Sport Options\n```swift\nclass SportFilterManager {\n    static func createSportOptions() -> [FilterOptionItem] {\n        return [\n            FilterOptionItem(type: .sport, title: \"Football\", icon: \"soccerball\"),\n            FilterOptionItem(type: .sport, title: \"Basketball\", icon: \"basketball\"),\n            FilterOptionItem(type: .sport, title: \"Baseball\", icon: \"baseball\"),\n            FilterOptionItem(type: .sport, title: \"Tennis\", icon: \"tennis.racket\"),\n            FilterOptionItem(type: .sport, title: \"Hockey\", icon: \"hockey.puck\"),\n            FilterOptionItem(type: .sport, title: \"Golf\", icon: \"golf.fill\"),\n            FilterOptionItem(type: .sport, title: \"American Football\", icon: \"football\"),\n            FilterOptionItem(type: .sport, title: \"Swimming\", icon: \"figure.pool.swim\")\n        ]\n    }\n    \n    static func createDefaultSportSelector() -> FilterOptionItem {\n        return FilterOptionItem(\n            type: .sport,\n            title: \"Select Sport\",\n            icon: \"sportscourt.fill\"\n        )\n    }\n}\n```\n\n### Dynamic Content Updates\n```swift\nclass DynamicSportSelector {\n    private let cell: SportSelectorCell\n    private var currentSport: String = \"All Sports\"\n    \n    init(cell: SportSelectorCell) {\n        self.cell = cell\n    }\n    \n    func updateSelectedSport(_ sportName: String, icon: String) {\n        currentSport = sportName\n        \n        let updatedOption = FilterOptionItem(\n            type: .sport,\n            title: sportName,\n            icon: icon\n        )\n        \n        let viewModel = SportSelectorCellViewModel(filterOptionItem: updatedOption)\n        cell.configure(with: viewModel)\n    }\n    \n    func resetToDefault() {\n        updateSelectedSport(\"All Sports\", icon: \"sportscourt\")\n    }\n}\n```\n\n## Component Behavior\n\n### Visual Characteristics\n- **Border Styling**: 2pt orange border using `highlightPrimary` color\n- **Corner Radius**: 21pt rounded corners for pill shape\n- **Background**: Clean white background for contrast\n- **Tint Colors**: Orange tint for icons matching theme\n- **Typography**: Bold 12pt font for sport titles\n\n### Layout Behavior\n- **Fixed Heights**: Container with 10pt top/bottom padding\n- **Flexible Width**: Adapts to content with 8pt side padding\n- **Icon Sizing**: Fixed 22x22pt sport icons\n- **Arrow Sizing**: Fixed 12x16pt selector arrows\n- **Stack Spacing**: 8pt between elements\n\n### Content Configuration\n- **Icon Display**: System icons with template rendering mode\n- **Title Display**: Bold text with primary text color\n- **Selector Arrows**: Custom \"selector_icon\" image\n- **Dynamic Updates**: Support for runtime content changes\n\n## Styling Integration\n\nThe component integrates with `StyleProvider` for consistent theming:\n\n- **Colors**:\n  - `highlightPrimary`: Orange border and icon tint color\n  - `textPrimary`: Title text color\n  - White background (hardcoded for contrast)\n- **Typography**:\n  - Bold 12pt font for sport titles\n- **Border**:\n  - 2pt border width\n  - 21pt corner radius for pill shape\n\n## Collection View Integration\n\n### Cell Registration\n```swift\ncollectionView.register(\n    SportSelectorCell.self,\n    forCellWithReuseIdentifier: \"SportSelectorCell\"\n)\n```\n\n### Recommended Layout\n```swift\nfunc collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {\n    // Dynamic width based on content\n    let title = filterOptions[indexPath.item].title\n    let titleWidth = title.size(withAttributes: [\n        .font: StyleProvider.fontWith(type: .bold, size: 12)\n    ]).width\n    \n    // Icon (22) + spacing (8) + title + spacing (8) + arrow (12) + padding (16)\n    let cellWidth = 22 + 8 + titleWidth + 8 + 12 + 16\n    \n    return CGSize(width: cellWidth, height: 42)\n}\n```\n\n## Accessibility Features\n\n- **Content Labels**: Clear sport names for screen readers\n- **Icon Descriptions**: System icons provide semantic meaning\n- **Touch Targets**: Adequate cell size for easy interaction\n- **Visual Hierarchy**: Bold typography for clear text hierarchy\n- **Color Contrast**: Orange border on white background for visibility\n\n## Use Cases\n\n### Primary Sport Filter\n```swift\n// First item in filter collection showing currently selected sport\nlet primarySportFilter = FilterOptionItem(\n    type: .sport,\n    title: \"Football\",\n    icon: \"soccerball\"\n)\n```\n\n### Multi-Sport Interface\n```swift\n// Multiple sport options in horizontal collection\nlet sportOptions = [\n    FilterOptionItem(type: .sport, title: \"All Sports\", icon: \"sportscourt\"),\n    FilterOptionItem(type: .sport, title: \"Football\", icon: \"soccerball\"),\n    FilterOptionItem(type: .sport, title: \"Basketball\", icon: \"basketball\")\n]\n```\n\n### Sport Category Selector\n```swift\n// General sport category selection\nlet categorySelector = FilterOptionItem(\n    type: .sport,\n    title: \"Team Sports\",\n    icon: \"person.3\"\n)\n```\n\n## Technical Implementation\n\n### Memory Management\n- Lightweight cell design with minimal retain cycles\n- Efficient view model pattern with simple data container\n- Proper cleanup in cell reuse scenarios\n\n### Performance Considerations\n- Minimal constraint setup for fast scrolling\n- Efficient image loading with system icons\n- Optimized for horizontal collection view usage\n- Small memory footprint per cell\n\n### Layout Optimization\n- Stack view for efficient element arrangement\n- Fixed icon sizes to prevent layout shifts\n- Flexible title width with compression resistance\n- Consistent padding across different content lengths\n\n## Error Handling\n\n### Defensive Programming\n- Safe unwrapping of optional view model data\n- Graceful fallbacks for missing icons\n- Proper handling of empty or nil titles\n- Safe system icon loading with fallbacks\n\n### Data Validation\n- FilterOptionItem type checking for `.sport` type\n- Non-empty title validation\n- Valid system icon name verification\n- Proper view model initialization\n\n## Dependencies\n\n- **UIKit**: Core UI framework for collection view cell\n- **StyleProvider**: Internal styling and theming system\n- **Foundation**: Basic data structures and utilities\n\n## Best Practices\n\n1. **Content Consistency**: Use appropriate system icons for each sport\n2. **Title Length**: Keep sport names concise for better layout\n3. **Icon Selection**: Choose recognizable sport-specific icons\n4. **Collection Layout**: Position as first item in filter collections\n5. **State Management**: Update content when sport selection changes\n6. **Accessibility**: Provide clear labels for screen reader support\n7. **Performance**: Use efficient cell reuse patterns in collections\n\n## Integration Patterns\n\n### With Sport Filter Interface\n```swift\nclass SportFilterCoordinator {\n    private let sportSelectorCell: SportSelectorCell\n    private var availableSports: [FilterOptionItem]\n    \n    func presentSportSelection() {\n        // Show sport selection modal/popover\n        let sportSelectionVC = SportSelectionViewController(sports: availableSports)\n        sportSelectionVC.onSportSelected = { [weak self] selectedSport in\n            self?.updateSportSelector(with: selectedSport)\n        }\n        \n        present(sportSelectionVC, animated: true)\n    }\n    \n    private func updateSportSelector(with sport: FilterOptionItem) {\n        let viewModel = SportSelectorCellViewModel(filterOptionItem: sport)\n        sportSelectorCell.configure(with: viewModel)\n    }\n}\n```\n\n### With Filter State Management\n```swift\nclass FilterStateManager {\n    private var selectedSport: FilterOptionItem?\n    private let sportSelectorCell: SportSelectorCell\n    \n    func updateSportFilter(_ sport: FilterOptionItem) {\n        selectedSport = sport\n        \n        let viewModel = SportSelectorCellViewModel(filterOptionItem: sport)\n        sportSelectorCell.configure(with: viewModel)\n        \n        // Notify other components of sport change\n        NotificationCenter.default.post(\n            name: .sportFilterChanged,\n            object: sport\n        )\n    }\n}\n\nextension Notification.Name {\n    static let sportFilterChanged = Notification.Name(\"sportFilterChanged\")\n}\n```\n\n## Future Enhancements\n\n- Support for custom sport icons beyond system images\n- Badge overlay for indicating active sport filters\n- Animation effects for sport selection changes\n- Custom color themes for different sports\n- Multi-sport selection support\n- Integration with haptic feedback\n- Support for sport category grouping\n- Dynamic sizing based on content\n- Custom selector arrow designs\n- Accessibility improvements for VoiceOver ",
      "snapshots": []
    },
    "SportTypeSelectorItemView": {
      "displayName": "SportTypeSelectorItemView",
      "category": "Filters",
      "subcategory": "Items",
      "summary": "Compact sport type selector card with centered icon and title",
      "description": "Card-style sport selector item with fixed 58pt height and 8pt corner radius. Displays centered sport icon (23x23pt) above sport name label (medium 12pt, centered). Supports custom named images and SF Symbols with template rendering. Tap gesture triggers callback with SportTypeData. Container padding: 8pt top, 6pt bottom, 12pt horizontal. Icon-to-title spacing: -2pt. Used as child in SportTypeSelectorView.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "sport",
        "selector",
        "card",
        "icon",
        "navigation",
        "type-selector",
        "compact",
        "leaf-component"
      ],
      "states": [
        "default"
      ],
      "similarTo": [
        "SportCardView",
        "QuickLinksItemView"
      ],
      "oftenUsedWith": [
        "SportTypeSelectorView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# SportTypeSelectorItemView\n\nA reusable UI component that displays a single sport type with an icon and label. Used as an individual item in sport selection interfaces.\n\n## Features\n\n- Clean icon + text layout with consistent styling\n- 24x24 icon display with system icon mapping\n- 12pt text label below icon\n- 56px fixed height with rounded corners\n- Tap gesture support with callback\n- Reactive state management via Combine\n- StyleProvider integration for theming\n\n## Usage Example\n\n```swift\n// Create a view model (or use a mock for testing)\nlet sportData = SportTypeData(id: \"football\", name: \"Football\", iconName: \"football\")\nlet viewModel = MockSportTypeSelectorItemViewModel(sportData: sportData)\n\n// Create the component\nlet sportItemView = SportTypeSelectorItemView(viewModel: viewModel)\n\n// Handle tap events\nsportItemView.onTap = { sportData in\n    print(\"Selected sport: \\(sportData.name)\")\n    // Perform navigation or other actions\n}\n\n// Add to your view hierarchy\nparentView.addSubview(sportItemView)\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    sportItemView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor),\n    sportItemView.trailingAnchor.constraint(equalTo: parentView.trailingAnchor),\n    sportItemView.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor),\n    sportItemView.heightAnchor.constraint(equalToConstant: 56)\n])\n```\n\n## Data Models\n\n### SportTypeData\n```swift\npublic struct SportTypeData: Equatable, Hashable {\n    public let id: String        // Unique identifier\n    public let name: String      // Display name (e.g., \"Football\")\n    public let iconName: String  // Icon identifier\n}\n```\n\n### SportTypeSelectorItemDisplayState\n```swift\npublic struct SportTypeSelectorItemDisplayState: Equatable {\n    public let sportData: SportTypeData\n}\n```\n\n## View Model Protocol\n\n```swift\npublic protocol SportTypeSelectorItemViewModelProtocol {\n    var displayStatePublisher: AnyPublisher<SportTypeSelectorItemDisplayState, Never> { get }\n}\n```\n\n## Mock Implementation\n\nThe `MockSportTypeSelectorItemViewModel` provides ready-to-use mock data for various sports:\n\n```swift\n// Pre-built sport mocks\nlet footballMock = MockSportTypeSelectorItemViewModel.footballMock\nlet basketballMock = MockSportTypeSelectorItemViewModel.basketballMock\nlet tennisMock = MockSportTypeSelectorItemViewModel.tennisMock\n// ... and more\n\n// Custom sport data\nlet customSport = SportTypeData(id: \"custom\", name: \"Custom Sport\", iconName: \"customIcon\")\nlet customMock = MockSportTypeSelectorItemViewModel(sportData: customSport)\n```\n\n## Icon Mapping\n\nThe component maps sport icon names to system icons:\n\n- \"football\"/\"soccer\"  `soccerball`\n- \"basketball\"  `basketball`\n- \"tennis\"  `tennisball`\n- \"baseball\"  `baseball`\n- \"hockey\"  `hockey.puck`\n- \"golf\"  `golf.stick.and.ball`\n- \"volleyball\"  `volleyball`\n- Default  `sportscourt`\n\n## Styling\n\nThe component uses StyleProvider for consistent theming:\n\n- **Background**: `StyleProvider.Color.backgroundSecondary` (#f6f6f8)\n- **Text Color**: `StyleProvider.Color.textPrimary` (#252634)\n- **Icon Tint**: `StyleProvider.Color.textPrimary` (#252634)\n- **Font**: `StyleProvider.fontWith(type: .regular, size: 12)`\n- **Corner Radius**: 8pt\n- **Padding**: 12pt horizontal, 2pt vertical\n\n## SwiftUI Previews\n\nThe component includes comprehensive SwiftUI previews:\n\n```swift\n#Preview(\"Default\") {\n    PreviewUIView {\n        SportTypeSelectorItemView(viewModel: MockSportTypeSelectorItemViewModel.footballMock)\n    }\n    .frame(width: 150, height: 56)\n}\n```\n\n## Integration Notes\n\n- This component is designed to be reusable across the app\n- Can be used standalone or within collection views\n- Integrates seamlessly with `SportTypeSelectorView` for full selection flows\n- Follows GomaUI architecture patterns with MVVM + Combine",
      "snapshots": []
    },
    "SportTypeSelectorView": {
      "displayName": "SportTypeSelectorView",
      "category": "Filters",
      "subcategory": "Grids",
      "summary": "2-column grid of sport type cards for category selection",
      "description": "Vertically scrolling 2-column grid using UICollectionViewFlowLayout displaying SportTypeSelectorItemView cells. 8pt spacing for items, lines, and section insets. Fixed 58pt cell height with dynamic width based on available space. Supports dynamic sport list updates via updateSports(), addSport(), removeSport() methods. Selection triggers onSportSelected callback with SportTypeData.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "sports",
        "grid",
        "selector",
        "2-column",
        "collection-view",
        "navigation",
        "category-selection"
      ],
      "states": [
        "default",
        "few-sports",
        "many-sports",
        "empty"
      ],
      "similarTo": [
        "SportGamesFilterView",
        "CasinoGameGridView"
      ],
      "oftenUsedWith": [
        "SportTypeSelectorItemView",
        "SportsNavigationView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# SportTypeSelectorView\n\nA full-screen sport selection component with a 2-column grid layout. Includes collection view implementation, wrapper cell, and presentation view controller for complete sport selection workflows.\n\n## Components Overview\n\nThis component consists of three main parts:\n\n1. **SportTypeSelectorView** - Main collection view component\n2. **SportTypeSelectorCollectionViewCell** - Wrapper cell for reuse\n3. **SportTypeSelectorViewController** - Full presentation controller\n\n## Features\n\n- 2-column UICollectionView with 8px spacing\n- Full-screen presentation with navigation\n- Sport selection callbacks and delegation\n- Reactive data updates via Combine\n- Modal presentation support\n- Proper cell reuse and memory management\n\n## Usage Example\n\n### Basic Integration\n\n```swift\n// Create view model with sports data\nlet sports = [\n    SportTypeData(id: \"football\", name: \"Football\", iconName: \"football\"),\n    SportTypeData(id: \"basketball\", name: \"Basketball\", iconName: \"basketball\"),\n    SportTypeData(id: \"tennis\", name: \"Tennis\", iconName: \"tennis\")\n]\nlet viewModel = MockSportTypeSelectorViewModel(sports: sports)\n\n// Create and present the view controller\nlet selectorVC = SportTypeSelectorViewController(viewModel: viewModel)\n\n// Handle sport selection\nselectorVC.onSportSelected = { selectedSport in\n    print(\"User selected: \\(selectedSport.name)\")\n    // Update your app state\n    selectorVC.dismiss()\n}\n\nselectorVC.onCancel = {\n    print(\"User cancelled selection\")\n    selectorVC.dismiss()\n}\n\n// Present modally\nselectorVC.presentModally(from: self)\n```\n\n### Delegate Pattern\n\n```swift\nclass MyViewController: UIViewController, SportTypeSelectorViewControllerDelegate {\n    \n    func presentSportSelector() {\n        let selectorVC = SportTypeSelectorViewController.createWithMockData()\n        selectorVC.delegate = self\n        selectorVC.presentModally(from: self)\n    }\n    \n    // MARK: - SportTypeSelectorViewControllerDelegate\n    \n    func sportTypeSelectorViewController(_ controller: SportTypeSelectorViewController, didSelectSport sport: SportTypeData) {\n        // Handle sport selection\n        print(\"Selected: \\(sport.name)\")\n        controller.dismiss()\n    }\n    \n    func sportTypeSelectorViewControllerDidCancel(_ controller: SportTypeSelectorViewController) {\n        // Handle cancellation\n        controller.dismiss()\n    }\n}\n```\n\n### Direct View Usage\n\n```swift\n// Use just the collection view component\nlet selectorView = SportTypeSelectorView(viewModel: viewModel)\nselectorView.onSportSelected = { sport in\n    // Handle selection\n}\n\nparentView.addSubview(selectorView)\n// Add constraints...\n```\n\n## Data Models\n\n### SportTypeSelectorDisplayState\n```swift\npublic struct SportTypeSelectorDisplayState: Equatable {\n    public let sports: [SportTypeData]  // Array of available sports\n}\n```\n\n## View Model Protocol\n\n```swift\npublic protocol SportTypeSelectorViewModelProtocol {\n    var displayStatePublisher: AnyPublisher<SportTypeSelectorDisplayState, Never> { get }\n}\n```\n\n## Component Architecture\n\n### SportTypeSelectorView\n- Main UICollectionView with flow layout\n- 2-column grid with dynamic sizing\n- Handles sport selection and callbacks\n- Uses `SportTypeSelectorCollectionViewCell` for items\n\n### SportTypeSelectorCollectionViewCell\n- Wrapper around `SportTypeSelectorItemView`\n- Proper cell reuse and cleanup\n- Forwards tap events to collection view\n\n### SportTypeSelectorViewController\n- Full presentation controller with navigation\n- Modal presentation support\n- Delegate pattern and closure-based callbacks\n- Cancel/dismiss handling\n\n## Layout Configuration\n\n- **Columns**: 2\n- **Item Spacing**: 8px horizontal and vertical\n- **Section Insets**: 8px all around\n- **Item Height**: 56px (fixed)\n- **Item Width**: Dynamic based on container width\n\n## Mock Data\n\nThe component includes comprehensive mock data:\n\n```swift\n// Pre-built mock sets\nlet defaultMock = MockSportTypeSelectorViewModel.defaultMock        // 4 sports\nlet manySportsMock = MockSportTypeSelectorViewModel.manySportsMock  // 12 sports\nlet fewSportsMock = MockSportTypeSelectorViewModel.fewSportsMock    // 2 sports\nlet emptyMock = MockSportTypeSelectorViewModel.emptySportsMock      // 0 sports\n\n// Custom mock data\nlet customSports = [/* your sports array */]\nlet customMock = MockSportTypeSelectorViewModel(sports: customSports)\n```\n\n## Styling\n\nUses StyleProvider for consistent theming:\n\n- **Background**: `StyleProvider.Color.backgroundSecondary`\n- **Navigation**: `StyleProvider.Color.textPrimary` for text and tint\n- **Individual Items**: Styled via `SportTypeSelectorItemView`\n\n## SwiftUI Previews\n\n```swift\n#Preview(\"Default\") {\n    PreviewUIView {\n        SportTypeSelectorView(viewModel: MockSportTypeSelectorViewModel.defaultMock)\n    }\n    .frame(height: 400)\n}\n```\n\n## Integration with Other Components\n\n- Uses `SportTypeSelectorItemView` for individual sport display\n- Integrates with any view model implementing `SportTypeSelectorViewModelProtocol`\n- Can be embedded in larger flows or used as standalone selection\n\n## Factory Methods\n\n```swift\n// Quick creation methods\nlet controller = SportTypeSelectorViewController.create(with: viewModel)\nlet mockController = SportTypeSelectorViewController.createWithMockData()\n```\n\n## Memory Management\n\n- Proper cleanup in `prepareForReuse()` for collection view cells\n- Combine cancellables are managed automatically\n- View controllers handle dismissal and memory cleanup\n\n## Best Practices\n\n1. Always handle both selection and cancellation events\n2. Dismiss the view controller after processing selection\n3. Use delegate pattern for complex flows, closures for simple ones\n4. Test with different sport counts to ensure layout works properly\n5. Consider loading states for dynamic data sources",
      "snapshots": []
    },
    "SquareSeeMoreView": {
      "displayName": "SquareSeeMoreView",
      "category": "UIElements",
      "subcategory": "Navigation",
      "summary": "Square 'See More' card matching casino game grid dimensions",
      "description": "Fixed 100x100pt tappable card displaying centered chevron.right icon (24pt) above localized 'See More' label (medium 12pt). Matches CasinoGameImageView dimensions for use as last item in game grids. Features 16pt corner radius, card background styling, and 4pt icon-to-label spacing. Tap triggers seeMoreTapped() callback. Optional ViewModel for tap handling.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "see-more",
        "navigation",
        "card",
        "casino",
        "grid-item",
        "chevron",
        "localized",
        "leaf-component"
      ],
      "states": [
        "default"
      ],
      "similarTo": [
        "SeeMoreButtonView",
        "CasinoGameImageView"
      ],
      "oftenUsedWith": [
        "CasinoCategorySectionView",
        "RecentlyPlayedGamesView"
      ],
      "parents": [],
      "children": [
        "CasinoGameImageView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# SquareSeeMoreView\n\nA square \"See More\" card matching casino game grid dimensions.\n\n## Overview\n\nSquareSeeMoreView displays a simple, tappable \"See More\" card that matches the size of CasinoGameImageView (100pt x 100pt). It shows a chevron icon and localized \"See More\" text, and is typically used as the last item in a casino game grid to navigate to the full category listing. The component supports tap callbacks via the view model.\n\n## Component Relationships\n\n### Used By (Parents)\n- Casino game grids\n- Game category sections\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Fixed 100pt x 100pt size\n- Centered chevron icon (24pt)\n- Localized \"See More\" label\n- Rounded corners (16pt)\n- Tap gesture with callback\n- Card background styling\n- Optional ViewModel for tap handling\n\n## Usage\n\n```swift\nlet viewModel = MockSquareSeeMoreViewModel.default\nlet seeMoreView = SquareSeeMoreView(viewModel: viewModel)\n\n// With tap callback\nlet interactiveVM = MockSquareSeeMoreViewModel.interactive\ninteractiveVM.onSeeMoreTapped = {\n    navigateToFullCategory()\n}\nlet interactiveView = SquareSeeMoreView(viewModel: interactiveVM)\n\n// Without ViewModel (placeholder)\nlet placeholderView = SquareSeeMoreView()\n\n// Reconfigure for reuse\nseeMoreView.configure(with: newViewModel)\n```\n\n## Data Model\n\n```swift\nprotocol SquareSeeMoreViewModelProtocol: AnyObject {\n    func seeMoreTapped()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundCards` - card background\n- `StyleProvider.Color.textPrimary` - icon and label color\n- `StyleProvider.fontWith(type: .medium, size: 12)` - label font\n\nLayout constants:\n- Card size: 100pt x 100pt\n- Corner radius: 16pt\n- Icon size: 24pt\n- Label top spacing: 4pt\n- Vertical stack alignment: center\n\nContent:\n- Icon: SF Symbol \"chevron.right\"\n- Label: Localized \"see_more\" string\n\n## Mock ViewModels\n\nAvailable presets:\n- `.default` - Basic mock (no action on tap)\n- `.interactive` - Prints \"See More tapped\" on tap\n\nParameters:\n- `onSeeMoreTapped: (() -> Void)?` - Optional callback for tap action\n",
      "snapshots": []
    },
    "StackViewBlockView": {
      "displayName": "StackViewBlockView",
      "category": "Promotions",
      "subcategory": "ContentBlocks",
      "summary": "Vertical stack container for CMS content blocks with dynamic composition",
      "description": "Dynamic vertical stack accepting any UIView array from view model. Arranges children with 0pt spacing, 10pt top/bottom padding, and edge-to-edge width. Clear background on both view and stack. Used for CMS-driven content layouts composing TitleBlockView, DescriptionBlockView, and BulletItemBlockView into cohesive sections. Auto-clears existing views on reconfigure.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "stack",
        "container",
        "cms",
        "content-block",
        "dynamic",
        "vertical",
        "composition"
      ],
      "states": [
        "single-view",
        "multiple-views",
        "empty"
      ],
      "similarTo": [
        "ContentBlockContainerView"
      ],
      "oftenUsedWith": [
        "TitleBlockView",
        "DescriptionBlockView",
        "BulletItemBlockView"
      ],
      "parents": [],
      "children": [
        "BulletItemBlockView",
        "DescriptionBlockView",
        "TitleBlockView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# StackViewBlockView\n\nA vertical stack container for CMS content blocks with dynamic child view composition.\n\n## Overview\n\nStackViewBlockView displays a vertical stack of child views provided by its view model, typically used for CMS-driven content layouts. The component accepts any UIView array and arranges them vertically with zero spacing. Commonly used to compose title blocks, description blocks, and bullet items into cohesive content sections.\n\n## Component Relationships\n\n### Used By (Parents)\n- CMS promotional screens\n- Content detail views\n- Onboarding flows\n\n### Uses (Children)\n- `BulletItemBlockView` - bullet point items\n- `DescriptionBlockView` - text descriptions\n- `TitleBlockView` - section titles\n- Any UIView can be added dynamically\n\n## Features\n\n- Dynamic vertical stack layout\n- Zero spacing between items\n- Accepts any UIView array\n- Clear background\n- Automatic view recycling on reconfigure\n- CMS block composition\n\n## Usage\n\n```swift\nlet viewModel = MockStackViewBlockViewModel.defaultMock\nlet stackBlock = StackViewBlockView(viewModel: viewModel)\n\n// Multiple views composition\nlet multiViewModel = MockStackViewBlockViewModel.multipleViewsMock\nlet multiStackBlock = StackViewBlockView(viewModel: multiViewModel)\n\n// Single view\nlet singleViewModel = MockStackViewBlockViewModel.singleViewMock\nlet singleStackBlock = StackViewBlockView(viewModel: singleViewModel)\n\n// Custom views\nlet customViews = [\n    TitleBlockView(viewModel: MockTitleBlockViewModel.defaultMock),\n    DescriptionBlockView(viewModel: MockDescriptionBlockViewModel.defaultMock)\n]\nlet customViewModel = MockStackViewBlockViewModel(views: customViews)\nlet customStack = StackViewBlockView(viewModel: customViewModel)\n```\n\n## Data Model\n\n```swift\nprotocol StackViewBlockViewModelProtocol {\n    var views: [UIView] { get }\n}\n```\n\n## Styling\n\nLayout constants:\n- Stack spacing: 0pt\n- Stack axis: vertical\n- Top padding: 10pt\n- Bottom padding: 10pt\n- Leading/trailing: edge to edge\n\nBackground:\n- View: clear\n- Stack: clear\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - TitleBlockView + DescriptionBlockView\n- `.multipleViewsMock` - Title + Description + 2 BulletItemBlockViews\n- `.singleViewMock` - Single TitleBlockView only\n\nFactory initialization:\n```swift\nMockStackViewBlockViewModel(views: [UIView])\n```\n",
      "snapshots": []
    },
    "StatisticsWidgetView": {
      "displayName": "Statistics Widget View",
      "category": "UIElements",
      "subcategory": "Statistics",
      "summary": "Tabbed statistics widget displaying match data via embedded WKWebViews with tab navigation and loading states",
      "description": "A complex container component that displays match statistics content through a tabbed interface. Uses MarketGroupSelectorTabView for tab navigation via an adapter pattern (StatisticsTabSelectorViewModel). Each tab contains a WKWebView that renders HTML content for different statistics types (head-to-head, form, team stats, last matches). Features horizontal paging scroll view for tab content, dynamic WebView creation per tab, loading overlay with activity indicator, error state handling with retry capability, and content refresh support. Tab selector is 50pt height, component has 400pt default intrinsic height. WebViews are configured with transparent backgrounds and disabled scrolling for seamless integration.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "statistics",
        "webview",
        "tabs",
        "html",
        "match-data",
        "paging",
        "loading-states",
        "wkwebview",
        "adapter-pattern",
        "horizontal-scroll"
      ],
      "states": [
        "loading",
        "loaded",
        "error",
        "not-loaded",
        "tab-selected",
        "refreshing"
      ],
      "similarTo": [
        "MarketGroupSelectorTabView"
      ],
      "oftenUsedWith": [
        "MatchDetailView",
        "MarketGroupSelectorTabView"
      ],
      "parents": [],
      "children": [
        "MarketGroupSelectorTabView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# StatisticsWidgetView\n\nA sophisticated statistics widget component that displays match statistics in a paginated, scrollable interface with tab navigation.\n\n## Overview\n\n`StatisticsWidgetView` is a UIKit-based component that combines a tab selector with multiple web views containing statistics content. Users can switch between different statistics categories (Head to Head, Form, Team Stats, Last Matches) either by tapping tabs or swiping horizontally through the content.\n\n## Features\n\n- **Paginated Content**: Horizontal scroll view with snap-to-page behavior\n- **Tab Navigation**: Synchronized tab selection and scroll position\n- **Multiple Web Views**: Each tab has its own WKWebView to avoid reloading\n- **User Interaction Control**: Web views have disabled interaction, only tabs and swiping work\n- **Loading States**: Individual loading states per tab with visual feedback\n- **Error Handling**: Graceful error display with retry capabilities\n- **Responsive Design**: Adapts to different screen sizes and orientations\n\n## Architecture\n\nThe component follows the MVVM pattern with a protocol-based design:\n\n```\nStatisticsWidgetView (UIView)\n MarketGroupSelectorTabView (tab navigation)\n UIScrollView (horizontal, paginated)\n     WKWebView (Head to Head)\n     WKWebView (Form)\n     WKWebView (Team Stats)\n     WKWebView (Last Matches)\n```\n\n## Usage\n\n### Basic Implementation\n\n```swift\n\n\nclass MatchDetailViewController: UIViewController {\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // Create statistics widget with mock data\n        let viewModel = MockStatisticsWidgetViewModel.footballMatch\n        let statisticsWidget = StatisticsWidgetView(viewModel: viewModel)\n        \n        view.addSubview(statisticsWidget)\n        statisticsWidget.translatesAutoresizingMaskIntoConstraints = false\n        \n        NSLayoutConstraint.activate([\n            statisticsWidget.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),\n            statisticsWidget.leadingAnchor.constraint(equalTo: view.leadingAnchor),\n            statisticsWidget.trailingAnchor.constraint(equalTo: view.trailingAnchor),\n            statisticsWidget.heightAnchor.constraint(equalToConstant: 400)\n        ])\n    }\n}\n```\n\n### Custom Statistics Implementation\n\n```swift\n// Create custom tabs\nlet tabs = [\n    StatisticsTabData(\n        id: \"custom_h2h\",\n        title: \"Head to Head\",\n        htmlContent: generateCustomHTML(),\n        loadingState: .loaded\n    ),\n    StatisticsTabData(\n        id: \"custom_form\",\n        title: \"Recent Form\",\n        loadingState: .loading\n    )\n]\n\n// Create custom data\nlet statisticsData = StatisticsWidgetData(\n    id: \"custom_match_stats\",\n    tabs: tabs,\n    selectedTabIndex: 0\n)\n\n// Create custom view model\nlet customViewModel = MockStatisticsWidgetViewModel(data: statisticsData)\nlet statisticsWidget = StatisticsWidgetView(viewModel: customViewModel)\n```\n\n## View Model Protocol\n\n### StatisticsWidgetViewModelProtocol\n\nThe main protocol that defines the interface for statistics data management:\n\n```swift\npublic protocol StatisticsWidgetViewModelProtocol {\n    // Publishers\n    var statisticsDataPublisher: AnyPublisher<StatisticsWidgetData, Never> { get }\n    var tabsPublisher: AnyPublisher<[StatisticsTabData], Never> { get }\n    var selectedTabIndexPublisher: AnyPublisher<Int, Never> { get }\n    var selectedTabIdPublisher: AnyPublisher<String?, Never> { get }\n    var isLoadingPublisher: AnyPublisher<Bool, Never> { get }\n    \n    // Actions\n    func selectTab(id: String)\n    func selectTab(index: Int)\n    func loadContent(for tabId: String)\n    func retryFailedLoad(for tabId: String)\n    func refreshAllContent()\n}\n```\n\n### Data Models\n\n#### StatisticsTabData\n\n```swift\npublic struct StatisticsTabData: Equatable, Hashable {\n    public let id: String\n    public let title: String\n    public let htmlContent: String\n    public let loadingState: StatisticsLoadingState\n}\n```\n\n#### StatisticsLoadingState\n\n```swift\npublic enum StatisticsLoadingState: Equatable, Hashable {\n    case notLoaded\n    case loading\n    case loaded\n    case error(String)\n}\n```\n\n#### StatisticsWidgetData\n\n```swift\npublic struct StatisticsWidgetData: Equatable, Hashable {\n    public let id: String\n    public let tabs: [StatisticsTabData]\n    public let selectedTabIndex: Int\n}\n```\n\n## Mock Data\n\nThe component includes comprehensive mock data for development and testing:\n\n### Available Mock Scenarios\n\n```swift\n// Football match with all statistics\nlet footballStats = MockStatisticsWidgetViewModel.footballMatch\n\n// Tennis match with limited tabs\nlet tennisStats = MockStatisticsWidgetViewModel.tennisMatch\n\n// Loading state demonstration\nlet loadingDemo = MockStatisticsWidgetViewModel.loadingState\n\n// Error state demonstration\nlet errorDemo = MockStatisticsWidgetViewModel.errorState\n\n// Empty state\nlet emptyDemo = MockStatisticsWidgetViewModel.emptyState\n```\n\n### Mock Content Types\n\nThe mock implementation includes realistic HTML content for:\n\n1. **Head to Head**: Historical match results and win/loss records\n2. **Form**: Recent 5-game performance with visual indicators\n3. **Team Stats**: Season statistics comparison with charts\n4. **Last Matches**: Recent match results with details\n\n## HTML Content Guidelines\n\n### Structure\n\nStatistics content should be provided as complete HTML documents:\n\n```html\n<html>\n<head>\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <style>\n        body {\n            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', sans-serif;\n            margin: 0;\n            padding: 16px;\n            background-color: #f6f6f8;\n            color: #252634;\n        }\n        /* Your custom styles */\n    </style>\n</head>\n<body>\n    <!-- Your statistics content -->\n</body>\n</html>\n```\n\n### Styling Recommendations\n\n- Use system fonts for consistency\n- Apply responsive design principles\n- Follow StyleProvider color patterns\n- Ensure readability in both light and dark modes\n- Keep content scrollable within the web view\n\n### Performance Considerations\n\n- Keep HTML content lightweight\n- Avoid external resource dependencies\n- Use inline styles for better loading performance\n- Optimize images and assets\n\n## Customization\n\n### Tab Configuration\n\n```swift\n// Custom tab titles and order\nlet customTabs = [\n    StatisticsTabData(id: \"overview\", title: \"Overview\"),\n    StatisticsTabData(id: \"players\", title: \"Key Players\"),\n    StatisticsTabData(id: \"tactics\", title: \"Tactics\")\n]\n```\n\n### Styling Integration\n\nThe component automatically uses StyleProvider colors:\n\n- `StyleProvider.Color.backgroundTertiary` - Main background\n- `StyleProvider.Color.highlightPrimary` - Loading indicators\n- `StyleProvider.Color.textSecondary` - Error messages\n- Inherits theme changes automatically\n\n### Loading Behavior\n\n```swift\n// Custom loading delays\nviewModel.loadContent(for: \"head_to_head\")\n\n// Retry failed loads\nviewModel.retryFailedLoad(for: \"team_stats\")\n\n// Refresh all content\nviewModel.refreshAllContent()\n```\n\n## Integration with Services\n\nWhile the component is designed with mock data, it can easily integrate with real services:\n\n```swift\nclass ProductionStatisticsViewModel: StatisticsWidgetViewModelProtocol {\n    private let statisticsService: StatisticsServiceProtocol\n    \n    func loadContent(for tabId: String) {\n        // Call your statistics service\n        statisticsService.loadStatistics(for: tabId)\n            .sink(receiveCompletion: { /* handle completion */ },\n                  receiveValue: { htmlContent in\n                      self.updateTabContent(tabId: tabId, htmlContent: htmlContent)\n                  })\n            .store(in: &cancellables)\n    }\n}\n```\n\n## Accessibility\n\nThe component includes accessibility features:\n\n- VoiceOver support for tab navigation\n- Semantic content structure in HTML\n- Proper focus management\n- Screen reader friendly error messages\n\n## Testing\n\n### Unit Testing\n\n```swift\nfunc testTabSelection() {\n    let viewModel = MockStatisticsWidgetViewModel.footballMatch\n    \n    // Test tab selection\n    viewModel.selectTab(id: \"team_stats\")\n    \n    XCTAssertEqual(viewModel.currentSelectedTabId, \"team_stats\")\n    XCTAssertEqual(viewModel.currentSelectedTabIndex, 2)\n}\n```\n\n### UI Testing\n\nThe component includes comprehensive SwiftUI previews for visual testing:\n\n- Football Match Statistics\n- Tennis Match Statistics  \n- Loading State\n- Error State\n- Empty State\n- Full Screen Demo\n- Interactive Demo with Navigation\n\n## Requirements\n\n- iOS 16.0+\n- UIKit framework\n- WebKit framework\n- Combine framework\n\n## Dependencies\n\n- StyleProvider (for theming)\n- MarketGroupSelectorTabView (for tab navigation)\n- PreviewUIViewController (for SwiftUI previews)\n\n## Performance Notes\n\n- Web views are created once and reused\n- Content is cached to avoid reloading\n- Smooth pagination with optimized scroll behavior\n- Minimal memory footprint with proper cleanup\n\n## Known Limitations\n\n- Web view content is not interactive (by design)\n- Limited to horizontal scrolling only\n- Requires manual content size management for complex layouts\n- iOS 16+ requirement due to modern WebKit features\n\n## Future Enhancements\n\nPotential improvements for future versions:\n\n- Support for video content in statistics\n- Offline content caching\n- Advanced animation transitions\n- Dynamic tab configuration\n- Accessibility improvements\n- Performance optimizations\n\n---\n\nFor more information about the GomaUI component library, see the main [GomaUI README](../../README.md).\n",
      "snapshots": []
    },
    "StatusInfoView": {
      "displayName": "Status Info View",
      "category": "Status",
      "subcategory": "Feedback",
      "summary": "Full-screen status display with centered icon, title, and message for confirmation or result screens",
      "description": "A simple status display component used for showing confirmation, success, error, or informational screens. Features a vertically stacked layout with a centered 100x100pt icon at top (supports both named images and SF Symbols), a bold 22pt center-aligned title (2 lines max) positioned 50pt below the icon, and a regular 16pt center-aligned multi-line message 14pt below the title. Uses backgroundTertiary background color with 16pt horizontal and vertical padding. Ideal for password change confirmations, operation success/failure screens, or any full-screen status feedback.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "status",
        "feedback",
        "confirmation",
        "success",
        "error",
        "icon",
        "message",
        "full-screen",
        "centered"
      ],
      "states": [
        "success",
        "error",
        "info",
        "warning"
      ],
      "similarTo": [
        "EmptyStateView",
        "ErrorStateView"
      ],
      "oftenUsedWith": [
        "ActionButtonView",
        "ModalViewController"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# StatusInfoView\n\nA status display with icon, title, and message for confirmation screens.\n\n## Overview\n\nStatusInfoView displays a centered status message with a large icon, bold title, and descriptive message text. It is typically used for confirmation screens, success states, or informational displays after completing an action (e.g., password changed successfully). The component supports both custom named images and SF Symbols for the icon.\n\n## Component Relationships\n\n### Used By (Parents)\n- Confirmation screens\n- Success/error result screens\n- Information displays\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Large centered icon (100pt x 100pt)\n- Bold title with multiline support\n- Regular message with multiline support\n- Custom or SF Symbol icons\n- Centered text alignment\n- Background color theming\n\n## Usage\n\n```swift\nlet statusInfo = StatusInfo(\n    icon: \"checkmark.circle.fill\",\n    title: \"Password Changed Successfully\",\n    message: \"Your password has been updated. You can now log in with your new password.\"\n)\nlet viewModel = MockStatusInfoViewModel(statusInfo: statusInfo)\nlet statusView = StatusInfoView(viewModel: viewModel)\n\n// Custom icon from bundle\nlet customStatusInfo = StatusInfo(\n    icon: \"success_icon\",  // Bundle asset name\n    title: \"Success!\",\n    message: \"Your request has been processed.\"\n)\n```\n\n## Data Model\n\n```swift\nstruct StatusInfo {\n    let id: String\n    let icon: String       // Bundle image name or SF Symbol name\n    let title: String\n    let message: String\n}\n\nprotocol StatusInfoViewModelProtocol {\n    var statusInfo: StatusInfo { get }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundTertiary` - view background\n\nLayout constants:\n- Icon size: 100pt x 100pt\n- Icon top padding: 16pt\n- Title top margin: 50pt (from icon)\n- Title horizontal padding: 16pt\n- Message top margin: 14pt (from title)\n- Message horizontal padding: 16pt\n- Message bottom padding: 16pt\n\nTypography:\n- Title: Bold, 22pt, centered, 2 lines max\n- Message: Regular, 16pt, centered, unlimited lines\n\nIcon handling:\n- Tries custom named image first\n- Falls back to SF Symbol\n- Content mode: scaleAspectFit\n\n## Mock ViewModels\n\nAvailable presets:\n- `.successMock` - \"Password Changed Successfully\" with checkmark icon\n\nParameters:\n- `statusInfo: StatusInfo` - The status information to display\n",
      "snapshots": [
        {
          "category": "BasicStates",
          "light": "StatusInfoView/__Snapshots__/StatusInfoViewSnapshotTests/testStatusInfoView_BasicStates_Light.1.png",
          "dark": "StatusInfoView/__Snapshots__/StatusInfoViewSnapshotTests/testStatusInfoView_BasicStates_Dark.1.png"
        }
      ]
    },
    "StatusNotificationView": {
      "displayName": "Status Notification View",
      "category": "Status",
      "subcategory": "Toast",
      "summary": "Horizontal toast/banner notification displaying status messages with type-specific colors and icons",
      "description": "A toast-style notification banner for displaying temporary status messages. Features a horizontal layout with a 24x24pt icon (white tint) on the left with 16pt leading padding, followed by a bold 16pt multi-line message label 8pt from the icon. Container has 4pt corner radius with 12pt vertical and 16pt horizontal padding. Background color is determined by StatusNotificationType: success (alertSuccess green), error (alertError red), or warning (alertWarning yellow). Supports custom named icons or falls back to type-specific SF Symbols (checkmark.circle.fill, xmark.circle.fill, exclamationmark.triangle.fill). Uses Combine bindings for reactive data updates.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "toast",
        "notification",
        "banner",
        "status",
        "success",
        "error",
        "warning",
        "alert",
        "message",
        "feedback"
      ],
      "states": [
        "success",
        "error",
        "warning"
      ],
      "similarTo": [
        "StatusInfoView",
        "AlertBannerView"
      ],
      "oftenUsedWith": [
        "DepositView",
        "TransactionView",
        "FormView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# StatusNotificationView\n\nA compact notification banner with icon and message for success, error, or warning states.\n\n## Overview\n\nStatusNotificationView displays a horizontal notification bar with an icon and message. It supports three notification types (success, error, warning) with appropriate background colors and default icons. The component is used for inline feedback messages, toast-style notifications, and status indicators throughout the app.\n\n## Component Relationships\n\n### Used By (Parents)\n- Transaction screens\n- Form validation displays\n- Action feedback areas\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Three notification types: success, error, warning\n- Type-specific background colors\n- Type-specific default icons\n- Custom icon override support\n- Multiline message support\n- Bold white text for visibility\n- Rounded corners (4pt)\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockStatusNotificationViewModel.successMock\nlet notificationView = StatusNotificationView(viewModel: viewModel)\n\n// Error notification\nlet errorVM = MockStatusNotificationViewModel.errorMock\nlet errorView = StatusNotificationView(viewModel: errorVM)\n\n// Warning notification\nlet warningVM = MockStatusNotificationViewModel.warningMock\nlet warningView = StatusNotificationView(viewModel: warningVM)\n\n// Custom notification\nlet customData = StatusNotificationData(\n    type: .success,\n    message: \"Your bet has been placed!\",\n    icon: \"custom_success_icon\"  // Optional custom icon\n)\nviewModel.configure(with: customData)\n```\n\n## Data Model\n\n```swift\nenum StatusNotificationType {\n    case success\n    case error\n    case warning\n\n    var backgroundColor: UIColor\n    var iconImage: UIImage?\n}\n\nstruct StatusNotificationData {\n    let id: String\n    let type: StatusNotificationType\n    let message: String\n    let icon: String?  // Optional custom icon override\n}\n\nprotocol StatusNotificationViewModelProtocol {\n    var data: StatusNotificationData { get }\n    var dataPublisher: AnyPublisher<StatusNotificationData, Never> { get }\n\n    func configure(with data: StatusNotificationData)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.alertSuccess` - success background\n- `StyleProvider.Color.alertError` - error background\n- `StyleProvider.Color.alertWarning` - warning background\n- `StyleProvider.Color.buttonTextPrimary` - message text color\n- `StyleProvider.Color.allWhite` - icon tint color\n- `StyleProvider.fontWith(type: .bold, size: 16)` - message font\n\nLayout constants:\n- Corner radius: 4pt\n- Vertical padding: 12pt\n- Horizontal padding: 16pt\n- Icon size: 24pt\n- Icon to message spacing: 8pt\n\nDefault icons (when not overridden):\n- Success: \"checkmark.circle.fill\" (bundle or SF Symbol)\n- Error: SF Symbol \"xmark.circle.fill\"\n- Warning: SF Symbol \"exclamationmark.triangle.fill\"\n\n## Mock ViewModels\n\nAvailable presets:\n- `.successMock` - \"Deposit Successful\" with success styling\n- `.errorMock` - \"Transaction Failed\" with error styling\n- `.warningMock` - \"Low Balance Warning\" with warning styling\n\nMethods:\n- `configure(with:)` - Update notification data reactively\n",
      "snapshots": [
        {
          "category": "NotificationTypes",
          "light": "StatusNotificationView/__Snapshots__/StatusNotificationViewSnapshotTests/testStatusNotificationView_NotificationTypes_Light.1.png",
          "dark": "StatusNotificationView/__Snapshots__/StatusNotificationViewSnapshotTests/testStatusNotificationView_NotificationTypes_Dark.1.png"
        }
      ]
    },
    "StepInstructionView": {
      "displayName": "Step Instruction View",
      "category": "UIElements",
      "subcategory": "Instructions",
      "summary": "Numbered step instruction row with circular indicator and highlighted text for guided workflows",
      "description": "A composite component for displaying numbered step instructions with keyword highlighting. Features a horizontal layout with a 32x32pt circular step indicator (16pt corner radius, highlightPrimary background) containing a bold 16pt centered step number, followed by a HighlightedTextView for the instruction text. Layout has 16pt leading padding for indicator with 8pt vertical padding, 8pt spacing to text, and 16pt trailing padding. Instruction text is left-aligned and vertically centered. Supports customizable indicator background color and number text color. Highlighted words are automatically detected and styled with highlightPrimary color via the embedded HighlightedTextView. Ideal for payment flows, onboarding wizards, and multi-step tutorials.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "step",
        "instruction",
        "numbered",
        "indicator",
        "highlight",
        "tutorial",
        "onboarding",
        "workflow",
        "guide"
      ],
      "states": [
        "default",
        "custom-colors",
        "single-highlight",
        "multiple-highlights"
      ],
      "similarTo": [
        "HighlightedTextView",
        "BulletItemBlockView"
      ],
      "oftenUsedWith": [
        "HighlightedTextView",
        "DepositInstructionsView",
        "PaymentFlowView"
      ],
      "parents": [],
      "children": [
        "HighlightedTextView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# StepInstructionView\n\nA numbered step instruction with highlighted keywords for guiding users through processes.\n\n## Overview\n\nStepInstructionView displays a numbered step indicator circle alongside instruction text with highlighted keywords. It uses HighlightedTextView to render text with colored keywords (e.g., button names, important terms) for emphasis. The component is used in onboarding flows, payment instructions, and multi-step processes where clear guidance is needed.\n\n## Component Relationships\n\n### Used By (Parents)\n- Payment instruction screens\n- Onboarding flows\n- Help/tutorial sections\n\n### Uses (Children)\n- `HighlightedTextView` (for instruction text with highlights)\n\n## Features\n\n- Numbered step indicator circle (32pt)\n- Highlighted text with auto-detected keyword ranges\n- Customizable indicator and text colors\n- Left-aligned instruction text\n- Flexible width layout\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet data = StepInstructionData(\n    stepNumber: 1,\n    instructionText: \"On the mobile money menu, select Pay Bill, then select the Betsson option.\",\n    highlightedWords: [\"Pay Bill\", \"Betsson\"]\n)\nlet viewModel = MockStepInstructionViewModel(data: data)\nlet stepView = StepInstructionView(viewModel: viewModel)\n\n// Custom indicator colors\nlet customData = StepInstructionData(\n    stepNumber: 2,\n    instructionText: \"Click the Confirm Payment button below.\",\n    highlightedWords: [\"Confirm Payment\"],\n    indicatorColor: StyleProvider.Color.highlightSecondary,\n    numberTextColor: StyleProvider.Color.textPrimary\n)\nlet customView = StepInstructionView(viewModel: MockStepInstructionViewModel(data: customData))\n```\n\n## Data Model\n\n```swift\nstruct StepInstructionData {\n    let id: String\n    let stepNumber: Int\n    let instructionText: String\n    let highlightedWords: [String]\n    let indicatorColor: UIColor?     // nil = highlightPrimary\n    let numberTextColor: UIColor?    // nil = buttonTextPrimary\n}\n\nprotocol StepInstructionViewModelProtocol {\n    var data: StepInstructionData { get }\n    var dataPublisher: AnyPublisher<StepInstructionData, Never> { get }\n    var highlightedTextViewModel: HighlightedTextViewModelProtocol { get }\n\n    func configure(with data: StepInstructionData)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.highlightPrimary` - default indicator background, highlight color\n- `StyleProvider.Color.buttonTextPrimary` - default step number text color\n- `StyleProvider.fontWith(type: .bold, size: 16)` - step number font\n\nLayout constants:\n- Indicator size: 32pt x 32pt\n- Indicator corner radius: 16pt (circular)\n- Indicator leading: 16pt\n- Text leading from indicator: 8pt\n- Text trailing: 16pt\n- Vertical padding: 8pt\n\nHighlighted text:\n- Handled by HighlightedTextView child component\n- Keywords automatically colorized in highlightPrimary\n- Left-aligned text\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - Mobile money step with \"x\" placeholder highlighted\n- `.customColorMock` - Step 2 with custom colors and \"Confirm Payment\" highlighted\n- `.multipleHighlightsMock` - Step 3 with two highlighted phrases\n\nMethods:\n- `configure(with:)` - Update step data reactively\n",
      "snapshots": [
        {
          "category": "InstructionVariants",
          "light": "StepInstructionView/__Snapshots__/StepInstructionViewSnapshotTests/testStepInstructionView_InstructionVariants_Light.1.png",
          "dark": "StepInstructionView/__Snapshots__/StepInstructionViewSnapshotTests/testStepInstructionView_InstructionVariants_Dark.1.png"
        }
      ]
    },
    "SuggestedBetsExpandedView": {
      "displayName": "Suggested Bets Expanded View",
      "category": "Betting",
      "subcategory": "Suggestions",
      "summary": "Collapsible carousel section displaying suggested betting match cards with paging and gradient styling",
      "description": "A complex composite component for displaying suggested bet recommendations in a collapsible, paginated carousel. Features a gradient container (backgroundGradient1 to backgroundGradient2) with a 34pt gradient header containing a 16x16pt flame icon, bold 14pt title in highlightPrimary, and a rotating chevron indicator (18x18pt). Content area has a horizontal paging collection view (152pt height, 12pt top offset) displaying TallOddsMatchCardView cells with 16pt horizontal padding. Includes a page control for navigation that hides for single page. Header tap toggles expand/collapse with animated chevron rotation. Supports external selection sync via selectedOutcomeIds for betslip integration. Uses SuggestedBetsMatchCardCell wrapper for collection cells.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "suggested-bets",
        "carousel",
        "paging",
        "collapsible",
        "gradient",
        "match-cards",
        "page-control",
        "expandable",
        "recommendations"
      ],
      "states": [
        "expanded",
        "collapsed",
        "visible",
        "hidden",
        "single-page",
        "multi-page"
      ],
      "similarTo": [
        "RecentlyPlayedGamesView",
        "CarouselView"
      ],
      "oftenUsedWith": [
        "TallOddsMatchCardView",
        "BetslipView",
        "HomeView"
      ],
      "parents": [],
      "children": [
        "TallOddsMatchCardView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# SuggestedBetsExpandedView\n\nA collapsible carousel of suggested match betting cards with gradient styling.\n\n## Overview\n\nSuggestedBetsExpandedView displays an expandable/collapsible section containing horizontally pageable match betting cards using TallOddsMatchCardView. It features a gradient header with an icon, title, and expand/collapse chevron. The content area shows one match card at a time with a page control indicator. The component syncs outcome selections with the betslip for visual consistency.\n\n## Component Relationships\n\n### Used By (Parents)\n- Betslip screens\n- Match detail screens\n\n### Uses (Children)\n- `TallOddsMatchCardView` (via internal SuggestedBetsMatchCardCell)\n- `GradientView` (for container and header backgrounds)\n\n## Features\n\n- Collapsible gradient header with icon and title\n- Horizontally paging UICollectionView (one card at a time)\n- Page control indicator with tap-to-select\n- Animated expand/collapse with chevron rotation\n- Selected outcome synchronization from betslip\n- Custom clear background for match cards\n- Visibility state control\n- Lazy content loading on first expand\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockSuggestedBetsExpandedViewModel.demo\nlet suggestedBetsView = SuggestedBetsExpandedView(viewModel: viewModel)\n\n// Toggle expanded state\nviewModel.toggleExpanded()\n\n// Navigate to page\nviewModel.didScrollToPage(2)\n\n// Sync selected outcomes from betslip\nviewModel.updateSelectedOutcomeIds([\"outcome1\", \"outcome2\"])\n\n// Update match cards dynamically\nviewModel.updateMatches(newMatchCardViewModels)\n\n// Reconfigure for reuse\nsuggestedBetsView.configure(with: newViewModel)\n```\n\n## Data Model\n\n```swift\nstruct SuggestedBetsSectionState: Equatable {\n    let title: String\n    let isExpanded: Bool\n    let currentPageIndex: Int\n    let totalPages: Int\n    let isVisible: Bool\n}\n\nprotocol SuggestedBetsExpandedViewModelProtocol: AnyObject {\n    // State\n    var displayStatePublisher: AnyPublisher<SuggestedBetsSectionState, Never> { get }\n\n    // Child match cards\n    var matchCardViewModelsPublisher: AnyPublisher<[TallOddsMatchCardViewModelProtocol], Never> { get }\n    var matchCardViewModels: [TallOddsMatchCardViewModelProtocol] { get }\n\n    // Selection sync\n    var selectedOutcomeIdsPublisher: AnyPublisher<Set<String>, Never> { get }\n    var selectedOutcomeIds: Set<String> { get }\n\n    // Actions\n    func toggleExpanded()\n    func didScrollToPage(_ index: Int)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundGradient1`, `backgroundGradient2` - container gradient\n- `StyleProvider.Color.allWhite` - header gradient start\n- `StyleProvider.Color.highlightPrimary` - icon and title color\n- `StyleProvider.Color.navBannerActive` - page control active dot\n- `StyleProvider.Color.navBanner` - page control inactive dots\n- `StyleProvider.fontWith(type: .bold, size: 14)` - title font\n\nLayout constants:\n- Header height: 34pt\n- Icon size: 16pt\n- Chevron size: 18pt\n- Collection view height: 152pt\n- Page control top spacing: 8pt\n- Horizontal padding: 16pt for cards\n\nIcons:\n- Bundle \"popular_icon\" or SF Symbol \"flame.fill\"\n- Bundle \"chevron_up_icon\"/\"chevron_down_icon\" or SF Symbols\n\nGradient:\n- Container: horizontal gradient\n- Header: horizontal gradient with white start\n\n## Mock ViewModels\n\nAvailable presets:\n- `.demo` - 4 match cards (Premier League, Live, Compact, Bundesliga variants)\n\nParameters:\n- `title: String` - Section title\n- `isExpanded: Bool` - Initial expand state\n- `isVisible: Bool` - Initial visibility\n- `initialPage: Int` - Starting page index\n- `matchCardViewModels: [TallOddsMatchCardViewModelProtocol]` - Match cards\n\nMethods:\n- `toggleExpanded()` - Toggle expand/collapse\n- `didScrollToPage(_ index:)` - Update current page\n- `updateMatches(_ matchCardViewModels:)` - Replace match cards\n- `updateSelectedOutcomeIds(_ ids:)` - Sync betslip selections\n",
      "snapshots": []
    },
    "TallOddsMatchCardView": {
      "displayName": "Tall Odds Match Card View",
      "category": "MatchCards",
      "subcategory": "Betting",
      "summary": "Complete match betting card with header, participants, score, market info, and outcome selections",
      "description": "A complex composite match card component combining multiple child views for comprehensive betting display. Vertical stack layout (4pt spacing) includes: MatchHeaderView (league, time, favorite toggle), FadingView separator (1pt with gradient edges), participants container with home/away labels (semibold 14.5pt, 20pt height) and ScoreView aligned right, MarketInfoLineView (market name pill, feature icons, market count), and MarketOutcomesMultiLineView (selectable betting outcomes). Supports live matches with visible score display, prepareForReuse() for efficient cell recycling, customizable background color, and configurable image resolver. Action callbacks for header tap, favorite toggle, outcome selection/deselection, market info tap, and card tap. Uses both synchronous current values and async publishers for proper UITableView sizing.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "match-card",
        "betting",
        "odds",
        "outcomes",
        "participants",
        "score",
        "live",
        "market-info",
        "composite",
        "reusable"
      ],
      "states": [
        "live",
        "pre-match",
        "favorited",
        "not-favorited",
        "outcome-selected",
        "outcome-deselected"
      ],
      "similarTo": [
        "MatchHeaderCompactView",
        "MarketOutcomesMultiLineView"
      ],
      "oftenUsedWith": [
        "MatchHeaderView",
        "MarketInfoLineView",
        "MarketOutcomesMultiLineView",
        "ScoreView",
        "SuggestedBetsExpandedView"
      ],
      "parents": [
        "SuggestedBetsExpandedView"
      ],
      "children": [
        "MarketInfoLineView",
        "MarketOutcomesMultiLineView",
        "MatchHeaderView",
        "ScoreView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# TallOddsMatchCardView\n\nA comprehensive match card component that assembles multiple existing GomaUI components to display pre-live sports betting matches with all necessary information and betting options.\n\n## Overview\n\nThe `TallOddsMatchCardView` is a **Tier 3 complex component** that combines:\n- **MatchHeaderView** - League information, favorite toggle, match date/time\n- **Separator Line** - Visual division between header and content\n- **MatchParticipantsInfoView** - Team/participant names in vertical layout\n- **MarketInfoLineView** - Market name pill, market count, and info icons\n- **MarketOutcomesMultiLineView** - Betting outcomes in multiple lines\n\n## Architecture\n\n### Component Structure\n```\nTallOddsMatchCardView\n MatchHeaderView (league info, date, favorite)\n Separator Line (1px divider)\n MatchParticipantsInfoView (vertical team layout)\n MarketInfoLineView (market pill + count + icons)\n MarketOutcomesMultiLineView (betting outcomes)\n```\n\n### MVVM Pattern\n- **Protocol**: `TallOddsMatchCardViewModelProtocol`\n- **View**: `TallOddsMatchCardView`\n- **Mock**: `MockTallOddsMatchCardViewModel`\n- **Child VMs**: Creates and manages all child component view models\n\n## Usage\n\n### Basic Implementation\n\n```swift\n\n\n// Create match data\nlet matchData = PreLiveMatchData(\n    matchId: \"liverpool_arsenal\",\n    leagueInfo: headerData,\n    participants: participantsData,\n    marketInfo: marketInfoData,\n    outcomes: outcomesData\n)\n\n// Create view model\nlet viewModel = MockTallOddsMatchCardViewModel(matchData: matchData)\n\n// Create view\nlet matchCardView = TallOddsMatchCardView(viewModel: viewModel)\n\n// Setup callbacks\nmatchCardView.onMatchHeaderTapped = {\n    // Navigate to match details\n}\n\nmatchCardView.onOutcomeSelected = { outcomeId in\n    // Add to betslip\n}\n```\n\n### Callback Configuration\n\n```swift\nmatchCardView.onMatchHeaderTapped = {\n    // Handle header tap (navigate to match details)\n}\n\nmatchCardView.onFavoriteToggled = {\n    // Handle favorite toggle\n}\n\nmatchCardView.onOutcomeSelected = { outcomeId in\n    // Handle outcome selection (add to betslip)\n}\n\nmatchCardView.onMarketInfoTapped = {\n    // Handle market info tap (show more markets)\n}\n```\n\n## Data Models\n\n### PreLiveMatchData\nMain data structure containing all child component data:\n\n```swift\npublic struct PreLiveMatchData: Equatable, Hashable {\n    public let matchId: String\n    public let leagueInfo: MatchHeaderData\n    public let participants: MatchParticipantsInfoData\n    public let marketInfo: MarketInfoData\n    public let outcomes: MarketOutcomesMultiLineData\n}\n```\n\n### Child Component Data\n- `MatchHeaderData` - League, country, competition info\n- `MatchParticipantsInfoData` - Team names and layout configuration\n- `MarketInfoData` - Market name, count, info icons\n- `MarketOutcomesMultiLineData` - Betting outcomes in multiple lines\n\n## Display Configuration\n\n### TallOddsMatchCardDisplayState\nControls visual appearance and spacing:\n\n```swift\npublic struct TallOddsMatchCardDisplayState: Equatable {\n    public let matchId: String\n    public let showSeparatorLine: Bool\n    public let cardBackgroundColor: UIColor\n    public let cornerRadius: CGFloat\n    public let horizontalPadding: CGFloat\n    public let verticalSpacing: CGFloat\n}\n```\n\n### Default Values\n- **Background**: `StyleProvider.Color.backgroundSecondary`\n- **Corner Radius**: `8.0`\n- **Horizontal Padding**: `16.0`\n- **Vertical Spacing**: `12.0`\n- **Separator**: Always shown\n\n## Mock Data\n\n### Available Mocks\n\n#### Premier League Match\n```swift\nlet viewModel = MockTallOddsMatchCardViewModel.premierLeagueMock\n```\n- Liverpool F.C. vs Arsenal F.C.\n- Premier League competition\n- Multiple market icons\n- Two-column outcome layout\n\n#### La Liga Match (Compact)\n```swift\nlet viewModel = MockTallOddsMatchCardViewModel.compactMock\n```\n- FC Barcelona vs Real Madrid\n- La Liga competition\n- Three-way betting (1X2)\n- Minimal icons\n\n#### Bundesliga Match\n```swift\nlet viewModel = MockTallOddsMatchCardViewModel.bundesliegaMock\n```\n- Bayern Munich vs Borussia Dortmund\n- Bundesliga competition\n- Both Teams Score market\n- All info icons displayed\n\n## Layout & Spacing\n\n### Vertical Stack Layout\nThe component uses `UIStackView` with vertical axis:\n\n1. **Spacing**: 12pt between components\n2. **Padding**: 16pt horizontal margins\n3. **Alignment**: Fill (full width)\n4. **Distribution**: Fill (natural heights)\n\n### Responsive Design\n- Adapts to different screen sizes\n- Flexible content compression\n- Proper constraint priorities\n\n## Child Component Integration\n\n### Parent-Child Relationship\nThe parent view model creates and manages all child view models:\n\n```swift\n// Parent creates child view models from single data source\nlet headerViewModel = MockMatchHeaderViewModel(headerData: matchData.leagueInfo)\nlet participantsViewModel = MockMatchParticipantsInfoViewModel(participantsData: matchData.participants)\nlet marketInfoViewModel = MockMarketInfoLineViewModel(marketInfoData: matchData.marketInfo)\nlet outcomesViewModel = MockMarketOutcomesMultiLineViewModel(marketData: matchData.outcomes)\n```\n\n### Reactive Updates\nAll child components receive updates through Combine publishers:\n\n```swift\n// Child view model publishers\nvar matchHeaderViewModelPublisher: AnyPublisher<MatchHeaderViewModelProtocol, Never> { get }\nvar matchParticipantsViewModelPublisher: AnyPublisher<MatchParticipantsInfoViewModelProtocol, Never> { get }\nvar marketInfoLineViewModelPublisher: AnyPublisher<MarketInfoLineViewModelProtocol, Never> { get }\nvar marketOutcomesViewModelPublisher: AnyPublisher<MarketOutcomesMultiLineViewModelProtocol, Never> { get }\n```\n\n## Testing & Previews\n\n### SwiftUI Previews\nMultiple preview configurations available:\n\n```swift\n#Preview(\"Premier League Match\") {\n    PreviewUIView {\n        TallOddsMatchCardView(viewModel: MockTallOddsMatchCardViewModel.premierLeagueMock)\n    }\n    .frame(height: 300)\n}\n```\n\n### TestCase Integration\nAvailable in TestCase app gallery with interactive demo:\n- Segmented control to switch between mock data\n- Live callback testing\n- Alert dialogs for user actions\n\n## MarketInfoLineView Component\n\n### New Tier 2 Component\nCreated specifically for this card assembly:\n\n**Features:**\n- Market name pill on the left\n- Market count label on the right\n- Info icons (EP, Popular, Stats, etc.)\n- Horizontal layout with proper spacing\n\n**Data Structure:**\n```swift\npublic struct MarketInfoData: Equatable, Hashable {\n    public let marketName: String\n    public let marketCount: Int\n    public let icons: [MarketInfoIcon]\n}\n```\n\n**Available Icons:**\n- `erep_short_info` - EP Short icon\n- `most_popular_info` - Popular markets icon\n- `stats_info` - Statistics icon\n- `bet_builder_info` - Bet Builder icon\n\n## Best Practices\n\n### Memory Management\n- Uses `[weak self]` in all closures\n- Proper Combine subscription management\n- Avoids retain cycles\n\n### Performance\n- Lazy component initialization\n- Efficient constraint updates\n- Minimal view recreation\n\n### Accessibility\n- Inherits accessibility from child components\n- Proper gesture recognition\n- Screen reader support\n\n## Migration Notes\n\n### From Individual Components\nWhen migrating from using individual components separately:\n\n1. **Data Consolidation**: Combine individual data models into `PreLiveMatchData`\n2. **View Model Updates**: Replace multiple view models with single parent\n3. **Layout Removal**: Remove manual spacing/layout code\n4. **Callback Consolidation**: Use card-level callbacks instead of individual ones\n\n### Spacing Adjustments\nThe card provides consistent spacing that may differ from manual layouts:\n- **12pt vertical spacing** between components\n- **16pt horizontal padding** from edges\n- **1px separator line** after header\n\n## Troubleshooting\n\n### Common Issues\n\n#### Child Components Not Updating\n**Cause**: View model publishers not properly bound\n**Solution**: Ensure all child view model publishers are connected in `setupChildViewModelBindings()`\n\n#### Layout Issues\n**Cause**: Incorrect constraint priorities\n**Solution**: Verify compression resistance settings for horizontal layouts\n\n#### Missing Icons\n**Cause**: Icon names don't match asset bundle\n**Solution**: Check icon names in `Resources/Icons.xcassets/info_card_line/`\n\n## Future Enhancements\n\n### Live Mode Support\nThe next iteration will include:\n- Live score updates\n- Live status indicators\n- Real-time odds changes\n- Different layout for in-play matches\n\n### Additional Features\n- Betting slip integration\n- Favorite persistence\n- Market expansion\n- Performance analytics\n",
      "snapshots": []
    },
    "TermsAcceptanceView": {
      "displayName": "Terms Acceptance View",
      "category": "Forms",
      "subcategory": "Legal",
      "summary": "Checkbox with highlighted text for legal terms acceptance with tappable policy links",
      "description": "A composite form component for legal terms acceptance featuring a checkbox with tappable policy links. Horizontal stack layout (12pt spacing) with a 24x24pt checkbox (4pt corner radius, 2pt border) containing a 16x16pt centered checkmark icon. Unchecked state has clear background with textSecondary border; checked state shows highlightPrimary background and border with visible checkmark. Uses HighlightedTextView (regular 12pt, left-aligned) to display the full terms text with highlighted and tappable links for Terms and Conditions, Privacy Policy, and optional Cookies Policy. Includes tap detection via NSLayoutManager for link identification, error label (regular 12pt, systemRed) positioned 4pt below with 40pt leading indent for validation feedback. Action callbacks for checkbox toggle and each policy link tap.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "terms",
        "checkbox",
        "legal",
        "privacy",
        "acceptance",
        "links",
        "form",
        "validation",
        "highlighted-text"
      ],
      "states": [
        "checked",
        "unchecked",
        "error",
        "valid"
      ],
      "similarTo": [
        "HighlightedTextView",
        "CheckboxView"
      ],
      "oftenUsedWith": [
        "HighlightedTextView",
        "RegistrationFormView",
        "BorderedTextFieldView"
      ],
      "parents": [],
      "children": [
        "HighlightedTextView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# TermsAcceptanceView\n\nA checkbox with terms text containing tappable links for legal acceptance.\n\n## Overview\n\nTermsAcceptanceView displays a checkbox alongside legal acceptance text with highlighted, tappable links for Terms and Conditions, Privacy Policy, and optionally Cookies Policy. The checkbox toggles acceptance state with visual feedback. Tapping highlighted terms triggers navigation callbacks. The component includes an error state for validation with a \"Required field\" message.\n\n## Component Relationships\n\n### Used By (Parents)\n- Registration screens\n- Account creation flows\n- Consent forms\n\n### Uses (Children)\n- `HighlightedTextView` (for text with tappable links)\n\n## Features\n\n- Checkbox with check/uncheck animation\n- Tappable highlighted links for terms documents\n- Terms, Privacy, and Cookies link callbacks\n- Error state with validation message\n- Acceptance state tracking\n- Hit-testing on specific text ranges\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockTermsAcceptanceViewModel.defaultMock\nlet termsView = TermsAcceptanceView(viewModel: viewModel)\n\n// Handle checkbox toggle\ntermsView.onCheckboxToggled = { isAccepted in\n    updateRegistrationState(accepted: isAccepted)\n}\n\n// Handle link taps\ntermsView.onTermsLinkTapped = { openTermsPage() }\ntermsView.onPrivacyLinkTapped = { openPrivacyPage() }\ntermsView.onCookiesLinkTapped = { openCookiesPage() }\n\n// Show validation error\ntermsView.showError(true)\n\n// Toggle acceptance programmatically\nviewModel.toggleAcceptance()\n```\n\n## Data Model\n\n```swift\nstruct TermsAcceptanceData {\n    let id: String\n    let fullText: String           // Complete legal text\n    let termsText: String          // \"Terms and Conditions\" to highlight\n    let privacyText: String        // \"Privacy Policy\" to highlight\n    let cookiesText: String?       // Optional \"Cookies\" to highlight\n    let isAccepted: Bool\n}\n\nprotocol TermsAcceptanceViewModelProtocol {\n    var data: TermsAcceptanceData { get }\n    var dataPublisher: AnyPublisher<TermsAcceptanceData, Never> { get }\n    var highlightedTextViewModel: HighlightedTextViewModelProtocol { get }\n\n    func configure(with data: TermsAcceptanceData)\n    func toggleAcceptance()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.highlightPrimary` - checked state, link highlights\n- `StyleProvider.Color.textSecondary` - unchecked border color\n- `StyleProvider.Color.allWhite` - checkmark icon color\n- `StyleProvider.fontWith(type: .regular, size: 12)` - error label, text\n\nLayout constants:\n- Checkbox size: 24pt x 24pt\n- Checkbox corner radius: 4pt\n- Checkbox border width: 2pt\n- Checkmark size: 16pt\n- Checkbox to text spacing: 12pt\n- Error label left margin: 40pt\n- Error label top spacing: 4pt\n\nCheckbox states:\n- Unchecked: clear background, gray border, hidden checkmark\n- Checked: orange background, orange border, white checkmark\n\nIcons:\n- Bundle \"check_icon\" or SF Symbol \"checkmark\"\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - Full legal text with Terms and Privacy links\n- `.acceptedMock` - Same text, pre-accepted\n- `.shortTextMock` - Short text \"I accept the Terms and Privacy Policy\"\n\nMethods:\n- `configure(with:)` - Update terms data\n- `toggleAcceptance()` - Toggle acceptance state\n",
      "snapshots": [
        {
          "category": "AcceptanceStates",
          "light": "TermsAcceptanceView/__Snapshots__/TermsAcceptanceViewSnapshotTests/testTermsAcceptanceView_AcceptanceStates_Light.1.png",
          "dark": "TermsAcceptanceView/__Snapshots__/TermsAcceptanceViewSnapshotTests/testTermsAcceptanceView_AcceptanceStates_Dark.1.png"
        }
      ]
    },
    "TextSectionView": {
      "displayName": "Text Section View",
      "category": "Promotions",
      "subcategory": "ContentBlocks",
      "summary": "Simple title and description text block with customizable fonts, colors, and spacing",
      "description": "A simple content block component displaying a title and description in a vertical stack layout. Features configurable title (default: bold 12pt, textPrimary) and description (default: regular 12pt, textPrimary) with customizable text colors, fonts, and spacing (default 4pt). Both labels support multi-line text. Uses Combine bindings for reactive content updates. Ideal for promotional content sections, information blocks, and responsible gambling notices.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "text",
        "section",
        "title",
        "description",
        "block",
        "content",
        "promotional",
        "customizable"
      ],
      "states": [
        "default",
        "custom-fonts",
        "custom-colors",
        "custom-spacing"
      ],
      "similarTo": [
        "TitleBlockView",
        "DescriptionBlockView"
      ],
      "oftenUsedWith": [
        "ImageBlockView",
        "ActionButtonBlockView",
        "PromotionDetailView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# TextSectionView\n\nA simple title and description text section with customizable styling.\n\n## Overview\n\nTextSectionView displays a vertical layout with a bold title label above a regular description label. It supports full customization of fonts, colors, and spacing through the content model. The component is used for informational sections, disclaimers, and descriptive content blocks throughout the app.\n\n## Component Relationships\n\n### Used By (Parents)\n- Information screens\n- Settings sections\n- Footer areas\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Title label with customizable font and color\n- Description label with customizable font and color\n- Configurable vertical spacing between labels\n- Multiline support for both labels\n- Dynamic content updates\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet content = TextSectionContent(\n    title: \"One bet too many?\",\n    description: \"We want our players to have fun while gaming at Betsson...\"\n)\nlet viewModel = MockTextSectionViewModel(content: content)\nlet sectionView = TextSectionView(viewModel: viewModel)\n\n// Custom styling\nlet customContent = TextSectionContent(\n    title: \"Important Notice\",\n    description: \"Please read carefully before proceeding.\",\n    titleTextColor: StyleProvider.Color.alertError,\n    descriptionTextColor: StyleProvider.Color.textSecondary,\n    titleFont: StyleProvider.fontWith(type: .semibold, size: 16),\n    descriptionFont: StyleProvider.fontWith(type: .regular, size: 14),\n    spacing: 8\n)\nlet customView = TextSectionView(viewModel: MockTextSectionViewModel(content: customContent))\n\n// Update content dynamically\nviewModel.update(content: newContent)\n```\n\n## Data Model\n\n```swift\nstruct TextSectionContent {\n    let title: String\n    let description: String\n    let titleTextColor: UIColor\n    let descriptionTextColor: UIColor\n    let titleFont: UIFont\n    let descriptionFont: UIFont\n    let spacing: CGFloat\n}\n\nprotocol TextSectionViewModelProtocol {\n    var contentPublisher: AnyPublisher<TextSectionContent, Never> { get }\n}\n```\n\n## Styling\n\nDefault StyleProvider properties:\n- `StyleProvider.Color.textPrimary` - default title and description color\n- `StyleProvider.fontWith(type: .bold, size: 12)` - default title font\n- `StyleProvider.fontWith(type: .regular, size: 12)` - default description font\n\nLayout constants:\n- Stack axis: vertical\n- Stack alignment: fill\n- Stack distribution: fill\n- Default spacing: 4pt\n- Number of lines: 0 (unlimited for both labels)\n\nAll styling properties are customizable via TextSectionContent.\n\n## Mock ViewModels\n\nAvailable presets:\n- `.default` - Responsible gambling message with standard styling\n\nFactory methods:\n- `custom(title:description:titleColor:descriptionColor:titleFont:descriptionFont:spacing:)` - Fully customizable\n\nMethods:\n- `update(content:)` - Update content reactively\n",
      "snapshots": [
        {
          "category": "ContentVariants",
          "light": "TextSectionView/__Snapshots__/TextSectionViewSnapshotTests/testTextSectionView_ContentVariants_Light.1.png",
          "dark": "TextSectionView/__Snapshots__/TextSectionViewSnapshotTests/testTextSectionView_ContentVariants_Dark.1.png"
        }
      ]
    },
    "ThemeSwitcherView": {
      "displayName": "Theme Switcher View",
      "category": "Profile",
      "subcategory": "Settings",
      "summary": "Segmented control for switching between light, system, and dark themes with animated indicator",
      "description": "A composite segmented control component for theme selection with three options: Light, System, and Dark. Features a horizontal stack of ThemeSegmentView children within a 31pt fixed-height container with 8pt corner radius and backgroundPrimary background. Each segment displays a 14x14pt SF Symbol icon (sun.max.fill, lightbulb.fill, moon.fill) and semibold 14pt localized title with 4pt spacing and 8pt minimum horizontal padding. Selection indicator (highlightPrimary background) animates with 0.2s duration to slide behind the selected segment. Selected segment uses buttonTextPrimary color; unselected uses textPrimary. Tap on any segment triggers selection callback via viewModel.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "theme",
        "switcher",
        "segmented-control",
        "settings",
        "dark-mode",
        "light-mode",
        "animated",
        "preferences"
      ],
      "states": [
        "light-selected",
        "system-selected",
        "dark-selected"
      ],
      "similarTo": [
        "BetslipTypeSelectorView",
        "PillSelectorBarView"
      ],
      "oftenUsedWith": [
        "SettingsView",
        "ProfileView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# ThemeSwitcherView\n\nA segmented control for switching between Light, System, and Dark themes.\n\n## Overview\n\nThemeSwitcherView provides a three-segment horizontal control for selecting app theme mode. Each segment displays an icon (sun, lightbulb, moon) with a localized label. The selected segment is indicated by a sliding highlight background that animates on selection change. The component is used in settings screens for theme preference selection.\n\n## Component Relationships\n\n### Used By (Parents)\n- Settings screens\n- Theme preference panels\n\n### Uses (Children)\n- `ThemeSegmentView` (internal helper for each segment)\n\n## Features\n\n- Three theme modes: Light, System, Dark\n- SF Symbol icons for each mode\n- Animated sliding selection indicator\n- Localized segment labels\n- Rounded container with primary background\n- Theme selection callback\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockThemeSwitcherViewModel.defaultMock\nlet themeSwitcher = ThemeSwitcherView(viewModel: viewModel)\n\n// Custom initial theme\nlet darkVM = MockThemeSwitcherViewModel.darkThemeMock\nlet darkSwitcher = ThemeSwitcherView(viewModel: darkVM)\n\n// With callback\nlet callbackVM = MockThemeSwitcherViewModel.customCallbackMock(\n    initialTheme: .light\n) { theme in\n    applyTheme(theme)\n}\nlet callbackSwitcher = ThemeSwitcherView(viewModel: callbackVM)\n```\n\n## Data Model\n\n```swift\nenum ThemeMode: String, CaseIterable {\n    case light = \"light\"\n    case system = \"system\"\n    case dark = \"dark\"\n\n    var displayName: String    // Localized\n    var iconName: String       // SF Symbol name\n}\n\nprotocol ThemeSwitcherViewModelProtocol {\n    var selectedThemePublisher: AnyPublisher<ThemeMode, Never> { get }\n\n    func selectTheme(_ theme: ThemeMode)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundPrimary` - container background\n- `StyleProvider.Color.highlightPrimary` - selection indicator\n\nLayout constants:\n- Container height: 31pt\n- Container corner radius: 8pt\n- Stack spacing: 0pt\n- Stack distribution: fill (equal segments)\n\nSegment icons (SF Symbols):\n- Light: \"sun.max.fill\"\n- System: \"lightbulb.fill\"\n- Dark: \"moon.fill\"\n\nAnimation:\n- Selection indicator slides with 0.2s animation\n- Segment selection updates icon/text appearance\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - Starts with System theme\n- `.lightThemeMock` - Starts with Light theme\n- `.darkThemeMock` - Starts with Dark theme\n- `.interactiveMock` - Demo with console feedback\n\nFactory methods:\n- `.customCallbackMock(initialTheme:onThemeSelected:)` - Custom callback\n\nMethods:\n- `selectTheme(_ theme:)` - Select a theme mode\n- `setInitialTheme(_ theme:)` - Update initial theme for testing\n",
      "snapshots": [
        {
          "category": "ThemeStates",
          "light": "ThemeSwitcherView/__Snapshots__/ThemeSwitcherViewSnapshotTests/testThemeSwitcherView_ThemeStates_Light.1.png",
          "dark": "ThemeSwitcherView/__Snapshots__/ThemeSwitcherViewSnapshotTests/testThemeSwitcherView_ThemeStates_Dark.1.png"
        }
      ]
    },
    "TicketBetInfoView": {
      "displayName": "Ticket Bet Info View",
      "category": "Betting",
      "subcategory": "MyBets",
      "summary": "Complete bet ticket card displaying selections, financial summary, cashout controls, and settlement status",
      "description": "A complex composite component for displaying complete bet ticket information with cashout functionality. Structure includes: header section with semibold 14pt title, regular 10pt bet details, and 24x24pt navigation chevron; horizontal action buttons stack (Rebet and Cashout using ButtonIconView, 24pt height, 12pt corner radius); vertical tickets stack with TicketSelectionView instances (8pt spacing); financial summary section with Total Odds, Bet Amount, Possible Winnings labels (semibold 12pt) and values (semibold 14pt) separated by 1pt highlightPrimary divider; and optional bottom components (CashoutAmountView, CashoutSliderView, or full cashout ButtonView). For settled bets, displays BetTicketStatusView (won/lost/draw) as sibling to main container. Wrapper has 8pt padding and configurable 8pt corner radius (all, topOnly, bottomOnly via CornerRadiusStyle). Includes loading overlay for cashout operations, prepareForReuse() for cell recycling, and tap gestures on view and navigation button.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "ticket",
        "bet",
        "cashout",
        "mybets",
        "financial",
        "summary",
        "rebet",
        "settled",
        "pending",
        "won",
        "lost",
        "draw",
        "slider"
      ],
      "states": [
        "pending",
        "settled-won",
        "settled-lost",
        "settled-draw",
        "cashout-available",
        "cashout-loading",
        "partial-cashout",
        "full-cashout"
      ],
      "similarTo": [
        "BetslipTicketView"
      ],
      "oftenUsedWith": [
        "TicketSelectionView",
        "BetTicketStatusView",
        "CashoutSliderView",
        "CashoutAmountView",
        "ButtonIconView"
      ],
      "parents": [],
      "children": [
        "BetTicketStatusView",
        "ButtonIconView",
        "CashoutAmountView",
        "CashoutSliderView",
        "TicketSelectionView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# TicketBetInfoView\n\nA comprehensive betting ticket card displaying bet details, selections, financial summary, and cashout options.\n\n## Overview\n\nTicketBetInfoView displays complete information about a placed bet including header with title and bet ID, action buttons (rebet/cashout), ticket selections, financial summary (odds, stake, potential winnings), and optional cashout components. The component supports both pending and settled bet states with status indicators for won, lost, and draw outcomes. It includes loading overlay for cashout operations.\n\n## Component Relationships\n\n### Used By (Parents)\n- My Bets screens\n- Bet history views\n- Cashout flow screens\n\n### Uses (Children)\n- `BetTicketStatusView` - settled bet status display\n- `ButtonIconView` - rebet and cashout buttons\n- `TicketSelectionView` - individual selection cards\n- `CashoutAmountView` - partial cashout amount display\n- `CashoutSliderView` - cashout amount slider\n\n## Features\n\n- Header with bet title, details, and navigation button\n- Rebet and cashout action buttons\n- Multiple ticket selection display\n- Financial summary (total odds, bet amount, possible winnings)\n- Settled bet status indicator (won/lost/draw)\n- Cashout amount view for partial cashouts\n- Cashout slider for selecting cashout amount\n- Loading overlay during cashout operations\n- Configurable corner radius styles (all, top, bottom)\n- Cell reuse support with prepareForReuse()\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockTicketBetInfoViewModel.pendingMock()\nlet ticketView = TicketBetInfoView(viewModel: viewModel)\n\n// With corner radius style\nlet topCornersView = TicketBetInfoView(\n    viewModel: viewModel,\n    cornerRadiusStyle: .topOnly\n)\n\n// Handle callbacks\nviewModel.onNavigationTap = { navigateToBetDetails() }\nviewModel.onRebetTap = { rebetTicket() }\nviewModel.onCashoutTap = { initiateCashout() }\n\n// Reconfigure for cell reuse\nticketView.configure(with: newViewModel)\n```\n\n## Data Model\n\n```swift\nstruct TicketBetInfoData: Equatable {\n    let id: String\n    let title: String\n    let betDetails: String\n    let tickets: [TicketSelectionData]\n    let totalOdds: String\n    let betAmount: String\n    let possibleWinnings: String\n    let partialCashoutValue: String?\n    let cashoutTotalAmount: String?\n    let betStatus: BetTicketStatusData?\n    let isSettled: Bool\n}\n\nenum CornerRadiusStyle {\n    case all\n    case topOnly\n    case bottomOnly\n}\n\nprotocol TicketBetInfoViewModelProtocol {\n    var currentBetInfo: TicketBetInfoData { get }\n    var betInfoPublisher: AnyPublisher<TicketBetInfoData, Never> { get }\n\n    var rebetButtonViewModel: ButtonIconViewModelProtocol { get }\n    var cashoutButtonViewModel: ButtonIconViewModelProtocol { get }\n    var cashoutSliderViewModel: CashoutSliderViewModelProtocol? { get }\n    var cashoutAmountViewModel: CashoutAmountViewModelProtocol? { get }\n\n    var isCashoutLoading: Bool { get }\n    var isCashoutLoadingPublisher: AnyPublisher<Bool, Never> { get }\n    var cashoutComponentsDidChangePublisher: AnyPublisher<Void, Never> { get }\n\n    func handleNavigationTap()\n    func handleRebetTap()\n    func handleCashoutTap()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundPrimary` - wrapper background\n- `StyleProvider.Color.backgroundTertiary` - container background\n- `StyleProvider.Color.backgroundSecondary` - button backgrounds\n- `StyleProvider.Color.highlightPrimary` - navigation button, separator\n- `StyleProvider.Color.textPrimary` - title, value labels\n- `StyleProvider.Color.textSecondary` - bet details label\n- `StyleProvider.fontWith(type: .semibold, size: 14)` - title font\n- `StyleProvider.fontWith(type: .regular, size: 10)` - details font\n- `StyleProvider.fontWith(type: .semibold, size: 12)` - summary labels\n\nLayout constants:\n- Wrapper corner radius: 8pt\n- Main stack corner radius: 8pt\n- Container padding: 8pt from wrapper\n- Header padding: 8pt from container\n- Action buttons height: 24pt\n- Button corner radius: 12pt\n- Separator height: 1pt\n- Navigation button size: 24pt\n\n## Mock ViewModels\n\nAvailable presets:\n- `.pendingMock()` - Single pending bet\n- `.multipleTicketsMock()` - Multiple selections\n- `.longCompetitionNamesMock()` - Overflow text test\n- `.pendingMockWithCashout()` - With cashout amount view\n- `.pendingMockWithSlider()` - With cashout slider\n- `.pendingMockWithBoth()` - Both cashout components\n- `.wonBetMock()` - Settled won bet\n- `.lostBetMock()` - Settled lost bet\n- `.drawBetMock()` - Settled draw bet\n\nMethods:\n- `configure(with:)` - Reconfigure with new ViewModel\n- `prepareForReuse()` - Clear state for cell reuse\n- `updateBetInfo(_:)` - Update bet data reactively\n",
      "snapshots": []
    },
    "TicketSelectionView": {
      "displayName": "Ticket Selection View",
      "category": "Betting",
      "subcategory": "MyBets",
      "summary": "Individual bet selection card displaying match info, teams, scores, market, and odds with live indicator",
      "description": "A core betting component for displaying individual bet selections within a ticket. Container has backgroundSecondary background with 8pt corner radius and 8pt padding. Top section (20pt height) shows: left side with 16x16pt sport icon, 16x16pt country flag (8pt corner radius), and competition label (semibold 10pt, textSecondary); right side with either dateLabel (semibold 10pt), liveIndicatorView (highlightPrimary pill with LIVE text), or resultTagCapsuleView (won/lost/draw capsule using CapsuleView). Match section (40pt height) displays home/away team names (semibold 14pt) with scores visible only in live state. 1pt highlightPrimary separator divides match and betting info. Bottom section shows Market, Selection, and Odds labels with values (regular 12pt, textSecondary). Supports dynamic constraints for layout adaptation and updateResultTag method for settlement status display.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "ticket",
        "selection",
        "bet",
        "match",
        "odds",
        "live",
        "score",
        "market",
        "teams",
        "mybets",
        "capsule"
      ],
      "states": [
        "pre-live",
        "live",
        "won",
        "lost",
        "draw",
        "cashed-out"
      ],
      "similarTo": [
        "TallOddsMatchCardView",
        "CapsuleView"
      ],
      "oftenUsedWith": [
        "TicketBetInfoView",
        "CapsuleView",
        "BetTicketStatusView"
      ],
      "parents": [
        "TicketBetInfoView"
      ],
      "children": [
        "CapsuleView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# TicketSelectionView\n\nA ticket selection component for displaying match information with two distinct states: preLive and Live. The component shows competition details, team names, scores (only in live state), and either a date label or live indicator based on the match state.\n\n## Overview\n\n`TicketSelectionView` is designed for sports betting applications that need to display match tickets with different visual states. It follows the GomaUI architecture with protocol-based design, reactive data flow, and unified visual state management.\n\n## Features\n\n- **Dual State Support**: Automatically switches between preLive and Live states\n- **Competition Display**: Shows competition name with sport icon and country flag\n- **Team Information**: Displays home and away team names\n- **Dynamic Scoring**: Shows scores only in live state, hidden in preLive state\n- **State Indicators**: Date label for preLive matches, live indicator for live matches\n- **Reactive Updates**: Real-time data updates through Combine publishers\n- **Accessibility**: Full accessibility support with proper labels\n- **Theming**: Consistent styling through StyleProvider integration\n\n## Visual States\n\n### PreLive State\n- Shows competition info (sport icon, country flag, competition name)\n- Displays team names\n- Shows date/time information in top right\n- Scores are hidden\n- Orange separator line\n- Betting market information (Market, Selection, Odds, 0.00)\n\n### Live State\n- Shows competition info (sport icon, country flag, competition name)\n- Displays team names\n- Shows live scores (home - away format)\n- Displays orange \"LIVE\" indicator with circle icon in top right\n- Orange separator line\n- Betting market information (Market, Selection, Odds, 0.00)\n\n## Basic Usage\n\n```swift\n\n\n// Create with mock data\nlet viewModel = MockTicketSelectionViewModel.preLiveMock\nlet ticketView = TicketSelectionView(viewModel: viewModel)\n\n// Set up callbacks\nviewModel.onTicketTapped = {\n    // Handle ticket tap\n}\n\n// Add to your view hierarchy\nview.addSubview(ticketView)\nticketView.translatesAutoresizingMaskIntoConstraints = false\n```\n\n## Layout Structure\n\n```\n\n   Premier League                   20:00     PreLive State\n Manchester United                               \n Liverpool                                       \n  \n\n\n\n   La Liga                        [LIVE ]    Live State\n Barcelona                                       \n Atletico Madrid                          2 - 1  \n  \n\n```\n\n## Data Model\n\n```swift\npublic struct TicketSelectionData {\n    public let id: String\n    public let competitionName: String\n    public let homeTeamName: String\n    public let awayTeamName: String\n    public let homeScore: Int\n    public let awayScore: Int\n    public let matchDate: String\n    public let isLive: Bool\n    public let sportIcon: UIImage?\n    public let countryFlag: UIImage?\n    public let marketName: String\n    public let selectionName: String\n    public let oddsValue: String\n}\n```\n\n## Mock Examples\n\n### PreLive Matches\n```swift\n// Premier League match\nlet preLiveViewModel = MockTicketSelectionViewModel.preLiveMock\n\n// Champions League match\nlet championsLeagueViewModel = MockTicketSelectionViewModel.preLiveChampionsLeagueMock\n```\n\n### Live Matches\n```swift\n// Live match with scores\nlet liveViewModel = MockTicketSelectionViewModel.liveMock\n\n// Live draw\nlet liveDrawViewModel = MockTicketSelectionViewModel.liveDrawMock\n\n// High scoring live match\nlet highScoreViewModel = MockTicketSelectionViewModel.liveHighScoreMock\n```\n\n### Edge Cases\n```swift\n// Long team names\nlet longNamesViewModel = MockTicketSelectionViewModel.longTeamNamesMock\n\n// No icons\nlet noIconsViewModel = MockTicketSelectionViewModel.noIconsMock\n```\n\n## State Management\n\nThe component automatically handles state transitions:\n\n```swift\n// Toggle between preLive and Live states\nmockViewModel.toggleLiveState()\n\n// Update with new data\nlet newData = TicketSelectionData(...)\nmockViewModel.updateTicketData(newData)\n```\n\n## Customization\n\n### Colors\nAll colors are managed through `StyleProvider.Color`:\n- `backgroundCards`: Component background\n- `textPrimary`: Primary text (team names, scores)\n- `textSecondary`: Secondary text (competition, date)\n- `accent`: Live indicator background and separator\n- `textOnAccent`: Text on accent backgrounds\n\n### Fonts\nFonts are managed through `StyleProvider.fontWith`:\n- Team names: Bold, 16pt\n- Competition: Semibold, 14pt\n- Date: Medium, 12pt\n- Live indicator: Semibold, 10pt\n\n## SwiftUI Previews\n\nThe component includes comprehensive SwiftUI previews for development:\n\n```swift\n// In Xcode, use the Canvas to see all preview states\nTicketSelectionPreviewView_Previews\n```\n\n## Integration with Existing Components\n\nThis component follows the same architectural patterns as other GomaUI components:\n- Protocol-driven ViewModel design\n- Combine-based reactive updates\n- StyleProvider theming integration\n- Comprehensive mock implementations\n- SwiftUI preview support\n\n## Accessibility\n\n- Proper accessibility labels for all UI elements\n- VoiceOver support for screen readers\n- Dynamic Type support for text scaling\n- High contrast mode compatibility\n\n## Performance Considerations\n\n- Efficient constraint-based layout\n- Minimal view hierarchy\n- Combine-based reactive updates\n- Proper memory management with cancellables \n",
      "snapshots": []
    },
    "TimeSliderView": {
      "displayName": "Time Slider View",
      "category": "Filters",
      "subcategory": "Time",
      "summary": "Time filter slider with labeled options for filtering events by time period",
      "description": "A time filter component with a slider control for selecting time ranges. Container has backgroundTertiary background with 8pt corner radius. Header section (16pt top/left padding) contains horizontal stack (8pt spacing) with 16x16pt time icon and bold 12pt title label. UISlider with highlightPrimary minimum track color, systemGray5 maximum track, and custom thumb image (slider_handle_icon or 20pt circular fallback), positioned with 16pt horizontal margins. Time option labels (regular 12pt) distributed evenly along the track (6pt below slider). Selected option highlighted in highlightPrimary; others in textPrimary. Values snap to integers for discrete time options. Uses Combine bindings for reactive state updates.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "slider",
        "time",
        "filter",
        "range",
        "options",
        "track",
        "thumb",
        "discrete",
        "snap"
      ],
      "states": [
        "default",
        "selected-first",
        "selected-middle",
        "selected-last"
      ],
      "similarTo": [
        "CustomSliderView",
        "CashoutSliderView"
      ],
      "oftenUsedWith": [
        "SportGamesFilterView",
        "GeneralFilterBarView",
        "SortFilterView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# TimeSliderView\n\nA customizable time slider component for iOS that allows users to select from predefined time options using a slider interface.\n\n![TimeSliderView Preview](./preview.png)\n\n## Overview\n\nTimeSliderView is a UIKit-based component that provides an intuitive slider interface for time-based filtering. It displays time options as labels below the slider and visually highlights the currently selected option.\n\n## Features\n\n-  **Customizable Time Options**: Define your own time intervals and labels\n-  **Visual Feedback**: Selected time option is highlighted with accent color\n-  **Reactive Design**: Uses Combine framework for reactive state management\n-  **Custom Styling**: Integrates with StyleProvider for consistent theming\n-  **Accessibility**: Proper label positioning and readable fonts\n-  **Preview Support**: Includes SwiftUI preview for development\n\n## Architecture\n\nThe component follows MVVM architecture pattern:\n\n```\nTimeSliderView (UIView)\n    \nTimeSliderViewModelProtocol\n    \nMockTimeSliderViewModel (Concrete Implementation)\n    \nTimeOption (Data Model)\n```\n\n## Files Structure\n\n```\nTimeSliderView/\n TimeSliderView.swift                    # Main UI component\n TimeSliderViewModelProtocol.swift       # View model protocol\n MockTimeSliderViewModel.swift           # Mock implementation\n Models/\n    TimeSliderViewModels.swift         # Data models\n README.md                              # This file\n```\n\n## Usage\n\n### Basic Implementation\n\n```swift\n\n\n// 1. Create time options\nlet timeOptions = [\n    TimeOption(title: \"All\", value: 0),\n    TimeOption(title: \"1h\", value: 1),\n    TimeOption(title: \"8h\", value: 8),\n    TimeOption(title: \"Today\", value: 24),\n    TimeOption(title: \"48h\", value: 48)\n]\n\n// 2. Create view model\nlet viewModel = MockTimeSliderViewModel(\n    title: \"Filter by Time\",\n    timeOptions: timeOptions,\n    selectedValue: 0\n)\n\n// 3. Create and configure the view\nlet timeSliderView = TimeSliderView(viewModel: viewModel)\ntimeSliderView.translatesAutoresizingMaskIntoConstraints = false\n\n// 4. Handle value changes\ntimeSliderView.onSliderValueChange = { selectedValue in\n    let selectedIndex = Int(selectedValue)\n    let selectedOption = timeOptions[selectedIndex]\n    print(\"Selected: \\(selectedOption.title) - Value: \\(selectedOption.value)\")\n}\n\n// 5. Add to your view hierarchy\nview.addSubview(timeSliderView)\nNSLayoutConstraint.activate([\n    timeSliderView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 20),\n    timeSliderView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 16),\n    timeSliderView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -16)\n])\n```\n\n### Reactive Implementation with Combine\n\n```swift\nimport Combine\n\nclass FilterViewController: UIViewController {\n    private var cancellables = Set<AnyCancellable>()\n    private let timeSliderView: TimeSliderView\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        \n        // Subscribe to value changes\n        timeSliderView.viewModel.selectedTimeValue\n            .sink { [weak self] value in\n                self?.handleTimeSelectionChange(value)\n            }\n            .store(in: &cancellables)\n    }\n    \n    private func handleTimeSelectionChange(_ value: Float) {\n        // Handle the selection change\n    }\n}\n```\n\n## API Reference\n\n### TimeSliderView\n\nThe main UI component that displays the time slider interface.\n\n#### Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `onSliderValueChange` | `((Float) -> Void)?` | Callback triggered when slider value changes |\n\n#### Methods\n\n| Method | Description |\n|--------|-------------|\n| `init(viewModel: TimeSliderViewModelProtocol)` | Initializes the view with a view model |\n\n### TimeSliderViewModelProtocol\n\nProtocol defining the interface for time slider view models.\n\n#### Required Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `title` | `String` | The title displayed at the top of the component |\n| `timeOptions` | `[TimeOption]` | Array of available time options |\n| `selectedTimeValue` | `CurrentValueSubject<Float, Never>` | Reactive property for selected value |\n\n#### Required Methods\n\n| Method | Description |\n|--------|-------------|\n| `didChangeValue(_ value: Float)` | Called when the slider value changes |\n\n### MockTimeSliderViewModel\n\nConcrete implementation of `TimeSliderViewModelProtocol` for testing and development.\n\n#### Initializer\n\n```swift\npublic init(\n    title: String, \n    timeOptions: [TimeOption], \n    selectedValue: Float = 0\n)\n```\n\n### TimeOption\n\nData model representing a time option in the slider.\n\n#### Properties\n\n| Property | Type | Description |\n|----------|------|-------------|\n| `title` | `String` | Display label for the time option |\n| `value` | `Float` | Actual time value (e.g., hours, days) |\n\n#### Initializer\n\n```swift\npublic init(title: String, value: Float)\n```\n\n## Customization\n\n### Styling\n\nThe component uses `StyleProvider` for consistent theming. You can customize:\n\n- **Colors**: Accent color, text colors, track colors\n- **Fonts**: Title and label fonts\n- **Spacing**: Margins and padding\n\n### Custom Time Options\n\nCreate custom time intervals based on your needs:\n\n```swift\n// Minutes-based intervals\nlet minuteOptions = [\n    TimeOption(title: \"Now\", value: 0),\n    TimeOption(title: \"15m\", value: 15),\n    TimeOption(title: \"30m\", value: 30),\n    TimeOption(title: \"1h\", value: 60)\n]\n\n// Day-based intervals\nlet dayOptions = [\n    TimeOption(title: \"Today\", value: 0),\n    TimeOption(title: \"3 days\", value: 3),\n    TimeOption(title: \"1 week\", value: 7),\n    TimeOption(title: \"1 month\", value: 30)\n]\n```\n\n### Custom View Model\n\nImplement your own view model for advanced functionality:\n\n```swift\nclass NetworkTimeSliderViewModel: TimeSliderViewModelProtocol {\n    let title: String = \"Network Time Filter\"\n    let timeOptions: [TimeOption]\n    let selectedTimeValue: CurrentValueSubject<Float, Never>\n    \n    init(options: [TimeOption]) {\n        self.timeOptions = options\n        self.selectedTimeValue = .init(0)\n    }\n    \n    func didChangeValue(_ value: Float) {\n        let roundedValue = round(value)\n        selectedTimeValue.send(roundedValue)\n        \n        // Trigger network request with new time filter\n        fetchDataWithTimeFilter(roundedValue)\n    }\n    \n    private func fetchDataWithTimeFilter(_ timeValue: Float) {\n        // Implement your network logic\n    }\n}\n```\n\n## Integration Examples\n\n### Filter Screen Integration\n\n```swift\nclass FiltersViewController: UIViewController {\n    private let timeSliderView: TimeSliderView\n    \n    override func viewDidLoad() {\n        super.viewDidLoad()\n        setupTimeSlider()\n    }\n    \n    private func setupTimeSlider() {\n        // Add to stack view or container\n        stackView.addArrangedSubview(timeSliderView)\n        \n        // Configure constraints\n        timeSliderView.heightAnchor.constraint(equalToConstant: 100).isActive = true\n    }\n}\n```\n\n### Navigation Integration\n\n```swift\n// Pass selected time value between view controllers\nlet selectedTimeValue = timeSliderView.viewModel.selectedTimeValue.value\nlet nextVC = ResultsViewController(timeFilter: selectedTimeValue)\nnavigationController?.pushViewController(nextVC, animated: true)\n```\n\n## Best Practices\n\n1. **Limit Options**: Keep time options to 3-7 items for optimal UX\n2. **Clear Labels**: Use concise, understandable time labels\n3. **Logical Order**: Arrange time options in ascending or logical order\n4. **Default Selection**: Set a sensible default value\n5. **Feedback**: Provide visual feedback for selection changes\n\n## Accessibility\n\nThe component includes accessibility features:\n\n- Proper label positioning for readability\n- Color contrast compliance through StyleProvider\n- Semantic font sizing\n- Touch target optimization\n\n## Requirements\n\n- iOS 13.0+\n- Swift 5.0+\n- UIKit\n- Combine framework\n\n## Dependencies\n\n- `StyleProvider`: For consistent theming and colors\n- `Combine`: For reactive programming\n\n## Notes\n\n- The slider uses index-based values (0, 1, 2, etc.) internally\n- The `value` property in `TimeOption` represents the actual time value\n- Layout updates automatically when the view bounds change\n- Component is fully compatible with Auto Layout\n\n## Contributing\n\nWhen contributing to this component:\n\n1. Maintain the existing architecture pattern\n2. Add tests for new functionality\n3. Update this README with any API changes\n4. Follow the established naming conventions\n5. Ensure backward compatibility\n\n## License\n\nThis component is part of the GomaUI library. See the main library license for details. \n",
      "snapshots": [
        {
          "category": "SliderStates",
          "light": "TimeSliderView/__Snapshots__/TimeSliderViewSnapshotTests/testTimeSliderView_SliderStates_Light.1.png",
          "dark": "TimeSliderView/__Snapshots__/TimeSliderViewSnapshotTests/testTimeSliderView_SliderStates_Dark.1.png"
        }
      ]
    },
    "TitleBlockView": {
      "displayName": "Title Block View",
      "category": "Promotions",
      "subcategory": "ContentBlocks",
      "summary": "Simple title label block for promotional content with configurable alignment",
      "description": "A simple title display component for CMS promotional content blocks. Features a semibold 24pt multi-line label with highlightSecondaryContrast text color. Supports configurable text alignment (center or left) via the isCentered property. Layout has 15pt horizontal padding and 5pt vertical padding with clear background. Ideal for promotion titles, welcome bonuses, and section headers in promotional detail views.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "title",
        "block",
        "promotional",
        "header",
        "text",
        "alignment",
        "cms"
      ],
      "states": [
        "centered",
        "left-aligned"
      ],
      "similarTo": [
        "DescriptionBlockView",
        "TextSectionView"
      ],
      "oftenUsedWith": [
        "DescriptionBlockView",
        "ImageBlockView",
        "ActionButtonBlockView",
        "PromotionDetailView"
      ],
      "parents": [
        "StackViewBlockView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# TitleBlockView\n\nA simple title block component for displaying promotional or section headings.\n\n## Overview\n\nTitleBlockView displays a large title label with configurable text alignment (centered or left-aligned). It uses a semibold font at 24pt with the secondary contrast highlight color. The component is designed for promotional banners, welcome messages, and section headings within stack-based layouts.\n\n## Component Relationships\n\n### Used By (Parents)\n- `StackViewBlockView` - CMS block containers\n- Promotional screens\n- Welcome sections\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Large semibold title text (24pt)\n- Configurable text alignment (center or left)\n- Multi-line support\n- Clear background\n- Used in CMS stack-based layouts\n\n## Usage\n\n```swift\nlet viewModel = MockTitleBlockViewModel(title: \"Welcome Bonus\")\nlet titleBlock = TitleBlockView(viewModel: viewModel)\n\n// Centered title (default)\nlet centered = TitleBlockView(\n    viewModel: MockTitleBlockViewModel(\n        title: \"Centered Title\",\n        isCentered: true\n    )\n)\n\n// Left-aligned title\nlet leftAligned = TitleBlockView(\n    viewModel: MockTitleBlockViewModel(\n        title: \"Left Aligned Title\",\n        isCentered: false\n    )\n)\n\n// Long promotional title\nlet promo = TitleBlockView(\n    viewModel: MockTitleBlockViewModel(\n        title: \"Amazing Welcome Bonus Promotion\"\n    )\n)\n```\n\n## Data Model\n\n```swift\nprotocol TitleBlockViewModelProtocol {\n    var title: String { get }\n    var isCentered: Bool { get }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.highlightSecondaryContrast` - title text color\n- `StyleProvider.fontWith(type: .semibold, size: 24)` - title font\n\nLayout constants:\n- Leading padding: 15pt\n- Trailing padding: 15pt\n- Top padding: 5pt\n- Bottom padding: 5pt\n- Number of lines: 0 (unlimited)\n- Background: clear\n\nText alignment:\n- Centered: `.center` (when `isCentered` is true)\n- Left-aligned: `.left` (when `isCentered` is false)\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - \"Welcome Bonus\" centered\n- `.centeredMock` - \"Centered Title\" centered\n- `.leftAlignedMock` - \"Left Aligned Title\" left\n- `.longTitleMock` - \"Amazing Welcome Bonus Promotion\"\n\nFactory initialization:\n```swift\nMockTitleBlockViewModel(\n    title: String,\n    isCentered: Bool = true\n)\n```\n",
      "snapshots": []
    },
    "ToasterView": {
      "displayName": "Toaster View",
      "category": "Status",
      "subcategory": "Toast",
      "summary": "Floating toast notification with optional icon and message for brief feedback",
      "description": "A floating toast notification component for displaying brief feedback messages. Features a container with 12pt corner radius and subtle shadow (black, 0.15 opacity, 4pt vertical offset, 8pt blur radius). Horizontal stack layout (12pt spacing, center aligned) with optional 20x20pt icon (supports named images or SF Symbols) and regular 16pt single-line title label. Layout has 16pt horizontal padding and 20pt vertical padding. Customizable background color (default: backgroundTertiary), title color (default: textPrimary), icon color (default: highlightPrimary), and corner radius. Uses CombineSchedulers for testable scheduler injection (.immediate for synchronous test execution).",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "toast",
        "notification",
        "floating",
        "feedback",
        "icon",
        "message",
        "shadow",
        "scheduler",
        "testable"
      ],
      "states": [
        "with-icon",
        "without-icon",
        "success",
        "error",
        "info"
      ],
      "similarTo": [
        "StatusNotificationView",
        "AlertBannerView"
      ],
      "oftenUsedWith": [
        "BetslipView",
        "DepositView",
        "BookingCodeView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# ToasterView\n\nA toast notification banner with icon and message for displaying brief feedback.\n\n## Overview\n\nToasterView displays a temporary notification banner with an optional leading icon and title text. It features a rounded container with drop shadow for visual prominence. The component supports customizable background color, text color, icon color, and corner radius. It is used to show confirmation messages, success feedback, or brief alerts.\n\n## Component Relationships\n\n### Used By (Parents)\n- Toast presentation managers\n- Feedback notification systems\n- Confirmation displays\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Rounded container with drop shadow\n- Optional leading icon (bundle or SF Symbol)\n- Title text label\n- Customizable background color\n- Customizable text and icon colors\n- Configurable corner radius\n- Horizontal icon + text layout\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet data = ToasterData(\n    title: \"Booking Code Loaded\",\n    icon: \"checkmark\",\n    backgroundColor: .white,\n    titleColor: StyleProvider.Color.textPrimary,\n    iconColor: .systemGreen,\n    cornerRadius: 14\n)\nlet viewModel = MockToasterViewModel(data: data)\nlet toaster = ToasterView(viewModel: viewModel)\n\n// Success toast\nlet successData = ToasterData(\n    title: \"Bet Placed Successfully\",\n    icon: \"checkmark.circle.fill\",\n    backgroundColor: StyleProvider.Color.backgroundTertiary,\n    iconColor: .systemGreen\n)\nlet successToast = ToasterView(viewModel: MockToasterViewModel(data: successData))\n\n// Error toast\nlet errorData = ToasterData(\n    title: \"Something went wrong\",\n    icon: \"exclamationmark.triangle.fill\",\n    backgroundColor: StyleProvider.Color.backgroundTertiary,\n    iconColor: .systemRed\n)\nlet errorToast = ToasterView(viewModel: MockToasterViewModel(data: errorData))\n\n// Update toast dynamically\nviewModel.update(newData)\n```\n\n## Data Model\n\n```swift\nstruct ToasterData: Equatable {\n    let title: String\n    let icon: String?\n    let backgroundColor: UIColor\n    let titleColor: UIColor\n    let iconColor: UIColor\n    let cornerRadius: CGFloat\n}\n\nprotocol ToasterViewModelProtocol {\n    var dataPublisher: AnyPublisher<ToasterData, Never> { get }\n    var currentData: ToasterData { get }\n}\n```\n\n## Styling\n\nDefault StyleProvider properties:\n- `StyleProvider.Color.backgroundTertiary` - default background\n- `StyleProvider.Color.textPrimary` - default title color\n- `StyleProvider.Color.highlightPrimary` - default icon color\n- `StyleProvider.fontWith(type: .regular, size: 16)` - title font\n\nLayout constants:\n- Container corner radius: 12pt (customizable)\n- Stack horizontal padding: 16pt\n- Stack vertical padding: 20pt\n- Icon to title spacing: 12pt\n- Icon size: 20pt x 20pt\n- Title lines: 1\n\nShadow properties:\n- Color: black\n- Opacity: 0.15\n- Offset: (0, 4)\n- Radius: 8pt\n\nIcon resolution:\n1. Try bundle image with name\n2. Fallback to SF Symbol\n3. Hide if neither found\n\n## Mock ViewModels\n\nDefault initialization:\n```swift\nMockToasterViewModel()\n// Creates: \"Booking Code Loaded\" with checkmark icon\n```\n\nCustom initialization:\n```swift\nMockToasterViewModel(data: ToasterData)\n```\n\nMethods:\n- `update(_:)` - Update toast data reactively\n",
      "snapshots": [
        {
          "category": "ToasterVariants",
          "light": "ToasterView/__Snapshots__/ToasterViewSnapshotTests/testToasterView_ToasterVariants_Light.1.png",
          "dark": "ToasterView/__Snapshots__/ToasterViewSnapshotTests/testToasterView_ToasterVariants_Dark.1.png"
        }
      ]
    },
    "TopBannerSliderView": {
      "displayName": "Top Banner Slider View",
      "category": "Promotions",
      "subcategory": "Carousel",
      "summary": "Full-width horizontal banner carousel with page indicators supporting multiple banner types",
      "description": "A complex composite carousel component for displaying promotional banners with horizontal paging. Fixed 140pt height with full-width horizontal paging collection view. Supports multiple BannerType variants: .info and .casino (both using SingleButtonBannerView cells) and .match (using MatchBannerView cells). Page control positioned top-right (9pt from top, 11pt from right) with highlightPrimary indicator color and automatic hiding for single-page scenarios. Features synchronous initial render for proper sizing with async updates for reactive state changes. Callbacks for onBannerTapped and onPageChanged. Visibility and user interaction can be controlled via display state. Uses wrapper cells (SingleButtonBannerViewCell, MatchBannerViewCell) for collection view integration.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "banner",
        "carousel",
        "slider",
        "paging",
        "promotions",
        "page-control",
        "collection-view",
        "horizontal",
        "full-width"
      ],
      "states": [
        "visible",
        "hidden",
        "interaction-enabled",
        "interaction-disabled",
        "single-page",
        "multi-page"
      ],
      "similarTo": [
        "SuggestedBetsExpandedView",
        "CarouselView"
      ],
      "oftenUsedWith": [
        "SingleButtonBannerView",
        "MatchBannerView",
        "HomeView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# TopBannerSliderView\n\nA horizontal collection view container that displays multiple TopBannerProtocol-compliant banner views with page indicators, auto-scroll functionality, and smooth transitions. Perfect for promotional content, announcements, and featured information.\n\n## Features\n\n- **Horizontal scrolling** - Smooth paging between banner items\n- **Page indicators** - Dots in the top-right corner showing current position\n- **Auto-scroll support** - Optional automatic progression through banners\n- **Full-width banners** - Each banner takes the full width and height of the container\n- **TopBannerProtocol compliance** - Works with any UIView that implements TopBannerViewProtocol\n- **Visibility management** - Automatically filters out non-visible banners\n- **MVVM architecture** - Clean separation with reactive updates\n- **Factory pattern** - Lazy loading of banner views for performance\n\n## Usage Example\n\n```swift\n\n\n// Create banner view factories\nlet bannerFactories = [\n    BannerViewFactory(id: \"welcome_banner\") {\n        let viewModel = MockSingleButtonBannerViewModel.defaultMock\n        return SingleButtonBannerView(viewModel: viewModel)\n    },\n    BannerViewFactory(id: \"promo_banner\") {\n        let viewModel = MockSingleButtonBannerViewModel.customStyledMock\n        return SingleButtonBannerView(viewModel: viewModel)\n    },\n    BannerViewFactory(id: \"info_banner\") {\n        let viewModel = MockSingleButtonBannerViewModel.noButtonMock\n        return SingleButtonBannerView(viewModel: viewModel)\n    }\n]\n\n// Create slider data\nlet sliderData = TopBannerSliderData(\n    bannerViewFactories: bannerFactories,\n    isAutoScrollEnabled: true,\n    autoScrollInterval: 5.0,\n    showPageIndicators: true,\n    currentPageIndex: 0\n)\n\n// Create view model\nlet viewModel = MockTopBannerSliderViewModel(sliderData: sliderData)\n\n// Create the slider view\nlet sliderView = TopBannerSliderView(viewModel: viewModel)\n\n// Add to your view hierarchy\nparentView.addSubview(sliderView)\nsliderView.translatesAutoresizingMaskIntoConstraints = false\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    sliderView.leadingAnchor.constraint(equalTo: parentView.leadingAnchor),\n    sliderView.trailingAnchor.constraint(equalTo: parentView.trailingAnchor),\n    sliderView.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor),\n    sliderView.heightAnchor.constraint(equalToConstant: 200)\n])\n\n// Handle events\nsliderView.onBannerTapped = { index in\n    print(\"Banner at index \\(index) was tapped\")\n    // Handle banner tap\n}\n\nsliderView.onPageChanged = { pageIndex in\n    print(\"Scrolled to page \\(pageIndex)\")\n    // Handle page change\n}\n```\n\n## Configuration Options\n\n### TopBannerSliderData\n\nThe main data model for configuring the slider:\n\n```swift\nlet sliderData = TopBannerSliderData(\n    bannerViewFactories: bannerFactories,    // Array of banner view factories\n    isAutoScrollEnabled: true,               // Enable automatic scrolling\n    autoScrollInterval: 5.0,                 // Seconds between auto-scroll\n    showPageIndicators: true,                // Show dots in top-right\n    currentPageIndex: 0                      // Starting page index\n)\n```\n\n### BannerViewFactory\n\nFactory pattern for creating banner views:\n\n```swift\nlet factory = BannerViewFactory(id: \"unique_banner_id\") {\n    // Return any UIView that conforms to TopBannerViewProtocol\n    let viewModel = YourBannerViewModel()\n    return YourBannerView(viewModel: viewModel)\n}\n```\n\n### TopBannerViewProtocol\n\nProtocol that banner views must implement:\n\n```swift\npublic protocol TopBannerViewProtocol: UIView, TopBannerProtocol {\n    func bannerDidBecomeVisible()    // Called when banner becomes visible\n    func bannerDidBecomeHidden()     // Called when banner becomes hidden\n}\n```\n\n## Layout Behavior\n\n- **Full-width banners**: Each banner occupies the full width and height of the slider\n- **Page indicators**: Positioned in the top-right corner with 16pt margins\n- **Horizontal scrolling**: Paging enabled for smooth transitions\n- **Auto-scroll**: Automatically advances to the next banner when enabled\n- **Visibility filtering**: Only visible banners (isVisible = true) are displayed\n\n## Auto-Scroll Features\n\n### Enabling Auto-Scroll\n\n```swift\nlet sliderData = TopBannerSliderData(\n    bannerViewFactories: factories,\n    isAutoScrollEnabled: true,\n    autoScrollInterval: 3.0,  // 3 seconds between transitions\n    showPageIndicators: true,\n    currentPageIndex: 0\n)\n```\n\n### Controlling Auto-Scroll\n\n```swift\n// Start auto-scroll programmatically\nsliderView.startAutoScroll()\n\n// Stop auto-scroll\nsliderView.stopAutoScroll()\n\n// Auto-scroll automatically stops when user interacts with the slider\n// and resumes after a brief pause\n```\n\n## Page Indicators\n\nThe page indicators (dots) appear in the top-right corner and:\n\n- Show the current position among all banners\n- Are automatically hidden for single banners\n- Use StyleProvider colors for consistency\n- Can be disabled via `showPageIndicators: false`\n- Are tappable to jump to specific pages\n\n## Mock View Models\n\nSeveral mock implementations are provided for testing and previews:\n\n### Available Mocks\n\n```swift\n// Default slider with multiple banners\nlet defaultMock = MockTopBannerSliderViewModel.defaultMock\n\n// Single banner (no page indicators shown)\nlet singleBannerMock = MockTopBannerSliderViewModel.singleBannerMock\n\n// Auto-scrolling slider\nlet autoScrollMock = MockTopBannerSliderViewModel.autoScrollMock\n\n// Slider without page indicators\nlet noIndicatorsMock = MockTopBannerSliderViewModel.noIndicatorsMock\n\n// Slider with disabled user interaction\nlet disabledMock = MockTopBannerSliderViewModel.disabledInteractionMock\n```\n\n### Creating Custom Mocks\n\n```swift\nlet customFactories = [\n    BannerViewFactory(id: \"custom_1\") {\n        // Your custom banner view\n        return CustomBannerView()\n    },\n    BannerViewFactory(id: \"custom_2\") {\n        // Another custom banner view\n        return AnotherCustomBannerView()\n    }\n]\n\nlet customSliderData = TopBannerSliderData(\n    bannerViewFactories: customFactories,\n    isAutoScrollEnabled: false,\n    autoScrollInterval: 4.0,\n    showPageIndicators: true,\n    currentPageIndex: 0\n)\n\nlet customMock = MockTopBannerSliderViewModel(sliderData: customSliderData)\n```\n\n## Performance Considerations\n\n- **Factory pattern**: Banner views are created lazily when needed\n- **Visibility filtering**: Non-visible banners are excluded from the collection view\n- **Memory management**: Banner views are properly cleaned up when scrolled out of view\n- **Auto-scroll optimization**: Timer is automatically managed and cleaned up\n\n## Integration with Other Banner Types\n\nThe slider works with any UIView that implements TopBannerViewProtocol:\n\n```swift\n// Example with different banner types\nlet mixedFactories = [\n    BannerViewFactory(id: \"single_button\") {\n        SingleButtonBannerView(viewModel: singleButtonViewModel)\n    },\n    BannerViewFactory(id: \"image_only\") {\n        ImageOnlyBannerView(viewModel: imageViewModel)\n    },\n    BannerViewFactory(id: \"video_banner\") {\n        VideoBannerView(viewModel: videoViewModel)\n    }\n]\n```\n\n## Styling Customization\n\nThe component uses StyleProvider for consistent theming:\n\n```swift\n// Page indicators use:\nStyleProvider.Color.highlightPrimary                    // For current page indicator\nStyleProvider.Color.highlightPrimary.withAlphaComponent(0.3)  // For inactive indicators\n\n// Background uses:\nStyleProvider.Color.backgroundPrimary                 // For slider background\n```\n\n## Accessibility\n\nThe component includes built-in accessibility support:\n\n- Page control is accessible with proper labels\n- Banner views maintain their individual accessibility\n- VoiceOver navigation works seamlessly\n- Page indicators announce current position\n\n## Collection View Integration\n\nFor use within UICollectionView layouts, use the provided wrapper cell:\n\n### TopBannerSliderCollectionViewCell\n\n```swift\n\n\n// Register the cell\ncollectionView.register(TopBannerSliderCollectionViewCell.self, forCellWithReuseIdentifier: \"TopBannerCell\")\n\n// Configure in cellForItemAt\nfunc collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {\n    let cell = collectionView.dequeueReusableCell(withReuseIdentifier: \"TopBannerCell\", for: indexPath) as! TopBannerSliderCollectionViewCell\n    \n    // Configure with your view model\n    cell.configure(with: topBannerSliderViewModel)\n    \n    // Setup callbacks\n    cell.onBannerTapped = { bannerIndex in\n        print(\"Banner tapped at index: \\(bannerIndex)\")\n        // Handle banner tap navigation\n    }\n    \n    cell.onPageChanged = { pageIndex in\n        print(\"Page changed to: \\(pageIndex)\")\n        // Handle page change if needed\n    }\n    \n    return cell\n}\n\n// Size for collection view layout\nfunc collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {\n    return CGSize(width: collectionView.bounds.width, height: 200)\n}\n```\n\n### Collection View Cell Features\n\n- **Automatic cleanup**: Properly handles reuse and memory management\n- **Callback forwarding**: All TopBannerSliderView callbacks are available\n- **Configuration support**: Works with any TopBannerSliderViewModelProtocol\n- **Placeholder handling**: Falls back to mock data when no viewModel provided\n\n## Requirements\n\n- iOS 15.0+\n- Swift 5.7+\n- UIKit framework\n- Banner views must conform to TopBannerViewProtocol \n",
      "snapshots": [
        {
          "category": "BannerVariants",
          "light": "TopBannerSliderView/__Snapshots__/TopBannerSliderViewSnapshotTests/testTopBannerSliderView_BannerVariants_Light.1.png",
          "dark": "TopBannerSliderView/__Snapshots__/TopBannerSliderViewSnapshotTests/testTopBannerSliderView_BannerVariants_Dark.1.png"
        }
      ]
    },
    "TransactionItemView": {
      "displayName": "Transaction Item View",
      "category": "Wallet",
      "subcategory": "History",
      "summary": "Three-row transaction card displaying category, status badge, amount, ID, date, and balance",
      "description": "A composite transaction card for wallet history displaying complete transaction details in three 44pt-height rows. Wrapper has backgroundPrimary with 12pt padding; inner container has backgroundTertiary with 8pt corner radius. Header row shows category label (regular 14pt), status badge pill (24pt height, 12pt corner radius) with type-specific colors (won=green, placed=highlight, etc.), and amount (medium 14pt, alertSuccess for positive or highlightTertiary for negative). Transaction ID row displays ID (medium 14pt) with copy button (24x24pt doc.on.clipboard icon). Footer row shows formatted date (medium 14pt) and balance with attributed string (prefix medium + amount bold). Rows separated by 1pt separatorLine dividers. Supports TransactionCornerRadiusStyle (all, topOnly, bottomOnly, none) for list grouping.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "transaction",
        "wallet",
        "history",
        "deposit",
        "bet",
        "status-badge",
        "copy",
        "balance",
        "amount",
        "corner-radius"
      ],
      "states": [
        "won",
        "placed",
        "tax",
        "pending",
        "cancelled",
        "positive-amount",
        "negative-amount"
      ],
      "similarTo": [
        "TicketBetInfoView",
        "WalletDetailView"
      ],
      "oftenUsedWith": [
        "WalletStatusView",
        "TransactionVerificationView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# TransactionItemView\n\nA transaction history item card displaying category, status, amount, transaction ID, date, and balance.\n\n## Overview\n\nTransactionItemView displays a single transaction record with three rows: header (category, status badge, amount), transaction ID row with copy button, and footer (date, balance). It supports various transaction types including deposits, withdrawals, bets placed, bets won, and tax deductions. The component includes a status badge with color-coded backgrounds and configurable corner radius styles for use in grouped lists.\n\n## Component Relationships\n\n### Used By (Parents)\n- Transaction history screens\n- Wallet detail views\n- Account statement lists\n\n### Uses (Children)\n- None (leaf component)\n\n## Features\n\n- Three-row layout (header, ID, footer)\n- Status badge with color-coded backgrounds\n- Amount display with +/- prefix and color\n- Transaction ID with copy-to-clipboard button\n- Date and balance display\n- Configurable corner radius (all, top, bottom, none)\n- Optional balance row (hidden when nil)\n- Cell reuse support with reset()\n- TableViewCell wrapper available\n\n## Usage\n\n```swift\nlet viewModel = MockTransactionItemViewModel.depositMock\nlet transactionView = TransactionItemView(viewModel: viewModel)\n\n// With corner radius style for grouped lists\nlet topCard = TransactionItemView(\n    viewModel: viewModel,\n    cornerRadiusStyle: .topOnly\n)\n\n// Reconfigure for cell reuse\ntransactionView.configure(with: newViewModel)\n\n// Update corner style only\ntransactionView.configure(with: .bottomOnly)\n\n// Reset for reuse\ntransactionView.reset()\n```\n\n## Data Model\n\n```swift\nstruct TransactionItemData {\n    let id: String\n    let category: String\n    let status: TransactionStatus?\n    let amount: Double\n    let currency: String\n    let transactionId: String\n    let date: Date\n    let balance: Double?\n    let isPositive: Bool\n    let amountIndicator: String?\n\n    var formattedAmount: String\n    var formattedDate: String\n    var formattedBalance: String\n}\n\nenum TransactionStatus {\n    case placed\n    case won\n    case lost\n    case tax\n\n    var displayName: String\n    var backgroundColor: UIColor\n    var textColor: UIColor\n}\n\nenum TransactionCornerRadiusStyle {\n    case all\n    case topOnly\n    case bottomOnly\n    case none\n}\n\nprotocol TransactionItemViewModelProtocol {\n    var data: TransactionItemData? { get }\n    var balancePrefix: String { get }\n    var balanceAmount: String { get }\n\n    func copyTransactionId()\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundPrimary` - wrapper background\n- `StyleProvider.Color.backgroundTertiary` - container background\n- `StyleProvider.Color.highlightTertiary` - category label, negative amounts\n- `StyleProvider.Color.alertSuccess` - positive amounts\n- `StyleProvider.Color.textPrimary` - transaction ID\n- `StyleProvider.Color.textSecondary` - copy button tint\n- `StyleProvider.Color.iconSecondary` - date, balance labels\n- `StyleProvider.Color.separatorLine` - row separators\n- `StyleProvider.fontWith(type: .regular, size: 14)` - category font\n- `StyleProvider.fontWith(type: .medium, size: 12)` - status badge font\n- `StyleProvider.fontWith(type: .medium, size: 14)` - amount, ID, date fonts\n- `StyleProvider.fontWith(type: .bold, size: 14)` - balance amount font\n\nLayout constants:\n- Wrapper padding: 12pt all sides\n- Container corner radius: 8pt\n- Row heights: 44pt each\n- Horizontal padding: 16pt\n- Status badge corner radius: 12pt\n- Status badge padding: 4pt vertical, 8pt horizontal\n- Copy button size: 24pt x 24pt\n- Separator height: 1pt\n\nIcons:\n- Copy button: \"doc.on.clipboard\" SF Symbol\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - Deposit transaction\n- `.depositMock` - Deposit with balance\n- `.withdrawalMock` - Negative withdrawal\n- `.betPlacedMock` - Bet placed with status badge\n- `.betWonMock` - Bet won with status badge\n- `.taxMock` - Tax deduction with status badge\n- `.emptyMock` - No data (nil)\n- `.noBalanceMock` - Transaction without balance\n\nMethods:\n- `copyTransactionId()` - Copy ID to clipboard\n",
      "snapshots": [
        {
          "category": "TransactionTypes",
          "light": "TransactionItemView/__Snapshots__/TransactionItemViewSnapshotTests/testTransactionItemView_TransactionTypes_Light.1.png",
          "dark": "TransactionItemView/__Snapshots__/TransactionItemViewSnapshotTests/testTransactionItemView_TransactionTypes_Dark.1.png"
        }
      ]
    },
    "TransactionVerificationView": {
      "displayName": "Transaction Verification View",
      "category": "Wallet",
      "subcategory": "Verification",
      "summary": "Full-screen USSD push verification display with animated loader, title, highlighted text, and instructional imagery",
      "description": "A composite verification screen for USSD push payment flows. Shows a top icon (40x40pt) that animates with a spinner rotation for 'ussd_push' state, a centered title (14pt bold), highlighted text via HighlightedTextView with phone number highlighting in primary color, and a bottom instructional image (200pt height). Layout uses 20pt horizontal padding with vertical spacing of 24pt (icon to title), 16pt (title to highlighted text), and 32pt (highlighted text to bottom image). Uses CurrentValueSubject for reactive data binding with TransactionVerificationData containing id, title, subtitle, highlightText, and optional images (supports both asset names and SF Symbols).",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "wallet",
        "verification",
        "ussd",
        "payment",
        "animation",
        "combine"
      ],
      "states": [
        "pushing (ussd_push with spinner)",
        "prompt received (ussd_received)",
        "incomplete pin",
        "complete pin"
      ],
      "similarTo": [
        "StatusInfoView",
        "StatusNotificationView"
      ],
      "oftenUsedWith": [
        "TransactionItemView",
        "WalletDetailView",
        "HighlightedTextView"
      ],
      "parents": [],
      "children": [
        "HighlightedTextView"
      ],
      "has_readme": true,
      "has_snapshot_tests": true,
      "readme_content": "# TransactionVerificationView\n\nA verification status view with icon, title, highlighted subtitle, and instructional image.\n\n## Overview\n\nTransactionVerificationView displays transaction verification status with a top icon (optionally spinning), title text, subtitle with highlighted text ranges, and a bottom instructional image. It is used in payment flows to show USSD push status, verification prompts, and confirmation screens. The top icon can animate with a spinning effect for loading states.\n\n## Component Relationships\n\n### Used By (Parents)\n- Payment verification screens\n- USSD push status screens\n- Transaction confirmation flows\n\n### Uses (Children)\n- `HighlightedTextView` - for subtitle with highlighted text\n\n## Features\n\n- Top icon with optional spinning animation\n- Bold title text (centered)\n- Subtitle with highlighted text ranges\n- Bottom instructional image\n- Conditional icon visibility\n- USSD push loading animation\n- Reactive updates via Combine publishers\n\n## Usage\n\n```swift\nlet viewModel = MockTransactionVerificationViewModel.defaultMock\nlet verificationView = TransactionVerificationView(viewModel: viewModel)\n\n// Simple prompt without highlights\nlet simpleView = TransactionVerificationView(\n    viewModel: MockTransactionVerificationViewModel.simpleMock\n)\n\n// Update data dynamically\nviewModel.configure(with: newData)\n```\n\n## Data Model\n\n```swift\nstruct TransactionVerificationData {\n    let id: String\n    let title: String\n    let subtitle: String\n    let highlightText: String?\n    let topImage: String?\n    let bottomImage: String?\n}\n\nprotocol TransactionVerificationViewModelProtocol {\n    var data: TransactionVerificationData { get }\n    var dataPublisher: AnyPublisher<TransactionVerificationData, Never> { get }\n    var highlightedTextViewModel: HighlightedTextViewModelProtocol { get }\n\n    func configure(with data: TransactionVerificationData)\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundTertiary` - view background\n- `StyleProvider.Color.highlightPrimary` - top icon tint, highlighted text\n- `StyleProvider.Color.textPrimary` - title text color\n- `StyleProvider.fontWith(type: .bold, size: 14)` - title font\n\nLayout constants:\n- Top icon to safe area: 20pt\n- Top icon size: 40pt x 40pt\n- Title to icon spacing: 24pt\n- Title horizontal padding: 20pt\n- Highlighted text to title spacing: 16pt\n- Highlighted text horizontal padding: 20pt\n- Bottom image to text spacing: 32pt\n- Bottom image height: 200pt\n- Bottom image horizontal padding: 20pt\n\nAnimation:\n- Top icon spins for \"ussd_push\" state\n- Rotation: 360 degrees, 1 second duration, infinite repeat\n\nImage resolution:\n1. Try bundle image with name\n2. Fallback to SF Symbol\n3. Hide if not found\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - USSD push with phone highlight and spinning icon\n- `.simpleMock` - Simple prompt without highlight\n- `.incompletePinMock` - Incomplete PIN entry state\n- `.completePinMock` - Complete PIN entry state\n\nMethods:\n- `configure(with:)` - Update verification data and highlighted text\n",
      "snapshots": [
        {
          "category": "VerificationVariants",
          "light": "TransactionVerificationView/__Snapshots__/TransactionVerificationViewSnapshotTests/testTransactionVerificationView_VerificationVariants_Light.1.png",
          "dark": "TransactionVerificationView/__Snapshots__/TransactionVerificationViewSnapshotTests/testTransactionVerificationView_VerificationVariants_Dark.1.png"
        }
      ]
    },
    "UserLimitCardView": {
      "displayName": "User Limit Card View",
      "category": "Profile",
      "subcategory": "Responsible Gaming",
      "summary": "Horizontal card displaying user limit type, value, and action button for responsible gambling limits",
      "description": "A simple card component for displaying and managing responsible gambling limits. Horizontal layout with a vertical info stack (typeLabel + valueLabel, both 14pt bold, 4pt spacing) on the left and an action ButtonView (35pt height, min 100pt width) on the right. Uses 16pt horizontal spacing between info and button, 12pt vertical padding. The action button defaults to solid red background ('Remove' style) using StyleProvider.Color.alertError. Triggers onActionTapped callback with limitId when button pressed. Non-reactive component with static data configuration.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "profile",
        "limits",
        "responsible-gaming",
        "card",
        "settings"
      ],
      "states": [
        "enabled",
        "disabled"
      ],
      "similarTo": [
        "SettingsCardView",
        "BalanceLineView"
      ],
      "oftenUsedWith": [
        "ProfileViewController",
        "SettingsListView"
      ],
      "parents": [],
      "children": [
        "ButtonView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# UserLimitCardView\n\nA user limit display card showing limit type, value, and a removal action button.\n\n## Overview\n\nUserLimitCardView displays a responsible gambling limit entry with the limit type (e.g., \"Daily\", \"Weekly\"), the limit value (e.g., \"5 XAF\"), and an action button for removing or modifying the limit. The component is used in responsible gambling settings screens where users can manage their deposit, loss, or wagering limits.\n\n## Component Relationships\n\n### Used By (Parents)\n- Responsible gambling settings screens\n- Limit management views\n- Account limits sections\n\n### Uses (Children)\n- `ButtonView` - for the action button\n\n## Features\n\n- Limit type label (bold)\n- Limit value label (bold)\n- Action button (customizable style and color)\n- Horizontal layout with info and button\n- Action tap callback with limit ID\n- Disabled state support for button\n\n## Usage\n\n```swift\nlet viewModel = MockUserLimitCardViewModel.removalMock()\nlet limitCard = UserLimitCardView(viewModel: viewModel)\n\n// Handle action tap\nlimitCard.onActionTapped = { limitId in\n    removeLimit(id: limitId)\n}\n\n// Disabled button state\nlet disabledViewModel = MockUserLimitCardViewModel.disabledMock()\nlet disabledCard = UserLimitCardView(viewModel: disabledViewModel)\n```\n\n## Data Model\n\n```swift\nprotocol UserLimitCardViewModelProtocol: AnyObject {\n    var limitId: String { get }\n    var typeText: String { get }\n    var valueText: String { get }\n    var actionButtonViewModel: ButtonViewModelProtocol { get }\n}\n```\n\n## Styling\n\nStyleProvider properties used:\n- `StyleProvider.Color.backgroundTertiary` - container background\n- `StyleProvider.Color.textPrimary` - type and value labels\n- `StyleProvider.Color.alertError` - default action button background\n- `StyleProvider.fontWith(type: .bold, size: 14)` - type and value fonts\n\nLayout constants:\n- Container padding: 12pt vertical\n- Stack spacing: 16pt horizontal\n- Action button height: 35pt\n- Action button min width: 100pt\n- Info stack spacing: 4pt vertical\n\nStack configuration:\n- Main: horizontal, center aligned\n- Info: vertical, leading aligned\n\n## Mock ViewModels\n\nAvailable presets:\n- `.removalMock()` - Daily limit with \"Remove\" button\n- `.disabledMock()` - Weekly limit with disabled button\n\nFactory initialization:\n```swift\nMockUserLimitCardViewModel(\n    limitId: String = UUID().uuidString,\n    typeText: String = \"Daily\",\n    valueText: String = \"5.0 XAF\",\n    actionButtonTitle: String = \"Remove\",\n    buttonStyle: ButtonStyle = .solidBackground\n)\n```\n",
      "snapshots": [
        {
          "category": "LimitVariants",
          "light": "UserLimitCardView/__Snapshots__/UserLimitCardViewSnapshotTests/testUserLimitCardView_LimitVariants_Light.1.png",
          "dark": "UserLimitCardView/__Snapshots__/UserLimitCardViewSnapshotTests/testUserLimitCardView_LimitVariants_Dark.1.png"
        }
      ]
    },
    "VideoBlockView": {
      "displayName": "Video Block View",
      "category": "Promotions",
      "subcategory": "ContentBlocks",
      "summary": "Inset video player block with dynamic aspect ratio calculation, play/pause overlay, and app lifecycle handling",
      "description": "A video player block for promotional content with intelligent height calculation. Uses AVPlayer and AVPlayerLayer with resizeAspectFill gravity. Default height 250pt, dynamically calculates actual height based on video aspect ratio (accounting for rotation transforms). Container has 15pt leading/trailing margins and 5pt top/bottom margins. Centered play/pause button (50x50pt, 25pt corner radius) with semi-transparent black background (50% opacity) that fades when playing. Tap gesture toggles playback. Automatically pauses when app enters background, resets to start when video completes. Uses async/await for video dimension loading with fallback to default height on error.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "video",
        "media",
        "promotions",
        "avplayer",
        "content-block"
      ],
      "states": [
        "paused (button visible)",
        "playing (button hidden)",
        "finished"
      ],
      "similarTo": [
        "VideoSectionView"
      ],
      "oftenUsedWith": [
        "TitleBlockView",
        "TextSectionView",
        "ImageBlockView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# VideoBlockView\n\nA video player block with play/pause overlay for CMS promotional content.\n\n## Overview\n\nVideoBlockView displays a video player with AVPlayer integration, featuring a centered play/pause button overlay. The component automatically calculates video dimensions to maintain aspect ratio and supports tap-to-play/pause interaction. It handles app lifecycle events to pause video when entering background. Used in CMS stack-based layouts for promotional video content.\n\n## Component Relationships\n\n### Used By (Parents)\n- `StackViewBlockView` - CMS block containers\n- Promotional screens\n- Welcome/onboarding flows\n\n### Uses (Children)\n- None (uses AVFoundation directly)\n\n## Features\n\n- AVPlayer video playback\n- Tap-to-play/pause interaction\n- Centered play/pause button overlay\n- Automatic aspect ratio calculation\n- Background app state handling\n- Video end detection with reset\n- Dynamic height based on video dimensions\n- Clear background for overlay compositions\n\n## Usage\n\n```swift\nlet viewModel = MockVideoBlockViewModel.defaultMock\nlet videoBlock = VideoBlockView(viewModel: viewModel)\n\n// Control playback programmatically\nvideoBlock.play()\nvideoBlock.pause()\n\n// With valid video URL\nlet validViewModel = MockVideoBlockViewModel.validUrlMock\nlet validVideo = VideoBlockView(viewModel: validViewModel)\n\n// Handle nil URL gracefully\nlet invalidViewModel = MockVideoBlockViewModel.invalidUrlMock\nlet noVideoBlock = VideoBlockView(viewModel: invalidViewModel)\n```\n\n## Data Model\n\n```swift\nprotocol VideoBlockViewModelProtocol {\n    var videoURL: URL? { get }\n}\n```\n\n## Styling\n\nLayout constants:\n- Default video height: 250pt\n- Max video height: 500pt\n- Container horizontal padding: 15pt\n- Container vertical padding: 5pt\n- Play button size: 50pt x 50pt\n- Play button corner radius: 25pt (circular)\n\nPlay/pause button:\n- Icon: SF Symbol \"play.fill\"\n- Tint: white\n- Background: black with 0.5 alpha\n- Hidden when playing (alpha = 0)\n- Visible when paused (alpha = 1)\n\nVideo container:\n- Clear background\n- Clips to bounds\n- User interaction enabled\n\nVideo gravity: `.resizeAspectFill`\n\n## App Lifecycle Handling\n\n- **Background**: Automatically pauses video\n- **Foreground**: Does not auto-resume (manual control)\n- **Video End**: Seeks to beginning, shows play button\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - Sample 720p video URL\n- `.validUrlMock` - Big Buck Bunny sample video\n- `.invalidUrlMock` - nil URL (no video)\n\nFactory initialization:\n```swift\nMockVideoBlockViewModel(videoURL: URL?)\n```\n\n## Video Loading\n\nThe component asynchronously loads video track metadata to:\n1. Determine natural video size\n2. Apply rotation transform\n3. Calculate aspect ratio\n4. Set height constraint maintaining ratio\n5. Fall back to default height on error\n",
      "snapshots": []
    },
    "VideoSectionView": {
      "displayName": "Video Section View",
      "category": "Promotions",
      "subcategory": "ContentBlocks",
      "summary": "Full-width video player section with fixed 400pt height, play/pause overlay, and app lifecycle handling",
      "description": "A simplified full-width video player for promotional content sections. Fixed 400pt height with edge-to-edge container (no margins). Uses AVPlayer and AVPlayerLayer with resizeAspectFill gravity. Centered play/pause button (50x50pt, 25pt corner radius) with semi-transparent black background (50% opacity) that fades when playing. Tap gesture toggles playback. Automatically pauses when app enters background, resets to start when video completes. Simpler than VideoBlockView - no dynamic aspect ratio calculation, designed for full-width hero sections.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "video",
        "media",
        "promotions",
        "avplayer",
        "full-width",
        "hero"
      ],
      "states": [
        "paused (button visible)",
        "playing (button hidden)",
        "finished"
      ],
      "similarTo": [
        "VideoBlockView"
      ],
      "oftenUsedWith": [
        "TitleBlockView",
        "TextSectionView",
        "PromotionDetailView"
      ],
      "parents": [],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# VideoSectionView\n\nA full-height video section with AVPlayer integration and tap-to-play/pause control.\n\n## Overview\n\nVideoSectionView displays a video player with a fixed 400pt height, featuring a centered play/pause button overlay. The component handles app lifecycle events to pause video when entering background and resets to the beginning when playback completes. Used for prominent video content sections in promotional or onboarding screens.\n\n## Component Relationships\n\n### Used By (Parents)\n- Promotional screens\n- Welcome/onboarding flows\n- Full-screen content sections\n\n### Uses (Children)\n- None (uses AVFoundation directly)\n\n## Features\n\n- AVPlayer video playback\n- Fixed 400pt height\n- Tap-to-play/pause interaction\n- Centered play/pause button overlay\n- Background app state handling\n- Video end detection with reset\n- Clear background for overlay compositions\n\n## Usage\n\n```swift\nlet viewModel = MockVideoSectionViewModel.defaultMock\nlet videoSection = VideoSectionView(viewModel: viewModel)\n\n// Control playback programmatically\nvideoSection.play()\nvideoSection.pause()\n\n// With valid video URL\nlet validViewModel = MockVideoSectionViewModel.validUrlMock\nlet validVideo = VideoSectionView(viewModel: validViewModel)\n\n// Handle nil URL gracefully\nlet invalidViewModel = MockVideoSectionViewModel.invalidUrlMock\nlet noVideoSection = VideoSectionView(viewModel: invalidViewModel)\n```\n\n## Data Model\n\n```swift\nprotocol VideoSectionViewModelProtocol {\n    var videoURL: URL? { get }\n}\n```\n\n## Styling\n\nLayout constants:\n- Video height: 400pt (fixed)\n- Play button size: 50pt x 50pt\n- Play button corner radius: 25pt (circular)\n\nPlay/pause button:\n- Icon: SF Symbol \"play.fill\"\n- Tint: white\n- Background: black with 0.5 alpha\n- Hidden when playing (alpha = 0)\n- Visible when paused (alpha = 1)\n\nVideo container:\n- Clear background\n- Clips to bounds\n- User interaction enabled\n\nVideo gravity: `.resizeAspectFill`\n\n## App Lifecycle Handling\n\n- **Background**: Automatically pauses video\n- **Foreground**: Does not auto-resume (manual control)\n- **Video End**: Seeks to beginning, shows play button\n\n## Mock ViewModels\n\nAvailable presets:\n- `.defaultMock` - Sample 720p video URL\n- `.validUrlMock` - Big Buck Bunny sample video\n- `.invalidUrlMock` - nil URL (no video)\n\nFactory initialization:\n```swift\nMockVideoSectionViewModel(videoURL: URL?)\n```\n",
      "snapshots": []
    },
    "WalletDetailView": {
      "displayName": "Wallet Detail View",
      "category": "Wallet",
      "subcategory": "Overview",
      "summary": "Comprehensive wallet card with gradient background showing header, multi-line balances, action buttons, and optional pending withdraws section",
      "description": "A complex composite wallet overview component with horizontal gradient background (8pt corner radius). Structure: WalletDetailHeaderView (48pt, wallet title + phone number on white background), WalletDetailBalanceView (total balance with 24x24pt icon, 18pt bold value, separator lines, and individual balance rows for current/bonus/cashback/withdrawable using WalletDetailBalanceLineView with 12pt title, 14pt bold value), buttons container (40pt height with equal-width withdraw/bordered and deposit/solid buttons, 12pt gap), and optional CustomExpandableSectionView for pending withdraws with PendingWithdrawView items. Uses 16pt padding, 12pt vertical spacing. Reactive via Combine with multiple CurrentValueSubject publishers for each balance type. Supports DEBUG-only long press for legacy cashier access.",
      "complexity": "complex",
      "maturity": "stable",
      "tags": [
        "wallet",
        "balance",
        "deposit",
        "withdraw",
        "gradient",
        "combine",
        "multi-section"
      ],
      "states": [
        "default",
        "empty balance",
        "high balance",
        "bonus only",
        "with pending withdraws",
        "loading"
      ],
      "similarTo": [
        "WalletStatusView",
        "WalletWidgetView"
      ],
      "oftenUsedWith": [
        "WalletViewController",
        "PendingWithdrawView",
        "CustomExpandableSectionView",
        "ButtonView"
      ],
      "parents": [],
      "children": [
        "ButtonView",
        "CustomExpandableSectionView",
        "PendingWithdrawView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# WalletDetailView\n\nA comprehensive wallet detail display component that shows wallet information, balances, and action buttons in an orange-themed overlay design. Perfect for modals, overlays, or embedded wallet displays.\n\n## Features\n\n- **White header section** with wallet icon and title\n- **Total XAF Balance** with cash icon\n- **Four balance types**: Current, Bonus, Cashback, Withdrawable amounts\n- **Action buttons** for Withdraw and Deposit operations\n- **Orange gradient background** with rounded corners\n- **Reactive architecture** with Combine publishers for real-time updates\n- **Comprehensive mock states** for testing and development\n\n## Visual Design\n\nThe component follows the Figma specification:\n- Orange background (#ff6600) with 8px corner radius\n- White header section with wallet branding\n- Balance lines with white text on orange background\n- Two action buttons at the bottom (bordered withdraw, filled deposit)\n- Total dimensions approximately 350x291px\n\n## Usage Example\n\n### Basic Implementation\n\n```swift\n// Create view model (or use mock for testing)\nlet viewModel = MockWalletDetailViewModel.defaultMock\n\n// Create the wallet detail view\nlet walletDetailView = WalletDetailView(viewModel: viewModel)\n\n// Add to your view hierarchy\nparentView.addSubview(walletDetailView)\n\n// Set up constraints (typically centered with fixed width)\nNSLayoutConstraint.activate([\n    walletDetailView.centerXAnchor.constraint(equalTo: parentView.centerXAnchor),\n    walletDetailView.centerYAnchor.constraint(equalTo: parentView.centerYAnchor),\n    walletDetailView.leadingAnchor.constraint(greaterThanOrEqualTo: parentView.leadingAnchor, constant: 20),\n    walletDetailView.trailingAnchor.constraint(lessThanOrEqualTo: parentView.trailingAnchor, constant: -20)\n])\n\n// Handle button actions\nwalletDetailView.onWithdraw = {\n    // Navigate to withdrawal screen or show withdrawal flow\n    print(\"User wants to withdraw funds\")\n}\n\nwalletDetailView.onDeposit = {\n    // Navigate to deposit screen or show deposit flow\n    print(\"User wants to deposit funds\")\n}\n```\n\n### Modal/Overlay Usage\n\n```swift\n// Create semi-transparent overlay\nlet overlayView = UIView()\noverlayView.backgroundColor = UIColor.black.withAlphaComponent(0.5)\noverlayView.translatesAutoresizingMaskIntoConstraints = false\n\n// Add to window or root view\nview.addSubview(overlayView)\nNSLayoutConstraint.activate([\n    overlayView.topAnchor.constraint(equalTo: view.topAnchor),\n    overlayView.leadingAnchor.constraint(equalTo: view.leadingAnchor),\n    overlayView.trailingAnchor.constraint(equalTo: view.trailingAnchor),\n    overlayView.bottomAnchor.constraint(equalTo: view.bottomAnchor)\n])\n\n// Add wallet detail view to overlay\nlet walletDetailView = WalletDetailView(viewModel: viewModel)\nwalletDetailView.translatesAutoresizingMaskIntoConstraints = false\noverlayView.addSubview(walletDetailView)\n\nNSLayoutConstraint.activate([\n    walletDetailView.centerXAnchor.constraint(equalTo: overlayView.centerXAnchor),\n    walletDetailView.centerYAnchor.constraint(equalTo: overlayView.centerYAnchor),\n    walletDetailView.leadingAnchor.constraint(greaterThanOrEqualTo: overlayView.leadingAnchor, constant: 20),\n    walletDetailView.trailingAnchor.constraint(lessThanOrEqualTo: overlayView.trailingAnchor, constant: -20)\n])\n\n// Add tap to dismiss\nlet tapGesture = UITapGestureRecognizer(target: self, action: #selector(dismissWalletOverlay))\noverlayView.addGestureRecognizer(tapGesture)\n```\n\n### Production Implementation\n\nIn production, your view model would connect to real wallet services:\n\n```swift\nclass ProductionWalletDetailViewModel: WalletDetailViewModelProtocol {\n    private let walletService: WalletServiceProtocol\n    private let displayStateSubject = CurrentValueSubject<WalletDetailDisplayState, Never>(/* initial state */)\n    private let totalBalanceSubject = CurrentValueSubject<String, Never>(\"0.00\")\n    // ... other subjects\n    \n    init(walletService: WalletServiceProtocol) {\n        self.walletService = walletService\n        \n        // Subscribe to wallet updates\n        walletService.walletUpdates\n            .map { wallet in\n                WalletDetailData(\n                    walletTitle: wallet.name,\n                    totalBalance: NumberFormatter.currency.string(from: wallet.totalBalance) ?? \"0.00\",\n                    currentBalance: NumberFormatter.currency.string(from: wallet.currentBalance) ?? \"0.00\",\n                    bonusBalance: NumberFormatter.currency.string(from: wallet.bonusBalance) ?? \"0.00\",\n                    cashbackBalance: NumberFormatter.currency.string(from: wallet.cashbackBalance) ?? \"0.00\",\n                    withdrawableAmount: NumberFormatter.currency.string(from: wallet.withdrawableAmount) ?? \"0.00\"\n                )\n            }\n            .sink { [weak self] walletData in\n                let newState = WalletDetailDisplayState(walletData: walletData)\n                self?.displayStateSubject.send(newState)\n                self?.updateIndividualPublishers(from: walletData)\n            }\n            .store(in: &cancellables)\n    }\n    \n    func performWithdraw() {\n        coordinator.navigateToWithdraw()\n    }\n    \n    func performDeposit() {\n        coordinator.navigateToDeposit()\n    }\n    \n    // Implement other protocol requirements...\n}\n```\n\n## Component Architecture\n\n### Multi-Component Design\n\nThe WalletDetailView is composed of several reusable sub-components:\n\n#### WalletDetailHeaderView\n- White background container with rounded corners\n- Wallet icon (MTN branding) with yellow background\n- \"Wallet\" title label\n- Clean, simple header design\n\n#### WalletDetailBalanceView\n- Total XAF Balance section with cash icon\n- White separator lines\n- Four balance line items:\n  - Current Balance: Available funds\n  - Bonus Balance: Promotional/bonus funds\n  - Cashback Balance: Earned cashback\n  - Withdrawable: Funds available for withdrawal\n- Reactive binding to balance publishers\n\n### Benefits of Modular Design\n- **Maintainability**: Each section is self-contained\n- **Reusability**: Header and balance sections can be used elsewhere\n- **Testability**: Individual components can be tested in isolation\n- **Type Safety**: No casting or unsafe UI element access\n- **Consistent Styling**: Unified StyleProvider usage\n\n## Mock States & Testing\n\nThe component includes comprehensive mock implementations:\n\n### Available Mock States\n\n```swift\n// Default state matching Figma design\nMockWalletDetailViewModel.defaultMock\n\n// Empty wallet for testing zero states\nMockWalletDetailViewModel.emptyBalanceMock\n\n// High balances for layout stress testing\nMockWalletDetailViewModel.highBalanceMock\n\n// Bonus-only scenario (no withdrawable funds)\nMockWalletDetailViewModel.bonusOnlyMock\n\n// Cashback focus scenario\nMockWalletDetailViewModel.cashbackFocusMock\n```\n\n### Dynamic Testing Methods\n\n```swift\n// Simulate balance updates\nviewModel.simulateBalanceUpdate(\n    total: \"3,500.00\",\n    current: \"2,000.00\"\n)\n\n// Simulate successful deposit\nviewModel.simulateDepositComplete(amount: 500.0)\n\n// Simulate withdrawal\nviewModel.simulateWithdrawalComplete(amount: 100.0)\n\n// Test loading states\nviewModel.simulateLoadingState()\n\n// Refresh data (with loading simulation)\nviewModel.refreshWalletData()\n```\n\n## Styling & Customization\n\n### Colors (from StyleProvider)\n\nThe component uses StyleProvider for all visual properties:\n\n- **Background**: `StyleProvider.Color.highlightPrimary` (orange)\n- **Header background**: `StyleProvider.Color.backgroundTertiary` (white)\n- **Text on white**: `StyleProvider.Color.textPrimary` (dark)\n- **Text on orange**: `StyleProvider.Color.highlightPrimaryContrast` (white)\n- **Icon background**: `StyleProvider.Color.highlightSecondary` (yellow)\n- **Separators**: `StyleProvider.Color.highlightPrimaryContrast` (white)\n\n### Typography\n\n- **Wallet title**: Regular 12px\n- **Balance labels**: Regular 14px\n- **Balance values**: Bold 14px (right-aligned)\n- **Total balance value**: Bold 18px\n- **Button text**: Bold 12px\n\n### Layout Specifications\n\n- **Component padding**: 16px all sides\n- **Section spacing**: 12px between header, balance, and buttons\n- **Header height**: 48px fixed\n- **Button height**: 40px fixed\n- **Corner radius**: 8px for main container, header container\n- **Icon sizes**: 32x32px (wallet icon), 24x24px (cash icon)\n\n## Integration with Existing Components\n\n### ButtonView Integration\n\nThe component uses GomaUI's existing ButtonView:\n\n- **Withdraw Button**: `.bordered` style with white border\n- **Deposit Button**: `.solidBackground` style with white background\n\n### WalletBalanceLineView Integration\n\nLeverages the existing `WalletBalanceLineView` component for consistent balance line formatting.\n\n## SwiftUI Preview Support\n\nThe component includes comprehensive SwiftUI previews using `PreviewUIViewController`:\n\n- Default state preview on orange background\n- Interactive button tap logging\n- Proper constraint setup examples\n- Multiple mock state demonstrations\n\n## File Structure\n\n```\nWalletDetailView/\n WalletDetailView.swift                      # Main container component\n WalletDetailHeaderView.swift                # White header section\n WalletDetailBalanceView.swift               # Balance display section  \n WalletDetailViewModelProtocol.swift         # Protocol definitions\n MockWalletDetailViewModel.swift             # Mock implementations\n Documentation/\n     README.md                               # This documentation\n```\n\n## Requirements\n\n- iOS 16.0+\n- GomaUI StyleProvider\n- GomaUI ButtonView component\n- GomaUI WalletBalanceLineView component (from WalletStatusView)\n- Combine framework for reactive bindings\n\n## Design Decisions\n\n### Why Multi-Component Architecture?\n\n1. **Single Responsibility**: Each component has one clear purpose\n2. **Reusability**: Header and balance sections can be used independently\n3. **Testing**: Easier to test individual components in isolation\n4. **Maintainability**: Changes to one section don't affect others\n5. **Performance**: Smaller components with focused rendering logic\n\n### Why Reactive Architecture?\n\n1. **Real-time Updates**: Balance changes reflect immediately in UI\n2. **Loose Coupling**: View doesn't need to know about data source\n3. **Testability**: Easy to simulate different states via publishers\n4. **Consistency**: Follows GomaUI's established patterns\n\nThis component provides a complete, production-ready wallet detail interface that matches the Figma specification while following GomaUI's architectural principles and design patterns.\n",
      "snapshots": []
    },
    "WalletStatusView": {
      "displayName": "Wallet Status View",
      "category": "Wallet",
      "subcategory": "Overview",
      "summary": "Compact wallet status card with balance breakdown, separator lines, and deposit/withdraw buttons",
      "description": "A composite wallet status card (8pt corner radius, backgroundTertiary) showing balance breakdown and actions. Uses vertical stack (8pt spacing) with WalletBalanceLineView rows: total balance with 24x24pt cash icon (3pt icon-to-title spacing), separator line (1pt), current/bonus/cashback balances, separator line, withdrawable amount. Title labels 12pt regular, value labels 14pt bold in highlightPrimary. Bottom section has 2pt spacer then two ButtonView instances (34pt height, 12pt font): deposit (solid) and withdraw (bordered). All content has 16pt padding. Reactive via Combine with CurrentValueSubject publishers for each balance. Exposes onDepositButtonTapped and onWithdrawButtonTapped callbacks.",
      "complexity": "composite",
      "maturity": "stable",
      "tags": [
        "wallet",
        "balance",
        "deposit",
        "withdraw",
        "card",
        "combine"
      ],
      "states": [
        "default",
        "empty balance",
        "high balance",
        "bonus only"
      ],
      "similarTo": [
        "WalletDetailView",
        "WalletWidgetView"
      ],
      "oftenUsedWith": [
        "WalletViewController",
        "ModalOverlay",
        "ButtonView"
      ],
      "parents": [],
      "children": [
        "ButtonView"
      ],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# WalletStatusView\n\nA comprehensive wallet status display component that shows various balance types with deposit and withdraw actions. Designed to work as an overlay dialog in any view controller.\n\n## Features\n\n- **Real-time balance updates** via Combine publishers\n- **Multiple balance types**: Total, Current, Bonus, Cashback, Withdrawable\n- **Integrated action buttons** using existing ButtonView component\n- **Clean visual hierarchy** with separator lines\n- **Reactive architecture** for server-side updates\n- **Dialog-ready design** with rounded corners and padding\n\n## Usage Example\n\n### Basic Implementation\n\n```swift\n// Create view model (or use mock for testing)\nlet viewModel = MockWalletStatusViewModel.defaultMock\n\n// Create the wallet status view\nlet walletStatusView = WalletStatusView(viewModel: viewModel)\n\n// Add to your view hierarchy\nparentView.addSubview(walletStatusView)\n\n// Set up constraints (typically centered with fixed width)\nNSLayoutConstraint.activate([\n    walletStatusView.centerXAnchor.constraint(equalTo: parentView.centerXAnchor),\n    walletStatusView.centerYAnchor.constraint(equalTo: parentView.centerYAnchor),\n    walletStatusView.widthAnchor.constraint(equalToConstant: 350),\n    walletStatusView.heightAnchor.constraint(equalToConstant: 340)\n])\n\n// Handle button actions\nviewModel.depositButtonViewModel.onButtonTapped = {\n    // Navigate to deposit screen\n}\n\nviewModel.withdrawButtonViewModel.onButtonTapped = {\n    // Navigate to withdrawal screen\n}\n```\n\n### Dialog/Overlay Usage\n\n```swift\n// Create overlay container\nlet overlayView = UIView()\noverlayView.backgroundColor = UIColor.black.withAlphaComponent(0.5)\noverlayView.translatesAutoresizingMaskIntoConstraints = false\n\n// Add to window or root view\nview.addSubview(overlayView)\nNSLayoutConstraint.activate([\n    overlayView.topAnchor.constraint(equalTo: view.topAnchor),\n    overlayView.leadingAnchor.constraint(equalTo: view.leadingAnchor),\n    overlayView.trailingAnchor.constraint(equalTo: view.trailingAnchor),\n    overlayView.bottomAnchor.constraint(equalTo: view.bottomAnchor)\n])\n\n// Add wallet status view to overlay\nlet walletView = WalletStatusView(viewModel: viewModel)\nwalletView.translatesAutoresizingMaskIntoConstraints = false\noverlayView.addSubview(walletView)\n\nNSLayoutConstraint.activate([\n    walletView.centerXAnchor.constraint(equalTo: overlayView.centerXAnchor),\n    walletView.centerYAnchor.constraint(equalTo: overlayView.centerYAnchor),\n    walletView.widthAnchor.constraint(equalToConstant: 350)\n])\n\n// Add tap to dismiss\nlet tapGesture = UITapGestureRecognizer(target: self, action: #selector(dismissOverlay))\noverlayView.addGestureRecognizer(tapGesture)\n```\n\n### Simulating Balance Updates\n\nThe mock view model provides methods to simulate server updates:\n\n```swift\n// Update specific balances\nviewModel.simulateBalanceUpdate(\n    total: \"2,500.00\",\n    current: \"1,200.00\"\n)\n\n// Simulate deposit completion\nviewModel.simulateDepositComplete(amount: 500.0)\n\n// Simulate withdrawal\nviewModel.simulateWithdrawalComplete(amount: 100.0)\n```\n\n## Production Implementation\n\nIn production, your view model would connect to real services:\n\n```swift\nclass WalletViewModel: WalletStatusViewModelProtocol {\n    private let walletService: WalletServiceProtocol\n    private let totalBalanceSubject = CurrentValueSubject<String, Never>(\"0.00\")\n    // ... other subjects\n    \n    init(walletService: WalletServiceProtocol) {\n        self.walletService = walletService\n        \n        // Subscribe to wallet updates\n        walletService.walletUpdates\n            .map { wallet in\n                NumberFormatter.currency.string(from: wallet.totalBalance) ?? \"0.00\"\n            }\n            .sink { [weak self] formattedBalance in\n                self?.totalBalanceSubject.send(formattedBalance)\n            }\n            .store(in: &cancellables)\n    }\n    \n    // Implement protocol requirements...\n}\n```\n\n## Customization\n\n### Button Styling\n\nThe component uses ButtonView with predefined styles:\n- **Deposit**: Solid background (green) - `.solidBackground`\n- **Withdraw**: Bordered (orange) - `.bordered`\n\nButton heights are set to 34pt with 12pt font size to match the design.\n\n### Colors\n\nAll colors come from StyleProvider:\n- Balance amounts: `highlightPrimary` (orange)\n- Labels: `textPrimary`\n- Separators: `separatorLine`\n- Background: `backgroundTertiary` (white)\n\n## Architecture Notes\n\n- **Tier 2 Component**: Interactive with button actions\n- **Reactive Design**: Publishers for all dynamic values\n- **Reusable Components**: Leverages existing ButtonView and custom WalletBalanceLineView\n- **Clean Separation**: View model handles all business logic\n- **Modular Design**: Balance lines are handled by dedicated WalletBalanceLineView components\n\n### Component Structure\n\nThe WalletStatusView is composed of several reusable sub-components:\n\n#### WalletBalanceLineView\nA dedicated component for displaying individual balance lines that provides:\n- **Flexible initialization**: With or without icons\n- **Clean API**: Direct property access (`titleText`, `valueText`, `icon`)\n- **Type safety**: No casting of arranged subviews\n- **Reusability**: Can be used in other wallet-related components\n\n```swift\n// Create with icon\nlet totalLine = WalletBalanceLineView(\n    title: \"Total Balance\",\n    value: \"2,000.00\",\n    icon: UIImage(named: \"banknote_cash_icon\", in: Bundle.module, compatibleWith: nil)\n)\n\n// Create without icon\nlet currentLine = WalletBalanceLineView(title: \"Current Balance\", value: \"1,000.00\")\n\n// Update dynamically\ncurrentLine.updateValue(\"1,500.00\")\ncurrentLine.titleText = \"Updated Balance\"\n```\n\n#### Benefits of Modular Design\n- **Maintainability**: Each balance line is a self-contained component\n- **Type Safety**: No risky casting of UI elements\n- **Testability**: Individual components can be tested in isolation\n- **Consistency**: Uniform styling and behavior across all balance lines\n\n## Testing\n\n### WalletStatusView Testing\n\nUse the provided mock factories for different scenarios:\n\n```swift\n// Default state matching Figma\nMockWalletStatusViewModel.defaultMock\n\n// Empty wallet\nMockWalletStatusViewModel.emptyBalanceMock\n\n// High balances\nMockWalletStatusViewModel.highBalanceMock\n\n// Bonus only (no withdrawable)\nMockWalletStatusViewModel.bonusOnlyMock\n```\n\n### WalletBalanceLineView Testing\n\nThe WalletBalanceLineView component includes comprehensive SwiftUI previews for testing:\n\n- **All Balance Line States**: Shows all variations used in the wallet (with/without icons)\n- **Balance Line Without Icon**: Simple balance line preview\n- **All Balance Line Types**: Collection view showing different balance types\n- **Different Value Lengths**: Tests layout with various text lengths\n\nThese previews can be accessed in Xcode's preview pane and help validate:\n- Layout behavior with long text\n- Icon alignment and spacing\n- Color theming consistency\n- Different value formats\n\n## File Structure\n\n```\nWalletStatusView/\n WalletStatusView.swift              # Main component\n WalletStatusViewModelProtocol.swift # Protocol definition\n WalletBalanceLineView.swift         # Reusable balance line component\n MockWalletStatusViewModel.swift     # Mock implementations\n Documentation/\n     README.md                       # This documentation\n```",
      "snapshots": [
        {
          "category": "BalanceVariants",
          "light": "WalletStatusView/__Snapshots__/WalletStatusViewSnapshotTests/testWalletStatusView_BalanceVariants_Light.1.png",
          "dark": "WalletStatusView/__Snapshots__/WalletStatusViewSnapshotTests/testWalletStatusView_BalanceVariants_Dark.1.png"
        }
      ]
    },
    "WalletWidgetView": {
      "displayName": "Wallet Widget View",
      "category": "Wallet",
      "subcategory": "Navigation",
      "summary": "Compact header bar widget showing balance with dropdown chevron and deposit button",
      "description": "A compact inline wallet widget (32pt height) for navigation bars. Horizontal stack with two sections: balance container (left-rounded 8pt corners, 10% alpha highlightPrimaryContrast background) containing balance label (14pt semibold white) + chevron.down icon (12pt white) with 12pt left padding and 6pt right padding, 5pt spacing; and deposit button (right-rounded 8pt corners, white background, primary color title, 14pt bold) with 6pt horizontal padding. Tap on balance triggers onBalanceTapped callback with WidgetTypeIdentifier, tap on deposit triggers onDepositTapped. Reactive via Combine with displayStatePublisher for WalletWidgetDisplayState containing balance string and deposit button title. Uses accessibilityIdentifier for type identification.",
      "complexity": "simple",
      "maturity": "stable",
      "tags": [
        "wallet",
        "widget",
        "navigation",
        "compact",
        "header",
        "combine"
      ],
      "states": [
        "default",
        "zero balance",
        "high balance"
      ],
      "similarTo": [
        "WalletStatusView",
        "QuickLinksTabBar"
      ],
      "oftenUsedWith": [
        "CustomNavigationView",
        "TopBarView",
        "HomeViewController"
      ],
      "parents": [
        "MultiWidgetToolbarView"
      ],
      "children": [],
      "has_readme": true,
      "has_snapshot_tests": false,
      "readme_content": "# WalletWidgetView\n\nA UI component that displays a wallet balance and a deposit button in a horizontally aligned view.\n\n## Features\n\n- Displays a wallet balance with a drop-down indicator\n- Includes a \"DEPOSIT\" button for quick access to deposit funds\n- Uses StyleProvider for consistent styling\n- Follows MVVM architecture pattern\n\n## Usage Example\n\n```swift\n// Create a view model (or use a mock for testing)\nlet walletData = WalletWidgetData(\n    id: \"user_wallet\",\n    balance: \"2,550.75\", \n    depositButtonTitle: \"DEPOSIT\"\n)\nlet viewModel = MockWalletWidgetViewModel(walletData: walletData)\n\n// Create the component\nlet walletWidget = WalletWidgetView(viewModel: viewModel)\n\n// Add to your view hierarchy\nparentView.addSubview(walletWidget)\n\n// Set up constraints\nNSLayoutConstraint.activate([\n    walletWidget.leadingAnchor.constraint(equalTo: parentView.leadingAnchor, constant: 16),\n    walletWidget.trailingAnchor.constraint(equalTo: parentView.trailingAnchor, constant: -16),\n    walletWidget.topAnchor.constraint(equalTo: parentView.safeAreaLayoutGuide.topAnchor, constant: 8),\n    walletWidget.heightAnchor.constraint(equalToConstant: 32)\n])\n\n// Handle deposit button taps\nwalletWidget.onDeposit = { widgetId in\n    print(\"Deposit button tapped for: \\(widgetId)\")\n    // Perform navigation or other actions\n}\n```\n\n## Customization\n\nThe component uses the StyleProvider to access appropriate colors and fonts:\n\n## Integration with MultiWidgetToolbarView\n\nThe WalletWidgetView is designed to be used as a widget within the MultiWidgetToolbarView component:\n\n```swift\nprivate func createWalletWidget(_ widget: Widget) -> UIView {\n    let walletData = WalletWidgetData(\n        id: widget.id,\n        balance: \"2,000.00\",\n        depositButtonTitle: \"DEPOSIT\"\n    )\n    \n    let viewModel = MockWalletWidgetViewModel(walletData: walletData)\n    let walletView = WalletWidgetView(viewModel: viewModel)\n    \n    walletView.onDeposit = { [weak self] widgetID in\n        self?.viewModel.selectWidget(id: widgetID)\n        self?.onWidgetSelected(widgetID)\n    }\n    \n    return walletView\n}\n``` \n",
      "snapshots": [
        {
          "category": "WidgetVariants",
          "light": "WalletWidgetView/__Snapshots__/WalletWidgetViewSnapshotTests/testWalletWidgetView_WidgetVariants_Light.1.png",
          "dark": "WalletWidgetView/__Snapshots__/WalletWidgetViewSnapshotTests/testWalletWidgetView_WidgetVariants_Dark.1.png"
        }
      ]
    }
  }
}