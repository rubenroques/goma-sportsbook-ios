This file is a merged representation of the entire codebase, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

## Additional Info

# Directory Structure
```
Docs/
  IntegrationTests.md
Sources/
  ServicesProvider/
    Helpers/
      FailableDecodable.swift
    Models/
      Bonus/
        AvailableBonus.swift
        AvailableBonusResponse.swift
        GrantedBonus.swift
        GrantedBonusResponse.swift
        RedeemBonus.swift
        RedeemBonusResponse.swift
      Cashback/
        CashbackBalance.swift
        CashbackResult.swift
      Cashout/
        Cashout.swift
        CashoutResult.swift
      Competitions/
        TopCompetitionsResponse.swift
      Documents/
        AcessTokenResponse.swift
        ApplicantDataResponse.swift
      HomeWidgets/
        PromotedSport.swift
        PromotionalBanner.swift
      Limits/
        ResponsibleGamingLimitsResponse.swift
      Promotions/
        AlertBanner.swift
        Banner.swift
        BoostedOddsBanner.swift
        HeroCard.swift
        HomeTemplate.swift
        NewsItem.swift
        ProChoice.swift
        SportBanner.swift
        Story.swift
      PromotionStories/
        PromotionalStoriesResponse.swift
      Referrals/
        Referee.swift
        RefereesResponse.swift
        ReferralLink.swift
        ReferralResponse.swift
      SharedTicket/
        SharedBet.swift
        SharedBetSelection.swift
        SharedTicketResponse.swift
        TicketSelection.swift
        TicketSelectionResponse.swift
      Social/
        AddFriendResponse.swift
        Chatroom.swift
        ChatroomData.swift
        ChatroomId.swift
        DeleteGroupResponse.swift
        Follower.swift
        FriendRequest.swift
        SearchUser.swift
        TipRanking.swift
        UserFriend.swift
        UserProfileInfo.swift
      Transactions/
        TransactionTypes.swift
      UserConsents/
        UserConsent.swift
        UserConsentInfo.swift
        UserConsentsResponse.swift
        UserConsentStatus.swift
        UserConsentType.swift
      Withdrawals/
        AddPaymentInformationResponse.swift
        BankPaymentDetail.swift
        BankPaymentInfo.swift
        CancelWithdrawalResponse.swift
        PaymentInformation.swift
        PendingWithdrawal.swift
        PendingWithdrawalResponse.swift
        ProcessWithdrawalResponse.swift
        WithdrawalMethod.swift
        WithdrawalMethodsResponse.swift
      AnalyticsTrackedEvent.swift
      BannerAlert.swift
      BetQRCode.swift
      Betting.swift
      BonusState.swift
      Country.swift
      Errors.swift
      EventListSort.swift
      Events.swift
      FeaturedTip.swift
      Filters.swift
      Freebet.swift
      News.swift
      PromotedBetslips.swift
      SportType.swift
      SubscribableContent.swift
      Subscription.swift
      TransactionsHistoryResponse.swift
      User.swift
    Network/
      Endpoint.swift
      HTTPTypes.swift
      MultipartRequest.swift
      NetworkManager.swift
      WebSocketClientStream.swift
    Protocols/
      AnalyticsProvider.swift
      BettingProvider.swift
      Connector.swift
      EventsProvider.swift
      ManagedContentProvider.swift
      new_managed_content_provider.md
      PrivilegedAccessManager.swift
      PromotionsProvider.swift
    Providers/
      Everymatrix/
        EverymatrixProvider.swift
      Goma/
        APIs/
          GomaAPIClient.swift
          GomaPromotionsAPIClient.swift
        Models/
          Mappers/
            GomaModelMapper.swift
            GomaModelMapper+Banners.swift
            GomaModelMapper+Betting.swift
            GomaModelMapper+Events.swift
            GomaModelMapper+FeaturedTips.swift
            GomaModelMapper+MyTickets.swift
            GomaModelMapper+News.swift
            GomaModelMapper+Promotions.swift
            GomaModelMapper+Social.swift
            GomaModelMapper+Sports.swift
            GomaModelMapper+Users.swift
          GomaModels.swift
          GomaModels+Banners.swift
          GomaModels+Betting.swift
          GomaModels+CMSInitialDump.swift
          GomaModels+Events.swift
          GomaModels+FeaturedTips.swift
          GomaModels+Home.swift
          GomaModels+News.swift
          GomaModels+Promotions.swift
          GomaModels+Social.swift
          GomaModels+Sports.swift
          GomaModels+Tickets.swift
          GomaModels+Users.swift
          GomaModelsHeroCardEvents.swift
        GomaAPIAuthenticator.swift
        GomaAPIProvider.swift
        GomaConnector.swift
        GomaDummyUnsubscriber.swift
        GomaEventPaginator.swift
        GomaManagedContentProvider.swift
      Sportsradar/
        APIs/
          Betting-Poseidon/
            BettingAPIClient.swift
            BettingConnector.swift
            BettingSession.swift
          Events-Poseidon/
            EventsDetails/
              SportRadarEventDetailsCoordinator.swift
            EventsGroups/
              SportRadarEventsGroupCoordinator.swift
              SportRadarEventsGroupStorage.swift
            EventsLists/
              SportRadarEventsPaginator.swift
              SportRadarEventsStorage.swift
            LiveEventDetails/
              SportRadarLiveEventDataCoordinator.swift
            MarketUpdates/
              SportRadarEventSecundaryMarketsCoordinator.swift
              SportRadarMarketDetailsCoordinator.swift
            Storage/
              SportRadarEventStorage.swift
            SportRadarRestAPIClient.swift
            SportRadarRestConnector.swift
            SportRadarSessionAccessToken.swift
            SportRadarSocketConnector.swift
            SportsMerger.swift
          PAM-Omega/
            OmegaAPIClient.swift
            OmegaConnector.swift
            OmegaSession.swift
          VaixAPI/
            VaixAnalytics/
              VaixAnalyticsEvent.swift
            VaixAPIClient.swift
        Models/
          Business/
            Bonus/
              SportRadarModels+AvailableBonus.swift
              SportRadarModels+AvailableBonusResponse.swift
              SportRadarModels+GrantedBonus.swift
              SportRadarModels+GrantedBonusResponse.swift
              SportRadarModels+RedeemBonus.swift
              SportRadarModels+RedeemBonusResponse.swift
            Cashback/
              SportRadarModels+CashbackBalance.swift
              SportRadarModels+CashbackResult.swift
            Cashout/
              SportRadarModels+Cashout.swift
              SportRadarModels+CashoutResult.swift
            Competitions/
              SportRadarModels+TopCompetitionsResponse.swift
            Documents/
              SportRadarModels+AcessTokenResponse.swift
              SportRadarModels+ApplicantDataResponse.swift
            Freebets/
              SportRadarModels+Freebet.swift
            Helpers/
              SocketMessageParseHelper.swift
            HomeWidgets/
              HeadlineResponse.swift
              PromotedSports.swift
              PromotionalBanners.swift
              SportRadarModelMapper+HeadlineResponse.swift
              SportRadarModelMapper+PromotedSports.swift
              SportRadarModelMapper+PromotionalBanner.swift
            Limits/
              SportRadarModels+ResponsibleGamingLimitsResponse.swift
            PromotionStories/
              SportRadarModels+PromotionalStoriesResponse.swift
            Referrals/
              SportRadarModels+Referee.swift
              SportRadarModels+RefereesResponse.swift
              SportRadarModels+ReferralLink.swift
              SportRadarModels+ReferralResponse.swift
            SharedTicket/
              SportRadarModels+SharedBets.swift
              SportRadarModels+SharedBetSelection.swift
              SportRadarModels+SharedTicketResponse.swift
              SportRadarModels+TicketSelection.swift
              SportRadarModels+TicketSelectionResponse.swift
            UserConsents/
              SportRadarModels+UserConsent.swift
              SportRadarModels+UserConsentInfo.swift
              SportRadarModels+UserConsentsResponse.swift
            Withdrawals/
              SportRadarModels+AddPaymentInformationResponse.swift
              SportRadarModels+BankPaymentDetail.swift
              SportRadarModels+BankPaymentInfo.swift
              SportRadarModels+CancelWithdrawalResponse.swift
              SportRadarModels+PaymentInformation.swift
              SportRadarModels+PendingWithdrawal.swift
              SportRadarModels+PendingWithdrawalResponse.swift
              SportRadarModels+ProcessWithdrawalResponse.swift
              SportRadarModels+WithdrawalMethod.swift
              SportRadarModels+WithdrawalMethodsResponse+Withdrawals.swift
            SportRadarModels+Betting.swift
            SportRadarModels+ContentContainer.swift
            SportRadarModels+EventLiveData.swift
            SportRadarModels+Events.swift
            SportRadarModels+PromotedBetslips.swift
            SportRadarModels+Scores.swift
            SportRadarModels+SocketContent.swift
            SportRadarModels+Sports.swift
            SportRadarModels+Transactions.swift
            SportRadarModels+User.swift
          Mapper/
            SportRadarModelMapper.swift
            SportRadarModelMapper+AnalyticsEvent.swift
            SportRadarModelMapper+Betting.swift
            SportRadarModelMapper+Events.swift
            SportRadarModelMapper+PromotedBetslips.swift
            SportRadarModelMapper+Sports.swift
            SportRadarModelMapper+User.swift
          SportRadarError.swift
        Sumsub/
          SumsubDataProvider.swift
        SportRadarAnalyticsProvider.swift
        SportRadarBettingProvider.swift
        SportRadarConfiguration.swift
        SportRadarEventsProvider.swift
        SportRadarManagedContentProvider.swift
        SportRadarPrivilegedAccessManager.swift
        SportRadarSessionCoordinator.swift
    ServiceProviderClient.swift
    ServicesProviderConfiguration.swift
Tests/
  ServicesProviderTests/
    Models/
      Promotions/
        HomeTemplateTests.swift
    Providers/
      Goma/
        Integration/
          Helpers/
            auth_helper.py
            auth_token.json
            fetch_responses.py
            JSONLoader.swift
            MockURLProtocol.swift
            ModelComparison.swift
            TestConfiguration.swift
          MockResponses/
            AlertBanner/
              response.json
            Banners/
              response.json
            BoostedOddsBanners/
              response.json
            HeroCards/
              response.json
            HomeTemplate/
              response.json
            InitialDump/
              response.json
            News/
              response.json
            ProChoices/
              response.json
            SportBanners/
              response.json
            Stories/
              response.json
          AlertBannerTests.swift
          BannersTests.swift
          BaseIntegrationTest.swift
          BoostedOddsBannersTests.swift
          HeroCardsTests.swift
          HomeTemplateTests.swift
          NewsTests.swift
          ProChoicesTests.swift
          SportBannersTests.swift
          StoriesTests.swift
        Models/
          Mappers/
            GomaModelMapperPromotionsTests.swift
          GomaModelsPromotionsTests.swift
      Sportsradar/
        APIs/
          Events-Poseidon/
            Helpers/
              SportsMergerTestHelpers.swift
            Mocks/
              TestableSubscription.swift
            SportsMergerTests.swift
    ServicesProviderTests.swift
.gitignore
.repomixignore
Package.swift
README.md
repomix.config.json
```

# Files

## File: Docs/IntegrationTests.md
````markdown
# Integration Tests for Managed Content Flow

## Introduction

This document outlines the comprehensive integration testing strategy for the managed content flow. The flow represents a clean architectural pattern that separates API data models from domain models, allowing for better maintainability and separation of concerns.

### Detailed Flow Description

```
API Request → Internal GomaModels → GomaModelMapper → Domain Models
```

Each endpoint in the system follows this consistent pattern:

1. **API Request Stage**:
   - The `GomaManagedContentProvider` initiates an API request using `GomaPromotionsAPIClient`
   - `GomaPromotionsAPIClient` constructs the appropriate URL with query parameters
   - Authentication is applied to the request via `GomaAPIAuthenticator`
   - The HTTP request is made with proper headers, method, and timeout settings

2. **Internal Model Decoding Stage**:
   - JSON responses from the API are parsed using `JSONDecoder`
   - Data is decoded into internal `GomaModels` structs (defined in `GomaModels+Promotions.swift`)
   - These internal models maintain direct mapping to the API's JSON structure using `CodingKeys`
   - Internal models may have nested structures for complex data (e.g., events containing teams)

3. **Model Transformation Stage**:
   - `GomaModelMapper` transforms internal models to domain models
   - Static mapper methods in `GomaModelMapper+Promotions.swift` handle different entity types
   - The mapper converts data types, handles optionals, and constructs more app-friendly structures
   - URL strings are converted to URL objects, date strings to Date objects, etc.

4. **Domain Model Return Stage**:
   - Clean domain models are returned to the caller via a Combine publisher
   - These models (like `HomeTemplate`, `Banner`, etc.) are what the app uses for presentation
   - Publishers may emit errors which need to be handled appropriately
   - Error types are unified as `ServiceProviderError` instances

The tests below are designed to verify each step of this flow for all endpoints, ensuring the integrity of the data pipeline from API to app.

## 0. Initial Setup

This section outlines critical preparatory tasks required before implementing the individual endpoint tests. We need to capture real API responses to ensure our test mocks accurately represent production data.

### 0.1 Authentication Setup

- [x] 0.1.1 Create a helper script to obtain authentication 'token' (it is a string) using the following cURL command:
```sh
curl --request POST \
  --url https://api.gomademo.com/api/auth/v1 \
  --header 'Accept: application/json' \
  --header 'Content-Type: application/json' \
  --header 'x-api-key: i4iStOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSvqPNhi' \
  --data '{
    "device_uuid": "68de20be-0e53-3cac-a822-ad0414f13502",
    "device_type": "ios"
}'
```
Response:
```json
{
	"token": "5944|V61S5ZW8Cn98tup13y3TWaOT4yHdclRwDIPrNrPib4ae0087",
	"expires_at": 1741215693,
	"type": "bearer"
}
```

- [x] 0.1.2 Store authentication response in a secure location for test use
- [x] 0.1.3 Create a helper function to extract token from authentication response
- [x] 0.1.4 Add token refresh mechanism for tests that may run beyond token expiration

### 0.2 API Response Collection

- [x] 0.2.1 Create a directory structure for storing JSON response mocks:
```
/Tests/GomaTests/MockResponses/
  ├── HomeTemplate/
  ├── AlertBanner/
  ├── Banners/
  ├── SportBanners/
  ├── BoostedOddsBanners/
  ├── HeroCards/
  ├── Stories/
  ├── News/
  └── ProChoices/
```

- [x] 0.2.2 Create helper script to fetch and save responses for all endpoints
- [x] 0.2.3 Capture Home Template response:
```sh
curl --request GET \
  --url https://api.gomademo.com/api/home/v1/template?platform=ios \
  --header 'Accept: application/json' \
  --header 'Authorization: Bearer TOKEN_FROM_AUTH_STEP' \
  --header 'x-api-key: i4iStOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSvqPNhi' \
  > /Tests/GomaTests/MockResponses/HomeTemplate/response.json
```

- [x] 0.2.4 Capture Alert Banner response:
```sh
curl --request GET \
  --url https://api.gomademo.com/api/promotions/v1/alert-banner \
  --header 'Accept: application/json' \
  --header 'Authorization: Bearer TOKEN_FROM_AUTH_STEP' \
  --header 'x-api-key: i4iStOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSvqPNhi' \
  > /Tests/GomaTests/MockResponses/AlertBanner/response.json
```

- [x] 0.2.5 Capture Banners response:
```sh
curl --request GET \
  --url https://api.gomademo.com/api/promotions/v1/banners \
  --header 'Accept: application/json' \
  --header 'Authorization: Bearer TOKEN_FROM_AUTH_STEP' \
  --header 'x-api-key: i4iStOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSvqPNhi' \
  > /Tests/GomaTests/MockResponses/Banners/response.json
```

- [x] 0.2.6 Capture Sport Banners response:
```sh
curl --request GET \
  --url https://api.gomademo.com/api/promotions/v1/sport-banners \
  --header 'Accept: application/json' \
  --header 'Authorization: Bearer TOKEN_FROM_AUTH_STEP' \
  --header 'x-api-key: i4iStOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSvqPNhi' \
  > /Tests/GomaTests/MockResponses/SportBanners/response.json
```

- [x] 0.2.7 Capture Boosted Odds Banners response:
```sh
curl --request GET \
  --url https://api.gomademo.com/api/promotions/v1/boosted-odds-banners \
  --header 'Accept: application/json' \
  --header 'Authorization: Bearer TOKEN_FROM_AUTH_STEP' \
  --header 'x-api-key: i4iStOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSvqPNhi' \
  > /Tests/GomaTests/MockResponses/BoostedOddsBanners/response.json
```

- [x] 0.2.8 Capture Hero Cards response:
```sh
curl --request GET \
  --url https://api.gomademo.com/api/promotions/v1/hero-cards \
  --header 'Accept: application/json' \
  --header 'Authorization: Bearer TOKEN_FROM_AUTH_STEP' \
  --header 'x-api-key: i4iStOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSvqPNhi' \
  > /Tests/GomaTests/MockResponses/HeroCards/response.json
```

- [x] 0.2.9 Capture Stories response:
```sh
curl --request GET \
  --url https://api.gomademo.com/api/promotions/v1/stories \
  --header 'Accept: application/json' \
  --header 'Authorization: Bearer TOKEN_FROM_AUTH_STEP' \
  --header 'x-api-key: i4iStOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSvqPNhi' \
  > /Tests/GomaTests/MockResponses/Stories/response.json
```

- [x] 0.2.10 Capture News response (with pagination):
```sh
curl --request GET \
  --url 'https://api.gomademo.com/api/promotions/v1/news?pageIndex=0&pageSize=10' \
  --header 'Accept: application/json' \
  --header 'Authorization: Bearer TOKEN_FROM_AUTH_STEP' \
  --header 'x-api-key: i4iStOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSvqPNhi' \
  > /Tests/GomaTests/MockResponses/News/response.json
```

- [x] 0.2.11 Capture Pro Choices response:
```sh
curl --request GET \
  --url https://api.gomademo.com/api/promotions/v1/pro-choices \
  --header 'Accept: application/json' \
  --header 'Authorization: Bearer TOKEN_FROM_AUTH_STEP' \
  --header 'x-api-key: i4iStOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSvqPNhi' \
  > /Tests/GomaTests/MockResponses/ProChoices/response.json
```

- [x] 0.2.12 Capture Initial Dump response:
```sh
curl --request GET \
  --url 'https://api.gomademo.com/api/initial-dump/v1?platform=ios' \
  --header 'Accept: application/json' \
  --header 'Authorization: Bearer TOKEN_FROM_AUTH_STEP' \
  --header 'x-api-key: i4iStOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSvqPNhi' \
  > /Tests/GomaTests/MockResponses/InitialDump/response.json
```

### 0.3 Test Preparation

- [x] 0.3.1 Create a JSONLoader utility to load saved JSON files in tests
- [x] 0.3.2 Create a MockURLProtocol to intercept network requests and return saved JSON responses
- [x] 0.3.3 Create a test configuration file to manage paths to mock responses
- [x] 0.3.4 Add test extension to verify JSON is correctly parsed into internal models
- [x] 0.3.5 Create helper function to compare internal models with domain models after mapping
- [x] 0.3.6 Implement a standard test setup method to configure environment for all tests

## 1. Home Template Tests

- [x] 1.1 Verify GomaPromotionsAPIClient.homeTemplate endpoint builds the correct URL with query parameters
- [x] 1.2 Verify GomaPromotionsAPIClient.homeTemplate endpoint uses correct HTTP method (GET)
- [x] 1.3 Mock a JSON response for homeTemplate and verify it decodes to GomaModels.HomeTemplate
- [x] 1.4 Test GomaModelMapper.homeTemplate transforms GomaModels.HomeTemplate to HomeTemplate correctly
- [x] 1.5 Verify widget types are correctly mapped in the transformation
- [x] 1.6 Test GomaManagedContentProvider.getHomeTemplate() calls the correct API endpoint
- [x] 1.7 Test GomaManagedContentProvider.getHomeTemplate() handles successful responses
- [x] 1.8 Test GomaManagedContentProvider.getHomeTemplate() handles error responses
- [x] 1.9 Test GomaManagedContentProvider.getHomeTemplate() applies authentication correctly
- [x] 1.10 Verify end-to-end flow with mocked API response to final domain model

## 2. Alert Banner Tests

- [x] 2.1 Verify GomaPromotionsAPIClient.alertBanner endpoint builds the correct URL with query parameters
- [x] 2.2 Verify GomaPromotionsAPIClient.alertBanner endpoint uses correct HTTP method (GET)
- [x] 2.3 Mock a JSON response for alertBanner and verify it decodes to GomaModels.AlertBannerData
- [x] 2.4 Test GomaModelMapper.alertBanner transforms GomaModels.AlertBannerData to AlertBanner correctly
- [x] 2.5 Test transformation correctly sets isActive based on status field
- [x] 2.6 Test URL construction for imageUrl field
- [x] 2.7 Test GomaManagedContentProvider.getAlertBanner() calls the correct API endpoint
- [x] 2.8 Test GomaManagedContentProvider.getAlertBanner() handles successful responses
- [x] 2.9 Test GomaManagedContentProvider.getAlertBanner() handles error responses
- [x] 2.10 Test GomaManagedContentProvider.getAlertBanner() handles empty/null responses
- [x] 2.11 Verify end-to-end flow with mocked API response to final domain model

## 3. Banners Tests

- [x] 3.1 Verify GomaPromotionsAPIClient.banners endpoint builds the correct URL with query parameters
- [x] 3.2 Verify GomaPromotionsAPIClient.banners endpoint uses correct HTTP method (GET)
- [x] 3.3 Mock a JSON response for banners and verify it decodes to [GomaModels.BannerData]
- [x] 3.4 Test GomaModelMapper.banner transforms single GomaModels.BannerData to Banner correctly
- [x] 3.5 Test GomaModelMapper.banners transforms array of GomaModels.BannerData to [Banner] correctly
- [x] 3.6 Test transformation correctly sets isActive based on status field
- [x] 3.7 Test URL construction for imageUrl field
- [x] 3.8 Test GomaManagedContentProvider.getBanners() calls the correct API endpoint
- [x] 3.9 Test GomaManagedContentProvider.getBanners() handles successful responses
- [x] 3.10 Test GomaManagedContentProvider.getBanners() handles error responses
- [x] 3.11 Test GomaManagedContentProvider.getBanners() handles empty array responses
- [x] 3.12 Verify end-to-end flow with mocked API response to final domain model

## 4. Sport Banners Tests

- [x] 4.1 Verify GomaPromotionsAPIClient.sportBanners endpoint builds the correct URL with query parameters
- [x] 4.2 Verify GomaPromotionsAPIClient.sportBanners endpoint uses correct HTTP method (GET)
- [x] 4.3 Mock a JSON response for sportBanners and verify it decodes to [GomaModels.SportBannerData]
- [x] 4.4 Test GomaModelMapper.sportBanner transforms GomaModels.SportBannerData to SportBanner correctly
- [x] 4.5 Test GomaModelMapper.sportBanners transforms array of GomaModels.SportBannerData to [SportBanner] correctly
- [x] 4.6 Test nested SportEventData mapping to SportEventSummary
- [x] 4.7 Test team data mapping for home and away teams
- [x] 4.8 Test URL construction for imageUrl and team logo URLs
- [x] 4.9 Test GomaManagedContentProvider.getSportBanners() calls the correct API endpoint
- [x] 4.10 Test GomaManagedContentProvider.getSportBanners() handles successful responses
- [x] 4.11 Test GomaManagedContentProvider.getSportBanners() handles error responses
- [x] 4.12 Test GomaManagedContentProvider.getSportBanners() handles empty array responses
- [x] 4.13 Verify end-to-end flow with mocked API response to final domain model

## 5. Boosted Odds Banners Tests

- [x] 5.1 Verify GomaPromotionsAPIClient.boostedOddsBanners endpoint builds the correct URL with query parameters
- [x] 5.2 Verify GomaPromotionsAPIClient.boostedOddsBanners endpoint uses correct HTTP method (GET)
- [x] 5.3 Mock a JSON response for boostedOddsBanners and verify it decodes to [GomaModels.BoostedOddsBannerData]
- [x] 5.4 Test GomaModelMapper.boostedOddsBanner transforms GomaModels.BoostedOddsBannerData to BoostedOddsBanner correctly
- [x] 5.5 Test GomaModelMapper.boostedOddsBanners transforms array of GomaModels.BoostedOddsBannerData to [BoostedOddsBanner] correctly
- [x] 5.6 Test originalOdd and boostedOdd values are correctly mapped
- [x] 5.7 Test nested SportEventData mapping to SportEventSummary
- [x] 5.8 Test URL construction for imageUrl field
- [x] 5.9 Test GomaManagedContentProvider.getBoostedOddsBanners() calls the correct API endpoint
- [x] 5.10 Test GomaManagedContentProvider.getBoostedOddsBanners() handles successful responses
- [x] 5.11 Test GomaManagedContentProvider.getBoostedOddsBanners() handles error responses
- [x] 5.12 Test GomaManagedContentProvider.getBoostedOddsBanners() handles empty array responses
- [x] 5.13 Verify end-to-end flow with mocked API response to final domain model

## 6. Hero Cards Tests

- [x] 6.1 Verify GomaPromotionsAPIClient.heroCards endpoint builds the correct URL with query parameters
- [x] 6.2 Verify GomaPromotionsAPIClient.heroCards endpoint uses correct HTTP method (GET)
- [x] 6.3 Mock a JSON response for heroCards and verify it decodes to [GomaModels.HeroCardData]
- [x] 6.4 Test GomaModelMapper.heroCard transforms GomaModels.HeroCardData to HeroCard correctly
- [x] 6.5 Test GomaModelMapper.heroCards transforms array of GomaModels.HeroCardData to [HeroCard] correctly
- [x] 6.6 Test actionType and actionTarget fields are correctly mapped
- [x] 6.7 Test eventId and eventData fields are correctly mapped
- [x] 6.8 Test URL construction for imageUrl field
- [x] 6.9 Test GomaManagedContentProvider.getHeroCards() calls the correct API endpoint
- [x] 6.10 Test GomaManagedContentProvider.getHeroCards() handles successful responses
- [x] 6.11 Test GomaManagedContentProvider.getHeroCards() handles error responses
- [x] 6.12 Test GomaManagedContentProvider.getHeroCards() handles empty array responses
- [x] 6.13 Verify end-to-end flow with mocked API response to final domain model

## 7. Stories Tests

- [x] 7.1 Verify GomaPromotionsAPIClient.stories endpoint builds the correct URL with query parameters
- [x] 7.2 Verify GomaPromotionsAPIClient.stories endpoint uses correct HTTP method (GET)
- [x] 7.3 Mock a JSON response for stories and verify it decodes to [GomaModels.StoryData]
- [x] 7.4 Test GomaModelMapper.story transforms GomaModels.StoryData to Story correctly
- [x] 7.5 Test GomaModelMapper.stories transforms array of GomaModels.StoryData to [Story] correctly
- [x] 7.6 Test content field is correctly mapped
- [x] 7.7 Test duration field is correctly mapped
- [x] 7.8 Test URL construction for imageUrl field
- [x] 7.9 Test GomaManagedContentProvider.getStories() calls the correct API endpoint
- [x] 7.10 Test GomaManagedContentProvider.getStories() handles successful responses
- [x] 7.11 Test GomaManagedContentProvider.getStories() handles error responses
- [x] 7.12 Test GomaManagedContentProvider.getStories() handles empty array responses
- [x] 7.13 Verify end-to-end flow with mocked API response to final domain model

## 8. News Tests

- [x] 8.1 Verify GomaPromotionsAPIClient.news endpoint builds the correct URL with query parameters
- [x] 8.2 Verify GomaPromotionsAPIClient.news endpoint uses correct HTTP method (GET)
- [x] 8.3 Verify pagination parameters (pageIndex, pageSize) are correctly added to URL
- [x] 8.4 Mock a JSON response for news and verify it decodes to [GomaModels.NewsItemData]
- [x] 8.5 Test GomaModelMapper.newsItem transforms GomaModels.NewsItemData to NewsItem correctly
- [x] 8.6 Test GomaModelMapper.newsItems transforms array of GomaModels.NewsItemData to [NewsItem] correctly
- [x] 8.7 Test author and tags fields are correctly mapped
- [x] 8.8 Test content field is correctly mapped
- [x] 8.9 Test URL construction for imageUrl field
- [x] 8.10 Test GomaManagedContentProvider.getNews() calls the correct API endpoint
- [x] 8.11 Test GomaManagedContentProvider.getNews() handles successful responses
- [x] 8.12 Test GomaManagedContentProvider.getNews() handles error responses
- [x] 8.13 Test GomaManagedContentProvider.getNews() handles empty array responses
- [x] 8.14 Test pagination works correctly with different page indexes and sizes
- [x] 8.15 Verify end-to-end flow with mocked API response to final domain model

## 9. Pro Choices Tests

- [x] 9.1 Verify the correct URL construction for the `GomaPromotionsAPIClient.proChoices` endpoint
- [x] 9.2 Ensure the correct HTTP method (GET) is used for the endpoint
- [x] 9.3 Mock a JSON response for the endpoint and verify it decodes to the internal model `[GomaModels.ProChoiceData]`
- [x] 9.4 Verify that `GomaModelMapper.proChoice` transforms a single `GomaModels.ProChoiceData` to `ProChoice` correctly
- [x] 9.5 Verify that `GomaModelMapper.proChoices` transforms an array of `GomaModels.ProChoiceData` to `[ProChoice]` correctly
- [x] 9.6 Test tipster data mapping (id, name, winRate, avatar)
- [x] 9.7 Test event summary mapping (id, homeTeam, awayTeam, dateTime)
- [x] 9.8 Test selection mapping (marketName, outcomeName, odds)
- [x] 9.9 Test reasoning field is correctly mapped
- [x] 9.10 Test URL construction for tipster avatar
- [x] 9.11 Test that `GomaManagedContentProvider.getProChoices()` calls the correct API endpoint
- [x] 9.12 Test that `GomaManagedContentProvider.getProChoices()` handles successful responses
- [x] 9.13 Test that `GomaManagedContentProvider.getProChoices()` handles error responses
- [x] 9.14 Test that `GomaManagedContentProvider.getProChoices()` handles empty array responses
- [x] 9.15 Test the end-to-end flow with mocked API response to final domain model

## 10. Initial Dump Tests

### Initial Dump Endpoint Overview

The Initial Dump endpoint (`https://api.gomademo.com/api/initial-dump/v1?platform=ios`) serves as a critical optimization for app startup performance. This endpoint consolidates data from all other content endpoints into a single API call, allowing the app to fetch its initial state with minimal network overhead.

#### Response Structure Analysis

The Initial Dump response contains a comprehensive JSON structure with the following key sections:

1. **`home_template`**: Contains the complete home screen layout configuration, including widget definitions, their order, and display rules based on user state.

2. **`promotions`**: A nested object containing all promotional content:
   - `alert_banner`: The current active alert banner
   - `banners`: Standard promotional banners
   - `sport_banners`: Sport-specific promotional banners with event data
   - `highlighted_events`: Featured sporting events
   - `pro_choices`: Expert betting picks
   - `boosted_odds_banners`: Special promotions with enhanced odds
   - `hero_cards`: Large featured promotional cards
   - `stories`: Instagram-style promotional content
   - `popular_events`: Categorized lists of popular events (e.g., "Top Football", "Top Tennis")

3. **`competitions`**: Featured competitions data, including:
   - League/tournament information
   - Region and sport associations
   - Icon identifiers

4. **`cms`**: Content Management System data, such as PDFs and other resources

This consolidated endpoint is particularly valuable for the app's cold start experience, as it eliminates the need for multiple sequential API calls. The response contains identical data structures to the individual endpoints, allowing the same model mappers to be reused for transforming the data into domain models.

The tests in this section will verify that the Initial Dump endpoint correctly returns all expected data and that our implementation properly transforms this data into the appropriate domain models.

### Initial Dump Tasks
- [ ] 10.1 Verify GomaPromotionsAPIClient.initialDump endpoint builds the correct URL with query parameters
- [ ] 10.2 Verify GomaPromotionsAPIClient.initialDump endpoint uses correct HTTP method (GET)
- [ ] 10.3 Mock a JSON response for initialDump and verify it decodes to GomaModels.InitialDumpData
- [ ] 10.4 Test that all nested objects within InitialDumpData decode correctly:
  - [ ] 10.4.1 Verify homeTemplate decodes to GomaModels.HomeTemplate
  - [ ] 10.4.2 Verify alertBanner decodes to GomaModels.AlertBannerData
  - [ ] 10.4.3 Verify banners decodes to [GomaModels.BannerData]
  - [ ] 10.4.4 Verify sportBanners decodes to [GomaModels.SportBannerData]
  - [ ] 10.4.5 Verify boostedOddsBanners decodes to [GomaModels.BoostedOddsBannerData]
  - [ ] 10.4.6 Verify heroCards decodes to [GomaModels.HeroCardData]
  - [ ] 10.4.7 Verify stories decodes to [GomaModels.StoryData]
  - [ ] 10.4.8 Verify news decodes to [GomaModels.NewsItemData]
  - [ ] 10.4.9 Verify proChoices decodes to [GomaModels.ProChoiceData]
- [ ] 10.5 Create GomaModelMapper.initialDump method to transform GomaModels.InitialDumpData to InitialDump domain model
- [ ] 10.6 Test GomaModelMapper.initialDump transforms GomaModels.InitialDumpData to InitialDump correctly
- [ ] 10.7 Verify all nested transformations work correctly:
  - [ ] 10.7.1 Test homeTemplate transforms to HomeTemplate correctly
  - [ ] 10.7.2 Test alertBanner transforms to AlertBanner correctly
  - [ ] 10.7.3 Test banners transforms to [Banner] correctly
  - [ ] 10.7.4 Test sportBanners transforms to [SportBanner] correctly
  - [ ] 10.7.5 Test boostedOddsBanners transforms to [BoostedOddsBanner] correctly
  - [ ] 10.7.6 Test heroCards transforms to [HeroCard] correctly
  - [ ] 10.7.7 Test stories transforms to [Story] correctly
  - [ ] 10.7.8 Test news transforms to [NewsItem] correctly
  - [ ] 10.7.9 Test proChoices transforms to [ProChoice] correctly
- [ ] 10.8 Test GomaManagedContentProvider.getInitialDump() calls the correct API endpoint
- [ ] 10.9 Test GomaManagedContentProvider.getInitialDump() handles successful responses
- [ ] 10.10 Test GomaManagedContentProvider.getInitialDump() handles error responses
- [ ] 10.11 Test GomaManagedContentProvider.getInitialDump() applies authentication correctly
- [ ] 10.12 Test GomaManagedContentProvider.getInitialDump() handles partial data (some fields missing)
- [ ] 10.13 Compare performance between calling getInitialDump() vs. calling individual endpoints
- [ ] 10.14 Verify end-to-end flow with mocked API response to final domain model
- [ ] 10.15 Create integration test that verifies data consistency between InitialDump and individual endpoint calls
````

## File: Sources/ServicesProvider/Helpers/FailableDecodable.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 14/02/2023.
//

import Foundation

struct FailableDecodable<Content: Codable>: Codable {
    let content: Content?

    init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()

        do {
            self.content = try container.decode(Content.self)
        } catch let DecodingError.typeMismatch(type, context)  {
            print("FailableDecodable Error: Type '\(type)' mismatch: \(context.debugDescription); codingPath: \(context.codingPath)")
            self.content = nil
        } catch let DecodingError.valueNotFound(type, context)  {
            print("FailableDecodable Error: Type '\(type)' mismatch: \(context.debugDescription); codingPath: \(context.codingPath)")
            self.content = nil
        } catch {
            print("FailableDecodable Error: Unknown error decoding \(error)")
            self.content = nil
        }
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(content)
    }
}
````

## File: Sources/ServicesProvider/Models/Bonus/AvailableBonus.swift
````swift
//
//  AvailableBonus.swift
//  
//
//  Created by André Lascas on 24/03/2023.
//

import Foundation

public struct AvailableBonus: Codable {
    public var id: String
    public var bonusPlanId: Int
    public var name: String
    public var description: String?
    public var type: String
    public var amount: Double
    public var triggerDate: Date?
    public var expiryDate: Date?
    public var wagerRequirement: Double?
    public var imageUrl: String?

    enum CodingKeys: String, CodingKey {
        case id = "optInId"
        case bonusPlanId = "bonusPlanId"
        case name = "bonusPlanName"
        case description = "description"
        case type = "bonusPlanType"
        case amount = "bonusAmount"
        case triggerDate = "startDate"
        case expiryDate = "endDate"
        case wagerRequirement = "wagerReq"
        case imageUrl = "imageUrl"
    }
}
````

## File: Sources/ServicesProvider/Models/Bonus/AvailableBonusResponse.swift
````swift
//
//  AvailableBonusResponse.swift
//  
//
//  Created by André Lascas on 24/03/2023.
//

import Foundation

public struct AvailableBonusResponse: Codable {

    public var status: String
    public var bonuses: [AvailableBonus]

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case bonuses = "optInBonusPlans"
    }
}
````

## File: Sources/ServicesProvider/Models/Bonus/GrantedBonus.swift
````swift
//
//  File.swift
//  
//
//  Created by André Lascas on 16/03/2023.
//

import Foundation

public struct GrantedBonus: Codable {
    public var id: Int
    public var name: String
    public var status: String
    public var amount: String
    public var triggerDate: Date?
    public var expiryDate: Date?
    public var wagerRequirement: String?
    public var amountWagered: String?

    enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "bonusPlanName"
        case status = "status"
        case amount = "amount"
        case triggerDate = "triggerDate"
        case expiryDate = "expiryDate"
        case wagerRequirement = "wagerRequirement"
        case amountWagered = "amountWagered"
    }
    
    init(id: Int,
         name: String,
         status: String,
         amount: String,
         triggerDate: Date?,
         expiryDate: Date?,
         wagerRequirement: String? = nil,
         amountWagered: String? = nil) {
        self.id = id
        self.name = name
        self.status = status
        self.amount = amount
        self.triggerDate = triggerDate
        self.expiryDate = expiryDate
        self.wagerRequirement = wagerRequirement
        self.amountWagered = amountWagered
    }
}
````

## File: Sources/ServicesProvider/Models/Bonus/GrantedBonusResponse.swift
````swift
//
//  GrantedBonusResponse.swift
//  
//
//  Created by André Lascas on 16/03/2023.
//

import Foundation

public struct GrantedBonusResponse: Codable {

    public var status: String
    public var bonuses: [GrantedBonus]

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case bonuses = "bonuses"
    }
}
````

## File: Sources/ServicesProvider/Models/Bonus/RedeemBonus.swift
````swift
//
//  File.swift
//  
//
//  Created by André Lascas on 17/03/2023.
//

import Foundation

public struct RedeemBonus: Codable {
    public var id: Int
    public var name: String
    public var status: String
    public var triggerDate: Date?
    public var expiryDate: Date?
    public var amount: String
    public var wagerRequired: String
    public var amountWagered: String

    enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "bonusPlanName"
        case status = "status"
        case triggerDate = "triggerDate"
        case expiryDate = "expiryDate"
        case amount = "amount"
        case wagerRequired = "wagerRequirement"
        case amountWagered = "amountWagered"
    }
}
````

## File: Sources/ServicesProvider/Models/Bonus/RedeemBonusResponse.swift
````swift
//
//  RedeemBonusResponse.swift
//  
//
//  Created by André Lascas on 17/03/2023.
//

import Foundation

public struct RedeemBonusResponse: Codable {
    public var status: String
    public var message: String?
    public var bonus: RedeemBonus?


    enum CodingKeys: String, CodingKey {
        case status = "status"
        case message = "message"
        case bonus = "bonus"
    }
}
````

## File: Sources/ServicesProvider/Models/Cashback/CashbackBalance.swift
````swift
//
//  CashbackBalance.swift
//  
//
//  Created by André Lascas on 17/07/2023.
//

import Foundation

public struct CashbackBalance: Codable {
    public var status: String
    public var balance: String?
    public var message: String?

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case balance = "balance"
        case message = "message"
    }
    
    public init(status: String, balance: String? = nil, message: String? = nil) {
        self.status = status
        self.balance = balance
        self.message = message
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.status = try container.decode(String.self, forKey: .status)
        self.message = try container.decodeIfPresent(String.self, forKey: .message)
        
        if let balanceString = try container.decodeIfPresent(String.self, forKey: .balance) {
            self.balance = balanceString
        }
        else if let balanceDouble = try container.decodeIfPresent(Double.self, forKey: .balance) {
            self.balance = String(balanceDouble)
        }
        else {
            self.balance = nil
        }
    }
    
}
````

## File: Sources/ServicesProvider/Models/Cashback/CashbackResult.swift
````swift
//
//  CashbackResult.swift
//  
//
//  Created by André Lascas on 18/07/2023.
//

import Foundation

public struct CashbackResult: Codable {
    public var id: Double
    public var amount: Double?
    public var amountFree: Double?

    enum CodingKeys: String, CodingKey {
        case id = "idFoSOOffer"
        case amount = "soReturn"
        case amountFree = "soFreeReturn"
    }
}
````

## File: Sources/ServicesProvider/Models/Cashout/Cashout.swift
````swift
//
//  Cashout.swift
//  
//
//  Created by André Lascas on 14/03/2023.
//

import Foundation

public struct Cashout: Codable {

    public var cashoutValue: Double
    public var partialCashoutAvailable: Bool?

    enum CodingKeys: String, CodingKey {
        case cashoutValue = "cashoutValue"
        case partialCashoutAvailable = "partialCashoutAvailable"
    }
}
````

## File: Sources/ServicesProvider/Models/Cashout/CashoutResult.swift
````swift
//
//  File.swift
//  
//
//  Created by André Lascas on 14/03/2023.
//

import Foundation

public struct CashoutResult: Codable {
    public var cashoutResult: Int?
    public var cashoutReoffer: Double?
    public var message: String?

    enum CodingKeys: String, CodingKey {
        case cashoutResult = "cashoutResult"
        case cashoutReoffer = "cashoutReoffer"
        case message = "message"
    }
}
````

## File: Sources/ServicesProvider/Models/Competitions/TopCompetitionsResponse.swift
````swift
//
//  TopCompetitionsResponse.swift
//  
//
//  Created by André Lascas on 05/07/2023.
//

import Foundation
import SharedModels

public struct TopCompetitionsResponse: Codable {
    public var data: [TopCompetitionData]

    enum CodingKeys: String, CodingKey {
        case data = "data"
    }
}

public struct TopCompetitionData: Codable {
    public var title: String
    public var competitions: [TopCompetitionPointer]

    enum CodingKeys: String, CodingKey {
        case title = "title"
        case competitions = "banneritems"
    }
}

public struct TopCompetitionPointer: Codable {
    public var id: String
    public var name: String
    public var competitionId: String

    enum CodingKeys: String, CodingKey {
        case id = "idfwbanneritem"
        case name = "name"
        case competitionId = "location"
    }

    public init(id: String, name: String, competitionId: String) {
        self.id = id
        self.name = name
        self.competitionId = competitionId
    }

}


public struct TopCompetition: Codable, Equatable {

    public var id: String
    public var name: String
    public var country: Country?
    public var sportType: SportType

    public init(id: String, name: String, country: Country?, sportType: SportType) {
        self.id = id
        self.name = name
        self.country = country
        self.sportType = sportType
    }

}
````

## File: Sources/ServicesProvider/Models/Documents/AcessTokenResponse.swift
````swift
//
//  File.swift
//  
//
//  Created by André Lascas on 12/06/2023.
//

import Foundation

public struct AccessTokenResponse: Codable {
    public var token: String?
    public var userId: String?
    public var description: String?
    public var code: Int?

    enum CodingKeys: String, CodingKey {
        case token = "token"
        case userId = "userId"
        case description = "description"
        case code = "code"
    }
}
````

## File: Sources/ServicesProvider/Models/Documents/ApplicantDataResponse.swift
````swift
//
//  File.swift
//  
//
//  Created by André Lascas on 12/06/2023.
//

import Foundation

public struct ApplicantDataResponse: Codable {
    public var externalUserId: String?
    public var info: ApplicantDataInfo?
    public var reviewData: ApplicantReviewData?
    public var description: String?

    enum CodingKeys: String, CodingKey {
        case externalUserId = "externalUserId"
        case info = "info"
        case reviewData = "review"
        case description = "description"
    }
}

public struct ApplicantDataInfo: Codable {
    public var applicantDocs: [ApplicantDoc]?

    enum CodingKeys: String, CodingKey {
        case applicantDocs = "idDocs"
    }
}

public struct ApplicantDoc: Codable {
    public var docType: String

    enum CodingKeys: String, CodingKey {
        case docType = "idDocType"
    }

}

public struct ApplicantReviewData: Codable {
    public var attemptCount: Int
    public var createDate: String
    public var reviewDate: String?
    public var reviewResult: ApplicantReviewResult?
    public var reviewStatus: String
    public var levelName: String

    enum CodingKeys: String, CodingKey {
        case attemptCount = "attemptCnt"
        case createDate = "createDate"
        case reviewDate = "reviewDate"
        case reviewResult = "reviewResult"
        case reviewStatus = "reviewStatus"
        case levelName = "levelName"
    }
}

public struct ApplicantReviewResult: Codable {
    public var reviewAnswer: String
    public var reviewRejectType: String?
    public var moderationComment: String?

    enum CodingKeys: String, CodingKey {
        case reviewAnswer = "reviewAnswer"
        case reviewRejectType = "reviewRejectType"
        case moderationComment = "moderationComment"
    }
}
````

## File: Sources/ServicesProvider/Models/HomeWidgets/PromotedSport.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 09/06/2023.
//

import Foundation

public struct PromotedSport: Codable {

    public let id: String
    public let name: String
    public let marketGroups: [MarketGroupPromotedSport]

    enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case marketGroups = "marketGroups"
    }

    public init(id: String, name: String, marketGroups: [MarketGroupPromotedSport]) {
        self.id = id
        self.name = name
        self.marketGroups = marketGroups
    }
}


public struct MarketGroupPromotedSport: Codable {

    public let id: String
    public let typeId: String?
    public let name: String?

    enum CodingKeys: String, CodingKey {
        case id = "id"
        case typeId = "typeId"
        case name = "name"
    }

    public init(id: String, typeId: String?, name: String?) {
        self.id = id
        self.typeId = typeId
        self.name = name
    }

}
````

## File: Sources/ServicesProvider/Models/HomeWidgets/PromotionalBanner.swift
````swift
//
//  File.swift
//
//
//  Created by Ruben Roques on 30/05/2023.
//

import Foundation

public struct PromotionalBannersResponse: Codable, Equatable, Hashable {
    public var promotionalBannerItems: [PromotionalBanner]
}

public struct PromotionalBanner: Codable, Equatable, Hashable {
    public let id: String
    public let name: String?
    public let bannerType: String?
    public let imageURL: String?
    public let bannerDisplay: String?
    public let linkType: String?
    public let location: String?
    public let bannerContents: [String]?
    public let specialAction: BannerSpecialAction
}

public enum BannerSpecialAction: Codable, Equatable, Hashable {
    case register
    case callToAction(url: String, text: String)
    case none
}

// AlertBanner has been moved to ServicesProvider/Models/Promotions/AlertBanner.swift
````

## File: Sources/ServicesProvider/Models/Limits/ResponsibleGamingLimitsResponse.swift
````swift
//
//  File.swift
//  
//
//  Created by André Lascas on 17/03/2023.
//

import Foundation

public struct ResponsibleGamingLimitsResponse: Codable {
    public var status: String
    public var limits: [ResponsibleGamingLimit]

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case limits = "limits"
    }
}

public struct ResponsibleGamingLimit: Codable {
    public var id: Int
    public var partyId: Int
    public var limitType: String
    public var periodType: String
    public var effectiveDate: String
    public var expiryDate: String
    public var limit: Double

    enum CodingKeys: String, CodingKey {
        case id = "responsibleGamingLimitID"
        case partyId = "partyID"
        case limitType = "limitType"
        case periodType = "periodType"
        case effectiveDate = "effectiveDate"
        case expiryDate = "expiryDate"
        case limit = "limit"
    }
}
````

## File: Sources/ServicesProvider/Models/Promotions/AlertBanner.swift
````swift
//
//  AlertBanner.swift
//  
//
//  Created on: May 15, 2024
//

import Foundation

/// Banner alert that appears at the top of the app
/// This unified model incorporates requirements from both Goma and SportRadar providers
public struct AlertBanner: Identifiable, Equatable, Hashable, Codable {
    /// Unique identifier for the alert banner
    /// Using String type for maximum compatibility across providers
    public let id: String
    
    /// Alert title - the main heading of the banner
    public let title: String
    
    /// Optional subtitle or secondary text
    public let subtitle: String?
    
    /// Optional detailed message content
    public let content: String?
    
    /// Background color in hex format (e.g. "#FF0000")
    /// May be nil if the provider doesn't support custom colors
    public let backgroundColor: String?
    
    /// Text color in hex format (e.g. "#FFFFFF")
    /// May be nil if the provider doesn't support custom colors
    public let textColor: String?
    
    /// Call-to-action button text
    /// Used by some providers to specify button text
    public let callToActionText: String?
    
    /// Type of action when banner is tapped (e.g. "url", "deeplink")
    /// Used to determine how to handle user interaction
    public let actionType: String?
    
    /// Target URL or deep link for the action
    /// Where the user should be directed when tapping the banner
    public let actionTarget: String?
    
    /// Whether the banner is currently active/visible
    public let isActive: Bool
    
    /// Start date when banner should begin being displayed
    /// May be nil if the provider doesn't support scheduling
    public let startDate: Date?
    
    /// End date when banner should stop being displayed
    /// May be nil if the provider doesn't support scheduling
    public let endDate: Date?
    
    /// Status of the banner (e.g. "active", "draft", "archived")
    /// Additional state information beyond simple active/inactive
    public let status: String?
    
    /// Optional image URL for the banner
    public let imageUrl: URL?
    
    /// Public initializer with default values for optional parameters
    /// This comprehensive initializer supports creation from both provider types
    /// - Parameters:
    ///   - id: Unique identifier (String for maximum compatibility)
    ///   - title: Alert title
    ///   - subtitle: Optional subtitle text
    ///   - content: Optional detailed message content
    ///   - backgroundColor: Optional background color in hex format
    ///   - textColor: Optional text color in hex format
    ///   - callToActionText: Optional button text
    ///   - actionType: Optional action type (url, deeplink, etc)
    ///   - actionTarget: Optional target URL or deep link path
    ///   - isActive: Whether the banner is currently active (default: true)
    ///   - startDate: Optional scheduling start date
    ///   - endDate: Optional scheduling end date
    ///   - status: Optional status description beyond active/inactive
    ///   - imageUrl: Optional image URL
    public init(
        id: String,
        title: String,
        subtitle: String? = nil,
        content: String? = nil,
        backgroundColor: String? = nil,
        textColor: String? = nil,
        callToActionText: String? = nil,
        actionType: String? = nil,
        actionTarget: String? = nil,
        isActive: Bool = true,
        startDate: Date? = nil,
        endDate: Date? = nil,
        status: String? = nil,
        imageUrl: URL? = nil
    ) {
        self.id = id
        self.title = title
        self.subtitle = subtitle
        self.content = content
        self.backgroundColor = backgroundColor
        self.textColor = textColor
        self.callToActionText = callToActionText
        self.actionType = actionType
        self.actionTarget = actionTarget
        self.isActive = isActive
        self.startDate = startDate
        self.endDate = endDate
        self.status = status
        self.imageUrl = imageUrl
    }
    
    /// Coding keys for JSON serialization/deserialization
    /// Ensures compatibility with API responses
    enum CodingKeys: String, CodingKey {
        case id
        case title
        case subtitle
        case content
        case backgroundColor = "background_color"
        case textColor = "text_color"
        case callToActionText = "cta_text"
        case actionType = "action_type"
        case actionTarget = "action_target"
        case isActive = "is_active"
        case startDate = "start_date"
        case endDate = "end_date"
        case status
        case imageUrl = "image_url"
    }
    
    // MARK: - Identifiable Conformance
    
    /// Identifier for Identifiable protocol
    /// Required for SwiftUI integration
    public var identifier: ID { id }
}
````

## File: Sources/ServicesProvider/Models/Promotions/Banner.swift
````swift
//
//  Banner.swift
//
//
//  Created on: May 15, 2024
//

import Foundation

/// Promotional banner displayed in the app
/// This unified model incorporates requirements from both Goma and SportRadar providers
public struct Banner: Identifiable, Equatable, Hashable, Codable {
    /// Unique identifier for the banner
    /// Using String type for maximum compatibility across providers
    public let id: String

    /// Banner title - the main heading
    public let title: String

    /// Optional subtitle or secondary text
    public let subtitle: String?

    /// Type of action when banner is tapped (e.g. "url", "deeplink")
    /// Used to determine how to handle user interaction
    public let actionType: String?

    /// Target URL or deep link for the action
    /// Where the user should be directed when tapping the banner
    public let actionTarget: String?

    /// Call-to-action button text
    /// Used by some providers to specify button text
    public let callToActionText: String?

    /// Whether the banner is currently active/visible
    public let isActive: Bool

    /// Start date when banner should begin being displayed
    /// May be nil if the provider doesn't support scheduling
    public let startDate: Date?

    /// End date when banner should stop being displayed
    /// May be nil if the provider doesn't support scheduling
    public let endDate: Date?

    /// Status of the banner (e.g. "active", "draft", "archived")
    /// Additional state information beyond simple active/inactive
    public let status: String?

    /// Image URL for the banner
    public let imageUrl: URL?

    /// Public initializer with default values for optional parameters
    /// This comprehensive initializer supports creation from both provider types
    /// - Parameters:
    ///   - id: Unique identifier (String for maximum compatibility)
    ///   - title: Banner title
    ///   - subtitle: Optional subtitle text
    ///   - actionType: Optional action type (url, deeplink, etc)
    ///   - actionTarget: Optional target URL or deep link path
    ///   - callToActionText: Optional button text
    ///   - isActive: Whether the banner is currently active (default: true)
    ///   - startDate: Optional scheduling start date
    ///   - endDate: Optional scheduling end date
    ///   - status: Optional status description beyond active/inactive
    ///   - imageUrl: Optional image URL
    public init(
        id: String,
        title: String,
        subtitle: String? = nil,
        actionType: String? = nil,
        actionTarget: String? = nil,
        callToActionText: String? = nil,
        isActive: Bool = true,
        startDate: Date? = nil,
        endDate: Date? = nil,
        status: String? = nil,
        imageUrl: URL? = nil
    ) {
        self.id = id
        self.title = title
        self.subtitle = subtitle
        self.actionType = actionType
        self.actionTarget = actionTarget
        self.callToActionText = callToActionText
        self.isActive = isActive
        self.startDate = startDate
        self.endDate = endDate
        self.status = status
        self.imageUrl = imageUrl
    }

    /// Coding keys for JSON serialization/deserialization
    /// Ensures compatibility with API responses
    enum CodingKeys: String, CodingKey {
        case id
        case title
        case subtitle
        case actionType = "action_type"
        case actionTarget = "action_target"
        case callToActionText = "cta_text"
        case isActive = "is_active"
        case startDate = "start_date"
        case endDate = "end_date"
        case status
        case imageUrl = "image_url"
    }

    // MARK: - Identifiable Conformance

    /// Identifier for Identifiable protocol
    /// Required for SwiftUI integration
    public var identifier: ID { id }

    // MARK: - Helper Methods

    /// Indicates if the banner is currently valid for display based on its date range
    /// Returns true if the current date is between startDate and endDate
    /// If startDate or endDate are nil, they are not considered in the calculation
    public var isInDateRange: Bool {
        let now = Date()
        let afterStart = startDate.map { now >= $0 } ?? true
        let beforeEnd = endDate.map { now <= $0 } ?? true
        return afterStart && beforeEnd
    }
}
````

## File: Sources/ServicesProvider/Models/Promotions/BoostedOddsBanner.swift
````swift
//
//  BoostedOddsBanner.swift
//  
//
//  Created on: May 15, 2024
//

import Foundation

/// Banner showcasing boosted odds for a sport event
public struct BoostedOddsBanner: Identifiable, Equatable {
    /// Unique identifier
    public let id: Int
    
    /// Banner title
    public let title: String
    
    /// Original odds value
    public let originalOdd: Double
    
    /// Boosted odds value
    public let boostedOdd: Double
    
    /// Associated sport event ID
    public let sportEventId: Int
    
    /// Start date when banner should be displayed
    public let startDate: Date
    
    /// End date when banner should stop being displayed
    public let endDate: Date
    
    /// Status of the banner
    public let status: String
    
    /// Image URL for the banner
    public let imageUrl: URL?
    
    /// Associated event information
    public let event: SportEventSummary?
    
    /// Public initializer
    /// - Parameters:
    ///   - id: Unique identifier
    ///   - title: Banner title
    ///   - originalOdd: Original odds value
    ///   - boostedOdd: Boosted odds value
    ///   - sportEventId: Associated sport event ID
    ///   - startDate: Start date when banner should be displayed
    ///   - endDate: End date when banner should stop being displayed
    ///   - status: Status of the banner
    ///   - imageUrl: Image URL for the banner
    ///   - event: Associated event information
    public init(
        id: Int,
        title: String,
        originalOdd: Double,
        boostedOdd: Double,
        sportEventId: Int,
        startDate: Date,
        endDate: Date,
        status: String,
        imageUrl: URL?,
        event: SportEventSummary?
    ) {
        self.id = id
        self.title = title
        self.originalOdd = originalOdd
        self.boostedOdd = boostedOdd
        self.sportEventId = sportEventId
        self.startDate = startDate
        self.endDate = endDate
        self.status = status
        self.imageUrl = imageUrl
        self.event = event
    }
}
````

## File: Sources/ServicesProvider/Models/Promotions/HeroCard.swift
````swift
//
//  HeroCard.swift
//  
//
//  Created on: May 15, 2024
//

import Foundation

/// Feature card displayed prominently in the app
public struct HeroCard: Identifiable, Equatable {
    /// Unique identifier
    public let id: Int
    
    /// Card title
    public let title: String
    
    /// Optional subtitle
    public let subtitle: String?
    
    /// Type of action when card is tapped
    public let actionType: String
    
    /// Target URL or deep link for the action
    public let actionTarget: String
    
    /// Start date when card should be displayed
    public let startDate: Date
    
    /// End date when card should stop being displayed
    public let endDate: Date
    
    /// Status of the card
    public let status: String
    
    /// Image URL for the card
    public let imageUrl: URL?
    
    /// Optional associated event ID
    public let eventId: Int?
    
    /// Public initializer
    /// - Parameters:
    ///   - id: Unique identifier
    ///   - title: Card title
    ///   - subtitle: Optional subtitle
    ///   - actionType: Type of action when card is tapped
    ///   - actionTarget: Target URL or deep link for the action
    ///   - startDate: Start date when card should be displayed
    ///   - endDate: End date when card should stop being displayed
    ///   - status: Status of the card
    ///   - imageUrl: Image URL for the card
    ///   - eventId: Optional associated event ID
    public init(
        id: Int,
        title: String,
        subtitle: String?,
        actionType: String,
        actionTarget: String,
        startDate: Date,
        endDate: Date,
        status: String,
        imageUrl: URL?,
        eventId: Int?
    ) {
        self.id = id
        self.title = title
        self.subtitle = subtitle
        self.actionType = actionType
        self.actionTarget = actionTarget
        self.startDate = startDate
        self.endDate = endDate
        self.status = status
        self.imageUrl = imageUrl
        self.eventId = eventId
    }
}
````

## File: Sources/ServicesProvider/Models/Promotions/HomeTemplate.swift
````swift
//
//  HomeTemplate.swift
//
//
//  Created on: May 15, 2024
//

import Foundation

public struct HomeTemplate: Codable {
    public let id: Int
    public let type: String
    public let widgets: [HomeWidget]
    
    init(id: Int, type: String, widgets: [HomeWidget]) {
        self.id = id
        self.type = type
        self.widgets = widgets
    }
    
}

public enum HomeWidget: Codable {
    case alertBanners(WidgetData)
    case banners(WidgetData)
    case carouselEvents(WidgetData)
    case stories(WidgetData)
    case heroCardEvents(WidgetData)
    case highlightedLiveEvents(WidgetData)
    case betSwipe(WidgetData)
    case highlightedEvents(WidgetData)
    case boostedEvents(WidgetData)
    case proChoices(WidgetData)
    case topCompetitions(WidgetData)
    case suggestedBets(WidgetData)
    case popularEvents(WidgetData)
    
    public init?(id: Int,
                 type: String,
                 description: String,
                 userState: String,
                 sortOrder: Int,
                 orientation: String?) {
        
        let widgetData = WidgetData.init(id: id,
                                         type: type,
                                         description: description,
                                         userState: userState,
                                         sortOrder: sortOrder,
                                         orientation: orientation)
        
        
        // Use the actual widget names from the API
        switch type.lowercased() {
        case "alertbanners":
            self = .alertBanners(widgetData)
        case "banners":
            self = .banners(widgetData)
        case "carouselevents":
            self = .carouselEvents(widgetData)
        case "stories":
            self = .stories(widgetData)
        case "herocardevents":
            self = .heroCardEvents(widgetData)
        case "highlightedliveevents":
            self = .highlightedLiveEvents(widgetData)
        case "betswipe":
            self = .betSwipe(widgetData)
        case "highlightedevents":
            self = .highlightedEvents(widgetData)
        case "boostedevents":
            self = .boostedEvents(widgetData)
        case "prochoices":
            self = .proChoices(widgetData)
        case "topcompetitions":
            self = .topCompetitions(widgetData)
        case "suggestedbets":
            self = .suggestedBets(widgetData)
        case "popularevents":
            self = .popularEvents(widgetData)
        default:
            return nil
        }
        
    }
    
    public struct WidgetData: Codable {
        public let id: Int
        public let type: String
        public let description: String
        public let userState: UserState
        public let sortOrder: Int
        public let orientation: Orientation?
        
        public enum Orientation: String, Codable {
            case horizontal
            case vertical
            case notSupported
        }
        
        public enum UserState: String, Codable {
            case authenticated
            case anonymous
            case any
        }
        
        init(id: Int,
             type: String,
             description: String,
             userState: String,
             sortOrder: Int,
             orientation: String?) {
            
            let userStateEnum: WidgetData.UserState
            switch userState {
            case "authenticated": userStateEnum = .authenticated
            case "anonymous": userStateEnum = .anonymous
            default: userStateEnum = .any
            }
            
            var orientationEnum: WidgetData.Orientation? = nil
            if let orientationStr = orientation {
                orientationEnum = WidgetData.Orientation(rawValue: orientationStr)
            }
            
            self.id = id
            self.type = type
            self.description = description
            self.sortOrder = sortOrder
            self.userState = userStateEnum
            self.orientation = orientationEnum
        }
    }
    
    // Properties that access the associated value
    public var widgetData: WidgetData {
        switch self {
        case .alertBanners(let data),
                .banners(let data),
                .carouselEvents(let data),
                .stories(let data),
                .heroCardEvents(let data),
                .highlightedLiveEvents(let data),
                .betSwipe(let data),
                .highlightedEvents(let data),
                .boostedEvents(let data),
                .proChoices(let data),
                .topCompetitions(let data),
                .suggestedBets(let data),
                .popularEvents(let data):
            return data
        }
    }
    
    // Convenience accessors
    public var id: Int { return widgetData.id }
    public var type: String { return widgetData.type }
    public var description: String { return widgetData.description }
    public var userType: WidgetData.UserState { return widgetData.userState }
    public var sortOrder: Int { return widgetData.sortOrder }
    public var orientation: WidgetData.Orientation? { return widgetData.orientation }
    
}
````

## File: Sources/ServicesProvider/Models/Promotions/NewsItem.swift
````swift
//
//  NewsItem.swift
//  
//
//  Created on: May 15, 2024
//

import Foundation

/// News article
public struct NewsItem: Identifiable, Equatable {
    /// Unique identifier
    public let id: Int
    
    /// News article title
    public let title: String
    
    /// Optional subtitle
    public let subtitle: String?
    
    /// Article content (may contain HTML)
    public let content: String
    
    /// Article author
    public let author: String
    
    /// Date when the article was published
    public let publishedDate: Date
    
    /// Status of the article
    public let status: String
    
    /// Featured image URL for the article
    public let imageUrl: URL?
    
    /// Tags associated with the article
    public let tags: [String]
    
    /// Public initializer
    /// - Parameters:
    ///   - id: Unique identifier
    ///   - title: News article title
    ///   - subtitle: Optional subtitle
    ///   - content: Article content (may contain HTML)
    ///   - author: Article author
    ///   - publishedDate: Date when the article was published
    ///   - status: Status of the article
    ///   - imageUrl: Featured image URL for the article
    ///   - tags: Tags associated with the article
    public init(
        id: Int,
        title: String,
        subtitle: String?,
        content: String,
        author: String,
        publishedDate: Date,
        status: String,
        imageUrl: URL?,
        tags: [String]
    ) {
        self.id = id
        self.title = title
        self.subtitle = subtitle
        self.content = content
        self.author = author
        self.publishedDate = publishedDate
        self.status = status
        self.imageUrl = imageUrl
        self.tags = tags
    }
}
````

## File: Sources/ServicesProvider/Models/Promotions/ProChoice.swift
````swift
//
//  ProChoice.swift
//  
//
//  Created on: May 15, 2024
//

import Foundation

/// Expert betting tip
public struct ProChoice: Identifiable, Equatable {
    /// Unique identifier
    public let id: Int
    
    /// Tip title
    public let title: String
    
    /// Information about the tipster
    public let tipster: Tipster
    
    /// Information about the event
    public let event: EventSummary
    
    /// Information about the selection
    public let selection: Selection
    
    /// Reasoning for the tip
    public let reasoning: String
    
    /// Public initializer
    /// - Parameters:
    ///   - id: Unique identifier
    ///   - title: Tip title
    ///   - tipster: Information about the tipster
    ///   - event: Information about the event
    ///   - selection: Information about the selection
    ///   - reasoning: Reasoning for the tip
    public init(
        id: Int,
        title: String,
        tipster: Tipster,
        event: EventSummary,
        selection: Selection,
        reasoning: String
    ) {
        self.id = id
        self.title = title
        self.tipster = tipster
        self.event = event
        self.selection = selection
        self.reasoning = reasoning
    }
}

/// Information about a tipster
public struct Tipster: Equatable {
    /// Unique identifier
    public let id: Int
    
    /// Tipster name
    public let name: String
    
    /// Win rate percentage
    public let winRate: Double
    
    /// Avatar image URL
    public let avatar: URL?
    
    /// Public initializer
    /// - Parameters:
    ///   - id: Unique identifier
    ///   - name: Tipster name
    ///   - winRate: Win rate percentage
    ///   - avatar: Avatar image URL
    public init(
        id: Int,
        name: String,
        winRate: Double,
        avatar: URL?
    ) {
        self.id = id
        self.name = name
        self.winRate = winRate
        self.avatar = avatar
    }
}

/// Summary information about an event
public struct EventSummary: Equatable {
    /// Event identifier
    public let id: Int
    
    /// Home team name
    public let homeTeam: String
    
    /// Away team name
    public let awayTeam: String
    
    /// Event date and time
    public let dateTime: Date
    
    /// Public initializer
    /// - Parameters:
    ///   - id: Event identifier
    ///   - homeTeam: Home team name
    ///   - awayTeam: Away team name
    ///   - dateTime: Event date and time
    public init(
        id: Int,
        homeTeam: String,
        awayTeam: String,
        dateTime: Date
    ) {
        self.id = id
        self.homeTeam = homeTeam
        self.awayTeam = awayTeam
        self.dateTime = dateTime
    }
}

/// Information about a betting selection
public struct Selection: Equatable {
    /// Market name
    public let marketName: String
    
    /// Outcome name
    public let outcomeName: String
    
    /// Odds value
    public let odds: Double
    
    /// Public initializer
    /// - Parameters:
    ///   - marketName: Market name
    ///   - outcomeName: Outcome name
    ///   - odds: Odds value
    public init(
        marketName: String,
        outcomeName: String,
        odds: Double
    ) {
        self.marketName = marketName
        self.outcomeName = outcomeName
        self.odds = odds
    }
}
````

## File: Sources/ServicesProvider/Models/Promotions/SportBanner.swift
````swift
//
//  SportBanner.swift
//  
//
//  Created on: May 15, 2024
//

import Foundation

/// Sport-related promotional banner
public struct SportBanner: Identifiable, Equatable {
    /// Unique identifier
    public let id: Int
    
    /// Banner title
    public let title: String
    
    /// Optional subtitle
    public let subtitle: String?
    
    /// Associated sport event ID
    public let sportEventId: Int
    
    /// Start date when banner should be displayed
    public let startDate: Date
    
    /// End date when banner should stop being displayed
    public let endDate: Date
    
    /// Status of the banner
    public let status: String
    
    /// Image URL for the banner
    public let imageUrl: URL?
    
    /// Associated event information
    public let event: SportEventSummary?
    
    /// Public initializer
    /// - Parameters:
    ///   - id: Unique identifier
    ///   - title: Banner title
    ///   - subtitle: Optional subtitle
    ///   - sportEventId: Associated sport event ID
    ///   - startDate: Start date when banner should be displayed
    ///   - endDate: End date when banner should stop being displayed
    ///   - status: Status of the banner
    ///   - imageUrl: Image URL for the banner
    ///   - event: Associated event information
    public init(
        id: Int,
        title: String,
        subtitle: String?,
        sportEventId: Int,
        startDate: Date,
        endDate: Date,
        status: String,
        imageUrl: URL?,
        event: SportEventSummary?
    ) {
        self.id = id
        self.title = title
        self.subtitle = subtitle
        self.sportEventId = sportEventId
        self.startDate = startDate
        self.endDate = endDate
        self.status = status
        self.imageUrl = imageUrl
        self.event = event
    }
}

/// Summary information about a sport event
public struct SportEventSummary: Equatable {
    /// Event identifier
    public let id: Int
    
    /// Sport identifier
    public let sportId: Int
    
    /// Home team identifier
    public let homeTeamId: Int
    
    /// Away team identifier
    public let awayTeamId: Int
    
    /// Event date and time
    public let dateTime: Date
    
    /// Home team name
    public let homeTeam: String
    
    /// Away team name
    public let awayTeam: String
    
    /// Home team logo URL
    public let homeTeamLogo: URL?
    
    /// Away team logo URL
    public let awayTeamLogo: URL?
    
    /// Public initializer
    /// - Parameters:
    ///   - id: Event identifier
    ///   - sportId: Sport identifier
    ///   - homeTeamId: Home team identifier
    ///   - awayTeamId: Away team identifier
    ///   - dateTime: Event date and time
    ///   - homeTeam: Home team name
    ///   - awayTeam: Away team name
    ///   - homeTeamLogo: Home team logo URL
    ///   - awayTeamLogo: Away team logo URL
    public init(
        id: Int,
        sportId: Int,
        homeTeamId: Int,
        awayTeamId: Int,
        dateTime: Date,
        homeTeam: String,
        awayTeam: String,
        homeTeamLogo: URL?,
        awayTeamLogo: URL?
    ) {
        self.id = id
        self.sportId = sportId
        self.homeTeamId = homeTeamId
        self.awayTeamId = awayTeamId
        self.dateTime = dateTime
        self.homeTeam = homeTeam
        self.awayTeam = awayTeam
        self.homeTeamLogo = homeTeamLogo
        self.awayTeamLogo = awayTeamLogo
    }
}
````

## File: Sources/ServicesProvider/Models/Promotions/Story.swift
````swift
//
//  Story.swift
//  
//
//  Created on: May 15, 2024
//

import Foundation

/// Ephemeral promotional story (similar to social media stories)
public struct Story: Identifiable, Equatable {
    /// Unique identifier
    public let id: Int
    
    /// Story title
    public let title: String
    
    /// Story content (may contain HTML)
    public let content: String
    
    /// Type of action when story is tapped
    public let actionType: String
    
    /// Target URL or deep link for the action
    public let actionTarget: String
    
    /// Start date when story should be displayed
    public let startDate: Date
    
    /// End date when story should stop being displayed
    public let endDate: Date
    
    /// Status of the story
    public let status: String
    
    /// Image URL for the story
    public let imageUrl: URL?
    
    /// Duration in seconds for automatic progression
    public let duration: Int
    
    /// Public initializer
    /// - Parameters:
    ///   - id: Unique identifier
    ///   - title: Story title
    ///   - content: Story content (may contain HTML)
    ///   - actionType: Type of action when story is tapped
    ///   - actionTarget: Target URL or deep link for the action
    ///   - startDate: Start date when story should be displayed
    ///   - endDate: End date when story should stop being displayed
    ///   - status: Status of the story
    ///   - imageUrl: Image URL for the story
    ///   - duration: Duration in seconds for automatic progression
    public init(
        id: Int,
        title: String,
        content: String,
        actionType: String,
        actionTarget: String,
        startDate: Date,
        endDate: Date,
        status: String,
        imageUrl: URL?,
        duration: Int
    ) {
        self.id = id
        self.title = title
        self.content = content
        self.actionType = actionType
        self.actionTarget = actionTarget
        self.startDate = startDate
        self.endDate = endDate
        self.status = status
        self.imageUrl = imageUrl
        self.duration = duration
    }
}
````

## File: Sources/ServicesProvider/Models/PromotionStories/PromotionalStoriesResponse.swift
````swift
//
//  File.swift
//  
//
//  Created by André Lascas on 25/07/2023.
//

import Foundation

public struct PromotionalStoriesResponse: Codable {

    public var promotionalStories: [PromotionalStory]

    enum CodingKeys: String, CodingKey {
        case promotionalStories = "headlineItems"
    }
}

public struct PromotionalStory: Codable {
    public var id: String
    public var title: String
    public var imageUrl: String
    public var linkUrl: String
    public var bodyText: String
    public var callToActionText: String?
    
    enum CodingKeys: String, CodingKey {
        case id = "idfwheadline"
        case title = "title"
        case imageUrl = "imageurl"
        case linkUrl = "linkurl"
        case bodyText = "bodytext"
        case callToActionText = "callToActionText"
    }
}
````

## File: Sources/ServicesProvider/Models/Referrals/Referee.swift
````swift
//
//  Referee.swift
//
//
//  Created by André Lascas on 11/03/2024.
//

import Foundation

public struct Referee: Codable {
    
    public var id: Int
    public var username: String
    public var registeredAt: String
    public var kycStatus: String
    public var depositPassed: Bool
    
    enum CodingKeys: String, CodingKey {
        case id = "partyId"
        case username = "userId"
        case registeredAt = "regDate"
        case kycStatus = "kycStatus"
        case depositPassed = "depositAmountPassed"
    }
}
````

## File: Sources/ServicesProvider/Models/Referrals/RefereesResponse.swift
````swift
//
//  RefereesResponse.swift
//
//
//  Created by André Lascas on 11/03/2024.
//

import Foundation

public struct RefereesResponse: Codable {
    public var status: String
    public var referees: [Referee]
    
    enum CodingKeys: String, CodingKey {
        case status = "status"
        case referees = "referees"
    }
}
````

## File: Sources/ServicesProvider/Models/Referrals/ReferralLink.swift
````swift
//
//  ReferralLink.swift
//
//
//  Created by André Lascas on 11/03/2024.
//

import Foundation

public struct ReferralLink: Codable {
    
    public var code: String
    public var link: String
    
    enum CodingKeys: String, CodingKey {
        case code = "referralCode"
        case link = "referralLink"
    }
}
````

## File: Sources/ServicesProvider/Models/Referrals/ReferralResponse.swift
````swift
//
//  ReferralResponse.swift
//
//
//  Created by André Lascas on 11/03/2024.
//

import Foundation

public struct ReferralResponse: Codable {
    public var status: String
    public var referralLinks: [ReferralLink]
    
    enum CodingKeys: String, CodingKey {
        case status = "status"
        case referralLinks = "referralLinks"
    }
}
````

## File: Sources/ServicesProvider/Models/SharedTicket/SharedBet.swift
````swift
//
//  SharedBet.swift
//  
//
//  Created by André Lascas on 21/04/2023.
//

import Foundation

public struct SharedBet: Codable {

    public var betSelections: [SharedBetSelection]
    public var winStake: Double
    public var potentialReturn: Double
    public var totalStake: Double

    enum CodingKeys: String, CodingKey {
        case betSelections = "betLegs"
        case winStake = "winStake"
        case potentialReturn = "potentialReturn"
        case totalStake = "totalStake"
    }
}
````

## File: Sources/ServicesProvider/Models/SharedTicket/SharedBetSelection.swift
````swift
//
//  SharedBetSelection.swift
//  
//
//  Created by André Lascas on 21/04/2023.
//

import Foundation

public struct SharedBetSelection: Codable {

    public var id: Double
    public var priceDenominator: Int
    public var priceNumerator: Int
    public var priceType: String

    public var odd: Double {
        let priceNumerator = Double(self.priceNumerator)
        let priceDenominator = Double(self.priceDenominator)
        return (priceNumerator/priceDenominator) + 1.0
    }

    enum CodingKeys: String, CodingKey {
        case id = "idFOSelection"
        case priceDenominator = "priceDown"
        case priceNumerator = "priceUp"
        case priceType = "idFOPriceType"
    }
}
````

## File: Sources/ServicesProvider/Models/SharedTicket/SharedTicketResponse.swift
````swift
//
//  SharedTicketResponse.swift
//  
//
//  Created by André Lascas on 21/04/2023.
//

import Foundation

public struct SharedTicketResponse: Codable {

    public var bets: [SharedBet]
    public var totalStake: Double?
    public var betId: Double

    enum CodingKeys: String, CodingKey {
        case bets = "bets"
        case totalStake = "totalStake"
        case betId = "idFOBetSlip"
    }
}
````

## File: Sources/ServicesProvider/Models/SharedTicket/TicketSelection.swift
````swift
//
//  TicketSelection.swift
//  
//
//  Created by André Lascas on 24/04/2023.
//

import Foundation

public struct TicketSelection: Codable {

    public var id: String
    public var marketId: String
    public var name: String
    public var priceDenominator: String
    public var priceNumerator: String

    public var odd: Double {
        let priceNumerator = Double(self.priceNumerator) ?? 0.0
        let priceDenominator = Double(self.priceDenominator) ?? 0.0
        return (priceNumerator/priceDenominator) + 1.0
    }

    enum CodingKeys: String, CodingKey {
        case id = "idfoselection"
        case marketId = "idfomarket"
        case name = "name"
        case priceDenominator = "currentpricedown"
        case priceNumerator = "currentpriceup"
    }
}
````

## File: Sources/ServicesProvider/Models/SharedTicket/TicketSelectionResponse.swift
````swift
//
//  TicketSelectionResponse.swift
//  
//
//  Created by André Lascas on 24/04/2023.
//

import Foundation

public struct TicketSelectionResponse: Codable {

    public var data: TicketSelection?
    public var errorType: String?

    enum CodingKeys: String, CodingKey {
        case data = "data"
        case errorType = "errorType"
    }
}
````

## File: Sources/ServicesProvider/Models/Social/AddFriendResponse.swift
````swift
//
//  AddFriendResponse.swift
//
//
//  Created by André Lascas on 26/03/2024.
//

import Foundation

public struct AddFriendResponse {
    public var chatroomIds: [Int]?
}
````

## File: Sources/ServicesProvider/Models/Social/Chatroom.swift
````swift
//
//  Chatroom.swift
//
//
//  Created by André Lascas on 26/03/2024.
//

import Foundation

public struct Chatroom {
    public let id: Int
    public let name: String
    public let type: String
    public let creationTimestamp: Int?
}
````

## File: Sources/ServicesProvider/Models/Social/ChatroomData.swift
````swift
//
//  ChatroomData.swift
//
//
//  Created by André Lascas on 26/03/2024.
//

import Foundation

public struct ChatroomData {
    public let chatroom: Chatroom
    public let users: [GomaFriend]
}
````

## File: Sources/ServicesProvider/Models/Social/ChatroomId.swift
````swift
//
//  ChatroomId.swift
//
//
//  Created by André Lascas on 27/03/2024.
//

import Foundation

public struct ChatroomId {
    public let id: Int

}
````

## File: Sources/ServicesProvider/Models/Social/DeleteGroupResponse.swift
````swift
//
//  DeleteGroupResponse.swift
//
//
//  Created by André Lascas on 27/03/2024.
//

import Foundation

public struct DeleteGroupResponse {
    public var status: String
    public var message: String?
}
````

## File: Sources/ServicesProvider/Models/Social/Follower.swift
````swift
//
//  Follower.swift
//
//
//  Created by André Lascas on 15/02/2024.
//

import Foundation

public struct Follower: Codable {
    public var id: Int
    public var name: String
    
}
````

## File: Sources/ServicesProvider/Models/Social/FriendRequest.swift
````swift
//
//  FriendRequest.swift
//
//
//  Created by André Lascas on 25/03/2024.
//

import Foundation

public struct FriendRequest: Codable {
    public var id: Int
    public var name: String
    public var username: String

}
````

## File: Sources/ServicesProvider/Models/Social/SearchUser.swift
````swift
//
//  SearchUser.swift
//  
//
//  Created by André Lascas on 26/03/2024.
//

import Foundation

public struct SearchUser: Decodable {
    public let id: Int
    public let username: String
    public let avatar: String?
}
````

## File: Sources/ServicesProvider/Models/Social/TipRanking.swift
````swift
//
//  TipRanking.swift
//
//
//  Created by André Lascas on 21/02/2024.
//

import Foundation

public struct TipRanking: Codable {
    public var position: Int
    public var result: Double
    public var userId: Int
    public var name: String
    public var code: String
    public var avatar: String?
    public var anonymous: Bool
}
````

## File: Sources/ServicesProvider/Models/Social/UserFriend.swift
````swift
//
//  GomaFriend.swift
//
//
//  Created by André Lascas on 26/03/2024.
//

import Foundation

public struct GomaFriend {
    public var id: Int
    public var name: String
    public var avatar: String?
    public var isAdmin: Bool?
}
````

## File: Sources/ServicesProvider/Models/Social/UserProfileInfo.swift
````swift
//
//  UserProfileInfo.swift
//
//
//  Created by André Lascas on 26/02/2024.
//

import Foundation


public struct UserProfileInfo: Codable {

    public var name: String
    public var avatar: String?
    public var following: Int
    public var followers: Int
    public var rankings: UserProfileRanking
    public var sportsPerc: [UserProfileSportsData]

    enum CodingKeys: String, CodingKey {
        case name = "name"
        case avatar = "avatar"
        case following = "following"
        case followers = "followers"
        case rankings = "rankings"
        case sportsPerc = "sports_perc"
    }
}

public struct UserProfileRanking: Codable {

    public var consecutiveWins: Int
    public var accumulatedWins: Double
    public var highestOdd: Double

    enum CodingKeys: String, CodingKey {
        case consecutiveWins = "consecutive_wins"
        case accumulatedWins = "accumulated_wins"
        case highestOdd = "highest_odd"
    }
}

public struct UserProfileSportsData: Codable {
    public var sportId: Int
    public var percentage: Double
    public var sportIdIcon: String

    enum CodingKeys: String, CodingKey {
        case sportId = "sport_id"
        case percentage = "percentage"
        case sportIdIcon = "sport_id_icon"
    }
}
````

## File: Sources/ServicesProvider/Models/Transactions/TransactionTypes.swift
````swift
//
//  TransactionTypes.swift
//  
//
//  Created by André Lascas on 11/04/2023.
//

import Foundation

public enum TransactionType: CaseIterable {

    public enum EscrowType: String {
        case ESC_AML
        case ESC_AN_WIN
        case ESC_REVIEW
        case ESC_RG_DEF
        
        public init?(rawValue: String) {
            switch rawValue {
            case "ESC_AML": self = .ESC_AML
            case "ESC_AN_WIN": self = .ESC_AN_WIN
            case "ESC_REVIEW": self = .ESC_REVIEW
            case "ESC_RG_DEF": self = .ESC_RG_DEF
            default: return nil
            }
        }
        
    }
    
    case deposit
    case withdrawal
    case bonusCredited
    case bonusExpired
    case bonusReleased
    case depositCancel
    case withdrawalCancel
    case betPlaced
    case betSettled
    case cashOut
    case refund
    case productBonus
    case manualAdjustment
    case withdrawalReject
    case automatedWithdrawalThreshold
    case automatedWithdrawal
    case depositReturned

    init?(transactionType: String, escrowType: String?) {

        switch transactionType {
        case "DEPOSIT": self = .deposit
        case "WITHDRAWAL": self = .withdrawal
        case "CRE_BONUS": self = .bonusCredited
        case "EXP_BONUS": self = .bonusExpired
        case "BONUS_REL": self = .bonusReleased
        case "DP_CANCEL": self = .depositCancel
        case "WD_CANCEL": self = .withdrawalCancel
        case "GAME_BET": self = .betPlaced
        case "GAME_WIN": self = .betSettled
        case "CASH_OUT": self = .cashOut
        case "REFUND": self = .refund
        case "PRODUC_BON": self = .productBonus
        case "MAN_ADJUST": self = .manualAdjustment
        case "WD_REJECT": self = .withdrawalReject
        case "ESC_XFER": self = .automatedWithdrawalThreshold
        case "ESC_XFER_SIMPLE": self = .automatedWithdrawal
        case "DP_RBACK": self = .depositReturned
        default: return nil
        }
    }

    var transactionKey: String {
        switch self {
        case .deposit: return "DEPOSIT"
        case .withdrawal: return "WITHDRAWAL"
        case .bonusCredited: return "CRE_BONUS"
        case .bonusExpired: return "EXP_BONUS"
        case .bonusReleased: return "BONUS_REL"
        case .depositCancel: return "DP_CANCEL"
        case .withdrawalCancel: return "WD_CANCEL"
        case .betPlaced: return "GAME_BET"
        case .betSettled: return "GAME_WIN"
        case .cashOut: return "CASH_OUT"
        case .refund: return "REFUND"
        case .productBonus: return "PRODUC_BON"
        case .manualAdjustment: return "MAN_ADJUST"
        case .withdrawalReject: return "WD_REJECT"
        case .automatedWithdrawalThreshold: return "ESC_XFER"
        case .automatedWithdrawal: return "ESC_XFER_SIMPLE"
        case .depositReturned: return "DP_RBACK"
        }
    }

}
````

## File: Sources/ServicesProvider/Models/UserConsents/UserConsent.swift
````swift
//
//  UserConsent.swift
//  
//
//  Created by André Lascas on 09/05/2023.
//

import Foundation

public struct UserConsent: Hashable {
    public var info: UserConsentInfo
    public var status: UserConsentStatus
    public var type: UserConsentType
}
````

## File: Sources/ServicesProvider/Models/UserConsents/UserConsentInfo.swift
````swift
//
//  UserConsentInfo.swift
//  
//
//  Created by André Lascas on 09/05/2023.
//

import Foundation

public struct ConsentInfo: Codable {

    public var id: Int
    public var key: String
    public var name: String
    public var consentVersionId: Int

    public var status: String?
    public var isMandatory: Bool?
    
}


public struct UserConsentInfo: Codable, Hashable {

    public var id: Int
    public var key: String
    public var name: String
    public var consentVersionId: Int    
    public var isMandatory: Bool?

}
````

## File: Sources/ServicesProvider/Models/UserConsents/UserConsentsResponse.swift
````swift
//
//  UserConsentsResponse.swift
//  
//
//  Created by André Lascas on 09/05/2023.
//

import Foundation

public struct UserConsentsResponse: Hashable {
    public var status: String
    public var message: String?
    public var userConsents: [UserConsent]
}
````

## File: Sources/ServicesProvider/Models/UserConsents/UserConsentStatus.swift
````swift
//
//  UserConsentStatus.swift
//  
//
//  Created by André Lascas on 12/05/2023.
//

import Foundation

public enum UserConsentStatus: Hashable {
    case consented
    case notConsented
    case unknown
}
````

## File: Sources/ServicesProvider/Models/UserConsents/UserConsentType.swift
````swift
//
//  UserConsentType.swift
//  
//
//  Created by André Lascas on 12/05/2023.
//

import Foundation

public enum UserConsentType: Hashable {
    case sms
    case email
    case terms
    case unknown
}
````

## File: Sources/ServicesProvider/Models/Withdrawals/AddPaymentInformationResponse.swift
````swift
//
//  AddPaymentInformationResponse.swift
//  
//
//  Created by André Lascas on 16/03/2023.
//

import Foundation

public struct AddPaymentInformationResponse: Codable {
    public var status: String
    public var message: String?

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case message = "message"
    }
}
````

## File: Sources/ServicesProvider/Models/Withdrawals/BankPaymentDetail.swift
````swift
//
//  BankPaymentDetail.swift
//  
//
//  Created by André Lascas on 15/03/2023.
//

import Foundation

public struct BankPaymentDetail: Codable {

    public var id: Int
    public var paymentInfoId: Int
    public var key: String
    public var value: String

    enum CodingKeys: String, CodingKey {
        case id = "id"
        case paymentInfoId = "paymentInformationId"
        case key = "key"
        case value = "value"
    }
}
````

## File: Sources/ServicesProvider/Models/Withdrawals/BankPaymentInfo.swift
````swift
//
//  BankPaymentInfo.swift
//  
//
//  Created by André Lascas on 15/03/2023.
//

import Foundation

public struct BankPaymentInfo: Codable {

    public var id: Int
    public var partyId: Int
    public var type: String
    public var description: String?
    public var priority: Int?
    public var details: [BankPaymentDetail]

    enum CodingKeys: String, CodingKey {
        case id = "id"
        case partyId = "partyId"
        case type = "type"
        case description = "description"
        case priority = "priority"
        case details = "details"
    }
}
````

## File: Sources/ServicesProvider/Models/Withdrawals/CancelWithdrawalResponse.swift
````swift
//
//  CancelWithdrawalResponse.swift
//  
//
//  Created by André Lascas on 28/02/2023.
//

import Foundation

public struct CancelWithdrawalResponse: Codable {
    public var status: String
    public var amount: String
    public var currency: String

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case amount = "amount"
        case currency = "currency"
    }
}
````

## File: Sources/ServicesProvider/Models/Withdrawals/PaymentInformation.swift
````swift
//
//  PaymentInformation.swift
//  
//
//  Created by André Lascas on 15/03/2023.
//

import Foundation

public struct PaymentInformation: Codable {

    public var status: String
    public var data: [BankPaymentInfo]

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case data = "data"
    }
}
````

## File: Sources/ServicesProvider/Models/Withdrawals/PendingWithdrawal.swift
````swift
//
//  PendingWithdrawal.swift
//  
//
//  Created by André Lascas on 28/02/2023.
//

import Foundation

public struct PendingWithdrawal: Codable {

    public var status: String
    public var paymentId: Int
    public var amount: String

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case paymentId = "paymentId"
        case amount = "amount"
    }
}
````

## File: Sources/ServicesProvider/Models/Withdrawals/PendingWithdrawalResponse.swift
````swift
//
//  PendingWithdrawalResponse.swift
//  
//
//  Created by André Lascas on 28/02/2023.
//

import Foundation

public struct PendingWithdrawalResponse: Codable {

    public var status: String
    public var pendingWithdrawals: [PendingWithdrawal]

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case pendingWithdrawals = "withdrawals"
    }
}
````

## File: Sources/ServicesProvider/Models/Withdrawals/ProcessWithdrawalResponse.swift
````swift
//
//  ProcessWithdrawalResponse.swift
//  
//
//  Created by André Lascas on 27/02/2023.
//

import Foundation

public struct ProcessWithdrawalResponse: Codable {

    public var status: String
    public var paymentId: String?
    public var message: String?

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case paymentId = "paymentId"
        case message = "message"
    }
}

public struct PrepareWithdrawalResponse: Codable {

    public var status: String
    public var conversionId: String?
    public var message: String?

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case conversionId = "conversionId"
        case message = "message"
    }
}
````

## File: Sources/ServicesProvider/Models/Withdrawals/WithdrawalMethod.swift
````swift
//
//  WithdrawalMethod.swift
//  
//
//  Created by André Lascas on 24/02/2023.
//

import Foundation

public struct WithdrawalMethod: Codable {
    public var code: String
    public var paymentMethod: String
    public var minimumWithdrawal: String
    public var maximumWithdrawal: String
    public var conversionRequired: Bool

    enum CodingKeys: String, CodingKey {
        case code = "code"
        case paymentMethod = "paymentMethod"
        case minimumWithdrawal = "minimumWithdrawal"
        case maximumWithdrawal = "maximumWithdrawal"
        case conversionRequired = "conversionRequired"
    }
}
````

## File: Sources/ServicesProvider/Models/Withdrawals/WithdrawalMethodsResponse.swift
````swift
//
//  WithdrawalMethodsResponse.swift
//  
//
//  Created by André Lascas on 24/02/2023.
//

import Foundation

public struct WithdrawalMethodsResponse: Codable {
    public var status: String
    public var withdrawalMethods: [WithdrawalMethod]

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case withdrawalMethods = "withdrawalMethods"
    }
}
````

## File: Sources/ServicesProvider/Models/AnalyticsTrackedEvent.swift
````swift
//
//  AnalyticsTrackedEvent.swift
//
//
//  Created by Ruben Roques on 28/05/2024.
//

import Foundation


public enum AnalyticsTrackedEvent {
    
    case impressionsEvents(eventsIds: [String])
    case clickEvent(id: String)
    case clickOutcome(eventId: String, outcomeId: String)
 
}
````

## File: Sources/ServicesProvider/Models/BannerAlert.swift
````swift
//
//  BannerAlert.swift
//  ServicesProvider
//
//  Created by Ruben Roques on 19/02/2025.
//

import Foundation

public struct BannerAlert: Codable {
    
    public var identifier: String
    public var title: String?
    public var subtitle: String?
    public var callToActionText: String?
    public var callToActionUrl: String?
    public var isActive: Int?
    public var createdAt: String?
    public var updatedAt: String?
    
    enum CodingKeys: String, CodingKey {
        case identifier = "id"
        case title = "title"
        case subtitle = "subtitle"
        case callToActionText = "cta_text"
        case callToActionUrl = "cta_url"
        case isActive = "is_active"
        case createdAt = "created_at"
        case updatedAt = "updated_at"
    }
    
    init(identifier: String,
         title: String?,
         subtitle: String?,
         ctaText: String?,
         ctaUrl: String?,
         isActive: Int?,
         createdAt: String?,
         updatedAt: String?)
    {
        self.identifier = identifier
        self.title = title
        self.subtitle = subtitle
        self.callToActionText = ctaText
        self.callToActionUrl = ctaUrl
        self.isActive = isActive
        self.createdAt = createdAt
        self.updatedAt = updatedAt
    }
}
````

## File: Sources/ServicesProvider/Models/BetQRCode.swift
````swift
//
//  BetQRCode.swift
//  ServicesProvider
//
//  Created by Ruben Roques on 19/02/2025.
//

import Foundation

public struct BetQRCode: Codable {
    public var qrCode: String?
    public var expirationDate: String?
    public var message: String?
    
    public init(qrCode: String? = nil, expirationDate: String? = nil, message: String? = nil) {
        self.qrCode = qrCode
        self.expirationDate = expirationDate
        self.message = message
    }
}
````

## File: Sources/ServicesProvider/Models/Betting.swift
````swift
//
//  Betting.swift
//
//
//  Created by Ruben Roques on 16/11/2022.
//

import Foundation
import SharedModels

public struct BettingHistory: Codable {
    public var bets: [Bet]
}

/// Represents a bet in the system
/// This struct is a merged version of both Sportsbook and Multibet implementations
public struct Bet: Codable, Equatable, Hashable {

    // Core properties - present in both implementations
    public var identifier: String
    public var type: String
    public var state: BetState
    public var result: BetResult
    public var globalState: BetState
    public var stake: Double
    public var totalOdd: Double
    public var selections: [BetSelection]
    public var potentialReturn: Double?
    public var totalReturn: Double?
    public var date: Date
    public var freebet: Bool

    // Cashout related properties - present in both implementations
    public var partialCashoutReturn: Double?
    public var partialCashoutStake: Double?

    // Betslip identifier - present in both implementations
    public var betslipId: Int?

    // Return calculation properties - present in both implementations
    public var cashbackReturn: Double?
    public var freebetReturn: Double?
    public var potentialCashbackReturn: Double?
    public var potentialFreebetReturn: Double?

    // MARK: - Properties specific to Multibet
    // Unique identifier for sharing bets
    // Note: This property was only present in Multibet implementation
    public var shareId: String?

    public init(
        identifier: String,
        type: String,
        state: BetState,
        result: BetResult,
        globalState: BetState,
        stake: Double,
        totalOdd: Double,
        selections: [BetSelection],
        potentialReturn: Double? = nil,
        totalReturn: Double? = nil,
        date: Date,
        freebet: Bool,
        partialCashoutReturn: Double? = nil,
        partialCashoutStake: Double? = nil,
        betslipId: Int? = nil,
        cashbackReturn: Double? = nil,
        freebetReturn: Double? = nil,
        potentialCashbackReturn: Double? = nil,
        potentialFreebetReturn: Double? = nil,
        shareId: String? = nil
    ) {
        self.identifier = identifier
        self.type = type
        self.state = state
        self.result = result
        self.globalState = globalState
        self.stake = stake
        self.totalOdd = totalOdd
        self.selections = selections
        self.potentialReturn = potentialReturn
        self.totalReturn = totalReturn
        self.date = date
        self.freebet = freebet
        self.partialCashoutReturn = partialCashoutReturn
        self.partialCashoutStake = partialCashoutStake
        self.betslipId = betslipId
        self.cashbackReturn = cashbackReturn
        self.freebetReturn = freebetReturn
        self.potentialCashbackReturn = potentialCashbackReturn
        self.potentialFreebetReturn = potentialFreebetReturn
        self.shareId = shareId
    }
}

/// Represents a selection within a bet
/// This struct is a merged version of both Sportsbook and Multibet implementations
public struct BetSelection: Codable, Equatable, Hashable {
    // MARK: - Core Properties (present in both implementations)
    public var identifier: String
    public var state: BetState
    public var result: BetResult
    public var globalState: BetState
    public var eventName: String
    public var homeTeamName: String?
    public var awayTeamName: String?
    public var marketName: String
    public var outcomeName: String
    public var odd: OddFormat

    // MARK: - Score Properties (present in both implementations)
    public var homeResult: String?
    public var awayResult: String?

    // MARK: - Event Properties (present in both implementations)
    public var eventId: String
    public var eventDate: Date?
    public var country: Country?
    public var tournamentName: String

    // MARK: - Sport Properties (implementation differences)
    /// Sport type information
    /// Note: Sportsbook uses String, Multibet uses SportType enum
    /// Migration: When converting from Sportsbook, use SportType(fromString:) to convert
    public var sportType: SportType

    // MARK: - Market and Outcome Properties (Multibet specific)
    /// Unique identifier for the market
    /// Note: Only present in Multibet implementation
    public var marketId: String?

    /// Unique identifier for the outcome
    /// Note: Only present in Multibet implementation
    public var outcomeId: String?

    // MARK: - Team Logo Properties (Multibet specific)
    /// URL for the home team's logo
    /// Note: Only present in Multibet implementation
    public var homeLogoUrl: String?

    /// URL for the away team's logo
    /// Note: Only present in Multibet implementation
    public var awayLogoUrl: String?

    public init(
        identifier: String,
        state: BetState,
        result: BetResult,
        globalState: BetState,
        eventName: String,
        homeTeamName: String?,
        awayTeamName: String?,
        marketName: String,
        outcomeName: String,
        odd: OddFormat,
        homeResult: String?,
        awayResult: String?,
        eventId: String,
        eventDate: Date?,
        country: Country?,
        sportType: SportType,
        tournamentName: String,
        marketId: String? = nil,
        outcomeId: String? = nil,
        homeLogoUrl: String? = nil,
        awayLogoUrl: String? = nil
    ) {
        self.identifier = identifier
        self.state = state
        self.result = result
        self.globalState = globalState
        self.eventName = eventName
        self.homeTeamName = homeTeamName
        self.awayTeamName = awayTeamName
        self.marketName = marketName
        self.outcomeName = outcomeName
        self.odd = odd
        self.homeResult = homeResult
        self.awayResult = awayResult
        self.eventId = eventId
        self.eventDate = eventDate
        self.country = country
        self.sportType = sportType
        self.tournamentName = tournamentName
        self.marketId = marketId
        self.outcomeId = outcomeId
        self.homeLogoUrl = homeLogoUrl
        self.awayLogoUrl = awayLogoUrl
    }
}

public enum BetResult: String, Codable, Equatable, Hashable {
    case won
    case lost
    case drawn
    case open
    case void
    case pending
    case notSpecified
}

public enum BetState: String, Codable, Equatable, Hashable {
    case opened
    case closed
    case settled
    case cancelled
    case attempted
    case won
    case lost
    case cashedOut
    case void
    case undefined
}

//public struct BetTicketStake: Codable {
//    var stake: Double
//}
public enum BetGroupingType: Codable, Equatable, Hashable {
    case single(identifier: String)
    case multiple(identifier: String)
    case system(identifier: String, name: String, numberOfBets: Int)

    var identifier: String {
        switch self {
        case .single(let identifier):
            return identifier
        case .multiple(let identifier):
            return identifier
        case .system(let identifier, _, _):
            return identifier
        }
    }
}

public struct BetType: Codable, Equatable, Hashable {
    public var name: String
    public var grouping: BetGroupingType
    public var code: String
    public var numberOfBets: Int
    public var potencialReturn: Double
    public var totalStake: Double?
}

public struct BetslipPotentialReturn: Codable, Equatable, Hashable {
    public var potentialReturn: Double
    public var totalStake: Double
    public var numberOfBets: Int
    public var totalOdd: Double
}

public struct BetBuilderPotentialReturn: Codable, Equatable, Hashable {
    public var potentialReturn: Double
    public var calculatedOdds: Double
}


public struct BetTicket: Codable {
    public var tickets: [BetTicketSelection]
    public var globalStake: Double?
    public var betGroupingType: BetGroupingType

    public init(tickets: [BetTicketSelection], stake: Double?, betGroupingType: BetGroupingType) {
        self.tickets = tickets
        self.globalStake = stake
        self.betGroupingType = betGroupingType
    }
}

public enum BetslipOddChangeSetting: String, Codable, Equatable, Hashable {
    case none
    // case any
    case higher
}

public enum OddFormat: Codable, Equatable, Hashable {
    case fraction(numerator: Int, denominator: Int)
    case decimal(odd: Double)

    var fractionOdd: (numerator: Int, denominator: Int)? {
        switch self {
        case .fraction(let numerator, let denominator):
            return (numerator: numerator, denominator: denominator)
        case .decimal:
            return nil
        }
    }

    var decimalOdd: Double {
        switch self {
        case .fraction(let numerator, let denominator):
            let decimal = (Double(numerator)/Double(denominator)) + 1.0
            if decimal.isNaN {
                return decimal
            }
            else {
                return decimal
            }
        case .decimal(let odd):
            return odd
        }
    }
}

public struct BetTicketSelection: Codable, Equatable, Hashable {

    public var identifier: String
    public var eventName: String
    public var homeTeamName: String
    public var awayTeamName: String
    public var marketName: String
    public var outcomeName: String
    public var odd: OddFormat
    public var stake: Double

    public var sportIdCode: String?
    public var eventId: String?
    public var marketId: String?
    public var outcomeId: String?

    public init(identifier: String,
                eventName: String,
                homeTeamName: String,
                awayTeamName: String,
                marketName: String,
                outcomeName: String,
                odd: OddFormat,
                stake: Double,
                sportIdCode: String?,
                eventId: String? = nil,
                marketId: String? = nil,
                outcomeId: String? = nil) {

        self.identifier = identifier
        self.eventName = eventName
        self.homeTeamName = homeTeamName
        self.awayTeamName = awayTeamName
        self.marketName = marketName
        self.outcomeName = outcomeName
        self.odd = odd
        self.stake = stake
        self.sportIdCode = sportIdCode
        self.eventId = eventId
        self.marketId = marketId
        self.outcomeId = outcomeId
    }

}

public struct PlacedBetsResponse: Codable, Equatable, Hashable {

    public var identifier: String

    public var bets: [PlacedBetEntry]
    public var detailedBets: [Bet]? // Contain all the details of the bet and event/outcome

    public var requiredConfirmation: Bool
    public var totalStake: Double

    public init(identifier: String,
                bets: [PlacedBetEntry],
                detailedBets: [Bet]?,
                requiredConfirmation: Bool = false,
                totalStake: Double) {

        self.identifier = identifier
        self.bets = bets
        self.detailedBets = detailedBets
        self.requiredConfirmation = requiredConfirmation
        self.totalStake = totalStake
    }

}

public struct NoReply: Codable {

}

public struct PlacedBetEntry: Codable, Equatable, Hashable {

    public var identifier: String
    public var potentialReturn: Double
    public var totalStake: Double
    public var betLegs: [PlacedBetLeg]
    public var type: String?

    enum CodingKeys: String, CodingKey {
        case identifier = "idFOBet"
        case betLegs = "betLegs"
        case potentialReturn = "potentialReturn"
        case totalStake = "totalStake"
        case type = "idfoBetType"
    }

    public init(identifier: String, potentialReturn: Double, totalStake: Double, betLegs: [PlacedBetLeg], type: String?) {
        self.identifier = identifier
        self.potentialReturn = potentialReturn
        self.totalStake = totalStake
        self.betLegs = betLegs
        self.type = type
    }
}

public struct PlacedBetLeg: Codable, Equatable, Hashable {
    public var identifier: String
    public var priceType: String

    public var odd: Double {
        let priceNumerator = Double(self.priceNumerator)
        let priceDenominator = Double(self.priceDenominator)
        return (priceNumerator/priceDenominator) + 1.0
    }

    private var priceNumerator: Int
    private var priceDenominator: Int

    enum CodingKeys: String, CodingKey {
        case identifier = "idFOSelection"
        case priceNumerator = "priceUp"
        case priceDenominator = "priceDown"
        case priceType = "idFOPriceType"
    }

    public init(identifier: String, priceType: String, priceNumerator: Int, priceDenominator: Int) {
        self.identifier = identifier
        self.priceType = priceType
        self.priceNumerator = priceNumerator
        self.priceDenominator = priceDenominator
    }

}

public struct BetslipSettings: Codable {

    public var oddChangeLegacy: BetslipOddChangeSetting?
    public var oddChangeRunningOrPreMatch: BetslipOddChangeSetting?

    public init(oddChangeLegacy: BetslipOddChangeSetting?, oddChangeRunningOrPreMatch: BetslipOddChangeSetting?) {
        self.oddChangeLegacy = oddChangeLegacy
        self.oddChangeRunningOrPreMatch = oddChangeRunningOrPreMatch
    }

}
````

## File: Sources/ServicesProvider/Models/BonusState.swift
````swift
//
//  BonusState.swift
//  
//
//  Created by André Lascas on 23/05/2023.
//

import Foundation

public enum BonusState {
    case accepted
    case declined
    case nonExistent
}
````

## File: Sources/ServicesProvider/Models/Country.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 27/10/2022.
//

import Foundation
import SharedModels

public enum CountryCode: String, CaseIterable {
    case AF
    case AX
    case AL
    case DZ
    case AS
    case AD
    case AO
    case AI
    case AQ
    case AG
    case AR
    case AM
    case AW
    case AU
    case AT
    case AZ
    case BS
    case BH
    case BD
    case BB
    case BY
    case BE
    case BZ
    case BJ
    case BM
    case BT
    case BO
    case BQ
    case BA
    case BW
    case BV
    case BR
    case IO
    case UM
    case VG
    case VI
    case BN
    case BG
    case BF
    case BI
    case KH
    case CM
    case CA
    case CV
    case KY
    case CF
    case TD
    case CL
    case CN
    case CX
    case CC
    case CO
    case KM
    case CG
    case CD
    case CK
    case CR
    case HR
    case CU
    case CW
    case CY
    case CZ
    case DK
    case DJ
    case DM
    case DO
    case EC
    case EG
    case SV
    case GQ
    case ER
    case EE
    case ET
    case FK
    case FO
    case FJ
    case FI
    case FR
    case GF
    case PF
    case TF
    case GA
    case GM
    case GE
    case DE
    case GH
    case GI
    case GR
    case GL
    case GD
    case GP
    case GU
    case GT
    case GG
    case GN
    case GW
    case GY
    case HT
    case HM
    case VA
    case HN
    case HU
    case HK
    case IS
    case IN
    case ID
    case CI
    case IR
    case IQ
    case IE
    case IM
    case IL
    case IT
    case JM
    case JP
    case JE
    case JO
    case KZ
    case KE
    case KI
    case KW
    case KG
    case LA
    case LV
    case LB
    case LS
    case LR
    case LY
    case LI
    case LT
    case LU
    case MO
    case MK
    case MG
    case MW
    case MY
    case MV
    case ML
    case MT
    case MH
    case MQ
    case MR
    case MU
    case YT
    case MX
    case FM
    case MD
    case MC
    case MN
    case ME
    case MS
    case MA
    case MZ
    case MM
    case NA
    case NR
    case NP
    case NL
    case NC
    case NZ
    case NI
    case NE
    case NG
    case NU
    case NF
    case KP
    case MP
    case NO
    case OM
    case PK
    case PW
    case PS
    case PA
    case PG
    case PY
    case PE
    case PH
    case PN
    case PL
    case PT
    case PR
    case QA
    case XK
    case RE
    case RO
    case RU
    case RW
    case BL
    case SH
    case KN
    case LC
    case MF
    case PM
    case VC
    case WS
    case SM
    case ST
    case SA
    case SN
    case RS
    case SC
    case SL
    case SG
    case SX
    case SK
    case SI
    case SB
    case SO
    case ZA
    case GS
    case KR
    case ES
    case LK
    case SD
    case SS
    case SR
    case SJ
    case SZ
    case SE
    case CH
    case SY
    case TW
    case TJ
    case TZ
    case TH
    case TL
    case TG
    case TK
    case TO
    case TT
    case TN
    case TR
    case TM
    case TC
    case TV
    case UG
    case UA
    case AE
    case GB
    case US
    case UY
    case UZ
    case VU
    case VE
    case VN
    case WF
    case EH
    case YE
    case ZM
    case ZW
}

public extension SharedModels.Country {
    
    init?(countryCode: CountryCode) {
        if let country = Self.country(withCountryCode: countryCode) {
            self = country
        }
        else {
            return nil
        }
    }
    
    init?(isoCode: String) {
        if let country = Self.country(withISOCode: isoCode) {
            self = country
        }
        else {
            return nil
        }
    }
    
    static var allCountries: [Country] {
        return CountryCode.allCases.map({ Self.country(withCountryCode:$0)}).compactMap({ $0 })
    }
    
    static func country(withCountryCode countryCode: CountryCode) -> Country? {
        self.country(withISOCode: countryCode.rawValue)
    }
    
    static func getAllCountries() -> [Country] {
        var allCountries: [Country] = []
        
        let allISOs = ["AD","AE","AF","AG","AI","AL","AM","AO","AQ","AR","AS","AT","AU","AW","AX","AZ","BA","BB","BD","BE","BF","BG","BH","BI","BJ","BL","BM","BN","BO","BQ","BR","BS","BT","BV",
                       "BW","BY","BZ","CA","CC","CD","CF","CG","CH","CI","CK","CL","CM","CN","CO","CR","CU","CV","CW","CX","CY","CZ","DE","DJ","DK","DM","DO","DZ","EC","EE","EG","EH","ER","ES",
                       "ET","FI","FJ","FK","FM","FO","FR","GA","GB","GD","GE","GF","GG","GH","GI","GL","GM","GN","GP","GQ","GR","GS","GT","GU","GW","GY","HK","HM","HN","HR","HT","HU","ID","IE",
                       "IL","IM","IN","IO","IQ","IR","IS","IT","JE","JM","JO","JP","KE","KG","KH","KI","KM","KN","KP","KR","KW","KY","KZ","LA","LB","LC","LI","LK","LR","LS","LT","LU","LV","LY",
                       "MA","MC","MD","ME","MF","MG","MH","MK","ML","MM","MN","MO","MP","MQ","MR","MS","MT","MU","MV","MW","MX","MY","MZ","NA","NC","NE","NF","NG","NI","NL","NO","NP","NR","NU",
                       "NZ","OM","PA","PE","PF","PG","PH","PK","PL","PM","PN","PR","PS","PT","PW","PY","QA","RE","RO","RS","RU","RW","SA","SB","SC","SD","SE","SG","SH","SI","SJ","SK","SL","SM",
                       "SN","SO","SR","SS","ST","SV","SX","SY","SZ","TC","TD","TF","TG","TH","TJ","TK","TL","TM","TN","TO","TR","TT","TV","TW","TZ","UA","UG","UM","US","UY","UZ","VA","VC","VE",
                       "VG","VI","VN","VU","WF","WS","XK","YE","YT","ZA","ZM","ZW"]
        
        for iso in allISOs {
            if let country = Self.country(withISOCode: iso) {
                allCountries.append(country)
            }
        }
        
        return allCountries
    }
    
    static func country(withISOCode isoCode: String) -> Country? {
        switch isoCode {
        case "AD": return Country(name: "Andorra", capital: "Andorra la Vella", region: "Europe", iso2Code: "AD", iso3Code: "AND", numericCode: "020", phonePrefix: "+376", frenchName: "Andorre")
        case "AE": return Country(name: "United Arab Emirates", capital: "Abu Dhabi", region: "Asia", iso2Code: "AE", iso3Code: "ARE", numericCode: "784", phonePrefix: "+971", frenchName: "Émirats Arabes Unis")
        case "AF": return Country(name: "Afghanistan", capital: "Kabul", region: "Asia", iso2Code: "AF", iso3Code: "AFG", numericCode: "004", phonePrefix: "+93", frenchName: "Afghanistan")
        case "AG": return Country(name: "Antigua and Barbuda", capital: "Saint John's", region: "Americas", iso2Code: "AG", iso3Code: "ATG", numericCode: "028", phonePrefix: "+1", frenchName: "Antigua-Et-Barbuda")
        case "AI": return Country(name: "Anguilla", capital: "The Valley", region: "Americas", iso2Code: "AI", iso3Code: "AIA", numericCode: "660", phonePrefix: "+1", frenchName: "Anguilla")
        case "AL": return Country(name: "Albania", capital: "Tirana", region: "Europe", iso2Code: "AL", iso3Code: "ALB", numericCode: "008", phonePrefix: "+355", frenchName: "Albanie")
        case "AM": return Country(name: "Armenia", capital: "Yerevan", region: "Asia", iso2Code: "AM", iso3Code: "ARM", numericCode: "051", phonePrefix: "+374", frenchName: "Arménie")
        case "AO": return Country(name: "Angola", capital: "Luanda", region: "Africa", iso2Code: "AO", iso3Code: "AGO", numericCode: "024", phonePrefix: "+244", frenchName: "Angola")
        case "AQ": return Country(name: "Antarctica", capital: nil, region: "Polar", iso2Code: "AQ", iso3Code: "ATA", numericCode: "010", phonePrefix: "+672", frenchName: "Antarctique")
        case "AR": return Country(name: "Argentina", capital: "Buenos Aires", region: "Americas", iso2Code: "AR", iso3Code: "ARG", numericCode: "032", phonePrefix: "+54", frenchName: "Argentine")
        case "AS": return Country(name: "American Samoa", capital: "Pago Pago", region: "Oceania", iso2Code: "AS", iso3Code: "ASM", numericCode: "016", phonePrefix: "+1", frenchName: "Samoa Américaines")
        case "AT": return Country(name: "Austria", capital: "Vienna", region: "Europe", iso2Code: "AT", iso3Code: "AUT", numericCode: "040", phonePrefix: "+43", frenchName: "Autriche")
        case "AU": return Country(name: "Australia", capital: "Canberra", region: "Oceania", iso2Code: "AU", iso3Code: "AUS", numericCode: "036", phonePrefix: "+61", frenchName: "Australie")
        case "AW": return Country(name: "Aruba", capital: "Oranjestad", region: "Americas", iso2Code: "AW", iso3Code: "ABW", numericCode: "533", phonePrefix: "+297", frenchName: "Aruba")
        case "AX": return Country(name: "Åland Islands", capital: "Mariehamn", region: "Europe", iso2Code: "AX", iso3Code: "ALA", numericCode: "248", phonePrefix: "+358", frenchName: "Îles Åland")
        case "AZ": return Country(name: "Azerbaijan", capital: "Baku", region: "Asia", iso2Code: "AZ", iso3Code: "AZE", numericCode: "031", phonePrefix: "+994", frenchName: "Azerbaïdjan")
        case "BA": return Country(name: "Bosnia and Herzegovina", capital: "Sarajevo", region: "Europe", iso2Code: "BA", iso3Code: "BIH", numericCode: "070", phonePrefix: "+387", frenchName: "Bosnie-Herzégovine")
        case "BB": return Country(name: "Barbados", capital: "Bridgetown", region: "Americas", iso2Code: "BB", iso3Code: "BRB", numericCode: "052", phonePrefix: "+1", frenchName: "Barbad")
        case "BD": return Country(name: "Bangladesh", capital: "Dhaka", region: "Asia", iso2Code: "BD", iso3Code: "BGD", numericCode: "050", phonePrefix: "+880", frenchName: "Bangladesh")
        case "BE": return Country(name: "Belgium", capital: "Brussels", region: "Europe", iso2Code: "BE", iso3Code: "BEL", numericCode: "056", phonePrefix: "+32", frenchName: "Belgique")
        case "BF": return Country(name: "Burkina Faso", capital: "Ouagadougou", region: "Africa", iso2Code: "BF", iso3Code: "BFA", numericCode: "854", phonePrefix: "+226", frenchName: "Burkina Faso")
        case "BG": return Country(name: "Bulgaria", capital: "Sofia", region: "Europe", iso2Code: "BG", iso3Code: "BGR", numericCode: "100", phonePrefix: "+359", frenchName: "Bulgarie")
        case "BH": return Country(name: "Bahrain", capital: "Manama", region: "Asia", iso2Code: "BH", iso3Code: "BHR", numericCode: "048", phonePrefix: "+973", frenchName: "Bahreïn")
        case "BI": return Country(name: "Burundi", capital: "Gitega", region: "Africa", iso2Code: "BI", iso3Code: "BDI", numericCode: "108", phonePrefix: "+257", frenchName: "Burundi")
        case "BJ": return Country(name: "Benin", capital: "Porto-Novo", region: "Africa", iso2Code: "BJ", iso3Code: "BEN", numericCode: "204", phonePrefix: "+229", frenchName: "Bénin")
        case "BL": return Country(name: "Saint Barthélemy", capital: "Gustavia", region: "Americas", iso2Code: "BL", iso3Code: "BLM", numericCode: "652", phonePrefix: "+590", frenchName: "Saint-Barthélemy")
        case "BM": return Country(name: "Bermuda", capital: "Hamilton", region: "Americas", iso2Code: "BM", iso3Code: "BMU", numericCode: "060", phonePrefix: "+1", frenchName: "Bermudes")
        case "BN": return Country(name: "Brunei Darussalam", capital: "Bandar Seri Begawan", region: "Asia", iso2Code: "BN", iso3Code: "BRN", numericCode: "096", phonePrefix: "+673", frenchName: "Brunei Darussalam")
        case "BO": return Country(name: "Bolivia (Plurinational State of)", capital: "Sucre", region: "Americas", iso2Code: "BO", iso3Code: "BOL", numericCode: "068", phonePrefix: "+591", frenchName: "Bolivie (État Plurinational)")
        case "BQ": return Country(name: "Bonaire, Sint Eustatius and Saba", capital: "Kralendijk", region: "Americas", iso2Code: "BQ", iso3Code: "BES", numericCode: "535", phonePrefix: "+599", frenchName: "Bonaire, Saint-Eustache Et Saba")
        case "BR": return Country(name: "Brazil", capital: "Brasília", region: "Americas", iso2Code: "BR", iso3Code: "BRA", numericCode: "076", phonePrefix: "+55", frenchName: "Brésil")
        case "BS": return Country(name: "Bahamas", capital: "Nassau", region: "Americas", iso2Code: "BS", iso3Code: "BHS", numericCode: "044", phonePrefix: "+1", frenchName: "Bahamas")
        case "BT": return Country(name: "Bhutan", capital: "Thimphu", region: "Asia", iso2Code: "BT", iso3Code: "BTN", numericCode: "064", phonePrefix: "+975", frenchName: "Bhoutan")
        case "BV": return Country(name: "Bouvet Island", capital: nil, region: "Antarctic Ocean", iso2Code: "BV", iso3Code: "BVT", numericCode: "074", phonePrefix: "+47", frenchName: "Île Bouvet")
        case "BW": return Country(name: "Botswana", capital: "Gaborone", region: "Africa", iso2Code: "BW", iso3Code: "BWA", numericCode: "072", phonePrefix: "+267", frenchName: "Botswana")
        case "BY": return Country(name: "Belarus", capital: "Minsk", region: "Europe", iso2Code: "BY", iso3Code: "BLR", numericCode: "112", phonePrefix: "+375", frenchName: "Biélorussie")
        case "BZ": return Country(name: "Belize", capital: "Belmopan", region: "Americas", iso2Code: "BZ", iso3Code: "BLZ", numericCode: "084", phonePrefix: "+501", frenchName: "Belize")
        case "CA": return Country(name: "Canada", capital: "Ottawa", region: "Americas", iso2Code: "CA", iso3Code: "CAN", numericCode: "124", phonePrefix: "+1", frenchName: "Canada")
        case "CC": return Country(name: "Cocos (Keeling) Islands", capital: "West Island", region: "Oceania", iso2Code: "CC", iso3Code: "CCK", numericCode: "166", phonePrefix: "+61", frenchName: "Îles Cocos")
        case "CD": return Country(name: "Congo (Democratic Republic of the)", capital: "Kinshasa", region: "Africa", iso2Code: "CD", iso3Code: "COD", numericCode: "180", phonePrefix: "+243", frenchName: "République Démocratique Du Congo")
        case "CF": return Country(name: "Central African Republic", capital: "Bangui", region: "Africa", iso2Code: "CF", iso3Code: "CAF", numericCode: "140", phonePrefix: "+236", frenchName: "République Centrafricaine")
        case "CG": return Country(name: "Congo", capital: "Brazzaville", region: "Africa", iso2Code: "CG", iso3Code: "COG", numericCode: "178", phonePrefix: "+242", frenchName: "Congo")
        case "CH": return Country(name: "Switzerland", capital: "Bern", region: "Europe", iso2Code: "CH", iso3Code: "CHE", numericCode: "756", phonePrefix: "+41", frenchName: "Suisse")
        case "CI": return Country(name: "Ivory Coast", capital: "Yamoussoukro", region: "Africa", iso2Code: "CI", iso3Code: "CIV", numericCode: "384", phonePrefix: "+225", frenchName: "Côte D'Ivoire")
        case "CK": return Country(name: "Cook Islands", capital: "Avarua", region: "Oceania", iso2Code: "CK", iso3Code: "COK", numericCode: "184", phonePrefix: "+682", frenchName: "Îles Cook")
        case "CL": return Country(name: "Chile", capital: "Santiago", region: "Americas", iso2Code: "CL", iso3Code: "CHL", numericCode: "152", phonePrefix: "+56", frenchName: "Chili")
        case "CM": return Country(name: "Cameroon", capital: "Yaoundé", region: "Africa", iso2Code: "CM", iso3Code: "CMR", numericCode: "120", phonePrefix: "+237", frenchName: "Cameroun")
        case "CN": return Country(name: "China", capital: "Beijing", region: "Asia", iso2Code: "CN", iso3Code: "CHN", numericCode: "156", phonePrefix: "+86", frenchName: "Chine")
        case "CO": return Country(name: "Colombia", capital: "Bogotá", region: "Americas", iso2Code: "CO", iso3Code: "COL", numericCode: "170", phonePrefix: "+57", frenchName: "Colombie")
        case "CR": return Country(name: "Costa Rica", capital: "San José", region: "Americas", iso2Code: "CR", iso3Code: "CRI", numericCode: "188", phonePrefix: "+506", frenchName: "Costa Rica")
        case "CU": return Country(name: "Cuba", capital: "Havana", region: "Americas", iso2Code: "CU", iso3Code: "CUB", numericCode: "192", phonePrefix: "+53", frenchName: "Cuba")
        case "CV": return Country(name: "Cabo Verde", capital: "Praia", region: "Africa", iso2Code: "CV", iso3Code: "CPV", numericCode: "132", phonePrefix: "+238", frenchName: "Cap-Vert")
        case "CW": return Country(name: "Curaçao", capital: "Willemstad", region: "Americas", iso2Code: "CW", iso3Code: "CUW", numericCode: "531", phonePrefix: "+599", frenchName: "Curaçao")
        case "CX": return Country(name: "Christmas Island", capital: "Flying Fish Cove", region: "Oceania", iso2Code: "CX", iso3Code: "CXR", numericCode: "162", phonePrefix: "+61", frenchName: "Île Christmas")
        case "CY": return Country(name: "Cyprus", capital: "Nicosia", region: "Europe", iso2Code: "CY", iso3Code: "CYP", numericCode: "196", phonePrefix: "+357", frenchName: "Chypre")
        case "CZ": return Country(name: "Czech Republic", capital: "Prague", region: "Europe", iso2Code: "CZ", iso3Code: "CZE", numericCode: "203", phonePrefix: "+420", frenchName: "République Tchèque")
        case "DE": return Country(name: "Germany", capital: "Berlin", region: "Europe", iso2Code: "DE", iso3Code: "DEU", numericCode: "276", phonePrefix: "+49", frenchName: "Allemagne")
        case "DJ": return Country(name: "Djibouti", capital: "Djibouti", region: "Africa", iso2Code: "DJ", iso3Code: "DJI", numericCode: "262", phonePrefix: "+253", frenchName: "Djibouti")
        case "DK": return Country(name: "Denmark", capital: "Copenhagen", region: "Europe", iso2Code: "DK", iso3Code: "DNK", numericCode: "208", phonePrefix: "+45", frenchName: "Denmark")
        case "DM": return Country(name: "Dominica", capital: "Roseau", region: "Americas", iso2Code: "DM", iso3Code: "DMA", numericCode: "212", phonePrefix: "+1", frenchName: "Dominique")
        case "DO": return Country(name: "Dominican Republic", capital: "Santo Domingo", region: "Americas", iso2Code: "DO", iso3Code: "DOM", numericCode: "214", phonePrefix: "+1", frenchName: "République Dominicaine")
        case "DZ": return Country(name: "Algeria", capital: "Algiers", region: "Africa", iso2Code: "DZ", iso3Code: "DZA", numericCode: "012", phonePrefix: "+213", frenchName: "Algérie")
        case "EC": return Country(name: "Ecuador", capital: "Quito", region: "Americas", iso2Code: "EC", iso3Code: "ECU", numericCode: "218", phonePrefix: "+593", frenchName: "Équateur")
        case "EE": return Country(name: "Estonia", capital: "Tallinn", region: "Europe", iso2Code: "EE", iso3Code: "EST", numericCode: "233", phonePrefix: "+372", frenchName: "Estonie")
        case "EG": return Country(name: "Egypt", capital: "Cairo", region: "Africa", iso2Code: "EG", iso3Code: "EGY", numericCode: "818", phonePrefix: "+20", frenchName: "Égypte")
        case "EH": return Country(name: "Western Sahara", capital: "El Aaiún", region: "Africa", iso2Code: "EH", iso3Code: "ESH", numericCode: "732", phonePrefix: "+212", frenchName: "Sahara Occidental")
        case "ER": return Country(name: "Eritrea", capital: "Asmara", region: "Africa", iso2Code: "ER", iso3Code: "ERI", numericCode: "232", phonePrefix: "+291", frenchName: "Érythrée")
        case "ES": return Country(name: "Spain", capital: "Madrid", region: "Europe", iso2Code: "ES", iso3Code: "ESP", numericCode: "724", phonePrefix: "+34", frenchName: "Espagne")
        case "ET": return Country(name: "Ethiopia", capital: "Addis Ababa", region: "Africa", iso2Code: "ET", iso3Code: "ETH", numericCode: "231", phonePrefix: "+251", frenchName: "Éthiopie")
        case "FI": return Country(name: "Finland", capital: "Helsinki", region: "Europe", iso2Code: "FI", iso3Code: "FIN", numericCode: "246", phonePrefix: "+358", frenchName: "Finlande")
        case "FJ": return Country(name: "Fiji", capital: "Suva", region: "Oceania", iso2Code: "FJ", iso3Code: "FJI", numericCode: "242", phonePrefix: "+679", frenchName: "Fidji")
        case "FK": return Country(name: "Falkland Islands (Malvinas)", capital: "Stanley", region: "Americas", iso2Code: "FK", iso3Code: "FLK", numericCode: "238", phonePrefix: "+500", frenchName: "Îles Malouines")
        case "FM": return Country(name: "Micronesia (Federated States of)", capital: "Palikir", region: "Oceania", iso2Code: "FM", iso3Code: "FSM", numericCode: "583", phonePrefix: "+691", frenchName: "Micronésie (États Fédérés)")
        case "FO": return Country(name: "Faroe Islands", capital: "Tórshavn", region: "Europe", iso2Code: "FO", iso3Code: "FRO", numericCode: "234", phonePrefix: "+298", frenchName: "Îles Féroé")
        case "FR": return Country(name: "France", capital: "Paris", region: "Europe", iso2Code: "FR", iso3Code: "FRA", numericCode: "250", phonePrefix: "+33", frenchName: "France")
        case "GA": return Country(name: "Gabon", capital: "Libreville", region: "Africa", iso2Code: "GA", iso3Code: "GAB", numericCode: "266", phonePrefix: "+241", frenchName: "Gabon")
        
        case "GB": return Country(name: "United Kingdom of Great Britain and Northern Ireland", capital: "London", region: "Europe", iso2Code: "GB", iso3Code: "GBR", numericCode: "826", phonePrefix: "+44", frenchName: "Royaume-Uni")
        case "GB1": return Country(name: "United Kingdom of Great Britain and Northern Ireland", capital: "London", region: "Europe", iso2Code: "GB1", iso3Code: "GBR", numericCode: "826", phonePrefix: "+44", frenchName: "Royaume-Uni")
        case "GB2": return Country(name: "United Kingdom of Great Britain and Northern Ireland", capital: "London", region: "Europe", iso2Code: "GB2", iso3Code: "GBR", numericCode: "826", phonePrefix: "+44", frenchName: "Royaume-Uni")
        case "GB3": return Country(name: "United Kingdom of Great Britain and Northern Ireland", capital: "London", region: "Europe", iso2Code: "GB3", iso3Code: "GBR", numericCode: "826", phonePrefix: "+44", frenchName: "Royaume-Uni")
        case "GB4": return Country(name: "United Kingdom of Great Britain and Northern Ireland", capital: "London", region: "Europe", iso2Code: "GB4", iso3Code: "GBR", numericCode: "826", phonePrefix: "+44", frenchName: "Royaume-Uni")
        
        case "GD": return Country(name: "Grenada", capital: "St. George's", region: "Americas", iso2Code: "GD", iso3Code: "GRD", numericCode: "308", phonePrefix: "+1", frenchName: "Grenade")
        case "GE": return Country(name: "Georgia", capital: "Tbilisi", region: "Asia", iso2Code: "GE", iso3Code: "GEO", numericCode: "268", phonePrefix: "+995", frenchName: "Géorgie")
        case "GF": return Country(name: "French Guiana", capital: "Cayenne", region: "Americas", iso2Code: "GF", iso3Code: "GUF", numericCode: "254", phonePrefix: "+594", frenchName: "Guyane")
        case "GG": return Country(name: "Guernsey", capital: "St. Peter Port", region: "Europe", iso2Code: "GG", iso3Code: "GGY", numericCode: "831", phonePrefix: "+44", frenchName: "Guernesey")
        case "GH": return Country(name: "Ghana", capital: "Accra", region: "Africa", iso2Code: "GH", iso3Code: "GHA", numericCode: "288", phonePrefix: "+233", frenchName: "Ghana")
        case "GI": return Country(name: "Gibraltar", capital: "Gibraltar", region: "Europe", iso2Code: "GI", iso3Code: "GIB", numericCode: "292", phonePrefix: "+350", frenchName: "Gibraltar")
        case "GL": return Country(name: "Greenland", capital: "Nuuk", region: "Americas", iso2Code: "GL", iso3Code: "GRL", numericCode: "304", phonePrefix: "+299", frenchName: "Groenland")
        case "GM": return Country(name: "Gambia", capital: "Banjul", region: "Africa", iso2Code: "GM", iso3Code: "GMB", numericCode: "270", phonePrefix: "+220", frenchName: "Gambie")
        case "GN": return Country(name: "Guinea", capital: "Conakry", region: "Africa", iso2Code: "GN", iso3Code: "GIN", numericCode: "324", phonePrefix: "+224", frenchName: "Guinée")
        case "GP": return Country(name: "Guadeloupe", capital: "Basse-Terre", region: "Americas", iso2Code: "GP", iso3Code: "GLP", numericCode: "312", phonePrefix: "+590", frenchName: "Guadeloupe")
        case "GQ": return Country(name: "Equatorial Guinea", capital: "Malabo", region: "Africa", iso2Code: "GQ", iso3Code: "GNQ", numericCode: "226", phonePrefix: "+240", frenchName: "Guinée Équatoriale")
        case "GR": return Country(name: "Greece", capital: "Athens", region: "Europe", iso2Code: "GR", iso3Code: "GRC", numericCode: "300", phonePrefix: "+30", frenchName: "Grèce")
        case "GS": return Country(name: "South Georgia and the South Sandwich Islands", capital: "King Edward Point", region: "Americas", iso2Code: "GS", iso3Code: "SGS", numericCode: "239", phonePrefix: "+500", frenchName: "Géorgie Du Sud-Et-Les Îles Sandwich Du Sud")
        case "GT": return Country(name: "Guatemala", capital: "Guatemala City", region: "Americas", iso2Code: "GT", iso3Code: "GTM", numericCode: "320", phonePrefix: "+502", frenchName: "Guatemala")
        case "GU": return Country(name: "Guam", capital: "Hagåtña", region: "Oceania", iso2Code: "GU", iso3Code: "GUM", numericCode: "316", phonePrefix: "+1", frenchName: "Guam")
        case "GW": return Country(name: "Guinea-Bissau", capital: "Bissau", region: "Africa", iso2Code: "GW", iso3Code: "GNB", numericCode: "624", phonePrefix: "+245", frenchName: "Guinée-Bissau")
        case "GY": return Country(name: "Guyana", capital: "Georgetown", region: "Americas", iso2Code: "GY", iso3Code: "GUY", numericCode: "328", phonePrefix: "+592", frenchName: "Guyana")
        case "HK": return Country(name: "Hong Kong", capital: "City of Victoria", region: "Asia", iso2Code: "HK", iso3Code: "HKG", numericCode: "344", phonePrefix: "+852", frenchName: "Hong Kong")
        case "HM": return Country(name: "Heard Island and McDonald Islands", capital: nil, region: "Antarctic", iso2Code: "HM", iso3Code: "HMD", numericCode: "334", phonePrefix: "+672", frenchName: "Îles Heard-Et-MacDonald")
        case "HN": return Country(name: "Honduras", capital: "Tegucigalpa", region: "Americas", iso2Code: "HN", iso3Code: "HND", numericCode: "340", phonePrefix: "+504", frenchName: "Honduras")
        case "HR": return Country(name: "Croatia", capital: "Zagreb", region: "Europe", iso2Code: "HR", iso3Code: "HRV", numericCode: "191", phonePrefix: "+385", frenchName: "Croatie")
        case "HT": return Country(name: "Haiti", capital: "Port-au-Prince", region: "Americas", iso2Code: "HT", iso3Code: "HTI", numericCode: "332", phonePrefix: "+509", frenchName: "Haïti")
        case "HU": return Country(name: "Hungary", capital: "Budapest", region: "Europe", iso2Code: "HU", iso3Code: "HUN", numericCode: "348", phonePrefix: "+36", frenchName: "Hongrie")
        case "ID": return Country(name: "Indonesia", capital: "Jakarta", region: "Asia", iso2Code: "ID", iso3Code: "IDN", numericCode: "360", phonePrefix: "+62", frenchName: "Indonésie")
        case "IE": return Country(name: "Ireland", capital: "Dublin", region: "Europe", iso2Code: "IE", iso3Code: "IRL", numericCode: "372", phonePrefix: "+353", frenchName: "Irlande")
        case "IL": return Country(name: "Israel", capital: "Jerusalem", region: "Asia", iso2Code: "IL", iso3Code: "ISR", numericCode: "376", phonePrefix: "+972", frenchName: "Israël")
        case "IM": return Country(name: "Isle of Man", capital: "Douglas", region: "Europe", iso2Code: "IM", iso3Code: "IMN", numericCode: "833", phonePrefix: "+44", frenchName: "Île De Man")
        case "IN": return Country(name: "India", capital: "New Delhi", region: "Asia", iso2Code: "IN", iso3Code: "IND", numericCode: "356", phonePrefix: "+91", frenchName: "Inde")
        case "IO": return Country(name: "British Indian Ocean Territory", capital: "Diego Garcia", region: "Africa", iso2Code: "IO", iso3Code: "IOT", numericCode: "086", phonePrefix: "+246", frenchName: "Territoire Britannique De L'océan Indien")
        case "IQ": return Country(name: "Iraq", capital: "Baghdad", region: "Asia", iso2Code: "IQ", iso3Code: "IRQ", numericCode: "368", phonePrefix: "+964", frenchName: "Irak")
        case "IR": return Country(name: "Iran (Islamic Republic of)", capital: "Tehran", region: "Asia", iso2Code: "IR", iso3Code: "IRN", numericCode: "364", phonePrefix: "+98", frenchName: "République Islamique D'Iran")
        case "IS": return Country(name: "Iceland", capital: "Reykjavík", region: "Europe", iso2Code: "IS", iso3Code: "ISL", numericCode: "352", phonePrefix: "+354", frenchName: "Islande")
        case "IT": return Country(name: "Italy", capital: "Rome", region: "Europe", iso2Code: "IT", iso3Code: "ITA", numericCode: "380", phonePrefix: "+39", frenchName: "Italie")
        case "JE": return Country(name: "Jersey", capital: "Saint Helier", region: "Europe", iso2Code: "JE", iso3Code: "JEY", numericCode: "832", phonePrefix: "+44", frenchName: "Jersey")
        case "JM": return Country(name: "Jamaica", capital: "Kingston", region: "Americas", iso2Code: "JM", iso3Code: "JAM", numericCode: "388", phonePrefix: "+1", frenchName: "Jamaïque")
        case "JO": return Country(name: "Jordan", capital: "Amman", region: "Asia", iso2Code: "JO", iso3Code: "JOR", numericCode: "400", phonePrefix: "+962", frenchName: "Jordanie")
        case "JP": return Country(name: "Japan", capital: "Tokyo", region: "Asia", iso2Code: "JP", iso3Code: "JPN", numericCode: "392", phonePrefix: "+81", frenchName: "Japon")
        case "KE": return Country(name: "Kenya", capital: "Nairobi", region: "Africa", iso2Code: "KE", iso3Code: "KEN", numericCode: "404", phonePrefix: "+254", frenchName: "Kenya")
        case "KG": return Country(name: "Kyrgyzstan", capital: "Bishkek", region: "Asia", iso2Code: "KG", iso3Code: "KGZ", numericCode: "417", phonePrefix: "+996", frenchName: "Kirghizistan")
        case "KH": return Country(name: "Cambodia", capital: "Phnom Penh", region: "Asia", iso2Code: "KH", iso3Code: "KHM", numericCode: "116", phonePrefix: "+855", frenchName: "Cambodge")
        case "KI": return Country(name: "Kiribati", capital: "South Tarawa", region: "Oceania", iso2Code: "KI", iso3Code: "KIR", numericCode: "296", phonePrefix: "+686", frenchName: "Kiribati")
        case "KM": return Country(name: "Comoros", capital: "Moroni", region: "Africa", iso2Code: "KM", iso3Code: "COM", numericCode: "174", phonePrefix: "+269", frenchName: "Comores")
        case "KN": return Country(name: "Saint Kitts and Nevis", capital: "Basseterre", region: "Americas", iso2Code: "KN", iso3Code: "KNA", numericCode: "659", phonePrefix: "+1", frenchName: "Saint-Christophe-et-Niévès")
        case "KP": return Country(name: "Korea (Democratic People's Republic of)", capital: "Pyongyang", region: "Asia", iso2Code: "KP", iso3Code: "PRK", numericCode: "408", phonePrefix: "+850", frenchName: "République Populaire Démocratique De Corée")
        case "KR": return Country(name: "Korea (Republic of)", capital: "Seoul", region: "Asia", iso2Code: "KR", iso3Code: "KOR", numericCode: "410", phonePrefix: "+82", frenchName: "République De Corée")
        case "KW": return Country(name: "Kuwait", capital: "Kuwait City", region: "Asia", iso2Code: "KW", iso3Code: "KWT", numericCode: "414", phonePrefix: "+965", frenchName: "Koweït")
        case "KY": return Country(name: "Cayman Islands", capital: "George Town", region: "Americas", iso2Code: "KY", iso3Code: "CYM", numericCode: "136", phonePrefix: "+1", frenchName: "Îles Caïmans")
        case "KZ": return Country(name: "Kazakhstan", capital: "Nur-Sultan", region: "Asia", iso2Code: "KZ", iso3Code: "KAZ", numericCode: "398", phonePrefix: "+76", frenchName: "Kazakhstan")
        case "LA": return Country(name: "Lao People's Democratic Republic", capital: "Vientiane", region: "Asia", iso2Code: "LA", iso3Code: "LAO", numericCode: "418", phonePrefix: "+856", frenchName: "République Démocratique Populaire Lao")
        case "LB": return Country(name: "Lebanon", capital: "Beirut", region: "Asia", iso2Code: "LB", iso3Code: "LBN", numericCode: "422", phonePrefix: "+961", frenchName: "Liban")
        case "LC": return Country(name: "Saint Lucia", capital: "Castries", region: "Americas", iso2Code: "LC", iso3Code: "LCA", numericCode: "662", phonePrefix: "+1", frenchName: "Sainte-Lucie")
        case "LI": return Country(name: "Liechtenstein", capital: "Vaduz", region: "Europe", iso2Code: "LI", iso3Code: "LIE", numericCode: "438", phonePrefix: "+423", frenchName: "Liechtenstein")
        case "LK": return Country(name: "Sri Lanka", capital: "Sri Jayawardenepura Kotte", region: "Asia", iso2Code: "LK", iso3Code: "LKA", numericCode: "144", phonePrefix: "+94", frenchName: "Sri Lanka")
        case "LR": return Country(name: "Liberia", capital: "Monrovia", region: "Africa", iso2Code: "LR", iso3Code: "LBR", numericCode: "430", phonePrefix: "+231", frenchName: "Liberia")
        case "LS": return Country(name: "Lesotho", capital: "Maseru", region: "Africa", iso2Code: "LS", iso3Code: "LSO", numericCode: "426", phonePrefix: "+266", frenchName: "Lesotho")
        case "LT": return Country(name: "Lithuania", capital: "Vilnius", region: "Europe", iso2Code: "LT", iso3Code: "LTU", numericCode: "440", phonePrefix: "+370", frenchName: "Lituanie")
        case "LU": return Country(name: "Luxembourg", capital: "Luxembourg", region: "Europe", iso2Code: "LU", iso3Code: "LUX", numericCode: "442", phonePrefix: "+352", frenchName: "Luxembourg")
        case "LV": return Country(name: "Latvia", capital: "Riga", region: "Europe", iso2Code: "LV", iso3Code: "LVA", numericCode: "428", phonePrefix: "+371", frenchName: "Lettonie")
        case "LY": return Country(name: "Libya", capital: "Tripoli", region: "Africa", iso2Code: "LY", iso3Code: "LBY", numericCode: "434", phonePrefix: "+218", frenchName: "Libye")
        case "MA": return Country(name: "Morocco", capital: "Rabat", region: "Africa", iso2Code: "MA", iso3Code: "MAR", numericCode: "504", phonePrefix: "+212", frenchName: "Maroc")
        case "MC": return Country(name: "Monaco", capital: "Monaco", region: "Europe", iso2Code: "MC", iso3Code: "MCO", numericCode: "492", phonePrefix: "+377", frenchName: "Monaco")
        case "MD": return Country(name: "Moldova (Republic of)", capital: "Chișinău", region: "Europe", iso2Code: "MD", iso3Code: "MDA", numericCode: "498", phonePrefix: "+373", frenchName: "République De Moldavie")
        case "ME": return Country(name: "Montenegro", capital: "Podgorica", region: "Europe", iso2Code: "ME", iso3Code: "MNE", numericCode: "499", phonePrefix: "+382", frenchName: "Monténégro")
        case "MF": return Country(name: "Saint Martin (French part)", capital: "Marigot", region: "Americas", iso2Code: "MF", iso3Code: "MAF", numericCode: "663", phonePrefix: "+590", frenchName: "Saint-Martin (Partie Française)")
        case "MG": return Country(name: "Madagascar", capital: "Antananarivo", region: "Africa", iso2Code: "MG", iso3Code: "MDG", numericCode: "450", phonePrefix: "+261", frenchName: "Madagascar")
        case "MH": return Country(name: "Marshall Islands", capital: "Majuro", region: "Oceania", iso2Code: "MH", iso3Code: "MHL", numericCode: "584", phonePrefix: "+692", frenchName: "Îles Marshall")
        case "MK": return Country(name: "North Macedonia", capital: "Skopje", region: "Europe", iso2Code: "MK", iso3Code: "MKD", numericCode: "807", phonePrefix: "+389", frenchName: "Macédoine")
        case "ML": return Country(name: "Mali", capital: "Bamako", region: "Africa", iso2Code: "ML", iso3Code: "MLI", numericCode: "466", phonePrefix: "+223", frenchName: "Mali")
        case "MM": return Country(name: "Myanmar", capital: "Naypyidaw", region: "Asia", iso2Code: "MM", iso3Code: "MMR", numericCode: "104", phonePrefix: "+95", frenchName: "Birmanie")
        case "MN": return Country(name: "Mongolia", capital: "Ulan Bator", region: "Asia", iso2Code: "MN", iso3Code: "MNG", numericCode: "496", phonePrefix: "+976", frenchName: "Mongolie")
        case "MO": return Country(name: "Macao", capital: nil, region: "Asia", iso2Code: "MO", iso3Code: "MAC", numericCode: "446", phonePrefix: "+853", frenchName: "Macao")
        case "MP": return Country(name: "Northern Mariana Islands", capital: "Saipan", region: "Oceania", iso2Code: "MP", iso3Code: "MNP", numericCode: "580", phonePrefix: "+1", frenchName: "Îles Mariannes Du Nord")
        case "MQ": return Country(name: "Martinique", capital: "Fort-de-France", region: "Americas", iso2Code: "MQ", iso3Code: "MTQ", numericCode: "474", phonePrefix: "+596", frenchName: "Martinique")
        case "MR": return Country(name: "Mauritania", capital: "Nouakchott", region: "Africa", iso2Code: "MR", iso3Code: "MRT", numericCode: "478", phonePrefix: "+222", frenchName: "Mauritanie")
        case "MS": return Country(name: "Montserrat", capital: "Plymouth", region: "Americas", iso2Code: "MS", iso3Code: "MSR", numericCode: "500", phonePrefix: "+1", frenchName: "Montserrat")
        case "MT": return Country(name: "Malta", capital: "Valletta", region: "Europe", iso2Code: "MT", iso3Code: "MLT", numericCode: "470", phonePrefix: "+356", frenchName: "Malte")
        case "MU": return Country(name: "Mauritius", capital: "Port Louis", region: "Africa", iso2Code: "MU", iso3Code: "MUS", numericCode: "480", phonePrefix: "+230", frenchName: "Maurice")
        case "MV": return Country(name: "Maldives", capital: "Malé", region: "Asia", iso2Code: "MV", iso3Code: "MDV", numericCode: "462", phonePrefix: "+960", frenchName: "Maldives")
        case "MW": return Country(name: "Malawi", capital: "Lilongwe", region: "Africa", iso2Code: "MW", iso3Code: "MWI", numericCode: "454", phonePrefix: "+265", frenchName: "Malawi")
        case "MX": return Country(name: "Mexico", capital: "Mexico City", region: "Americas", iso2Code: "MX", iso3Code: "MEX", numericCode: "484", phonePrefix: "+52", frenchName: "Mexique")
        case "MY": return Country(name: "Malaysia", capital: "Kuala Lumpur", region: "Asia", iso2Code: "MY", iso3Code: "MYS", numericCode: "458", phonePrefix: "+60", frenchName: "Malaisie")
        case "MZ": return Country(name: "Mozambique", capital: "Maputo", region: "Africa", iso2Code: "MZ", iso3Code: "MOZ", numericCode: "508", phonePrefix: "+258", frenchName: "Mozambique")
        case "NA": return Country(name: "Namibia", capital: "Windhoek", region: "Africa", iso2Code: "NA", iso3Code: "NAM", numericCode: "516", phonePrefix: "+264", frenchName: "Namibie")
        case "NC": return Country(name: "New Caledonia", capital: "Nouméa", region: "Oceania", iso2Code: "NC", iso3Code: "NCL", numericCode: "540", phonePrefix: "+687", frenchName: "Nouvelle-Calédonie")
        case "NE": return Country(name: "Niger", capital: "Niamey", region: "Africa", iso2Code: "NE", iso3Code: "NER", numericCode: "562", phonePrefix: "+227", frenchName: "Niger")
        case "NF": return Country(name: "Norfolk Island", capital: "Kingston", region: "Oceania", iso2Code: "NF", iso3Code: "NFK", numericCode: "574", phonePrefix: "+672", frenchName: "Île Norfolk")
        case "NG": return Country(name: "Nigeria", capital: "Abuja", region: "Africa", iso2Code: "NG", iso3Code: "NGA", numericCode: "566", phonePrefix: "+234", frenchName: "Nigéria")
        case "NI": return Country(name: "Nicaragua", capital: "Managua", region: "Americas", iso2Code: "NI", iso3Code: "NIC", numericCode: "558", phonePrefix: "+505", frenchName: "Nicaragua")
        case "NL": return Country(name: "Netherlands", capital: "Amsterdam", region: "Europe", iso2Code: "NL", iso3Code: "NLD", numericCode: "528", phonePrefix: "+31", frenchName: "Pays-Bas")
        case "NO": return Country(name: "Norway", capital: "Oslo", region: "Europe", iso2Code: "NO", iso3Code: "NOR", numericCode: "578", phonePrefix: "+47", frenchName: "Norvège")
        case "NP": return Country(name: "Nepal", capital: "Kathmandu", region: "Asia", iso2Code: "NP", iso3Code: "NPL", numericCode: "524", phonePrefix: "+977", frenchName: "Népal")
        case "NR": return Country(name: "Nauru", capital: "Yaren", region: "Oceania", iso2Code: "NR", iso3Code: "NRU", numericCode: "520", phonePrefix: "+674", frenchName: "Nauru")
        case "NU": return Country(name: "Niue", capital: "Alofi", region: "Oceania", iso2Code: "NU", iso3Code: "NIU", numericCode: "570", phonePrefix: "+683", frenchName: "Niue")
        case "NZ": return Country(name: "New Zealand", capital: "Wellington", region: "Oceania", iso2Code: "NZ", iso3Code: "NZL", numericCode: "554", phonePrefix: "+64", frenchName: "Nouvelle-Zélande")
        case "OM": return Country(name: "Oman", capital: "Muscat", region: "Asia", iso2Code: "OM", iso3Code: "OMN", numericCode: "512", phonePrefix: "+968", frenchName: "Oman")
        case "PA": return Country(name: "Panama", capital: "Panama City", region: "Americas", iso2Code: "PA", iso3Code: "PAN", numericCode: "591", phonePrefix: "+507", frenchName: "Panama")
        case "PE": return Country(name: "Peru", capital: "Lima", region: "Americas", iso2Code: "PE", iso3Code: "PER", numericCode: "604", phonePrefix: "+51", frenchName: "Pérou")
        case "PF": return Country(name: "French Polynesia", capital: "Papeetē", region: "Oceania", iso2Code: "PF", iso3Code: "PYF", numericCode: "258", phonePrefix: "+689", frenchName: "Polynésie Française")
        case "PG": return Country(name: "Papua New Guinea", capital: "Port Moresby", region: "Oceania", iso2Code: "PG", iso3Code: "PNG", numericCode: "598", phonePrefix: "+675", frenchName: "Papouasie-Nouvelle-Guinée")
        case "PH": return Country(name: "Philippines", capital: "Manila", region: "Asia", iso2Code: "PH", iso3Code: "PHL", numericCode: "608", phonePrefix: "+63", frenchName: "Philippines")
        case "PK": return Country(name: "Pakistan", capital: "Islamabad", region: "Asia", iso2Code: "PK", iso3Code: "PAK", numericCode: "586", phonePrefix: "+92", frenchName: "Pakistan")
        case "PL": return Country(name: "Poland", capital: "Warsaw", region: "Europe", iso2Code: "PL", iso3Code: "POL", numericCode: "616", phonePrefix: "+48", frenchName: "Pologne")
        case "PM": return Country(name: "Saint Pierre and Miquelon", capital: "Saint-Pierre", region: "Americas", iso2Code: "PM", iso3Code: "SPM", numericCode: "666", phonePrefix: "+508", frenchName: "Saint-Pierre-Et-Miquelon")
        case "PN": return Country(name: "Pitcairn", capital: "Adamstown", region: "Oceania", iso2Code: "PN", iso3Code: "PCN", numericCode: "612", phonePrefix: "+64", frenchName: "Pitcairn")
        case "PR": return Country(name: "Puerto Rico", capital: "San Juan", region: "Americas", iso2Code: "PR", iso3Code: "PRI", numericCode: "630", phonePrefix: "+1", frenchName: "Porto Rico")
        case "PS": return Country(name: "Palestine, State of", capital: "Ramallah", region: "Asia", iso2Code: "PS", iso3Code: "PSE", numericCode: "275", phonePrefix: "+970", frenchName: "Territoires Palestiniens Occupés")
        case "PT": return Country(name: "Portugal", capital: "Lisbon", region: "Europe", iso2Code: "PT", iso3Code: "PRT", numericCode: "620", phonePrefix: "+351", frenchName: "Portugal")
        case "PW": return Country(name: "Palau", capital: "Ngerulmud", region: "Oceania", iso2Code: "PW", iso3Code: "PLW", numericCode: "585", phonePrefix: "+680", frenchName: "Palaos")
        case "PY": return Country(name: "Paraguay", capital: "Asunción", region: "Americas", iso2Code: "PY", iso3Code: "PRY", numericCode: "600", phonePrefix: "+595", frenchName: "Paraguay")
        case "QA": return Country(name: "Qatar", capital: "Doha", region: "Asia", iso2Code: "QA", iso3Code: "QAT", numericCode: "634", phonePrefix: "+974", frenchName: "Qatar")
        case "RE": return Country(name: "Réunion", capital: "Saint-Denis", region: "Africa", iso2Code: "RE", iso3Code: "REU", numericCode: "638", phonePrefix: "+262", frenchName: "Réunion")
        case "RO": return Country(name: "Romania", capital: "Bucharest", region: "Europe", iso2Code: "RO", iso3Code: "ROU", numericCode: "642", phonePrefix: "+40", frenchName: "Roumanie")
        case "RS": return Country(name: "Serbia", capital: "Belgrade", region: "Europe", iso2Code: "RS", iso3Code: "SRB", numericCode: "688", phonePrefix: "+381", frenchName: "Serbie")
        case "RU": return Country(name: "Russian Federation", capital: "Moscow", region: "Europe", iso2Code: "RU", iso3Code: "RUS", numericCode: "643", phonePrefix: "+7", frenchName: "Fédération De Russie")
        case "RW": return Country(name: "Rwanda", capital: "Kigali", region: "Africa", iso2Code: "RW", iso3Code: "RWA", numericCode: "646", phonePrefix: "+250", frenchName: "Rwanda")
        case "SA": return Country(name: "Saudi Arabia", capital: "Riyadh", region: "Asia", iso2Code: "SA", iso3Code: "SAU", numericCode: "682", phonePrefix: "+966", frenchName: "Arabie Saoudite")
        case "SB": return Country(name: "Solomon Islands", capital: "Honiara", region: "Oceania", iso2Code: "SB", iso3Code: "SLB", numericCode: "090", phonePrefix: "+677", frenchName: "Îles Salomon")
        case "SC": return Country(name: "Seychelles", capital: "Victoria", region: "Africa", iso2Code: "SC", iso3Code: "SYC", numericCode: "690", phonePrefix: "+248", frenchName: "Seychelles")
        case "SD": return Country(name: "Sudan", capital: "Khartoum", region: "Africa", iso2Code: "SD", iso3Code: "SDN", numericCode: "729", phonePrefix: "+249", frenchName: "Soudan")
        case "SE": return Country(name: "Sweden", capital: "Stockholm", region: "Europe", iso2Code: "SE", iso3Code: "SWE", numericCode: "752", phonePrefix: "+46", frenchName: "Suède")
        case "SG": return Country(name: "Singapore", capital: "Singapore", region: "Asia", iso2Code: "SG", iso3Code: "SGP", numericCode: "702", phonePrefix: "+65", frenchName: "Singapour")
        case "SH": return Country(name: "Saint Helena, Ascension and Tristan da Cunha", capital: "Jamestown", region: "Africa", iso2Code: "SH", iso3Code: "SHN", numericCode: "654", phonePrefix: "+290", frenchName: "Sainte-Hélène")
        case "SI": return Country(name: "Slovenia", capital: "Ljubljana", region: "Europe", iso2Code: "SI", iso3Code: "SVN", numericCode: "705", phonePrefix: "+386", frenchName: "Slovénie")
        case "SJ": return Country(name: "Svalbard and Jan Mayen", capital: "Longyearbyen", region: "Europe", iso2Code: "SJ", iso3Code: "SJM", numericCode: "744", phonePrefix: "+47", frenchName: "Svalbard Et Jan Mayen")
        case "SK": return Country(name: "Slovakia", capital: "Bratislava", region: "Europe", iso2Code: "SK", iso3Code: "SVK", numericCode: "703", phonePrefix: "+421", frenchName: "Slovaquie")
        case "SL": return Country(name: "Sierra Leone", capital: "Freetown", region: "Africa", iso2Code: "SL", iso3Code: "SLE", numericCode: "694", phonePrefix: "+232", frenchName: "Sierra Leone")
        case "SM": return Country(name: "San Marino", capital: "City of San Marino", region: "Europe", iso2Code: "SM", iso3Code: "SMR", numericCode: "674", phonePrefix: "+378", frenchName: "Saint-Marin")
        case "SN": return Country(name: "Senegal", capital: "Dakar", region: "Africa", iso2Code: "SN", iso3Code: "SEN", numericCode: "686", phonePrefix: "+221", frenchName: "Sénégal")
        case "SO": return Country(name: "Somalia", capital: "Mogadishu", region: "Africa", iso2Code: "SO", iso3Code: "SOM", numericCode: "706", phonePrefix: "+252", frenchName: "Somalie")
        case "SR": return Country(name: "Suriname", capital: "Paramaribo", region: "Americas", iso2Code: "SR", iso3Code: "SUR", numericCode: "740", phonePrefix: "+597", frenchName: "Suriname")
        case "SS": return Country(name: "South Sudan", capital: "Juba", region: "Africa", iso2Code: "SS", iso3Code: "SSD", numericCode: "728", phonePrefix: "+211", frenchName: "Soudan Du Sud")
        case "ST": return Country(name: "Sao Tome and Principe", capital: "São Tomé", region: "Africa", iso2Code: "ST", iso3Code: "STP", numericCode: "678", phonePrefix: "+239", frenchName: "Sao Tomé-Et-Principe")
        case "SV": return Country(name: "El Salvador", capital: "San Salvador", region: "Americas", iso2Code: "SV", iso3Code: "SLV", numericCode: "222", phonePrefix: "+503", frenchName: "République Du Salvador")
        case "SX": return Country(name: "Sint Maarten (Dutch part)", capital: "Philipsburg", region: "Americas", iso2Code: "SX", iso3Code: "SXM", numericCode: "534", phonePrefix: "+1", frenchName: "Saint-Martin (Partie Néerlandaise)")
        case "SY": return Country(name: "Syrian Arab Republic", capital: "Damascus", region: "Asia", iso2Code: "SY", iso3Code: "SYR", numericCode: "760", phonePrefix: "+963", frenchName: "République Arabe Syrienne")
        case "SZ": return Country(name: "Swaziland", capital: "Mbabane", region: "Africa", iso2Code: "SZ", iso3Code: "SWZ", numericCode: "748", phonePrefix: "+268", frenchName: "Swaziland")
        case "TC": return Country(name: "Turks and Caicos Islands", capital: "Cockburn Town", region: "Americas", iso2Code: "TC", iso3Code: "TCA", numericCode: "796", phonePrefix: "+1", frenchName: "Îles Turks-Et-Caïcos")
        case "TD": return Country(name: "Chad", capital: "N'Djamena", region: "Africa", iso2Code: "TD", iso3Code: "TCD", numericCode: "148", phonePrefix: "+235", frenchName: "Tchad")
        case "TF": return Country(name: "French Southern Territories", capital: "Port-aux-Français", region: "Africa", iso2Code: "TF", iso3Code: "ATF", numericCode: "260", phonePrefix: "+262", frenchName: "Terres Australes Françaises")
        case "TG": return Country(name: "Togo", capital: "Lomé", region: "Africa", iso2Code: "TG", iso3Code: "TGO", numericCode: "768", phonePrefix: "+228", frenchName: "Togo")
        case "TH": return Country(name: "Thailand", capital: "Bangkok", region: "Asia", iso2Code: "TH", iso3Code: "THA", numericCode: "764", phonePrefix: "+66", frenchName: "Thaïlande")
        case "TJ": return Country(name: "Tajikistan", capital: "Dushanbe", region: "Asia", iso2Code: "TJ", iso3Code: "TJK", numericCode: "762", phonePrefix: "+992", frenchName: "Tadjikistan")
        case "TK": return Country(name: "Tokelau", capital: "Fakaofo", region: "Oceania", iso2Code: "TK", iso3Code: "TKL", numericCode: "772", phonePrefix: "+690", frenchName: "Tokelau")
        case "TL": return Country(name: "Timor-Leste", capital: "Dili", region: "Asia", iso2Code: "TL", iso3Code: "TLS", numericCode: "626", phonePrefix: "+670", frenchName: "Timor-Leste")
        case "TM": return Country(name: "Turkmenistan", capital: "Ashgabat", region: "Asia", iso2Code: "TM", iso3Code: "TKM", numericCode: "795", phonePrefix: "+993", frenchName: "Turkménistan")
        case "TN": return Country(name: "Tunisia", capital: "Tunis", region: "Africa", iso2Code: "TN", iso3Code: "TUN", numericCode: "788", phonePrefix: "+216", frenchName: "Tunisie")
        case "TO": return Country(name: "Tonga", capital: "Nuku'alofa", region: "Oceania", iso2Code: "TO", iso3Code: "TON", numericCode: "776", phonePrefix: "+676", frenchName: "Tonga")
        case "TR": return Country(name: "Turkey", capital: "Ankara", region: "Asia", iso2Code: "TR", iso3Code: "TUR", numericCode: "792", phonePrefix: "+90", frenchName: "Turquie")
        case "TT": return Country(name: "Trinidad and Tobago", capital: "Port of Spain", region: "Americas", iso2Code: "TT", iso3Code: "TTO", numericCode: "780", phonePrefix: "+1", frenchName: "Trinité-Et-Tobago")
        case "TV": return Country(name: "Tuvalu", capital: "Funafuti", region: "Oceania", iso2Code: "TV", iso3Code: "TUV", numericCode: "798", phonePrefix: "+688", frenchName: "Tuvalu")
        case "TW": return Country(name: "Taiwan", capital: "Taipei", region: "Asia", iso2Code: "TW", iso3Code: "TWN", numericCode: "158", phonePrefix: "+886", frenchName: "Taïwan")
        case "TZ": return Country(name: "Tanzania, United Republic of", capital: "Dodoma", region: "Africa", iso2Code: "TZ", iso3Code: "TZA", numericCode: "834", phonePrefix: "+255", frenchName: "République-Unie De Tanzanie")
        case "UA": return Country(name: "Ukraine", capital: "Kyiv", region: "Europe", iso2Code: "UA", iso3Code: "UKR", numericCode: "804", phonePrefix: "+380", frenchName: "Ukraine")
        case "UG": return Country(name: "Uganda", capital: "Kampala", region: "Africa", iso2Code: "UG", iso3Code: "UGA", numericCode: "800", phonePrefix: "+256", frenchName: "Ouganda")
        case "UM": return Country(name: "United States Minor Outlying Islands", capital: nil, region: "Americas", iso2Code: "UM", iso3Code: "UMI", numericCode: "581", phonePrefix: "+246", frenchName: "Îles Mineures Éloignées Des États-Unis")
        case "US": return Country(name: "United States of America", capital: "Washington, D.C.", region: "Americas", iso2Code: "US", iso3Code: "USA", numericCode: "840", phonePrefix: "+1", frenchName: "États-Unis")
        case "UY": return Country(name: "Uruguay", capital: "Montevideo", region: "Americas", iso2Code: "UY", iso3Code: "URY", numericCode: "858", phonePrefix: "+598", frenchName: "Uruguay")
        case "UZ": return Country(name: "Uzbekistan", capital: "Tashkent", region: "Asia", iso2Code: "UZ", iso3Code: "UZB", numericCode: "860", phonePrefix: "+998", frenchName: "Ouzbékistan")
        case "VA": return Country(name: "Vatican City", capital: "Vatican City", region: "Europe", iso2Code: "VA", iso3Code: "VAT", numericCode: "336", phonePrefix: "+379", frenchName: "Saint-Siège (État De La Cité Du Vatican)")
        case "VC": return Country(name: "Saint Vincent and the Grenadines", capital: "Kingstown", region: "Americas", iso2Code: "VC", iso3Code: "VCT", numericCode: "670", phonePrefix: "+1", frenchName: "Saint-Vincent-Et-Les Grenadines")
        case "VE": return Country(name: "Venezuela (Bolivarian Republic of)", capital: "Caracas", region: "Americas", iso2Code: "VE", iso3Code: "VEN", numericCode: "862", phonePrefix: "+58", frenchName: "Venezuela")
        case "VG": return Country(name: "Virgin Islands (British)", capital: "Road Town", region: "Americas", iso2Code: "VG", iso3Code: "VGB", numericCode: "092", phonePrefix: "+1", frenchName: "Îles Vierges Britanniques")
        case "VI": return Country(name: "Virgin Islands (U.S.)", capital: "Charlotte Amalie", region: "Americas", iso2Code: "VI", iso3Code: "VIR", numericCode: "850", phonePrefix: "+1-340", frenchName: "Îles Vierges Des États-Unis")
        case "VN": return Country(name: "Vietnam", capital: "Hanoi", region: "Asia", iso2Code: "VN", iso3Code: "VNM", numericCode: "704", phonePrefix: "+84", frenchName: "Viet Nam")
        case "VU": return Country(name: "Vanuatu", capital: "Port Vila", region: "Oceania", iso2Code: "VU", iso3Code: "VUT", numericCode: "548", phonePrefix: "+678", frenchName: "Vanuatu")
        case "WF": return Country(name: "Wallis and Futuna", capital: "Mata-Utu", region: "Oceania", iso2Code: "WF", iso3Code: "WLF", numericCode: "876", phonePrefix: "+681", frenchName: "Wallis Et Futuna")
        case "WS": return Country(name: "Samoa", capital: "Apia", region: "Oceania", iso2Code: "WS", iso3Code: "WSM", numericCode: "882", phonePrefix: "+685", frenchName: "Samoa")
        case "XK": return Country(name: "Republic of Kosovo", capital: "Pristina", region: "Europe", iso2Code: "XK", iso3Code: "UNK", numericCode: "926", phonePrefix: "+383", frenchName: "Kosov")
        case "YE": return Country(name: "Yemen", capital: "Sana'a", region: "Asia", iso2Code: "YE", iso3Code: "YEM", numericCode: "887", phonePrefix: "+967", frenchName: "Yémen")
        case "YT": return Country(name: "Mayotte", capital: "Mamoudzou", region: "Africa", iso2Code: "YT", iso3Code: "MYT", numericCode: "175", phonePrefix: "+262", frenchName: "Mayotte")
        case "ZA": return Country(name: "South Africa", capital: "Pretoria", region: "Africa", iso2Code: "ZA", iso3Code: "ZAF", numericCode: "710", phonePrefix: "+27", frenchName: "Afrique Du Sud")
        case "ZM": return Country(name: "Zambia", capital: "Lusaka", region: "Africa", iso2Code: "ZM", iso3Code: "ZMB", numericCode: "894", phonePrefix: "+260", frenchName: "Zambie")
        case "ZW": return Country(name: "Zimbabwe", capital: "Harare", region: "Africa", iso2Code: "ZW", iso3Code: "ZWE", numericCode: "716", phonePrefix: "+263", frenchName: "Zimbabw")
        default: return Country(name: "International", capital: "", region: "", iso2Code: "", iso3Code: "", numericCode: "", phonePrefix: "", frenchName: "")
        }
        
    }

    static func country(withName name: String) -> Country? {
        let simplifiedName = Self.removeAccents(fromString: name)
        
        if simplifiedName.lowercased() == "international" {
            return Country(name: "International", capital: "", region: "", iso2Code: "", iso3Code: "", numericCode: "", phonePrefix: "", frenchName: "")
        }
        else if let isoCode = Self.englishCountryCode(withName: simplifiedName) {
            return Self.country(withISOCode: isoCode)
        }
        else if let iso = Self.frenchhCountryCode(withName: simplifiedName) {
            return Self.country(withISOCode: iso)
        }
        return Country(name: "International", capital: "", region: "", iso2Code: "", iso3Code: "", numericCode: "", phonePrefix: "", frenchName: "")
    }
    
    private static func removeAccents(fromString string: String) -> String {
        return string.folding(options: .diacriticInsensitive, locale: .current)
    }

    static func frenchhCountryCode(withName name: String) -> String? {
        let processedName = name.lowercased()
        switch processedName {
        case "afghanistan": return "AF"
        case "iles aland": return "AX"
        case "albanie": return "AL"
        case "algerie": return "DZ"
        case "samoa americaines", 
            "samoa americaine": return "AS"
        case "andorre": return "AD"
        case "angola": return "AO"
        case "anguilla": return "AI"
        case "antarctique": return "AQ"
        case "antigua-et-barbuda": return "AG"
        case "argentine": return "AR"
        case "armenie": return "AM"
        case "aruba": return "AW"
        case "australie": return "AU"
        case "autriche": return "AT"
        case "azerbaidjan": return "AZ"
        case "bahamas": return "BS"
        case "bahrein": return "BH"
        case "bangladesh": return "BD"
        case "barbade": return "BB"
        case "bielorussie": return "BY"
        case "belgique": return "BE"
        case "belize": return "BZ"
        case "benin": return "BJ"
        case "bermudes": return "BM"
        case "bhoutan": return "BT"
        case "bolivie": return "BO"
        case "bonaire, saint-eustache et saba",
            "bonaire": return "BQ"
        case "bosnie-herzegovine": return "BA"
        case "botswana": return "BW"
        case "ile bouvet": return "BV"
        case "bresil": return "BR"
        case "territoire britannique de l'ocean indien": return "IO"
        case "iles mineures eloignees des etats-unis",
            "iles mineures eloignees": return "UM"
        case "iles vierges britanniques",
            "iles vierges": return "VG"
        case "iles vierges des etats-unis",
            "iles vierges americaines": return "VI"
        case "brunei darussalam",
            "brunei": return "BN"
        case "bulgarie": return "BG"
        case "burkina faso": return "BF"
        case "burundi": return "BI"
        case "cambodge": return "KH"
        case "cameroun": return "CM"
        case "canada": return "CA"
        case "cap-vert",
            "capvert": return "CV"
        case "iles caimans": return "KY"
        case "republique centrafricaine", 
            "centrafrique": return "CF"
        case "tchad": return "TD"
        case "chili": return "CL"
        case "chine",
            "taipei chinois": return "CN"
        case "ile christmas": return "CX"
        case "iles cocos (keeling)", 
            "iles cocos": return "CC"
        case "colombie": return "CO"
        case "comores": return "KM"
        case "republique du congo",
            "congo": return "CG"
        case "republique democratique du congo", "congo democratique": return "CD"
        case "iles cook",
            "cook": return "CK"
        case "costa rica": return "CR"
        case "croatie": return "HR"
        case "cuba": return "CU"
        case "chypre": return "CY"
        case "republique tcheque": return "CZ"
        case "danemark": return "DK"
        case "djibouti": return "DJ"
        case "dominique": return "DM"
        case "republique dominicaine": return "DO"
        case "equateur": return "EC"
        case "egypte": return "EG"
        case "el salvador": return "SV"
        case "guinee equatoriale": return "GQ"
        case "erythree": return "ER"
        case "estonie": return "EE"
        case "ethiopie": return "ET"
        case "iles falkland": return "FK"
        case "iles feroe": return "FO"
        case "fidji": return "FJ"
        case "finlande": return "FI"
        case "france": return "FR"
        case "guyane francaise": return "GF"
        case "polynesie francaise": return "PF"
        case "terres australes francaises": return "TF"
        case "gabon": return "GA"
        case "gambie": return "GM"
        case "georgie": return "GE"
        case "allemagne",
            "allemagne amateur": return "DE"
        case "ghana": return "GH"
        case "gibraltar": return "GI"
        case "grece": return "GR"
        case "groenland": return "GL"
        case "grenade": return "GD"
        case "guadeloupe": return "GP"
        case "guam": return "GU"
        case "guatemala": return "GT"
        case "guernesey": return "GG"
        case "guinee": return "GN"
        case "guinee-bissau": return "GW"
        case "guyana": return "GY"
        case "haiti": return "HT"
        case "iles heard-et-macdonald": return "HM"
        case "saint-siege": return "VA"
        case "honduras": return "HN"
        case "hongrie": return "HU"
        case "islande": return "IS"
        case "inde": return "IN"
        case "indonesie": return "ID"
        case "cote d'ivoire": return "CI"
        case "iran": return "IR"
        case "iraq", "irak": return "IQ"
        case "irlande": return "IE"
        case "ile de man": return "IM"
        case "israel": return "IL"
        case "italie": return "IT"
        case "jamaique": return "JM"
        case "japon": return "JP"
        case "jersey": return "JE"
        case "jordanie": return "JO"
        case "kazakhstan": return "KZ"
        case "kenya": return "KE"
        case "kiribati": return "KI"
        case "koweit": return "KW"
        case "kirghizistan": return "KG"
        case "republique democratique populaire lao": return "LA"
        case "lettonie": return "LV"
        case "liban": return "LB"
        case "lesotho": return "LS"
        case "liberia": return "LR"
        case "libye": return "LY"
        case "liechtenstein": return "LI"
        case "lituanie": return "LT"
        case "luxembourg": return "LU"
        case "macedoine du nord": return "MK"
        case "madagascar": return "MG"
        case "malaisie": return "MY"
        case "malawi": return "MW"
        case "maldives": return "MV"
        case "mali": return "ML"
        case "malte": return "MT"
        case "iles marshall": return "MH"
        case "martinique": return "MQ"
        case "mauritanie": return "MR"
        case "ile maurice": return "MU"
        case "mayotte": return "YT"
        case "mexique": return "MX"
        case "micronesie": return "FM"
        case "moldavie": return "MD"
        case "monaco": return "MC"
        case "mongolie": return "MN"
        case "montenegro": return "ME"
        case "montserrat": return "MS"
        case "maroc": return "MA"
        case "mozambique": return "MZ"
        case "myanmar": return "MM"
        case "namibie": return "NA"
        case "nauru": return "NR"
        case "nepal": return "NP"
        case "pays-bas": return "NL"
        case "nouvelle-caledonie": return "NC"
        case "nouvelle-zelande": return "NZ"
        case "nicaragua": return "NI"
        case "niger": return "NE"
        case "nigeria": return "NG"
        case "niue": return "NU"
        case "ile norfolk": return "NF"
        case "coree du nord": return "KP"
        case "iles mariannes du nord": return "MP"
        case "norvege": return "NO"
        case "oman": return "OM"
        case "pakistan": return "PK"
        case "palau": return "PW"
        case "palestine": return "PS"
        case "panama": return "PA"
        case "papouasie-nouvelle-guinee": return "PG"
        case "paraguay": return "PY"
        case "perou": return "PE"
        case "philippines": return "PH"
        case "iles pitcairn": return "PN"
        case "pologne": return "PL"
        case "portugal": return "PT"
        case "porto rico": return "PR"
        case "qatar": return "QA"
        case "kosovo": return "XK"
        case "reunion": return "RE"
        case "roumanie": return "RO"
        case "russie": return "RU"
        case "rwanda": return "RW"
        case "saint-barthelemy": return "BL"
        case "sainte-helene, ascension et tristan da cunha": return "SH"
        case "saint-kitts-et-nevis": return "KN"
        case "sainte-lucie": return "LC"
        case "saint-martin": return "MF"
        case "saint-pierre-et-miquelon": return "PM"
        case "saint-vincent-et-les-grenadines": return "VC"
        case "samoa": return "WS"
        case "san marin": return "SM"
        case "sao tome-et-principe": return "ST"
        case "arabie saoudite": return "SA"
        case "senegal": return "SN"
        case "serbie": return "RS"
        case "seychelles": return "SC"
        case "sierra leone": return "SL"
        case "singapour": return "SG"
        case "slovaquie": return "SK"
        case "slovenie": return "SI"
        case "salomon, iles": return "SB"
        case "somalie": return "SO"
        case "afrique du sud": return "ZA"
        case "georgie du sud-et-les iles sandwich du sud", "georgie du sud": return "GS"
        case "coree (republique de)", "coree du sud": return "KR"
        case "espagne": return "ES"
        case "sri lanka": return "LK"
        case "soudan": return "SD"
        case "soudan du sud": return "SS"
        case "suriname": return "SR"
        case "svalbard et ile jan mayen": return "SJ"
        case "swaziland": return "SZ"
        case "suede": return "SE"
        case "suisse": return "CH"
        case "republique arabe syrienne", "syrie": return "SY"
        case "taiwan": return "TW"
        case "tadjikistan": return "TJ"
        case "tanzanie": return "TZ"
        case "thailande": return "TH"
        case "timor-leste": return "TL"
        case "togo": return "TG"
        case "tokelau": return "TK"
        case "tonga": return "TO"
        case "trinite-et-tobago", 
            "trinidad-et-tobago",
            "trinidad et tobago": return "TT"
        case "tunisie": return "TN"
        case "turquie": return "TR"
        case "turkmenistan": return "TM"
        case "iles turks et caicos": return "TC"
        case "tuvalu": return "TV"
        case "ouganda": return "UG"
        case "ukraine": return "UA"
        case "emirats arabes unis": return "AE"
        // -
        case "england", "angleterre": return "GB1"
        case "ecosse": return "GB2"
        case "irlande du nord": return "GB3"
        case "pays de galles": return "GB4"
        // -
        case "royaume-uni de grande-bretagne et d'irlande du nord",
            "uk",
            "royaume uni",
            "royaume-uni": return "GB"
        // -
        case "etats-unis d'amerique",
            "amerique",
            "usa",
            "etats-unis",
            "etats unis": return "US"
            
        case "uruguay": return "UY"
        case "ouzbekistan": return "UZ"
        case "vanuatu": return "VU"
        case "venezuela": return "VE"
        case "viet nam": return "VN"
        case "wallis-et-futuna": return "WF"
        case "sahara occidental": return "EH"
        case "yemen": return "YE"
        case "zambie": return "ZM"
        case "zimbabwe": return "ZW"
        default: return nil
        }
    }

    static func englishCountryCode(withName name: String) -> String? {
          let processedName = name.lowercased()
          switch processedName {
          case "afghanistan": return "AF"
          case "aland islands": return "AX"
          case "albania": return "AL"
          case "algeria": return "DZ"
          case "american samoa": return "AS"
          case "andorra": return "AD"
          case "angola": return "AO"
          case "anguilla": return "AI"
          case "antarctica": return "AQ"
          case "antigua and barbuda": return "AG"
          case "argentina": return "AR"
          case "armenia": return "AM"
          case "aruba": return "AW"
          case "australia": return "AU"
          case "austria": return "AT"
          case "azerbaijan": return "AZ"
          case "bahamas": return "BS"
          case "bahrain": return "BH"
          case "bangladesh": return "BD"
          case "barbados": return "BB"
          case "belarus": return "BY"
          case "belgium": return "BE"
          case "belize": return "BZ"
          case "benin": return "BJ"
          case "bermuda": return "BM"
          case "bhutan": return "BT"
          case "bolivia": return "BO"
          case "bonaire": return "BQ"
          case "bosnia and herzegovina": return "BA"
          case "botswana": return "BW"
          case "bouvet island": return "BV"
          case "brazil": return "BR"
          case "british indian ocean territory": return "IO"
          case "united states minor outlying islands": return "UM"
          case "virgin islands": return "VG"
          case "virgin islands (u.s.)": return "VI"
          case "brunei darussalam": return "BN"
          case "bulgaria": return "BG"
          case "burkina faso": return "BF"
          case "burundi": return "BI"
          case "cambodia": return "KH"
          case "cameroon": return "CM"
          case "canada": return "CA"
          case "cabo verde": return "CV"
          case "cayman islands": return "KY"
          case "central african republic": return "CF"
          case "chad": return "TD"
          case "chile": return "CL"
          case "china": return "CN"
          case "christmas island": return "CX"
          case "cocos islands": return "CC"
          case "colombia": return "CO"
          case "comoros": return "KM"
          case "congo": return "CG"
          case "congo democratic republic": return "CD"
          case "cook islands": return "CK"
          case "costa rica": return "CR"
          case "croatia": return "HR"
          case "cuba": return "CU"
          case "curaçao": return "CW"
          case "cyprus": return "CY"
          case "czech republic": return "CZ"
          case "denmark": return "DK"
          case "djibouti": return "DJ"
          case "dominica": return "DM"
          case "dominican republic": return "DO"
          case "ecuador": return "EC"
          case "egypt": return "EG"
          case "el salvador", "le salvador": return "SV"
          case "equatorial guinea": return "GQ"
          case "eritrea": return "ER"
          case "estonia": return "EE"
          case "ethiopia": return "ET"
          case "falkland islands": return "FK"
          case "faroe islands": return "FO"
          case "fiji": return "FJ"
          case "finland": return "FI"
          case "france": return "FR"
          case "french guiana": return "GF"
          case "french polynesia": return "PF"
          case "french southern territories": return "TF"
          case "gabon": return "GA"
          case "gambia": return "GM"
          case "georgia": return "GE"
          case "germany": return "DE"
          case "ghana": return "GH"
          case "gibraltar": return "GI"
          case "greece": return "GR"
          case "greenland": return "GL"
          case "grenada": return "GD"
          case "guadeloupe": return "GP"
          case "guam": return "GU"
          case "guatemala": return "GT"
          case "guernsey": return "GG"
          case "guinea": return "GN"
          case "guinea-bissau": return "GW"
          case "guyana": return "GY"
          case "haiti": return "HT"
          case "heard island and mcdonald islands": return "HM"
          case "vatican city": return "VA"
          case "honduras": return "HN"
          case "hungary": return "HU"
          case "hong kong": return "HK"
          case "iceland": return "IS"
          case "india": return "IN"
          case "indonesia": return "ID"
          case "ivory coast": return "CI"
          case "iran": return "IR"
          case "iraq": return "IQ"
          case "ireland": return "IE"
          case "isle of man": return "IM"
          case "israel": return "IL"
          case "italy": return "IT"
          case "jamaica": return "JM"
          case "japan": return "JP"
          case "jersey": return "JE"
          case "jordan": return "JO"
          case "kazakhstan": return "KZ"
          case "kenya": return "KE"
          case "kiribati": return "KI"
          case "kuwait": return "KW"
          case "kyrgyzstan": return "KG"
          case "lao people's democratic republic": return "LA"
          case "latvia": return "LV"
          case "lebanon": return "LB"
          case "lesotho": return "LS"
          case "liberia": return "LR"
          case "libya": return "LY"
          case "liechtenstein": return "LI"
          case "lithuania": return "LT"
          case "luxembourg": return "LU"
          case "macao": return "MO"
          case "north macedonia": return "MK"
          case "madagascar": return "MG"
          case "malawi": return "MW"
          case "malaysia": return "MY"
          case "maldives": return "MV"
          case "mali": return "ML"
          case "malta": return "MT"
          case "marshall islands": return "MH"
          case "martinique": return "MQ"
          case "mauritania": return "MR"
          case "mauritius": return "MU"
          case "mayotte": return "YT"
          case "mexico": return "MX"
          case "micronesia": return "FM"
          case "moldova": return "MD"
          case "monaco": return "MC"
          case "mongolia": return "MN"
          case "montenegro": return "ME"
          case "montserrat": return "MS"
          case "morocco": return "MA"
          case "mozambique": return "MZ"
          case "myanmar": return "MM"
          case "namibia": return "NA"
          case "nauru": return "NR"
          case "nepal": return "NP"
          case "netherlands": return "NL"
          case "new caledonia": return "NC"
          case "new zealand": return "NZ"
          case "nicaragua": return "NI"
          case "niger": return "NE"
          case "nigeria": return "NG"
          case "niue": return "NU"
          case "norfolk island": return "NF"
          case "korea (democratic people's republic of)", "nourth korea": return "KP"
          case "northern mariana islands": return "MP"
          case "norway": return "NO"
          case "oman": return "OM"
          case "pakistan": return "PK"
          case "palau": return "PW"
          case "palestine, state of": return "PS"
          case "panama": return "PA"
          case "papua new guinea": return "PG"
          case "paraguay": return "PY"
          case "peru": return "PE"
          case "philippines": return "PH"
          case "pitcairn": return "PN"
          case "poland": return "PL"
          case "portugal": return "PT"
          case "puerto rico": return "PR"
          case "qatar": return "QA"
          case "republic of kosovo": return "XK"
          case "réunion": return "RE"
          case "romania": return "RO"
          case "russian federation", "russia": return "RU"
          case "rwanda": return "RW"
          case "saint barthélemy": return "BL"
          case "saint helena, ascension and tristan da cunha": return "SH"
          case "saint kitts and nevis": return "KN"
          case "saint lucia": return "LC"
          case "saint martin (french part)", "saint martin": return "MF"
          case "saint pierre and miquelon": return "PM"
          case "saint vincent and the grenadines": return "VC"
          case "samoa": return "WS"
          case "san marino": return "SM"
          case "sao tome and principe": return "ST"
          case "saudi arabia": return "SA"
          case "senegal": return "SN"
          case "serbia": return "RS"
          case "seychelles": return "SC"
          case "sierra leone": return "SL"
          case "singapore": return "SG"
          case "sint maarten (dutch part)", "sint maarten": return "SX"
          case "slovakia": return "SK"
          case "slovenia": return "SI"
          case "solomon islands": return "SB"
          case "somalia": return "SO"
          case "south africa": return "ZA"
          case "south georgia and the south sandwich islands", "south georgia": return "GS"
          case "korea (republic of)", "south korea": return "KR"
          case "spain": return "ES"
          case "sri lanka": return "LK"
          case "sudan": return "SD"
          case "south sudan": return "SS"
          case "suriname": return "SR"
          case "svalbard and jan mayen": return "SJ"
          case "swaziland": return "SZ"
          case "sweden": return "SE"
          case "switzerland": return "CH"
          case "syrian arab republic": return "SY"
          case "taiwan": return "TW"
          case "tajikistan": return "TJ"
          case "tanzania", "zanzibar": return "TZ"
          case "thailand": return "TH"
          case "timor-leste": return "TL"
          case "togo": return "TG"
          case "tokelau": return "TK"
          case "tonga": return "TO"
          case "trinidad and tobago": return "TT"
          case "tunisia": return "TN"
          case "turkey": return "TR"
          case "turkmenistan": return "TM"
          case "turks and caicos islands": return "TC"
          case "tuvalu": return "TV"
          case "uganda": return "UG"
          case "ukraine": return "UA"
          case "united arab emirates": return "AE"
          case "united kingdom of great britain and northern ireland", "uk", "united kingdom": return "GB"
          case "united states of america", "usa": return "US"
          case "uruguay": return "UY"
          case "uzbekistan": return "UZ"
          case "vanuatu": return "VU"
          case "venezuela": return "VE"
          case "vietnam": return "VN"
          case "wallis and futuna": return "WF"
          case "western sahara": return "EH"
          case "yemen": return "YE"
          case "zambia": return "ZM"
          case "zimbabwe": return "ZW"
          default: return nil
          }

      }

}
````

## File: Sources/ServicesProvider/Models/Errors.swift
````swift
//
//  File.swift
//
//
//  Created by Ruben Roques on 11/10/2022.
//

import Foundation

public enum ServiceProviderError: Error, Equatable, Hashable {

    case privilegedAccessManagerNotFound
    case eventsProviderNotFound
    case bettingProviderNotFound
    case promotionsProviderNotFound
    case subscriptionNotFound

    case invalidEmailPassword
    case quickSignUpIncomplete

    case invalidSignUpEmail
    case invalidSignUpUsername
    case invalidSignUpPassword

    case invalidMobileVerifyCode

    case failedTempLock(date: String)

    case incompletedSportData
    case userSessionNotFound

    case notPlacedBet(message: String)
    case betNeedsUserConfirmation(betDetails: PlacedBetsResponse)

    case onSubscribe
    case resourceNotFound

    case resourceUnavailableOrDeleted

    case badRequest
    case pageNotFound
    case invalidRequestFormat
    case internalServerError
    case request
    case unauthorized
    case forbidden
    case invalidResponse
    case emptyData

    case decodingError(message: String)
    case errorMessage(message: String)

    case errorDetailedMessage(key: String, message: String)

    case invalidUserLocation
    case notSupportedForProvider
    case unknown
}
````

## File: Sources/ServicesProvider/Models/EventListSort.swift
````swift
//
//  EventListSort.swift
//  
//
//  Created by Ruben Roques on 21/11/2022.
//

import Foundation

public enum EventListSort: String {
    case date = "D"
    case popular = "T"
}
````

## File: Sources/ServicesProvider/Models/Events.swift
````swift
//
//  Events.swift
//
//
//  Created by Ruben Roques on 11/10/2022.
//

import Foundation
import SharedModels


public class EventMetadataPointer: Codable {

    public var id: String?
    public var eventId: String
    public var eventMarketId: String
    public var callToActionURL: String?
    public var imageURL: String?

    init(id: String?, eventId: String, eventMarketId: String, callToActionURL: String?, imageURL: String?) {
        self.id = id
        self.eventId = eventId
        self.eventMarketId = eventMarketId
        self.callToActionURL = callToActionURL
        self.imageURL = imageURL
    }

}

public class EventGroupPointer: Codable {

    public var eventsPointers: [String]
    public var marketGroupId: String?
    public var title: String?

    public init(eventsPointers: [String], marketGroupId: String?, title: String?) {
        self.eventsPointers = eventsPointers
        self.marketGroupId = marketGroupId
        self.title = title
    }

}

public class EventsGroup {
    public var events: [Event]
    public var marketGroupId: String?
    public var title: String?

    public init(events: [Event], marketGroupId: String?, title: String? = nil) {
        self.events = events
        self.marketGroupId = marketGroupId
        self.title = title
    }
}

public enum EventType: String, Equatable {
    case match
    case competition
}

public enum EventStatus: Hashable {
    case unknown
    case notStarted
    case inProgress(String)
    case ended(String)

    public init(value: String) {
        switch value {
        case "not_started": self = .notStarted
        case "ended": self = .ended(value)
        default: self = .inProgress(value)
        }
    }
}

public class Event: Codable, Equatable {

    public var id: String
    public var homeTeamName: String
    public var awayTeamName: String
    public var sport: SportType
    public var sportIdCode: String?

    public var homeTeamScore: Int?
    public var awayTeamScore: Int?
    public var homeTeamLogoUrl: String?
    public var awayTeamLogoUrl: String?

    public var competitionId: String
    public var competitionName: String
    public var startDate: Date

    public var markets: [Market]

    public var venueCountry: Country?
    public var numberMarkets: Int?

    public var name: String?

    public var status: EventStatus?

    public var matchTime: String?

    public var promoImageURL: String?
    public var oldMainMarketId: String?

    public var trackableReference: String?

    public var activePlayerServing: ActivePlayerServe?

    public var boostedMarket: Market?

    public var type: EventType {
        if self.homeTeamName.isEmpty && self.awayTeamName.isEmpty {
            return .competition
        }
        else {
            return .match
        }
    }

    public var scores: [String: Score]

    enum CodingKeys: String, CodingKey {
        case id = "id"
        case homeTeamName = "homeName"
        case awayTeamName = "awayName"
        case competitionId = "competitionId"
        case competitionName = "competitionName"
        case sport = "sport"
        case sportIdCode = "sportIdCode"
        case startDate = "startDate"
        case markets = "markets"
        case venueCountry = "venueCountry"
        case numberMarkets = "numMarkets"
        case scores = "scores"
        case trackableReference = "trackableReference"
        case activePlayerServing = "activePlayerServing"
        case homeTeamLogoUrl = "homeTeamLogoUrl"
        case awayTeamLogoUrl = "awayTeamLogoUrl"
        case promoImageURL = "promoImageURL"
        case boostedMarket = "boostedMarket"
    }

    public init(id: String,
                homeTeamName: String,
                awayTeamName: String,
                homeTeamScore: Int?,
                awayTeamScore: Int?,
                homeTeamLogoUrl: String?,
                awayTeamLogoUrl: String?,
                competitionId: String,
                competitionName: String,
                sport: SportType,
                sportIdCode: String?,
                startDate: Date,
                markets: [Market],
                venueCountry: Country? = nil,
                numberMarkets: Int? = nil,
                name: String? = nil,
                trackableReference: String?,
                status: EventStatus?,
                matchTime: String?,
                activePlayerServing: ActivePlayerServe?,
                boostedMarket: Market?,
                promoImageURL: String?,
                scores: [String: Score]) {

        self.id = id
        self.homeTeamName = homeTeamName
        self.awayTeamName = awayTeamName

        self.homeTeamScore = homeTeamScore
        self.awayTeamScore = awayTeamScore
        self.homeTeamLogoUrl = homeTeamLogoUrl
        self.awayTeamLogoUrl = awayTeamLogoUrl

        self.competitionId = competitionId
        self.competitionName = competitionName

        self.sport = sport
        self.sportIdCode = sportIdCode

        self.trackableReference = trackableReference

        self.startDate = startDate
        self.markets = markets
        self.venueCountry = venueCountry
        self.numberMarkets = numberMarkets

        self.name = name
        self.status = status
        self.matchTime = matchTime

        self.promoImageURL = promoImageURL
        self.oldMainMarketId = nil

        self.activePlayerServing = activePlayerServing

        self.boostedMarket = boostedMarket

        self.scores = scores
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try container.decode(String.self, forKey: .id)
        self.homeTeamName = try container.decode(String.self, forKey: .homeTeamName)
        self.awayTeamName = try container.decode(String.self, forKey: .awayTeamName)
        self.competitionId = try container.decode(String.self, forKey: .competitionId)
        self.competitionName = try container.decode(String.self, forKey: .competitionName)
        self.sport = try container.decode(SportType.self, forKey: .sport)
        self.startDate = try container.decode(Date.self, forKey: .startDate)
        self.markets = try container.decode([Market].self, forKey: .markets)
        self.venueCountry = try container.decodeIfPresent(Country.self, forKey: .venueCountry)
        self.numberMarkets = try container.decodeIfPresent(Int.self, forKey: .numberMarkets)
        self.sportIdCode = try container.decodeIfPresent(String.self, forKey: .sportIdCode)
        self.trackableReference = try container.decodeIfPresent(String.self, forKey: .trackableReference)
        self.activePlayerServing = try container.decodeIfPresent(ActivePlayerServe.self, forKey: .activePlayerServing)
        self.boostedMarket = try container.decodeIfPresent(Market.self, forKey: .boostedMarket)
        self.scores = (try? container.decode([String: Score].self, forKey: .scores)) ?? [:]

    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.id, forKey: .id)
        try container.encode(self.homeTeamName, forKey: .homeTeamName)
        try container.encode(self.awayTeamName, forKey: .awayTeamName)
        try container.encode(self.competitionId, forKey: .competitionId)
        try container.encode(self.competitionName, forKey: .competitionName)
        try container.encode(self.sport, forKey: .sport)
        try container.encode(self.startDate, forKey: .startDate)
        try container.encode(self.markets, forKey: .markets)
        try container.encodeIfPresent(self.venueCountry, forKey: .venueCountry)
        try container.encodeIfPresent(self.numberMarkets, forKey: .numberMarkets)
        try container.encodeIfPresent(self.sportIdCode, forKey: .sportIdCode)
        try container.encodeIfPresent(self.trackableReference, forKey: .trackableReference)
        try container.encodeIfPresent(self.activePlayerServing, forKey: .activePlayerServing)
        try container.encodeIfPresent(self.boostedMarket, forKey: .boostedMarket)
    }

    public static func == (lhs: Event, rhs: Event) -> Bool {
        // Compare all properties for equality
        return lhs.id == rhs.id &&
        lhs.homeTeamName == rhs.homeTeamName &&
        lhs.awayTeamName == rhs.awayTeamName &&
        lhs.homeTeamScore == rhs.homeTeamScore &&
        lhs.awayTeamScore == rhs.awayTeamScore &&
        lhs.competitionId == rhs.competitionId &&
        lhs.competitionName == rhs.competitionName &&
        lhs.sport == rhs.sport &&
        lhs.startDate == rhs.startDate &&
        lhs.markets == rhs.markets &&
        lhs.venueCountry == rhs.venueCountry &&
        lhs.numberMarkets == rhs.numberMarkets &&
        lhs.name == rhs.name &&
        lhs.status == rhs.status &&
        lhs.matchTime == rhs.matchTime &&
        lhs.trackableReference == rhs.trackableReference &&
        lhs.scores == rhs.scores &&
        lhs.activePlayerServing == rhs.activePlayerServing
    }
}

public class HighlightMarket: Codable, Equatable {
    public var id: String {
        return market.id
    }
    public var market: Market
    public var enabledSelectionsCount: Int
    public var promotionImageURl: String?

    public init(market: Market, enabledSelectionsCount: Int, promotionImageURl: String?) {
        self.market = market
        self.enabledSelectionsCount = enabledSelectionsCount
        self.promotionImageURl = promotionImageURl
    }

    public static func == (lhs: HighlightMarket, rhs: HighlightMarket) -> Bool {
        // Compare all properties for equality
        return lhs.market == rhs.market &&
        lhs.enabledSelectionsCount == rhs.enabledSelectionsCount
    }
}

public class Market: Codable, Equatable {

    public enum OutcomesOrder: Codable, Hashable {
        case none
        case odds // by odd
        case name // by name
        case setup // The original order that the server sends us
    }

    public var id: String
    public var name: String
    public var outcomes: [Outcome]
    public var marketTypeId: String?
    public var marketFilterId: String?
    public var eventMarketTypeId: String?
    public var eventName: String?
    public var isMainOutright: Bool?
    public var eventMarketCount: Int?
    public var isTradable: Bool
    public var startDate: Date?
    public var homeParticipant: String?
    public var awayParticipant: String?
    public var eventId: String?
    public var marketDigitLine: String?
    public var outcomesOrder: OutcomesOrder
    public var customBetAvailable: Bool?

    public var stats: Stats?

    public var isMainMarket: Bool

    // Event related properties
    public var competitionId: String?
    public var competitionName: String?
    public var sport: SportType?
    public var sportIdCode: String?

    public var venueCountry: Country?

    enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case outcomes = "outcomes"
        case marketTypeId = "marketTypeId"
        case marketFilterId = "marketFilterId"
        case eventMarketTypeId = "eventMarketTypeId"
        case eventName = "eventName"
        case isMainOutright = "ismainoutright"
        case eventMarketCount = "eventMarketCount"
        case isTradable = "isTradable"
        case startDate = "tsstart"
        case homeParticipant = "participantname_home"
        case awayParticipant = "participantname_away"
        case eventId = "idfoevent"
        case marketDigitLine = "marketDigitLine"
        case outcomesOrder = "outcomesOrder"
        case customBetAvailable = "custombetavailable"
        case sport = "sport"
        case sportIdCode = "sportIdCode"
        case venueCountry = "venueCountry"
        case isMainMarket = "isMainMarket"
        case stats = "stats"
    }

    public init(id: String,
                name: String,
                outcomes: [Outcome],
                marketTypeId: String?,
                marketFilterId: String?,
                eventMarketTypeId: String?,
                eventName: String?,
                isMainOutright: Bool?,
                eventMarketCount: Int?,
                isTradable: Bool,
                startDate: Date?,
                homeParticipant: String?,
                awayParticipant: String?,
                eventId: String?,
                marketDigitLine: String?,
                outcomesOrder: OutcomesOrder = .none,
                competitionId: String? = nil,
                competitionName: String? = nil,
                sport: SportType? = nil,
                sportIdCode: String?,
                venueCountry: Country? = nil,
                customBetAvailable: Bool?,
                isMainMarket: Bool,
                stats: Stats? = nil) {

        self.id = id
        self.name = name
        self.outcomes = outcomes
        self.marketTypeId = marketTypeId
        self.marketFilterId = marketFilterId
        self.eventMarketTypeId = eventMarketTypeId
        self.eventName = eventName
        self.isMainOutright = isMainOutright
        self.eventMarketCount = eventMarketCount
        self.isTradable = isTradable
        self.startDate = startDate
        self.homeParticipant = homeParticipant
        self.awayParticipant = awayParticipant
        self.eventId = eventId
        self.marketDigitLine = marketDigitLine
        self.outcomesOrder = outcomesOrder

        // Event related properties
        self.competitionId = competitionId
        self.competitionName = competitionName

        self.sport = sport
        self.sportIdCode = sportIdCode

        self.venueCountry = venueCountry

        self.customBetAvailable = customBetAvailable
        self.isMainMarket = isMainMarket
        self.stats = stats
    }

    public static func == (lhs: Market, rhs: Market) -> Bool {
        // Compare all properties for equality
        return lhs.id == rhs.id &&
        lhs.name == rhs.name &&
        lhs.outcomes == rhs.outcomes &&
        lhs.marketTypeId == rhs.marketTypeId &&
        lhs.eventMarketTypeId == rhs.eventMarketTypeId &&
        lhs.eventName == rhs.eventName &&
        lhs.isMainOutright == rhs.isMainOutright &&
        lhs.eventMarketCount == rhs.eventMarketCount &&
        lhs.isTradable == rhs.isTradable &&
        lhs.startDate == rhs.startDate &&
        lhs.homeParticipant == rhs.homeParticipant &&
        lhs.awayParticipant == rhs.awayParticipant &&
        lhs.eventId == rhs.eventId &&
        lhs.outcomesOrder == rhs.outcomesOrder &&
        lhs.customBetAvailable == rhs.customBetAvailable &&
        lhs.isMainMarket == rhs.isMainMarket
    }
}


public class Outcome: Codable, Equatable {

    public var id: String
    public var name: String
    public var odd: OddFormat
    public var marketId: String?
    public var bettingOfferId: String?
    public var orderValue: String?
    public var externalReference: String?

    public var isTradable: Bool
    public var isTerminated: Bool

    public var customBetAvailableMarket: Bool?

    enum CodingKeys: String, CodingKey {
        case id = "id"
        case name = "name"
        case odd = "odd"
        case marketId = "marketId"
        case bettingOfferId = "bettingOfferId"
        case orderValue = "orderValue"
        case externalReference = "externalReference"
        case isTradable = "isTradable"
        case isTerminated = "isTerminated"
        case customBetAvailableMarket = "customBetAvailableMarket"
    }

    public init(id: String,
                name: String,
                odd: OddFormat,
                marketId: String? = nil,
                bettingOfferId: String? = nil,
                orderValue: String? = nil,
                externalReference: String? = nil,
                isTradable: Bool = true,
                isTerminated: Bool = false,
                customBetAvailableMarket: Bool?) {

        self.id = id
        self.name = name
        self.odd = odd
        self.marketId = marketId
        self.bettingOfferId = bettingOfferId
        self.orderValue = orderValue
        self.externalReference = externalReference
        self.isTradable = isTradable
        self.isTerminated = isTerminated
        self.customBetAvailableMarket = customBetAvailableMarket
    }

    required public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try container.decode(String.self, forKey: .id)
        self.name = try container.decode(String.self, forKey: .name)
        self.odd = try container.decode(OddFormat.self, forKey: .odd)
        self.marketId = try container.decodeIfPresent(String.self, forKey: .marketId)
        self.bettingOfferId = try container.decodeIfPresent(String.self, forKey: .bettingOfferId)
        self.orderValue = try container.decodeIfPresent(String.self, forKey: .orderValue)
        self.externalReference = try container.decodeIfPresent(String.self, forKey: .externalReference)
        self.isTradable = (try? container.decode(Bool.self, forKey: .isTradable)) ?? false
        self.isTerminated = (try? container.decode(Bool.self, forKey: .isTerminated)) ?? false
        self.customBetAvailableMarket = try container.decodeIfPresent(Bool.self, forKey: .customBetAvailableMarket)
    }

    public static func == (lhs: Outcome, rhs: Outcome) -> Bool {
        // Compare all properties for equality
        return lhs.id == rhs.id &&
        lhs.name == rhs.name &&
        lhs.odd == rhs.odd &&
        lhs.marketId == rhs.marketId &&
        lhs.bettingOfferId == rhs.bettingOfferId &&
        lhs.orderValue == rhs.orderValue &&
        lhs.externalReference == rhs.externalReference &&
        lhs.isTradable == rhs.isTradable &&
        lhs.isTerminated == rhs.isTerminated &&
        lhs.customBetAvailableMarket == rhs.customBetAvailableMarket
    }
}

public struct EventLiveData: Equatable {

    public var id: String
    public var homeScore: Int?
    public var awayScore: Int?
    public var matchTime: String?
    public var status: EventStatus?
    public var detailedScores: [String: Score]?
    public var activePlayerServing: ActivePlayerServe?

    enum CodingKeys: String, CodingKey {
        case id = "id"
        case homeScore = "homeScore"
        case awayScore = "awayScore"
        case matchTime = "matchTime"
        case status = "status"
        case detailedScores = "detailedScores"
        case activePlayerServing = "activePlayerServing"
    }

    public init(id: String,
                homeScore: Int?,
                awayScore: Int?,
                matchTime: String?,
                status: EventStatus?,
                detailedScores: [String: Score]?,
                activePlayerServing: ActivePlayerServe?)
    {
        self.id = id
        self.homeScore = homeScore
        self.awayScore = awayScore
        self.matchTime = matchTime
        self.status = status
        self.detailedScores = detailedScores
        self.activePlayerServing = activePlayerServing
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        id = try container.decode(String.self, forKey: .id)
        homeScore = try container.decodeIfPresent(Int.self, forKey: .homeScore)
        awayScore = try container.decodeIfPresent(Int.self, forKey: .awayScore)
        matchTime = try container.decodeIfPresent(String.self, forKey: .matchTime)

        // Decode the status based on the "status" key
        let statusValue = try container.decode(String.self, forKey: .status)
        status = EventStatus(value: statusValue)

        detailedScores = try container.decodeIfPresent([String: Score].self, forKey: .detailedScores)
        activePlayerServing = try container.decodeIfPresent(ActivePlayerServe.self, forKey: .activePlayerServing)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encode(id, forKey: .id)
        try container.encodeIfPresent(homeScore, forKey: .homeScore)
        try container.encodeIfPresent(awayScore, forKey: .awayScore)
        try container.encodeIfPresent(matchTime, forKey: .matchTime)
        try container.encodeIfPresent(detailedScores, forKey: .detailedScores)
        try container.encodeIfPresent(activePlayerServing, forKey: .activePlayerServing)

        if let status = self.status {
            switch status {
            case .unknown:
                try container.encode("unknown", forKey: .status)
            case .notStarted:
                try container.encode("not_started", forKey: .status)
            case .inProgress(let value):
                try container.encode(value, forKey: .status)
            case .ended:
                try container.encode("ended", forKey: .status)
            }
        }
    }

}

public struct FieldWidget: Codable {
    public var data: String?
    public var version: Int?

    enum CodingKeys: String, CodingKey {
        case data = "data"
        case version = "version"
    }
}

public struct MarketGroupPointer {
    public var id: String
    public var name: String
    public var marketGroupIds: [String]
    public var groupOrder: Int
}

public struct AvailableMarket {
    public var marketId: String
    public var marketGroupId: String
    public var market: Market
    public var orderGroupOrder: Int
}

public struct MarketGroup {

    public var type: String
    public var id: String
    public var groupKey: String?
    public var translatedName: String?
    public var position: Int?
    public var isDefault: Bool?
    public var numberOfMarkets: Int?
    public var loaded: Bool
    public var markets: [Market]?

}

public struct FieldWidgetRenderData {
    public var url: URL?
    public var htmlString: String?
}

public enum FieldWidgetRenderDataType {
    case url(url: URL)
    case htmlString(url: URL, htmlString: String)
}

public enum StatsWidgetRenderDataType {
    case url(url: URL)
    case htmlString(url: URL, htmlString: String)
}

public struct SportNodeInfo: Codable {
    public var id: String
    public var regionNodes: [SportRegion]
    public var navigationTypes: [String]?
    public var name: String?
    public var defaultOrder: Int?
    public var numMarkets: String?
    public var numEvents: String?
    public var numOutrightMarkets: String?
    public var numOutrightEvents: String?

    enum CodingKeys: String, CodingKey {
        case id = "idfwbonavigation"
        case regionNodes = "bonavigationnodes"
        case navigationTypes = "idfwbonavigationtypes"
        case name = "name"
        case defaultOrder = "defaultOrder"
        case numMarkets = "nummarkets"
        case numEvents = "numevents"
        case numOutrightMarkets = "numoutrightmarkets"
        case numOutrightEvents = "numoutrightevents"
    }
}

public struct SportRegion: Codable {
    public var id: String
    public var name: String?
    public var numberEvents: String
    public var numberOutrightEvents: String
    public var country: Country?

    enum CodingKeys: String, CodingKey {
        case id = "idfwbonavigation"
        case name = "name"
        case numberEvents = "numevents"
        case numberOutrightEvents = "numoutrightevents"
    }
}

public struct SportRegionInfo: Codable {
    public var id: String
    public var name: String
    public var competitionNodes: [SportCompetition]

    enum CodingKeys: String, CodingKey {
        case id = "idfwbonavigation"
        case name = "name"
        case competitionNodes = "bonavigationnodes"
    }
}

public struct SportCompetition: Codable {
    public var id: String
    public var name: String
    public var numberEvents: String
    public var numberOutrightEvents: String

    enum CodingKeys: String, CodingKey {
        case id = "idfwbonavigation"
        case name = "name"
        case numberEvents = "numevents"
        case numberOutrightEvents = "numoutrightevents"
    }
}

public struct SportCompetitionInfo: Codable, Hashable {
    public var id: String
    public var name: String
    public var marketGroups: [SportCompetitionMarketGroup]
    public var numberOutrightEvents: String
    public var numberOutrightMarkets: String

    enum CodingKeys: String, CodingKey {
        case id = "idfwbonavigation"
        case name = "name"
        case marketGroups = "marketgroups"
        case numberOutrightEvents = "numoutrightevents"
        case numberOutrightMarkets = "numoutrightmarkets"
    }

}

public struct SportCompetitionMarketGroup: Codable, Hashable {
    public var id: String
    public var name: String

    enum CodingKeys: String, CodingKey {
        case id = "idfwmarketgroup"
        case name = "name"
    }
}

public struct BannerResponse: Codable {
    public var bannerItems: [EventBanner]

    enum CodingKeys: String, CodingKey {
        case bannerItems = "headlineItems"
    }
}

// Renamed from Banner to EventBanner to avoid conflict with the consolidated version in Promotions
public struct EventBanner: Codable {
    public var id: String
    public var name: String
    public var title: String
    public var imageUrl: String
    public var bodyText: String?
    public var type: String
    public var linkUrl: String?
    public var marketId: String?

    enum CodingKeys: String, CodingKey {
        case id = "idfwheadline"
        case name = "name"
        case title = "title"
        case imageUrl = "imageurl"
        case bodyText = "bodytext"
        case type = "idfwheadlinetype"
        case linkUrl = "linkurl"
        case marketId = "idfomarket"
    }
}



// Favorites
public struct FavoritesListResponse: Codable {
    public var favoritesList: [FavoriteList]

    enum CodingKeys: String, CodingKey {
        case favoritesList = "accountFavouriteCoupons"
    }
}

public struct FavoriteList: Codable {
    public var id: Int
    public var name: String
    public var customerId: Int

    enum CodingKeys: String, CodingKey {
        case id = "idfwAccountFavouriteCoupon"
        case name = "name"
        case customerId = "idmmCustomer"
    }
}

public struct FavoritesListAddResponse: Codable {
    public var listId: Int

    enum CodingKeys: String, CodingKey {
        case listId = "addAccountFavouriteCouponResult"
    }
}

public struct FavoritesListDeleteResponse: Codable {
    public var listId: String?

    enum CodingKeys: String, CodingKey {
        case listId = "addAccountFavouriteCouponResult"
    }
}

public struct FavoriteAddResponse: Codable {
    public var displayOrder: Int?
    public var idAccountFavorite: Int?

    enum CodingKeys: String, CodingKey {
        case displayOrder = "displayOrder"
        case idAccountFavorite = "idAccountFavourite"
    }
}

public struct FavoriteEventResponse: Codable {
    public var favoriteEvents: [FavoriteEvent]

    enum CodingKeys: String, CodingKey {
        case favoriteEvents = "accountFavourites"
    }
}

public struct FavoriteEvent: Codable {
    public var id: String
    public var name: String
    public var favoriteListId: Int
    public var accountFavoriteId: Int

    enum CodingKeys: String, CodingKey {
        case id = "favouriteId"
        case name = "favouriteName"
        case favoriteListId = "idfwAccountFavouriteCoupon"
        case accountFavoriteId = "idfwAccountFavourites"
    }

}

public struct HighlightedEventPointer : Codable {
    public var status: String
    public var sportId: String
    public var eventId: String
    public var eventType: String?
    public var countryId: String

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case sportId = "sport_id"
        case eventId = "event_id"
        case eventType = "event_type"
        case countryId = "country_id"
    }
}

public struct Stats: Codable, Equatable {
    public var homeParticipant: ParticipantStats
    public var awayParticipant: ParticipantStats
}

public struct ParticipantStats: Codable, Equatable {
    public var total: Int
    public var wins: Int?
    public var draws: Int?
    public var losses: Int?
    public var over: Int?
    public var under: Int?
}

public enum Score: Codable, Hashable {

    case set(index: Int, home: Int?, away: Int?)
    case gamePart(home: Int?, away: Int?)
    case matchFull(home: Int?, away: Int?)

    public var sortValue: Int {
        switch self {
        case .set(let index, _, _):
            return index
        case .gamePart:
            return 100
        case .matchFull:
            return 200
        }
    }

    public var key: String {
        switch self {
        case .set(let index, _, _):
            return "set\(index)"
        case .gamePart:
            return "gamePart"
        case .matchFull:
            return "matchFull"
        }
    }

}


public enum ActivePlayerServe: String, Codable {
    case home
    case away
}

public struct HeroGameEvent: Codable {
    public var event: Event
    public var image: String
}
````

## File: Sources/ServicesProvider/Models/FeaturedTip.swift
````swift
//
//  FeaturedTip.swift
//  ServicesProvider
//
//  Created by Ruben Roques on 19/02/2025.
//

import Foundation

public typealias FeaturedTips = [FeaturedTip]

public struct FeaturedTip {
    public var id: String
    
    public var stake: Double
    public var odd: Double
    
    public var status: String
    public var type: String
    
    public var selections: [FeaturedTipSelection]
    public var user: FeaturedTipUser

    public init(id: String,
     stake: Double,
     odd: Double,
     status: String,
     type: String,
     selections: [FeaturedTipSelection],
     user: FeaturedTipUser) {
        self.id = id
        self.stake = stake
        self.odd = odd
        self.status = status
        self.type = type
        self.selections = selections
        self.user = user
    }
}

public struct FeaturedTipSelection {
    
    public var id: String
    public var marketId: String
    public var outcomeId: String
    public var marketName: String
    public var outcomeName: String
    public var odd: Double
    public var event: Event
    
}

public struct FeaturedTipUser {
    
    public var id: String
    public var name: String?
    public var code: String?
    public var avatar: String?

    public init(id: String, name: String?, code: String?, avatar: String?) {
        self.id = id
        self.name = name
        self.code = code
        self.avatar = avatar
    }
}
````

## File: Sources/ServicesProvider/Models/Filters.swift
````swift
//
//  MarketFilter.swift
//  
//
//  Created by André Lascas on 02/11/2022.
//

import Foundation

public struct DynamicCodingKeys: CodingKey {

    // Use for string-keyed dictionary
    public var stringValue: String

    public init?(stringValue: String) {
        self.stringValue = stringValue
    }

    // Use for integer-keyed dictionary
    public var intValue: Int?

    public init?(intValue: Int) {
        return nil
    }
}

public struct MarketFilter: Codable {

    public var marketFilters: [MarketInfo]

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: DynamicCodingKeys.self)

        var tempArray = [MarketInfo]()

        for key in container.allKeys {
            let decodedObject = try container.decode(MarketInfo.self, forKey: DynamicCodingKeys(stringValue: key.stringValue)!)
            tempArray.append(decodedObject)
        }

        self.marketFilters = tempArray
    }
}

public struct MarketInfo: Codable {
    public var displayOrder: Int
    public var translations: TranslationInfo?
    public var marketsSportType: MarketSportType?

    enum CodingKeys: String, CodingKey {
        case displayOrder = "displayOrder"
        case translations = "translations"
        case marketsSportType = "marketsBySportType"
    }
}

public struct TranslationInfo: Codable {
    public var english: String
    public var spanish: String
    public var chinese: String?

    enum CodingKeys: String, CodingKey {
        case english = "UK"
        case spanish = "ES"
        case chinese = "ZH"
    }

}

public struct MarketSportType: Codable {

    public var marketSports: [String: [MarketSport]]

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: DynamicCodingKeys.self)

        var tempArray = [String: [MarketSport]]()

        for key in container.allKeys {

            let decodedObject = try container.decode([MarketSport].self, forKey: DynamicCodingKeys(stringValue: key.stringValue)!)
            tempArray[key.stringValue] = decodedObject
        }

        self.marketSports = tempArray
    }
}

public struct MarketSport: Codable {
    public var ids: [String]
    public var marketOrder: Int
    public var expanded: Bool

    enum CodingKeys: String, CodingKey {
        case ids = "ids"
        case marketOrder = "displayOrder"
        case expanded = "expanded"
    }
}
````

## File: Sources/ServicesProvider/Models/Freebet.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 04/04/2023.
//

import Foundation


public struct FreebetBalance: Codable {

    public var balance: Double

    enum CodingKeys: CodingKey {
        case balance
    }

    public init(balance: Double) {
        self.balance = balance
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.balance = try container.decode(Double.self, forKey: .balance)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.balance, forKey: .balance)
    }

}
````

## File: Sources/ServicesProvider/Models/News.swift
````swift
//
//  News.swift
//  ServicesProvider
//
//  Created by Ruben Roques on 19/02/2025.
//

import Foundation

public struct News: Codable {
    public var id: Int
    public var title: String
    public var slug: String?
    public var image: String?
    public var content: String
    public var sportEventId: Int?
    public var status: String?
    public var startDate: Date?
    public var endDate: Date?
    public var userType: String?
    public var order: Int
    public var event: Event?
    
    enum CodingKeys: String, CodingKey {
        case id = "id"
        case title = "title"
        case slug = "slug"
        case image = "image"
        case content = "content"
        case sportEventId = "sport_event_id"
        case status = "status"
        case startDate = "start_date"
        case endDate = "end_date"
        case userType = "user_type"
        case order = "order"
        case event = "event"
    }
}
````

## File: Sources/ServicesProvider/Models/PromotedBetslips.swift
````swift
//
//  File.swift
//
//
//  Created by Ruben Roques on 01/08/2024.
//

import Foundation
import SharedModels

public struct PromotedBetslipsBatchResponse: Codable {
    public var promotedBetslips: [PromotedBetslip]
}

public struct PromotedBetslip: Codable {
    
    public var selections: [PromotedBetslipSelection]
    public var betslipCount: Int
    
    public init(selections: [PromotedBetslipSelection], betslipCount: Int) {
        self.selections = selections
        self.betslipCount = betslipCount
    }
    
}

public struct PromotedBetslipSelection: Codable {
    
    public var id: String
    public var country: Country?
    public var competitionName: String
    
    public var eventId: String
    public var marketId: String
    public var outcomeId: String
    
    public var marketName: String
    public var outcomeName: String?
        
    public var participantIds: [String]
    public var participants: [String]
    public var sport: SportType?
    public var odd: Double
  

    public var eventName: String {
        return (participants.first ?? "") + " x " + (participants.last ?? "")
    }
    
    init(id: String, countryName: String, competitionName: String, eventId: String, marketId: String, outcomeId: String, marketName: String, outcomeType: String, participantIds: [String], participants: [String], sport: SportType? = nil, odd: Double) {
        self.id = id
        self.competitionName = competitionName
        
        self.eventId = eventId
        self.marketId = marketId
        self.outcomeId = outcomeId
        
        self.marketName = marketName
        
        switch outcomeType.lowercased() {
        case "home":
            self.outcomeName = (participants.first ?? "")
        case "draw":
            self.outcomeName = "draw"
        case "away":
            self.outcomeName = (participants.last ?? "")
        default:
            self.outcomeName = "-"
        }
        
        self.participantIds = participantIds
        self.participants = participants
        self.sport = sport
        self.odd = odd
        
        self.country = Country.country(withName: countryName)
    }
 
    
}

extension PromotedBetslipsBatchResponse {
    static var dummyData: Data {
        let dummyString = """
                            {"data":[{"body":{"data":{"betslips":[{"betslip":[{"begin":"2024-08-08T17:00:00Z","bet_offer_id":null,"count":225,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:52117173","event_type":null,"league":"UEFA Europa League","league_id":"sr:tournament:679","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376682.1","orako_market_id":"59886737.1","orako_selection_id":"283875899.1","outcome":"home","outcome_id":1,"participant_ids":["sr:competitor:3051","sr:competitor:2055"],"participants":["Trabzonspor","SK Rapid"],"period":null,"period_id":null,"quote":1.83,"quote_group":"1.8-2.6","selection_id":"48805a6d6cb3953cfa30dc27965a528e","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/1"},{"begin":"2024-08-08T16:30:00Z","bet_offer_id":null,"count":125,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:52117069","event_type":null,"league":"UEFA Conference League","league_id":"sr:tournament:34480","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376560.1","orako_market_id":"59877201.1","orako_selection_id":"283834819.1","outcome":"away","outcome_id":3,"participant_ids":["sr:competitor:2397","sr:competitor:2036"],"participants":["MFK Ruzomberok","HNK Hajduk Split"],"period":null,"period_id":null,"quote":1.74,"quote_group":"1.4-1.8","selection_id":"e0a141b9bc122f5e0a2b3f7a6bc77ad4","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/3"},{"begin":"2024-08-08T18:45:00Z","bet_offer_id":null,"count":28,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:52117013","event_type":null,"league":"UEFA Conference League","league_id":"sr:tournament:34480","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376577.1","orako_market_id":"59878499.1","orako_selection_id":"283841760.1","outcome":"home","outcome_id":1,"participant_ids":["sr:competitor:3169","sr:competitor:382568"],"participants":["Saint Patrick´s Athletic FC","Sabah Masazir"],"period":null,"period_id":null,"quote":3.3,"quote_group":"2.6-4.2","selection_id":"180a66c41088ac8b42303bb41d6fa2f7","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/1"},{"begin":"2024-08-08T18:15:00Z","bet_offer_id":null,"count":81,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:52117009","event_type":null,"league":"UEFA Conference League","league_id":"sr:tournament:34480","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376562.1","orako_market_id":"59877203.1","orako_selection_id":"283834823.1","outcome":"home","outcome_id":1,"participant_ids":["sr:competitor:2420","sr:competitor:5150"],"participants":["NK Maribor","FK Vojvodina Novi Sad"],"period":null,"period_id":null,"quote":1.82,"quote_group":"1.8-2.6","selection_id":"6cfce48e6f784a4003f8c0c6c40495bf","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/1"},{"begin":"2024-08-08T18:00:00Z","bet_offer_id":null,"count":161,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:51795749","event_type":null,"league":"UEFA Europa League","league_id":"sr:tournament:679","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376684.1","orako_market_id":"59886768.1","orako_selection_id":"283875980.1","outcome":"away","outcome_id":3,"participant_ids":["sr:competitor:3320","sr:competitor:4502"],"participants":["FC Kryvbas Kriviy Rih","FC Viktoria Plzen"],"period":null,"period_id":null,"quote":1.59,"quote_group":"1.4-1.8","selection_id":"5b7e687e0c162113f369045ae9277a0c","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/3"}],"betslip_count":3}],"count":1},"status":"success"},"name":"multigame_acca_1","status_code":200},{"body":{"data":{"betslips":[{"betslip":[{"begin":"2024-08-08T17:00:00Z","bet_offer_id":null,"count":225,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:52117173","event_type":null,"league":"UEFA Europa League","league_id":"sr:tournament:679","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376682.1","orako_market_id":"59886737.1","orako_selection_id":"283875899.1","outcome":"home","outcome_id":1,"participant_ids":["sr:competitor:3051","sr:competitor:2055"],"participants":["Trabzonspor","SK Rapid"],"period":null,"period_id":null,"quote":1.83,"quote_group":"1.8-2.6","selection_id":"48805a6d6cb3953cfa30dc27965a528e","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/1"},{"begin":"2024-08-08T16:30:00Z","bet_offer_id":null,"count":125,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:52117069","event_type":null,"league":"UEFA Conference League","league_id":"sr:tournament:34480","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376560.1","orako_market_id":"59877201.1","orako_selection_id":"283834819.1","outcome":"away","outcome_id":3,"participant_ids":["sr:competitor:2397","sr:competitor:2036"],"participants":["MFK Ruzomberok","HNK Hajduk Split"],"period":null,"period_id":null,"quote":1.74,"quote_group":"1.4-1.8","selection_id":"e0a141b9bc122f5e0a2b3f7a6bc77ad4","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/3"},{"begin":"2024-08-08T18:45:00Z","bet_offer_id":null,"count":28,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:52117013","event_type":null,"league":"UEFA Conference League","league_id":"sr:tournament:34480","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376577.1","orako_market_id":"59878499.1","orako_selection_id":"283841760.1","outcome":"home","outcome_id":1,"participant_ids":["sr:competitor:3169","sr:competitor:382568"],"participants":["Saint Patrick´s Athletic FC","Sabah Masazir"],"period":null,"period_id":null,"quote":3.3,"quote_group":"2.6-4.2","selection_id":"180a66c41088ac8b42303bb41d6fa2f7","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/1"},{"begin":"2024-08-08T18:15:00Z","bet_offer_id":null,"count":81,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:52117009","event_type":null,"league":"UEFA Conference League","league_id":"sr:tournament:34480","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376562.1","orako_market_id":"59877203.1","orako_selection_id":"283834823.1","outcome":"home","outcome_id":1,"participant_ids":["sr:competitor:2420","sr:competitor:5150"],"participants":["NK Maribor","FK Vojvodina Novi Sad"],"period":null,"period_id":null,"quote":1.82,"quote_group":"1.8-2.6","selection_id":"6cfce48e6f784a4003f8c0c6c40495bf","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/1"},{"begin":"2024-08-08T18:00:00Z","bet_offer_id":null,"count":161,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:51795749","event_type":null,"league":"UEFA Europa League","league_id":"sr:tournament:679","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376684.1","orako_market_id":"59886768.1","orako_selection_id":"283875980.1","outcome":"away","outcome_id":3,"participant_ids":["sr:competitor:3320","sr:competitor:4502"],"participants":["FC Kryvbas Kriviy Rih","FC Viktoria Plzen"],"period":null,"period_id":null,"quote":1.59,"quote_group":"1.4-1.8","selection_id":"5b7e687e0c162113f369045ae9277a0c","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/3"}],"betslip_count":3}],"count":1},"status":"success"},"name":"multigame_acca_2","status_code":200},{"body":{"data":{"betslips":[{"betslip":[{"begin":"2024-08-08T17:00:00Z","bet_offer_id":null,"count":225,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:52117173","event_type":null,"league":"UEFA Europa League","league_id":"sr:tournament:679","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376682.1","orako_market_id":"59886737.1","orako_selection_id":"283875899.1","outcome":"home","outcome_id":1,"participant_ids":["sr:competitor:3051","sr:competitor:2055"],"participants":["Trabzonspor","SK Rapid"],"period":null,"period_id":null,"quote":1.83,"quote_group":"1.8-2.6","selection_id":"48805a6d6cb3953cfa30dc27965a528e","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/1"},{"begin":"2024-08-08T16:30:00Z","bet_offer_id":null,"count":125,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:52117069","event_type":null,"league":"UEFA Conference League","league_id":"sr:tournament:34480","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376560.1","orako_market_id":"59877201.1","orako_selection_id":"283834819.1","outcome":"away","outcome_id":3,"participant_ids":["sr:competitor:2397","sr:competitor:2036"],"participants":["MFK Ruzomberok","HNK Hajduk Split"],"period":null,"period_id":null,"quote":1.74,"quote_group":"1.4-1.8","selection_id":"e0a141b9bc122f5e0a2b3f7a6bc77ad4","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/3"},{"begin":"2024-08-08T18:45:00Z","bet_offer_id":null,"count":28,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:52117013","event_type":null,"league":"UEFA Conference League","league_id":"sr:tournament:34480","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376577.1","orako_market_id":"59878499.1","orako_selection_id":"283841760.1","outcome":"home","outcome_id":1,"participant_ids":["sr:competitor:3169","sr:competitor:382568"],"participants":["Saint Patrick´s Athletic FC","Sabah Masazir"],"period":null,"period_id":null,"quote":3.3,"quote_group":"2.6-4.2","selection_id":"180a66c41088ac8b42303bb41d6fa2f7","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/1"},{"begin":"2024-08-08T18:15:00Z","bet_offer_id":null,"count":81,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:52117009","event_type":null,"league":"UEFA Conference League","league_id":"sr:tournament:34480","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376562.1","orako_market_id":"59877203.1","orako_selection_id":"283834823.1","outcome":"home","outcome_id":1,"participant_ids":["sr:competitor:2420","sr:competitor:5150"],"participants":["NK Maribor","FK Vojvodina Novi Sad"],"period":null,"period_id":null,"quote":1.82,"quote_group":"1.8-2.6","selection_id":"6cfce48e6f784a4003f8c0c6c40495bf","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/1"},{"begin":"2024-08-08T18:00:00Z","bet_offer_id":null,"count":161,"country":"International Clubs","country_id":"sr:category:393","event_id":"sr:match:51795749","event_type":null,"league":"UEFA Europa League","league_id":"sr:tournament:679","market":null,"market_id":null,"market_type":"1x2","market_type_id":1,"orako_event_id":"3376684.1","orako_market_id":"59886768.1","orako_selection_id":"283875980.1","outcome":"away","outcome_id":3,"participant_ids":["sr:competitor:3320","sr:competitor:4502"],"participants":["FC Kryvbas Kriviy Rih","FC Viktoria Plzen"],"period":null,"period_id":null,"quote":1.59,"quote_group":"1.4-1.8","selection_id":"5b7e687e0c162113f369045ae9277a0c","sport":"Soccer","sport_id":"sr:sport:1","status":"not_started","uof_external_id":"uof:3/sr:sport:1/1/3"}],"betslip_count":3}],"count":1},"status":"success"},"name":"multigame_acca_3","status_code":200}],"status":"success"}
                    """
        
        return dummyString.data(using: .utf8)!
    }
}
````

## File: Sources/ServicesProvider/Models/SportType.swift
````swift
//
//  SportType.swift
//  
//
//  Created by Ruben Roques on 10/10/2022.
//

import Foundation

public struct SportType: Codable, Equatable, Hashable {

    public var name: String
    public var numericId: String?
    public var alphaId: String?
    public var iconId: String?
    public var showEventCategory: Bool
    public var numberEvents: Int
    public var numberOutrightEvents: Int
    public var numberOutrightMarkets: Int
    public var numberLiveEvents: Int

    public init(name: String,
                numericId: String?,
                alphaId: String?,
                iconId: String?,
                showEventCategory: Bool,
                numberEvents: Int,
                numberOutrightEvents: Int,
                numberOutrightMarkets: Int,
                numberLiveEvents: Int) {
        self.name = name
        self.numericId = numericId
        self.alphaId = alphaId
        self.iconId = iconId
        self.showEventCategory = showEventCategory
        self.numberEvents = numberEvents
        self.numberOutrightEvents = numberOutrightEvents
        self.numberOutrightMarkets = numberOutrightMarkets
        self.numberLiveEvents = numberLiveEvents
    }
    
    public init(name: String) {
        self.name = name
        self.numericId = nil
        self.alphaId = nil
        self.iconId = nil
        self.showEventCategory = false
        self.numberEvents = 0
        self.numberOutrightEvents = 0
        self.numberOutrightMarkets = 0
        self.numberLiveEvents = 0
    }
}

// TODO: TASK André - Este devia ser o unico modelo publico

enum SportTypeInfo: CaseIterable {

    case football
    case golf
    case tennis
    case americanFootball
    case iceHockey
    case handball
    case basketball
    case baseball
    case fieldHockey
    case softball
    case weightlifting
    case athletics
    case badminton
    case gymnastics
    case rowing
    case sailing
    case swimming
    case triathlon
    case volleyball
    case wintersports
    case waterPolo
    case motorRacing
    case horseRacing
    case fighting
    case cricket
    case greyhounds
    case rugbyLeague
    case specials
    case snooker
    case cycling
    case afl
    case rugbyUnion
    case bandy
    case floorball
    case darts
    case hurling
    case gaelicFootball
    case pool
    case futsal
    case surfing
    case poker
    case chess
    case alpineSkiing
    case crossCountrySkiing
    case freestyleSkiing
    case nordicCombined
    case skiJumping
    case snowboard
    case biathlon
    case curling
    case bobsleigh
    case lacrosse
    case tableTennis
    case beachVolleyball
    case canoeing
    case beachFootball
    case bowls
    case luge
    case figureSkating
    case skeleton
    case speedSkating
    case shortTrackSpeedSkating
    case netball
    case harnessRacing
    case fencing
    case squash
    case horseball
    case judo
    case petanque
    case basquePelota
    case diving
    case equestrianSports
    case virtualSports
    case sepakTakraw
    case archery
    case virtualFootball
    case virtualHorseRacing
    case virtualGreyhounds
    case pesapallo
    case eSportsOld
    case virtualTennis
    case virtualBasketball
    case fantasyDuels
    case eSports
    case csGo
    case dota2
    case leagueOfLegends
    case priceBoost
    case bowling
    case hearthstone
    case heroesOfTheStorm
    case kingOfGlory
    case nba2K
    case overwatch
    case rocketLeague
    case starcraftBroodwar
    case starcraft2
    case newSignUp1StBetBoost
    case rainbowSix
    case virtualESports
    case artifact
    case accas
    case warcraft3
    case smash
    case fifa
    case callOfDuty
    case smite
    case magicTheGathering
    case fortnite
    case pubg
    case financials
    case eTennis
    case eIceHockey
    case eFighting
    case eMotorSports
    case eVolleyball
    case valorant
    case virtualMortalKombat
    case virtualCsGo
    case virtualRocketLeague
    case virtualStreetFighter
    case virtualNba2K
    case footballSimulated
    case tennisSimulated
    case virtualCallOfDuty
    case virtualUfc
    case virtualPubg
    case virtualInjustice
    case boatRacing
    case sumo
    case competitiveEating
    case droneRacing
    case japaneseHandicap
    case modernPentathlon
    case shooting
    case skateboarding
    case sportClimbing
    case kabaddi
    case virtualBasketballSuperHoops
    case virtualBasketballFinalHoops
    case virtualIceHockey
    case virtualDashingDerby
    case virtualHarnessRacing
    case virtualHorsesEqual
    case virtualSteepleChaseRacing
    case virtualPlatinumHounds
    case virtualMotorRacing
    case virtualTableTennis
    case virtualBadminton
    case virtualArchery
    case virtualCycling
    case virtualSpeedSkating
    case virtualHockeyShots
    //
    case gaelicHurling
    case gaelicSports
    case rinkHockey
    case dogRacing
    case basketball3X3
    case worldOfTanks
    case olympics
    case synchronizedSwimming
    case trotting
    //
    case canoeSlalom
    case cyclingBmxFreestyle
    case cyclingBmxRacing
    case mountainBike
    case trackCycling
    case trampolineGymnastics
    case rhythmicGymnastics
    case marathonSwimming
    //
    case boxing
    case taekwondo
    case karate
    case wrestling
    case mma
    //
    case stockCarRacing
    case touringCarRacing
    case rally
    case speedway
    case formulaE
    case indyRacing
    case motorcycleRacing
    case formula1
    //
    case numbers
    case emptyBets
    case lotteries

    //
    case esportscounterstrikego
    case mmaFighting
    case counterStrike
    case aussieRules

    public init?(id: String) {
        switch id {
        // Initial list from EveryMatrix
        case "1": self = .football
        case "2": self = .golf
        case "3": self = .tennis
        case "5": self = .americanFootball
        case "6": self = .iceHockey
        case "7": self = .handball
        case "8": self = .basketball
        case "9": self = .baseball
        case "10": self = .fieldHockey
        case "11": self = .softball
        case "12": self = .weightlifting
        case "13": self = .athletics
        case "14": self = .badminton
        case "15": self = .gymnastics
        case "16": self = .rowing
        case "17": self = .sailing
        case "18": self = .swimming
        case "19": self = .triathlon
        case "20": self = .volleyball
        case "21": self = .wintersports
        case "22": self = .waterPolo
        case "23": self = .motorRacing
        case "24": self = .horseRacing
        case "25": self = .fighting
        case "26": self = .cricket
        case "27": self = .greyhounds
        case "28": self = .rugbyLeague
        case "34": self = .specials
        case "36": self = .snooker
        case "37": self = .cycling
        case "38": self = .afl
        case "39": self = .rugbyUnion
        case "40": self = .bandy
        case "41": self = .floorball
        case "45": self = .darts
        case "46": self = .hurling
        case "47": self = .gaelicFootball
        case "48": self = .pool
        case "49": self = .futsal
        case "50": self = .surfing
        case "51": self = .poker
        case "52": self = .chess
        case "53": self = .alpineSkiing
        case "54": self = .crossCountrySkiing
        case "55": self = .freestyleSkiing
        case "56": self = .nordicCombined
        case "57": self = .skiJumping
        case "58": self = .snowboard
        case "59": self = .biathlon
        case "60": self = .curling
        case "61": self = .bobsleigh
        case "62": self = .lacrosse
        case "63": self = .tableTennis
        case "64": self = .beachVolleyball
        case "65": self = .canoeing
        case "66": self = .beachFootball
        case "67": self = .bowls
        case "68": self = .luge
        case "69": self = .figureSkating
        case "70": self = .skeleton
        case "71": self = .speedSkating
        case "72": self = .shortTrackSpeedSkating
        case "73": self = .netball
        case "74": self = .harnessRacing
        case "75": self = .fencing
        case "76": self = .squash
        case "77": self = .horseball
        case "78": self = .judo
        case "79": self = .petanque
        case "80": self = .basquePelota
        case "81": self = .diving
        case "82": self = .equestrianSports
        case "83": self = .virtualSports
        case "84": self = .sepakTakraw
        case "85": self = .archery
        case "86": self = .virtualFootball
        case "87": self = .virtualHorseRacing
        case "88": self = .virtualGreyhounds
        case "89": self = .pesapallo
        case "90": self = .eSportsOld
        case "91": self = .virtualTennis
        case "92": self = .virtualBasketball
        case "93": self = .fantasyDuels
        case "96": self = .eSports
        case "98": self = .csGo
        case "99": self = .dota2
        case "100": self = .leagueOfLegends
        case "101": self = .priceBoost
        case "102": self = .bowling
        case "103": self = .hearthstone
        case "104": self = .heroesOfTheStorm
        case "105": self = .kingOfGlory
        case "106": self = .nba2K
        case "107": self = .overwatch
        case "108": self = .rocketLeague
        case "109": self = .starcraftBroodwar
        case "110": self = .starcraft2
        case "111": self = .newSignUp1StBetBoost
        case "112": self = .rainbowSix
        case "113": self = .virtualESports
        case "115": self = .artifact
        case "116": self = .accas
        case "117": self = .warcraft3
        case "120": self = .smash
        case "121": self = .fifa
        case "122": self = .callOfDuty
        case "123": self = .smite
        case "124": self = .magicTheGathering
        case "125": self = .fortnite
        case "126": self = .pubg
        case "127": self = .financials
        case "128": self = .eTennis
        case "129": self = .eIceHockey
        case "130": self = .eFighting
        case "131": self = .eMotorSports
        case "133": self = .eVolleyball
        case "134": self = .valorant
        case "135": self = .virtualMortalKombat
        case "136": self = .virtualCsGo
        case "137": self = .virtualRocketLeague
        case "138": self = .virtualStreetFighter
        case "139": self = .virtualNba2K
        case "140": self = .footballSimulated
        case "141": self = .tennisSimulated
        case "142": self = .virtualCallOfDuty
        case "143": self = .virtualUfc
        case "144": self = .virtualPubg
        case "145": self = .virtualInjustice
        case "146": self = .boatRacing
        case "147": self = .sumo
        case "148": self = .competitiveEating
        case "149": self = .droneRacing
        case "150": self = .japaneseHandicap
        case "151": self = .modernPentathlon
        case "152": self = .shooting
        case "153": self = .skateboarding
        case "154": self = .sportClimbing
        case "155": self = .kabaddi
        case "156": self = .virtualBasketballSuperHoops
        case "157": self = .virtualBasketballFinalHoops
        case "158": self = .virtualIceHockey
        case "159": self = .virtualDashingDerby
        case "160": self = .virtualHarnessRacing
        case "161": self = .virtualHorsesEqual
        case "162": self = .virtualSteepleChaseRacing
        case "163": self = .virtualPlatinumHounds
        case "164": self = .virtualMotorRacing
        case "165": self = .virtualTableTennis
        case "166": self = .virtualBadminton
        case "167": self = .virtualArchery
        case "168": self = .virtualCycling
        case "169": self = .virtualSpeedSkating
        case "170": self = .virtualHockeyShots
        //
        // Aditional sports from SportRadar
        case "900": self = .gaelicHurling
        case "901": self = .gaelicSports
        case "902": self = .rinkHockey
        case "903": self = .dogRacing
        case "904": self = .basketball3X3
        case "905": self = .worldOfTanks
        case "906": self = .olympics
        case "907": self = .synchronizedSwimming
        case "908": self = .trotting
        case "909": self = .canoeSlalom
        case "910": self = .cyclingBmxFreestyle
        case "911": self = .cyclingBmxRacing
        case "912": self = .mountainBike
        case "913": self = .trackCycling
        case "914": self = .trampolineGymnastics
        case "915": self = .rhythmicGymnastics
        case "916": self = .marathonSwimming
        case "917": self = .boxing
        case "918": self = .taekwondo
        case "919": self = .karate
        case "920": self = .wrestling
        case "921": self = .mma
        case "922": self = .stockCarRacing
        case "923": self = .touringCarRacing
        case "924": self = .rally
        case "925": self = .speedway
        case "926": self = .formulaE
        case "927": self = .indyRacing
        case "928": self = .motorcycleRacing
        case "929": self = .formula1
        case "930": self = .numbers
        case "931": self = .emptyBets
        case "932": self = .lotteries
        case "982": self = .counterStrike
        case "983": self = .aussieRules
        default: return nil
        }
    }

    public init?(alphaCode: String) {
        switch alphaCode {
        // Initial list from EveryMatrix
        case "FBL": self = .football
        case "GLF": self = .golf
        case "TNS": self = .tennis
        case "UFB": self = .americanFootball
        case "HKY": self = .iceHockey
        case "HBL": self = .handball
        case "BKB": self = .basketball
        case "BSB": self = .baseball
        case "10": self = .fieldHockey
        case "11": self = .softball
        case "12": self = .weightlifting
        case "ATL": self = .athletics
        case "BAD": self = .badminton
        case "15": self = .gymnastics
        case "16": self = .rowing
        case "17": self = .sailing
        case "18": self = .swimming
        case "19": self = .triathlon
        case "VBL": self = .volleyball
        case "21": self = .wintersports
        case "WAT": self = .waterPolo
        case "23": self = .motorRacing
        case "HRR": self = .horseRacing
        case "25": self = .fighting
        case "CRK": self = .cricket
        case "DGR": self = .greyhounds
        case "RBL": self = .rugbyLeague
        case "34": self = .specials
        case "SNK": self = .snooker
        case "CYC": self = .cycling
        case "38": self = .afl
        case "RBU": self = .rugbyUnion
        case "40": self = .bandy
        case "FLR": self = .floorball
        case "DAR": self = .darts
        case "46": self = .hurling
        case "GAF": self = .gaelicFootball
        case "48": self = .pool
        case "FSL": self = .futsal
        case "50": self = .surfing
        case "51": self = .poker
        case "52": self = .chess
        case "WAS": self = .alpineSkiing
        case "54": self = .crossCountrySkiing
        case "55": self = .freestyleSkiing
        case "56": self = .nordicCombined
        case "WSJ": self = .skiJumping
        case "58": self = .snowboard
        case "WBI": self = .biathlon
        case "60": self = .curling
        case "61": self = .bobsleigh
        case "LAC": self = .lacrosse
        case "TBT": self = .tableTennis
        case "BVB": self = .beachVolleyball
        case "65": self = .canoeing
        case "66": self = .beachFootball
        case "67": self = .bowls
        case "68": self = .luge
        case "69": self = .figureSkating
        case "70": self = .skeleton
        case "71": self = .speedSkating
        case "72": self = .shortTrackSpeedSkating
        case "73": self = .netball
        case "74": self = .harnessRacing
        case "75": self = .fencing
        case "76": self = .squash
        case "77": self = .horseball
        case "78": self = .judo
        case "79": self = .petanque
        case "80": self = .basquePelota
        case "81": self = .diving
        case "82": self = .equestrianSports
        case "83": self = .virtualSports
        case "84": self = .sepakTakraw
        case "85": self = .archery
        case "86": self = .virtualFootball
        case "87": self = .virtualHorseRacing
        case "88": self = .virtualGreyhounds
        case "89": self = .pesapallo
        case "90": self = .eSportsOld
        case "91": self = .virtualTennis
        case "92": self = .virtualBasketball
        case "93": self = .fantasyDuels
        case "96": self = .eSports
        case "98": self = .csGo
        case "99": self = .dota2
        case "LOL": self = .leagueOfLegends
        case "101": self = .priceBoost
        case "102": self = .bowling
        case "103": self = .hearthstone
        case "104": self = .heroesOfTheStorm
        case "105": self = .kingOfGlory
        case "106": self = .nba2K
        case "107": self = .overwatch
        case "108": self = .rocketLeague
        case "109": self = .starcraftBroodwar
        case "110": self = .starcraft2
        case "111": self = .newSignUp1StBetBoost
        case "112": self = .rainbowSix
        case "113": self = .virtualESports
        case "115": self = .artifact
        case "116": self = .accas
        case "117": self = .warcraft3
        case "120": self = .smash
        case "121": self = .fifa
        case "122": self = .callOfDuty
        case "123": self = .smite
        case "124": self = .magicTheGathering
        case "125": self = .fortnite
        case "126": self = .pubg
        case "127": self = .financials
        case "128": self = .eTennis
        case "129": self = .eIceHockey
        case "130": self = .eFighting
        case "131": self = .eMotorSports
        case "133": self = .eVolleyball
        case "134": self = .valorant
        case "135": self = .virtualMortalKombat
        case "136": self = .virtualCsGo
        case "137": self = .virtualRocketLeague
        case "138": self = .virtualStreetFighter
        case "139": self = .virtualNba2K
        case "140": self = .footballSimulated
        case "141": self = .tennisSimulated
        case "142": self = .virtualCallOfDuty
        case "143": self = .virtualUfc
        case "144": self = .virtualPubg
        case "145": self = .virtualInjustice
        case "146": self = .boatRacing
        case "147": self = .sumo
        case "148": self = .competitiveEating
        case "149": self = .droneRacing
        case "150": self = .japaneseHandicap
        case "151": self = .modernPentathlon
        case "152": self = .shooting
        case "153": self = .skateboarding
        case "154": self = .sportClimbing
        case "155": self = .kabaddi
        case "156": self = .virtualBasketballSuperHoops
        case "157": self = .virtualBasketballFinalHoops
        case "158": self = .virtualIceHockey
        case "159": self = .virtualDashingDerby
        case "160": self = .virtualHarnessRacing
        case "161": self = .virtualHorsesEqual
        case "162": self = .virtualSteepleChaseRacing
        case "163": self = .virtualPlatinumHounds
        case "164": self = .virtualMotorRacing
        case "165": self = .virtualTableTennis
        case "166": self = .virtualBadminton
        case "167": self = .virtualArchery
        case "168": self = .virtualCycling
        case "169": self = .virtualSpeedSkating
        case "170": self = .virtualHockeyShots
        //
        // Aditional sports from SportRadar
        case "GAH": self = .gaelicHurling
        case "901": self = .gaelicSports
        case "902": self = .rinkHockey
        case "903": self = .dogRacing
        case "904": self = .basketball3X3
        case "905": self = .worldOfTanks
        case "906": self = .olympics
        case "907": self = .synchronizedSwimming
        case "908": self = .trotting
        case "909": self = .canoeSlalom
        case "910": self = .cyclingBmxFreestyle
        case "911": self = .cyclingBmxRacing
        case "912": self = .mountainBike
        case "913": self = .trackCycling
        case "914": self = .trampolineGymnastics
        case "915": self = .rhythmicGymnastics
        case "916": self = .marathonSwimming
        case "BOX": self = .boxing
        case "918": self = .taekwondo
        case "919": self = .karate
        case "920": self = .wrestling
        case "MMA": self = .mma
        case "SCR": self = .stockCarRacing
        case "923": self = .touringCarRacing
        case "RLL": self = .rally
        case "SPW": self = .speedway
        case "FOE": self = .formulaE
        case "IRC": self = .indyRacing
        case "MCR": self = .motorcycleRacing
        case "FO1": self = .formula1
        case "930": self = .numbers
        case "931": self = .emptyBets
        case "932": self = .lotteries
        case "AFL": self = .aussieRules
        case "CST": self = .counterStrike
        default: return nil
        }
    }
    
    public var id: String {
        switch self {
        case .football: return "1"
        case .golf: return "2"
        case .tennis: return "3"
        case .americanFootball: return "5"
        case .iceHockey: return "6"
        case .handball: return "7"
        case .basketball: return "8"
        case .baseball: return "9"
        case .fieldHockey: return "10"
        case .softball: return "11"
        case .weightlifting: return "12"
        case .athletics: return "13"
        case .badminton: return "14"
        case .gymnastics: return "15"
        case .rowing: return "16"
        case .sailing: return "17"
        case .swimming: return "18"
        case .triathlon: return "19"
        case .volleyball: return "20"
        case .wintersports: return "21"
        case .waterPolo: return "22"
        case .motorRacing: return "23"
        case .horseRacing: return "24"
        case .fighting: return "25"
        case .cricket: return "26"
        case .greyhounds: return "27"
        case .rugbyLeague: return "28"
        case .specials: return "34"
        case .snooker: return "36"
        case .cycling: return "37"
        case .afl: return "38"
        case .rugbyUnion: return "39"
        case .bandy: return "40"
        case .floorball: return "41"
        case .darts: return "45"
        case .hurling: return "46"
        case .gaelicFootball: return "47"
        case .pool: return "48"
        case .futsal: return "49"
        case .surfing: return "50"
        case .poker: return "51"
        case .chess: return "52"
        case .alpineSkiing: return "53"
        case .crossCountrySkiing: return "54"
        case .freestyleSkiing: return "55"
        case .nordicCombined: return "56"
        case .skiJumping: return "57"
        case .snowboard: return "58"
        case .biathlon: return "59"
        case .curling: return "60"
        case .bobsleigh: return "61"
        case .lacrosse: return "62"
        case .tableTennis: return "63"
        case .beachVolleyball: return "64"
        case .canoeing: return "65"
        case .beachFootball: return "66"
        case .bowls: return "67"
        case .luge: return "68"
        case .figureSkating: return "69"
        case .skeleton: return "70"
        case .speedSkating: return "71"
        case .shortTrackSpeedSkating: return "72"
        case .netball: return "73"
        case .harnessRacing: return "74"
        case .fencing: return "75"
        case .squash: return "76"
        case .horseball: return "77"
        case .judo: return "78"
        case .petanque: return "79"
        case .basquePelota: return "80"
        case .diving: return "81"
        case .equestrianSports: return "82"
        case .virtualSports: return "83"
        case .sepakTakraw: return "84"
        case .archery: return "85"
        case .virtualFootball: return "86"
        case .virtualHorseRacing: return "87"
        case .virtualGreyhounds: return "88"
        case .pesapallo: return "89"
        case .eSportsOld: return "90"
        case .virtualTennis: return "91"
        case .virtualBasketball: return "92"
        case .fantasyDuels: return "93"
        case .eSports: return "96"
        case .csGo: return "98"
        case .dota2: return "99"
        case .leagueOfLegends: return "100"
        case .priceBoost: return "101"
        case .bowling: return "102"
        case .hearthstone: return "103"
        case .heroesOfTheStorm: return "104"
        case .kingOfGlory: return "105"
        case .nba2K: return "106"
        case .overwatch: return "107"
        case .rocketLeague: return "108"
        case .starcraftBroodwar: return "109"
        case .starcraft2: return "110"
        case .newSignUp1StBetBoost: return "111"
        case .rainbowSix: return "112"
        case .virtualESports: return "113"
        case .artifact: return "115"
        case .accas: return "116"
        case .warcraft3: return "117"
        case .smash: return "120"
        case .fifa: return "121"
        case .callOfDuty: return "122"
        case .smite: return "123"
        case .magicTheGathering: return "124"
        case .fortnite: return "125"
        case .pubg: return "126"
        case .financials: return "127"
        case .eTennis: return "128"
        case .eIceHockey: return "129"
        case .eFighting: return "130"
        case .eMotorSports: return "131"
        case .eVolleyball: return "133"
        case .valorant: return "134"
        case .virtualMortalKombat: return "135"
        case .virtualCsGo: return "136"
        case .virtualRocketLeague: return "137"
        case .virtualStreetFighter: return "138"
        case .virtualNba2K: return "139"
        case .footballSimulated: return "140"
        case .tennisSimulated: return "141"
        case .virtualCallOfDuty: return "142"
        case .virtualUfc: return "143"
        case .virtualPubg: return "144"
        case .virtualInjustice: return "145"
        case .boatRacing: return "146"
        case .sumo: return "147"
        case .competitiveEating: return "148"
        case .droneRacing: return "149"
        case .japaneseHandicap: return "150"
        case .modernPentathlon: return "151"
        case .shooting: return "152"
        case .skateboarding: return "153"
        case .sportClimbing: return "154"
        case .kabaddi: return "155"
        case .virtualBasketballSuperHoops: return "156"
        case .virtualBasketballFinalHoops: return "157"
        case .virtualIceHockey: return "158"
        case .virtualDashingDerby: return "159"
        case .virtualHarnessRacing: return "160"
        case .virtualHorsesEqual: return "161"
        case .virtualSteepleChaseRacing: return "162"
        case .virtualPlatinumHounds: return "163"
        case .virtualMotorRacing: return "164"
        case .virtualTableTennis: return "165"
        case .virtualBadminton: return "166"
        case .virtualArchery: return "167"
        case .virtualCycling: return "168"
        case .virtualSpeedSkating: return "169"
        case .virtualHockeyShots: return "170"
            //
        case .gaelicHurling: return "900"
        case .gaelicSports: return "901"
        case .rinkHockey: return "902"
        case .dogRacing: return "903"
        case .basketball3X3: return "904"
        case .worldOfTanks: return "905"
        case .olympics: return "906"
        case .synchronizedSwimming: return "907"
        case .trotting: return "908"
        case .canoeSlalom: return "909"
        case .cyclingBmxFreestyle: return "910"
        case .cyclingBmxRacing: return "911"
        case .mountainBike: return "912"
        case .trackCycling: return "913"
        case .trampolineGymnastics: return "914"
        case .rhythmicGymnastics: return "915"
        case .marathonSwimming: return "916"
        case .boxing: return "917"
        case .taekwondo: return "918"
        case .karate: return "919"
        case .wrestling: return "920"
        case .mma: return "921"
        case .stockCarRacing: return "922"
        case .touringCarRacing: return "923"
        case .rally: return "924"
        case .speedway: return "925"
        case .formulaE: return "926"
        case .indyRacing: return "927"
        case .motorcycleRacing: return "928"
        case .formula1: return "929"
        case .numbers: return "930"
        case .emptyBets: return "931"
        case .lotteries: return "932"

        case .esportscounterstrikego: return "980"
        case .mmaFighting: return "981"
        case .counterStrike: return "982"
        case .aussieRules: return "983"
        }
    }
    
    public var name: String {
        switch self {
        case .football: return "Football"
        case .golf: return "Golf"
        case .tennis: return "Tennis"
        case .americanFootball: return "American Football"
        case .iceHockey: return "Ice Hockey"
        case .handball: return "Handball"
        case .basketball: return "Basketball"
        case .baseball: return "Baseball"
        case .fieldHockey: return "Field Hockey"
        case .softball: return "Softball"
        case .weightlifting: return "Weightlifting"
        case .athletics: return "Athletics"
        case .badminton: return "Badminton"
        case .gymnastics: return "Gymnastics"
        case .rowing: return "Rowing"
        case .sailing: return "Sailing"
        case .swimming: return "Swimming"
        case .triathlon: return "Triathlon"
        case .volleyball: return "Volleyball"
        case .wintersports: return "Wintersports"
        case .waterPolo: return "Water Polo"
        case .motorRacing: return "Motor Racing"
        case .horseRacing: return "Horse Racing"
        case .fighting: return "Fighting"
        case .cricket: return "Cricket"
        case .greyhounds: return "Greyhounds"
        case .rugbyLeague: return "Rugby League"
        case .specials: return "Specials"
        case .snooker: return "Snooker"
        case .cycling: return "Cycling"
        case .afl: return "AFL"
        case .rugbyUnion: return "Rugby Union"
        case .bandy: return "Bandy"
        case .floorball: return "Floorball"
        case .darts: return "Darts"
        case .hurling: return "Hurling"
        case .gaelicFootball: return "Gaelic Football"
        case .pool: return "Pool"
        case .futsal: return "Futsal"
        case .surfing: return "Surfing"
        case .poker: return "Poker"
        case .chess: return "Chess"
        case .alpineSkiing: return "Alpine Skiing"
        case .crossCountrySkiing: return "Cross Country Skiing"
        case .freestyleSkiing: return "Freestyle Skiing"
        case .nordicCombined: return "Nordic Combined"
        case .skiJumping: return "Ski Jumping"
        case .snowboard: return "Snowboard"
        case .biathlon: return "Biathlon"
        case .curling: return "Curling"
        case .bobsleigh: return "Bobsleigh"
        case .lacrosse: return "Lacrosse"
        case .tableTennis: return "Table Tennis"
        case .beachVolleyball: return "Beach Volleyball"
        case .canoeing: return "Canoeing"
        case .beachFootball: return "Beach Football"
        case .bowls: return "Bowls"
        case .luge: return "Luge"
        case .figureSkating: return "Figure Skating"
        case .skeleton: return "Skeleton"
        case .speedSkating: return "Speed Skating"
        case .shortTrackSpeedSkating: return "Short Track Speed Skating"
        case .netball: return "Netball"
        case .harnessRacing: return "Harness Racing"
        case .fencing: return "Fencing"
        case .squash: return "Squash"
        case .horseball: return "Horseball"
        case .judo: return "Judo"
        case .petanque: return "Petanque"
        case .basquePelota: return "Basque Pelota"
        case .diving: return "Diving"
        case .equestrianSports: return "Equestrian Sports"
        case .virtualSports: return "Virtual Sports"
        case .sepakTakraw: return "Sepak takraw"
        case .archery: return "Archery"
        case .virtualFootball: return "Virtual Football"
        case .virtualHorseRacing: return "Virtual Horse Racing"
        case .virtualGreyhounds: return "Virtual Greyhounds"
        case .pesapallo: return "Pesapallo"
        case .eSportsOld: return "E-Sports (old)"
        case .virtualTennis: return "Virtual Tennis"
        case .virtualBasketball: return "Virtual Basketball"
        case .fantasyDuels: return "Fantasy Duels"
        case .eSports: return "eSports"
        case .csGo: return "CS:GO"
        case .dota2: return "DOTA 2"
        case .leagueOfLegends: return "League of Legends"
        case .priceBoost: return "Price boost"
        case .bowling: return "Bowling"
        case .hearthstone: return "Hearthstone"
        case .heroesOfTheStorm: return "Heroes Of The Storm"
        case .kingOfGlory: return "King Of Glory"
        case .nba2K: return "NBA2k"
        case .overwatch: return "Overwatch"
        case .rocketLeague: return "Rocket League"
        case .starcraftBroodwar: return "Starcraft Broodwar"
        case .starcraft2: return "Starcraft 2"
        case .newSignUp1StBetBoost: return "New Sign-up 1st Bet Boost"
        case .rainbowSix: return "Rainbow Six"
        case .virtualESports: return "Virtual eSports"
        case .artifact: return "Artifact"
        case .accas: return "Accas"
        case .warcraft3: return "Warcraft III"
        case .smash: return "Smash"
        case .fifa: return "FIFA"
        case .callOfDuty: return "Call of Duty"
        case .smite: return "Smite"
        case .magicTheGathering: return "Magic The Gathering"
        case .fortnite: return "Fortnite"
        case .pubg: return "PUBG"
        case .financials: return "Financials"
        case .eTennis: return "e-Tennis"
        case .eIceHockey: return "e-Ice Hockey"
        case .eFighting: return "e-Fighting"
        case .eMotorSports: return "e-Motor Sports"
        case .eVolleyball: return "e-Volleyball"
        case .valorant: return "Valorant"
        case .virtualMortalKombat: return "Virtual Mortal Kombat"
        case .virtualCsGo: return "Virtual CS:GO"
        case .virtualRocketLeague: return "Virtual Rocket League"
        case .virtualStreetFighter: return "Virtual Street Fighter"
        case .virtualNba2K: return "Virtual NBA2k"
        case .footballSimulated: return "Football – Simulated"
        case .tennisSimulated: return "Tennis – Simulated"
        case .virtualCallOfDuty: return "Virtual Call of Duty"
        case .virtualUfc: return "Virtual UFC"
        case .virtualPubg: return "Virtual PUBG"
        case .virtualInjustice: return "Virtual Injustice"
        case .boatRacing: return "Boat Racing"
        case .sumo: return "Sumo"
        case .competitiveEating: return "Competitive Eating"
        case .droneRacing: return "Drone Racing"
        case .japaneseHandicap: return "Japanese Handicap"
        case .modernPentathlon: return "Modern Pentathlon"
        case .shooting: return "Shooting"
        case .skateboarding: return "Skateboarding"
        case .sportClimbing: return "Sport Climbing"
        case .kabaddi: return "Kabaddi"
        case .virtualBasketballSuperHoops: return "Virtual Basketball - Super Hoops"
        case .virtualBasketballFinalHoops: return "Virtual Basketball - Final Hoops"
        case .virtualIceHockey: return "Virtual Ice Hockey"
        case .virtualDashingDerby: return "Virtual Dashing Derby"
        case .virtualHarnessRacing: return "Virtual Harness Racing"
        case .virtualHorsesEqual: return "Virtual Horses Equal"
        case .virtualSteepleChaseRacing: return "Virtual Steeple Chase Racing"
        case .virtualPlatinumHounds: return "Virtual Platinum Hounds"
        case .virtualMotorRacing: return "Virtual Motor Racing"
        case .virtualTableTennis: return "Virtual Table Tennis"
        case .virtualBadminton: return "Virtual Badminton"
        case .virtualArchery: return "Virtual Archery"
        case .virtualCycling: return "Virtual Cycling"
        case .virtualSpeedSkating: return "Virtual Speed Skating"
        case .virtualHockeyShots: return "Virtual Hockey Shots"
        //
        case .gaelicHurling: return "Gaelic Hurling"
        case .gaelicSports: return "Gaelic Sports"
        case .rinkHockey: return "Rink Hockey"
        case .dogRacing: return "Dog Racing"
        case .basketball3X3: return "Basketball 3X3"
        case .worldOfTanks: return "World Of Tanks"
        case .olympics: return "Olympics"
        case .synchronizedSwimming: return "SynchronizedSwimming"
        case .trotting: return "Trotting"
        case .canoeSlalom: return "CanoeSlalom"
        case .cyclingBmxFreestyle: return "Cycling BMX Freestyle"
        case .cyclingBmxRacing: return "Cycling BMX Racing"
        case .mountainBike: return "Mountain Bike"
        case .trackCycling: return "Track Cycling"
        case .trampolineGymnastics: return "Trampoline Gymnastics"
        case .rhythmicGymnastics: return "Rhythmic Gymnastics"
        case .marathonSwimming: return "Marathon Swimming"
        case .boxing: return "Boxing"
        case .taekwondo: return "Taekwondo"
        case .karate: return "Karate"
        case .wrestling: return "Wrestling"
        case .mma: return "MMA"
        case .stockCarRacing: return "Stock Car Racing"
        case .touringCarRacing: return "Touring Car Racing"
        case .rally: return "Rally"
        case .speedway: return "Speedway"
        case .formulaE: return "Formula E"
        case .indyRacing: return "Indy Racing"
        case .motorcycleRacing: return "Motorcycle Racing"
        case .formula1: return "Formula 1"
        case .numbers: return "Numbers"
        case .emptyBets: return "Empty Bets"
        case .lotteries: return "Lotteries"
        case .esportscounterstrikego: return "eSports - Counter Strike GO"
        case .mmaFighting: return "MMA Fighting"
        case .counterStrike: return "Counter-Strike"
        case .aussieRules: return "Aussie Rules"
        }
    }
}
````

## File: Sources/ServicesProvider/Models/SubscribableContent.swift
````swift
//
//  SubscribableContent.swift
//  
//
//  Created by Ruben Roques on 11/10/2022.
//

import Foundation

public enum SubscribableContent<T> {
    case connected(subscription: Subscription)
    case contentUpdate(content: T)
    case disconnected
}

extension SubscribableContent: Equatable where T: Equatable {
    public static func == (lhs: SubscribableContent<T>, rhs: SubscribableContent<T>) -> Bool {
        switch (lhs, rhs) {
        case let (.connected(lhsSubscription), .connected(rhsSubscription)):
            return lhsSubscription == rhsSubscription
        case let (.contentUpdate(lhsValue), .contentUpdate(rhsValue)):
            return lhsValue == rhsValue
        case (.disconnected, .disconnected):
            return true
        default:
            return false
        }
    }
}
````

## File: Sources/ServicesProvider/Models/Subscription.swift
````swift
//
//  SubscriptionIdentifier.swift
//
//
//  Created by Ruben Roques on 11/10/2022.
//

import Foundation
import Extensions

extension Subscription {
    var detailedDescription: String {
        var description = "Subscription ID: \(id)\n"
        description += "Content Identifier: \(contentIdentifier)\n"
        description += "Session Token: \(sessionToken)\n"
        description += "Associated Subscriptions: \(associatedSubscriptions.map { $0.id }.joined(separator: ", "))"
        return description
    }

    // ... rest of your Subscription class ...
}


public protocol UnsubscriptionController: AnyObject {
    func unsubscribe(subscription: Subscription)
}

public class Subscription: Hashable, Identifiable {

    public var id: String

    public var contentIdentifier: ContentIdentifier
    public var sessionToken: String

    var associatedSubscriptions: [Subscription] = []
    private weak var unsubscriber: UnsubscriptionController?

    init(contentIdentifier: ContentIdentifier, sessionToken: String, unsubscriber: UnsubscriptionController) {
        self.contentIdentifier = contentIdentifier
        self.sessionToken = sessionToken
        self.id = contentIdentifier.id
        self.unsubscriber = unsubscriber
        // print("ServiceProvider.Subscription init \(self.contentIdentifier)")
    }

    init(contentType: ContentType, contentRoute: ContentRoute, sessionToken: String, unsubscriber: UnsubscriptionController) {
        self.contentIdentifier = ContentIdentifier(contentType: contentType, contentRoute: contentRoute)
        self.id = self.contentIdentifier.id
        self.sessionToken = sessionToken
        self.unsubscriber = unsubscriber
        // print("ServiceProvider.Subscription init \(self.contentIdentifier)")
    }

    deinit {
        print("subscr deinit \(self)")
        self.unsubscriber?.unsubscribe(subscription: self)
    }

    func associateSubscription(_ subscription: Subscription) {
        self.associatedSubscriptions.append(subscription)
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(contentIdentifier)
    }

    public static func == (lhs: Subscription, rhs: Subscription) -> Bool {
        return lhs.id == rhs.id && lhs.contentIdentifier == rhs.contentIdentifier
    }

}


extension Subscription: CustomStringConvertible {
    public var description: String {
        return "Subscription: \(self.id) \(self.contentIdentifier)"
    }
}

public enum ContentType: String, Codable {
    case liveEvents = "liveDataSummaryAdvancedListBySportType"
    case preLiveEvents = "eventListBySportTypeDate"

    case liveSports = "inplaySportListBySportType"
    case preLiveSports = "sportTypeByDate"
    case allSports = "boNavigationList"

    case eventDetails = "event"
    case eventDetailsLiveData = "liveDataExtended"
    case eventGroup = "eventGroup"
    case eventSummary = "eventSummary"

    case market = "market"

    case eventMainMarket = "liveDataSummaryEventSummary"
    case eventSecundaryMarkets = "eventWithBalancedMarkets"
}

public enum ContentRoute {

    case liveEvents(sportAlphaId: String, pageIndex: Int)
    case preLiveEvents(sportAlphaId: String, startDate: Date?, endDate: Date?, pageIndex: Int, eventCount: Int, sortType: EventListSort)

    case liveSports
    case preLiveSports(startDate: Date?, endDate: Date?)
    case allSports

    case eventDetails(eventId: String)
    case eventDetailsLiveData(eventId: String)
    case eventGroup(marketGroupId: String)
    case eventSummary(eventId: String)

    case market(marketId: String)

    case eventMainMarket(eventId: String)
    case eventSecundaryMarkets(eventId: String)

    var fullRoute: String {
        switch self {
        case .liveEvents(let sportAlphaId, let pageIndex):
            return "\(sportAlphaId)/\(pageIndex)"
        case .preLiveEvents(let sportAlphaId, let startDate, let endDate, let pageIndex, let eventCount, let sortType):
            let dateRange = ContentDateFormatter.getDateRangeId(startDate: startDate, endDate: endDate)
            return "\(sportAlphaId)/\(dateRange)/\(pageIndex)/\(eventCount)/\(sortType.rawValue)"

        case .liveSports:
            return ""
        case .preLiveSports(let startDate, let endDate):
            let dateRange = ContentDateFormatter.getDateRangeId(startDate: startDate, endDate: endDate)
            return dateRange
        case .allSports:
            return "\(SportRadarConfiguration.shared.frontEndCode)/top"

        case .eventDetails(let eventId):
            return eventId
        case .eventDetailsLiveData(let eventId):
            return eventId
        case .eventGroup(let marketGroupId):
            return marketGroupId
        case .eventSummary(let eventId):
            return eventId
        case .market(let marketId):
            return marketId

        case .eventMainMarket(let eventId):
            return eventId
        case .eventSecundaryMarkets(let eventId):
            return eventId
        }
    }

    var pageableRoute: String {
        switch self {
        case .liveEvents(let sportAlphaId, _):
            return sportAlphaId
        case .preLiveEvents(let sportAlphaId, let startDate, let endDate, _, let eventCount, let sortType):
            let dateRange = ContentDateFormatter.getDateRangeId(startDate: startDate, endDate: endDate)
            return "\(sportAlphaId)/\(dateRange)/\(eventCount)/\(sortType.rawValue)"
        case .liveSports:
            return ""
        case .preLiveSports:
            return ""
        case .allSports:
            return ""
        case .eventDetails(let eventId):
            return eventId
        case .eventDetailsLiveData(let eventId):
            return eventId
        case .eventGroup(let marketGroupId):
            return marketGroupId
        case .eventSummary(let eventId):
            return eventId
        case .market(let marketId):
            return marketId

        case .eventMainMarket(let eventId):
            return eventId
        case .eventSecundaryMarkets(let eventId):
            return eventId
        }
    }

    var eventCount: Int? {
        switch self {
        case .liveEvents(_, _):
            return nil
        case .preLiveEvents(_, _, _, _, let eventCount, _):
            return eventCount
        case .liveSports:
            return nil
        case .preLiveSports:
            return nil
        case .allSports:
            return nil
        case .eventDetails:
            return nil
        case .eventDetailsLiveData:
            return nil
        case .eventGroup:
            return nil
        case .eventSummary:
            return nil
        case .market:
            return nil

        case .eventMainMarket:
            return nil
        case .eventSecundaryMarkets:
            return nil
        }
    }
}

public class ContentIdentifier: Decodable, Identifiable {

    public let id: String

    public let pageableId: String

    public var contentType: ContentType
    public var contentRoute: ContentRoute

    public var pageableRoute: String {
        self.contentRoute.pageableRoute
    }

    enum CodingKeys: String, CodingKey {
        case contentType = "type"
        case contentRoute = "id"
    }

    public required init(contentType: ContentType,
                         contentRoute: ContentRoute) {
        self.contentType = contentType
        self.contentRoute = contentRoute

        self.id = "\(contentType.rawValue)-\(contentRoute.fullRoute)".MD5()
        self.pageableId = "\(contentType.rawValue)-\(contentRoute.pageableRoute)".MD5()
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        let contentType = try container.decode(ContentType.self, forKey: .contentType)
        self.contentType = contentType
        let contentRouteRawString = try container.decode(String.self, forKey: .contentRoute)
        let contentRouteRawParts = contentRouteRawString.components(separatedBy: "/")

        switch contentType {
        case .liveEvents:
            guard
                let sportId = contentRouteRawParts[safe: 0],
                let pageIndex = Int(contentRouteRawParts[safe: 1] ?? "")
            else {
                let context = DecodingError.Context(codingPath: [CodingKeys.contentRoute], debugDescription: "Not a valid contentRoute path")
                throw DecodingError.valueNotFound(ContentRoute.self, context)
            }
            self.contentRoute = ContentRoute.liveEvents(sportAlphaId: sportId, pageIndex: pageIndex)

        case .preLiveEvents:
            guard
                let sportId = contentRouteRawParts[safe: 0],
                let pageIndex = Int(contentRouteRawParts[safe: 3] ?? ""),
                let eventCount = Int(contentRouteRawParts[safe: 4] ?? ""),
                let sortTypeString = contentRouteRawParts[safe: 5],
                let sortType = EventListSort(rawValue: sortTypeString)
            else {
                let context = DecodingError.Context(codingPath: [CodingKeys.contentRoute], debugDescription: "Not a valid contentRoute path")
                throw DecodingError.valueNotFound(ContentRoute.self, context)
            }

            let startDateString = contentRouteRawParts[safe: 1] ?? ""
            let startDate = ContentDateFormatter.dateFromString(dateString: startDateString)
            let endDateString = contentRouteRawParts[safe: 2] ?? ""
            let endDate = ContentDateFormatter.dateFromString(dateString: endDateString)

            self.contentRoute = ContentRoute.preLiveEvents(sportAlphaId: sportId,
                                                           startDate: startDate,
                                                           endDate: endDate,
                                                           pageIndex: pageIndex,
                                                           eventCount: eventCount,
                                                           sortType: sortType)
        case .liveSports:
            self.contentRoute = ContentRoute.liveSports
        case .preLiveSports:
            let startDateString = contentRouteRawParts[safe: 0] ?? ""
            let startDate = ContentDateFormatter.dateFromString(dateString: startDateString)
            let endDateString = contentRouteRawParts[safe: 1] ?? ""
            let endDate = ContentDateFormatter.dateFromString(dateString: endDateString)

            self.contentRoute = ContentRoute.preLiveSports(startDate: startDate, endDate: endDate)
        case .allSports:
            self.contentRoute = ContentRoute.allSports

        case .eventDetails:
            self.contentRoute = ContentRoute.eventDetails(eventId: contentRouteRawString)
        case .eventDetailsLiveData:
            self.contentRoute = ContentRoute.eventDetailsLiveData(eventId: contentRouteRawString)
        case .eventGroup:
            self.contentRoute = ContentRoute.eventGroup(marketGroupId: contentRouteRawString)
        case .eventSummary:
            self.contentRoute = ContentRoute.eventSummary(eventId: contentRouteRawString)
        case .market:
            self.contentRoute = ContentRoute.market(marketId: contentRouteRawString)
        case .eventMainMarket:
            self.contentRoute = ContentRoute.eventMainMarket(eventId: contentRouteRawString)
        case .eventSecundaryMarkets:
            self.contentRoute = ContentRoute.eventSecundaryMarkets(eventId: contentRouteRawString)
        }

        self.id = "\(contentType.rawValue)-\(contentRoute.fullRoute)".MD5()
        self.pageableId = "\(contentType.rawValue)-\(contentRoute.pageableRoute)".MD5()
    }

}

extension ContentIdentifier: Hashable {

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(pageableId)
    }

}


extension ContentIdentifier: Equatable {
    public static func == (lhs: ContentIdentifier, rhs: ContentIdentifier) -> Bool {
        return lhs.id == rhs.id && lhs.pageableId == rhs.pageableId
    }
}

extension ContentIdentifier: CustomStringConvertible {
    public var description: String {
        return "[\(self.contentType.rawValue)] \(self.contentRoute.fullRoute)"
    }
}

struct ContentDateFormatter {

    static func getDateRangeId(startDate: Date? = nil, endDate: Date? = nil) -> String {
        // TODO: Re-check dates with hour and minute after confirmation with SportRadar
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyyMMdd"

        let startDateDefault: Date = startDate ?? Date()
        let endDateDefault: Date = endDate ?? Calendar.current.date(byAdding: .day, value: 90, to: startDateDefault) ?? Date()

        let startDateId = dateFormatter.string(from: startDateDefault)
        let endDateId = dateFormatter.string(from: endDateDefault)

        let dateRangeId = "\(startDateId)0000/\(endDateId)2359"

        return dateRangeId
    }

    static func dateFromString(dateString: String) -> Date? {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyyMMddHHmm"
        return dateFormatter.date(from: dateString)
    }

}
````

## File: Sources/ServicesProvider/Models/TransactionsHistoryResponse.swift
````swift
//
//  TransactionsHistoryResponse.swift
//  
//
//  Created by André Lascas on 13/02/2023.
//

import Foundation

public struct TransactionsHistoryResponse {

    public var status: String
    public var transactions: [TransactionDetail]?

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case transactions = "transactions"
    }

    public init(status: String, transactions: [TransactionDetail]?) {
        self.status = status
        self.transactions = transactions
    }
}

public struct TransactionDetail {

    public var id: Int
    public var date: Date
    public var type: TransactionType?
    public var amount: Double
    public var postBalance: Double
    public var amountBonus: Double
    public var postBalanceBonus: Double
    public var currency: String
    public var paymentId: Int?
    public var gameTranId: String?
    public var reference: String?
    public var escrowTranType: String?
    public var escrowTranSubType: String?
    public var escrowType: String?

    public init(id: Int, date: Date, type: TransactionType? = nil, amount: Double, postBalance: Double, amountBonus: Double, postBalanceBonus: Double, currency: String, paymentId: Int?, gameTranId: String?, reference: String?, escrowTranType: String?, escrowTranSubType: String?, escrowType: String?) {
        self.id = id
        self.date = date
        self.type = type
        self.amount = amount
        self.postBalance = postBalance
        self.amountBonus = amountBonus
        self.postBalanceBonus = postBalanceBonus
        self.currency = currency
        self.paymentId = paymentId
        self.gameTranId = gameTranId
        self.reference = reference
        self.escrowTranType = escrowTranType
        self.escrowTranSubType = escrowTranSubType
        self.escrowType = escrowType
    }
}

public struct TransactionHistory {
    public let transactionID: String
    public let date: Date
    public let type: String
    public let transactionType: TransactionType?
    public let valueType: TransactionValueType
    public let debit: DebitCredit
    public let credit: DebitCredit
    public let fees: [Fees]
    public let status: String?
    public let transactionReference: String?
    public let id: String?
    public let isRallbackAllowed: Bool?
    public let paymentId: Int?
    public let reference: String?
    public let escrowTranType: String?
    public let escrowTranSubType: String?
    public let escrowType: String?

    public init(transactionID: String, date: Date, type: String, transactionType: TransactionType?, valueType: TransactionValueType, debit: DebitCredit, credit: DebitCredit, fees: [Fees], status: String?, transactionReference: String?, id: String?, isRallbackAllowed: Bool?, paymentId: Int?, reference: String?, escrowTranType: String?, escrowTranSubType: String?, escrowType: String?) {
        self.transactionID = transactionID
        self.date = date
        self.type = type
        self.transactionType = transactionType
        self.valueType = valueType
        self.debit = debit
        self.credit = credit
        self.fees = fees
        self.status = status
        self.transactionReference = transactionReference
        self.id = id
        self.isRallbackAllowed = isRallbackAllowed
        self.paymentId = paymentId
        self.reference = reference
        self.escrowTranType = escrowTranType
        self.escrowTranSubType = escrowTranSubType
        self.escrowType = escrowType
    }
}

public struct DebitCredit {
    public let currency: String
    public let amount: Double
    public let name: String

    public init(currency: String, amount: Double, name: String) {
        self.currency = currency
        self.amount = amount
        self.name = name
    }
}

public struct Fees {
    public let currency: String
    public let amount: Double

    public init(currency: String, amount: Double) {
        self.currency = currency
        self.amount = amount
    }
}

public enum TransactionValueType {
    case won
    case loss
    case neutral
}
````

## File: Sources/ServicesProvider/Models/User.swift
````swift
//
//  User.swift
//  
//
//  Created by Ruben Roques on 24/10/2022.
//

import Foundation
import SharedModels

public enum KnowYourClientStatus: String, Codable, Equatable, Hashable {
    case open
    case requested
    case failed
    case completed
}

public enum UserVerificationStatus: String, Codable, Equatable, Hashable {
    case verified
    case unverified
}

public enum EmailVerificationStatus: String, Codable, Equatable, Hashable {
    case verified
    case unverified
}

public enum UserRegistrationStatus: String, Codable, Equatable, Hashable {
    case completed
    case quickOpen
    case quickRegister
}

public enum KnowYourCustomerStatus: String, Codable, Equatable, Hashable {
    case request
    case passConditional
    case pass
}

public enum LockedStatus: String, Codable, Equatable, Hashable {
    case locked
    case notLocked
}

public struct UserOverview: Codable, Equatable, Hashable {
    
    public let sessionKey: String
    public let username: String
    public let email: String
    
    public let partyID: String?
    public let language: String?
    public let currency: String?
    public let parentID: String?
    
    public let level: String?
    public let userType: String?
    public let isFirstLogin: String?
    public let registrationStatus: String?
    public let country: String?
    public let kycStatus: String?
    public let lockStatus: String?
    
    enum CodingKeys: String, CodingKey {
        case sessionKey = "sessionKey"
        case username = "username"
        case email = "email"
        case partyID = "partyId"
        case language = "language"
        case currency = "currency"
        case parentID = "parentId"
        case level = "level"
        case userType = "userType"
        case isFirstLogin = "isFirstLogin"
        case registrationStatus = "registrationStatus"
        case country = "country"
        case kycStatus = "kycStatus"
        case lockStatus = "lockStatus"
    }
    
}

public struct UserProfile: Codable, Equatable, Hashable {
    
    public let userIdentifier: String
    public let sessionKey: String
    public let username: String
    public let email: String
    public let firstName: String?
    public let middleName: String?
    public let lastName: String?
    public let birthDate: Date
    public let gender: String?
    public let nationalityCode: String?
    public let countryCode: String?
    public let personalIdNumber: String?
    public let address: String?
    public let province: String?
    public let city: String?
    public let postalCode: String?
    public let birthDepartment: String?
    public let streetNumber: String?
    public let phoneNumber: String?
    public let mobilePhone: String?
    public let mobileCountryCode: String?
    public let mobileLocalNumber: String?
    
    public let avatarName: String?
    public let godfatherCode: String?
    public let placeOfBirth: String?
    public let additionalStreetLine: String?

    public let emailVerificationStatus: EmailVerificationStatus
    public let userRegistrationStatus: UserRegistrationStatus
    public let kycStatus: KnowYourCustomerStatus
    public let lockedStatus: LockedStatus
    public let hasMadeDeposit: Bool
    public let kycExpiryDate: String?

    public let currency: String?
    
    public init(userIdentifier: String,
                sessionKey: String,
                username: String,
                email: String,
                firstName: String?,
                middleName: String?,
                lastName: String?,
                birthDate: Date,
                gender: String?,
                nationalityCode: String?,
                countryCode: String?,
                personalIdNumber: String?,
                address: String?,
                province: String?,
                city: String?,
                postalCode: String?,
                birthDepartment: String?,
                streetNumber: String?,
                phoneNumber: String?,
                mobilePhone: String?,
                mobileCountryCode: String?,
                mobileLocalNumber: String?,
                avatarName: String?,
                godfatherCode: String?,
                placeOfBirth: String?,
                additionalStreetLine: String?,
                emailVerificationStatus: EmailVerificationStatus,
                userRegistrationStatus: UserRegistrationStatus,
                kycStatus: KnowYourCustomerStatus,
                lockedStatus: LockedStatus,
                hasMadeDeposit: Bool,
                kycExpiryDate: String?,
                currency: String?) {
        
        self.userIdentifier = userIdentifier
        self.sessionKey = sessionKey
        self.username = username
        self.email = email
        self.firstName = firstName
        self.middleName = middleName
        self.lastName = lastName
        self.birthDate = birthDate
        self.gender = gender
        self.nationalityCode = nationalityCode
        self.countryCode = countryCode
        self.personalIdNumber = personalIdNumber
        self.address = address
        self.province = province
        self.city = city
        self.postalCode = postalCode
        self.birthDepartment = birthDepartment
        self.streetNumber = streetNumber
        self.phoneNumber = phoneNumber
        self.mobilePhone = mobilePhone
        self.mobileCountryCode = mobileCountryCode
        self.mobileLocalNumber = mobileLocalNumber
        
        self.avatarName = avatarName
        self.godfatherCode = godfatherCode
        self.placeOfBirth = placeOfBirth
        self.additionalStreetLine = additionalStreetLine

        self.emailVerificationStatus = emailVerificationStatus
        self.userRegistrationStatus = userRegistrationStatus
        self.kycStatus = kycStatus
        self.lockedStatus = lockedStatus
        self.hasMadeDeposit = hasMadeDeposit
        self.kycExpiryDate = kycExpiryDate
        self.currency = currency
    }

}

public extension UserProfile {
    var isEmailVerified: Bool {
        return self.emailVerificationStatus == .verified
    }
    var isRegistrationCompleted: Bool {
        return self.userRegistrationStatus == .completed
    }
    var nationalityCountry: Country? {
        if let nationalityCode = self.nationalityCode {
            return Country.init(isoCode: nationalityCode.uppercased())
        }
        return nil
    }
    var country: Country? {
        if let countryCode = self.countryCode {
            return Country.init(isoCode: countryCode)
        }
        return nil
    }
}

// TODO: SP Merge - why do we need another struct for login reply
public struct LoginResponse {
    public var token: String
    public var userProfile: UserProfile
    
    public init(token: String, userProfile: UserProfile) {
        self.token = token
        self.userProfile = userProfile
    }
}

public struct LogoutResponse {
    public var message: String
    
    public init(message: String) {
        self.message = message
    }
}

public struct SimpleSignUpForm {
    public var email: String
    public var username: String
    public var password: String
    public var birthDate: Date
    public var mobilePrefix: String
    public var mobileNumber: String
    public var countryIsoCode: String
    public var currencyCode: String

    public init(email: String, username: String, password: String, birthDate: Date, mobilePrefix: String, mobileNumber: String, countryIsoCode: String, currencyCode: String) {
        self.email = email
        self.username = username
        self.password = password
        self.birthDate = birthDate
        self.mobilePrefix = mobilePrefix
        self.mobileNumber = mobileNumber
        self.countryIsoCode = countryIsoCode
        self.currencyCode = currencyCode
    }

}

public class SignUpForm {

    public var email: String
    public var username: String
    public var password: String
    public var birthDate: Date
    public var mobilePrefix: String
    public var mobileNumber: String
    public var nationalityIsoCode: String
    public var currencyCode: String

    public var firstName: String
    public var lastName: String
    public var middleName: String?

    public var gender: String
    public var address: String

    public var city: String
    public var postCode: String
    public var countryIsoCode: String

    public var birthDepartment: String
    public var streetNumber: String
    public var birthCountry: String
    public var birthCity: String

    public var bonusCode: String?
    public var receiveMarketingEmails: Bool?

    public var avatarName: String?
    public var additionalStreetAddress: String?
    public var godfatherCode: String?
    
    public var mobileVerificationRequestId: String?
    
    public var consentedIds: [String]
    public var unConsentedIds: [String]

    public init(email: String, username: String, password: String, birthDate: Date,
                mobilePrefix: String, mobileNumber: String, nationalityIsoCode: String,
                currencyCode: String, firstName: String, lastName: String, middleName: String?,
                gender: String, address: String, city: String,
                countryIsoCode: String, bonusCode: String? = nil,
                receiveMarketingEmails: Bool? = nil, avatarName: String? = nil,
                godfatherCode: String? = nil, postCode: String,
                birthDepartment: String, streetNumber: String,
                birthCountry: String, birthCity: String, mobileVerificationRequestId: String?,
                consentedIds: [String], unConsentedIds: [String]) {

        self.email = email
        self.username = username
        self.password = password
        self.birthDate = birthDate
        self.mobilePrefix = mobilePrefix
        self.mobileNumber = mobileNumber
        self.nationalityIsoCode = nationalityIsoCode
        self.currencyCode = currencyCode
        self.firstName = firstName
        self.lastName = lastName
        self.middleName = middleName
        self.gender = gender
        self.address = address
        self.city = city
        self.countryIsoCode = countryIsoCode
        self.bonusCode = bonusCode
        self.receiveMarketingEmails = receiveMarketingEmails
        self.avatarName = avatarName
        self.godfatherCode = godfatherCode
        self.postCode = postCode
        self.birthDepartment = birthDepartment
        self.streetNumber = streetNumber
        self.birthCountry = birthCountry
        self.birthCity = birthCity
        self.mobileVerificationRequestId = mobileVerificationRequestId
        
        self.consentedIds = consentedIds
        self.unConsentedIds = unConsentedIds
    }

}

public struct SignUpResponse {

    public struct SignUpError {
        public var field: String
        public var error: String
    }

    public var successful: Bool
    public var errors: [SignUpError]?

    public init(successful: Bool, errors: [SignUpError]? = nil) {
        self.successful = successful
        self.errors = errors
    }
    
}

public struct DetailedSignUpResponse {
    
    public var successful: Bool
    public var errors: [SignUpError]?
    public var userData: SignUpUserData?
    
    public init(successful: Bool, errors: [SignUpError]? = nil, userData: SignUpUserData? = nil) {
        self.successful = successful
        self.errors = errors
        self.userData = userData
    }
}

public struct SignUpError {
    public var field: String
    public var error: String
}

public struct SignUpUserData {
    public var id: Int
    public var name: String
    public var email: String
    public var username: String
    public var avatarName: String
    
    public init(id: Int, name: String, email: String, username: String, avatarName: String) {
        self.id = id
        self.name = name
        self.email = email
        self.username = username
        self.avatarName = avatarName
    }
}

public struct UpdateUserProfileForm {
    
    public var username: String?
    public var email: String?
    public var firstName: String?
    public var middleName: String?
    public var lastName: String?
    public var birthDate: Date?
    public var gender: String?
    public var address: String?
    public var province: String?
    public var city: String?
    public var postalCode: String?
    public var country: Country?
    public var cardId: String?
    
    public var mobileNumber: String?
    public var securityQuestion: String?
    public var securityAnswer: String?
    
    public var avatar: String?
    
    public init(username: String? = nil, email: String? = nil,
                firstName: String? = nil, middleName: String? = nil, lastName: String? = nil,
                birthDate: Date? = nil, gender: String? = nil,
                address: String? = nil, province: String? = nil, city: String? = nil,
                postalCode: String? = nil, country: Country? = nil, cardId: String? = nil,
                mobileNumber: String? = nil, securityQuestion: String? = nil, securityAnswer: String? = nil,
                avatar: String? = nil) {
        self.username = username
        self.email = email
        self.firstName = firstName
        self.middleName = middleName
        self.lastName = lastName
        self.birthDate = birthDate
        self.gender = gender
        self.address = address
        self.province = province
        self.city = city
        self.postalCode = postalCode
        self.country = country
        self.cardId = cardId
        self.mobileNumber = mobileNumber
        self.securityQuestion = securityQuestion
        self.securityAnswer = securityAnswer
        self.avatar = avatar
    }
    
}

public struct UserWallet {
    public var vipStatus: String?
    public var currency: String?
    public var loyaltyPoint: Int?
    
    public var totalString: String?
    public var total: Double?
    public var withdrawableString: String?
    public var withdrawable: Double?
    public var bonusString: String?
    public var bonus: Double?
    public var pendingBonusString: String?
    public var pendingBonus: Double?
    public var casinoPlayableBonusString: String?
    public var casinoPlayableBonus: Double?
    public var sportsbookPlayableBonusString: String?
    public var sportsbookPlayableBonus: Double?
    public var withdrawableEscrowString: String?
    public var withdrawableEscrow: Double?
    public var totalWithdrawableString: String?
    public var totalWithdrawable: Double?
    public var withdrawRestrictionAmountString: String?
    public var withdrawRestrictionAmount: Double?
    public var totalEscrowString: String?
    public var totalEscrow: Double?
    
    enum CodingKeys: String, CodingKey {
        case totalString = "totalBalance"
        case total = "totalBalanceNumber"
        case withdrawableString = "withdrawableBalance"
        case withdrawable = "withdrawableBalanceNumber"
        case bonusString = "bonusBalance"
        case bonus = "bonusBalanceNumber"
        case pendingBonusString = "pendingBonusBalance"
        case pendingBonus = "pendingBonusBalanceNumber"
        case casinoPlayableBonusString = "casinoPlayableBonusBalance"
        case casinoPlayableBonus = "casinoPlayableBonusBalanceNumber"
        case sportsbookPlayableBonusString = "sportsbookPlayableBonusBalance"
        case sportsbookPlayableBonus = "sportsbookPlayableBonusBalanceNumber"
        case withdrawableEscrowString = "withdrawableEscrowBalance"
        case withdrawableEscrow = "withdrawableEscrowBalanceNumber"
        case totalWithdrawableString = "totalWithdrawableBalance"
        case totalWithdrawable = "totalWithdrawableBalanceNumber"
        case withdrawRestrictionAmountString = "withdrawRestrictionAmount"
        case withdrawRestrictionAmount = "withdrawRestrictionAmountNumber"
        case totalEscrowString = "totalEscrowBalance"
        case totalEscrow = "totalEscrowBalanceNumber"
        case currency = "currency"
        case loyaltyPoint = "loyaltyPoint"
        case vipStatus = "vipStatus"
    }
    
    
}

public struct UsernameValidation {
    public var username: String
    public var isAvailable: Bool
    public var suggestedUsernames: [String]?
    public var hasErrors: Bool
}

public struct DocumentTypesResponse {
    public var status: String
    public var documentTypes: [DocumentType]

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case documentTypes = "documentTypes"
    }
}

public struct DocumentType {
    public var documentType: String
    public var issueDateRequired: Bool?
    public var expiryDateRequired: Bool?
    public var documentNumberRequired: Bool?
    public var documentTypeGroup: DocumentTypeGroup?
    public var multipleFileRequired: Bool?

    enum CodingKeys: String, CodingKey {
        case documentType = "documentType"
        case expiryDateRequired = "expiryDateRequired"
        case documentNumberRequired = "documentNumberRequired"
        case issueDateRequired = "issueDateRequired"
        case multipleFileRequired = "multipleFileRequired"
    }
}

public enum DocumentTypeGroup {
    case identityCard
    case passport
    case drivingLicense
    case residenceId
    case proofOfAddress
    case rib
    case others

    init?(documentType: String) {

        switch documentType {
        case "IDENTITY_CARD": self = .identityCard
        case "PASSPORT": self = .passport
        case "DRIVING_LICENCE": self = .drivingLicense
        case "RESIDENCE_ID": self = .residenceId
        case "POA": self = .proofOfAddress
        case "RIB": self = .rib
        case "OTHERS": self = .others
        default: return nil
        }
    }
}

public struct UserDocumentsResponse {
    public var status: String
    public var userDocuments: [UserDocument]

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case documentTypes = "userDocuments"
    }
}

public struct UserDocument {
    public var documentType: String
    public var fileName: String?
    public var status: String
    public var uploadDate: String
    public var userDocumentFiles: [UserDocumentFile]?

    enum CodingKeys: String, CodingKey {
        case documentType = "documentType"
        case fileName = "fileName"
        case status = "status"
        case uploadDate = "uploadDate"
        case userDocumentFiles = "userDocumentFiles"
    }
}

public struct UserDocumentFile {
    public var fileName: String

    enum CodingKeys: String, CodingKey {
        case fileName = "fileName"
    }
}

public struct UploadDocumentResponse {
    public var status: String
    public var message: String?

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case message = "message"
    }
}

public struct PaymentsResponse: Codable {
    public var status: String
    public var depositMethods: [DepositMethod]

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case depositMethods = "depositMethods"
    }
}

public struct DepositMethod: Codable {
    public var code: String
    public var paymentMethod: String
    public var methods: [PaymentMethod]?

    enum CodingKeys: String, CodingKey {
        case code = "code"
        case paymentMethod = "paymentMethod"
        case methods = "methods"
    }
}

public struct PaymentMethod: Codable {
    public var name: String
    public var type: String
    public var brands: [String]?

    enum CodingKeys: String, CodingKey {
        case name = "name"
        case type = "type"
        case brands = "brands"
    }
}

public struct SimplePaymentMethodsResponse: Codable {

    public var paymentMethods: [SimplePaymentMethod]

}

public struct SimplePaymentMethod: Codable, Equatable {
    public var name: String
    public var type: String
    public var brands: [String]?

    public static func == (lhs: SimplePaymentMethod, rhs: SimplePaymentMethod) -> Bool {
        return lhs.name == rhs.name
    }
}

public struct ProcessDepositResponse: Codable {
    public var status: String
    public var paymentId: String?
    public var continueUrl: String?
    public var clientKey: String?
    public var sessionId: String?
    public var sessionData: String?
    public var message: String?

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case paymentId = "paymentId"
        case continueUrl = "continueUrl"
        case clientKey = "clientKey"
        case sessionId = "sessionId"
        case sessionData = "sessionData"
        case message = "message"
    }
}

public struct UpdatePaymentResponse: Codable {
    public var resultCode: String
    public var action: UpdatePaymentAction?

    enum CodingKeys: String, CodingKey {
        case resultCode = "resultCode"
        case action = "action"
    }
}

public struct UpdatePaymentAction: Codable {
    public var paymentMethodType: String
    public var url: String
    public var method: String
    public var type: String

    enum CodingKeys: String, CodingKey {
        case paymentMethodType = "paymentMethodType"
        case url = "url"
        case method = "method"
        case type = "type"
    }
}

public struct PersonalDepositLimitResponse: Codable {

    public var status: String
    public var dailyLimit: String?
    public var weeklyLimit: String?
    public var monthlyLimit: String?
    public var currency: String
    public var hasPendingWeeklyLimit: String?
    public var pendingWeeklyLimit: String?
    public var pendingWeeklyLimitEffectiveDate: String?

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case dailyLimit = "dailyLimit"
        case weeklyLimit = "weeklyLimit"
        case monthlyLimit = "monthlyLimit"
        case currency = "currency"
        case hasPendingWeeklyLimit = "hasPendingWeeklyLimit"
        case pendingWeeklyLimit = "pendingWeeklyLimit"
        case pendingWeeklyLimitEffectiveDate = "pendingWeeklyLimitEffectiveDate"
    }
}

public struct LimitsResponse: Codable {

    public var status: String
    public var wagerLimit: String?
    public var lossLimit: String?
    public var currency: String
    public var pendingWagerLimit: LimitPending?

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case wagerLimit = "wagerLimit"
        case lossLimit = "lossLimit"
        case currency = "currency"
        case pendingWagerLimit = "pendingWagerLimit"
    }
}

public struct LimitPending: Codable {
    public var effectiveDate: String
    public var limit: String
    public var limitNumber: Double

    enum CodingKeys: String, CodingKey {
        case effectiveDate = "effectiveDate"
        case limit = "limit"
        case limitNumber = "limitNumber"
    }
}

public struct Limit {
    public var updatable: Bool
    public var current: LimitInfo?
    public var queued: LimitInfo?

    public init(updatable: Bool, current: LimitInfo?, queued: LimitInfo?) {
        self.updatable = updatable
        self.current = current
        self.queued = queued
    }
}

public struct LimitInfo {
    public var period: String
    public var currency: String
    public var amount: Double
    public var expiryDate: String?

    public init(period: String, currency: String, amount: Double, expiryDate: String? = nil) {
        self.period = period
        self.currency = currency
        self.amount = amount
        self.expiryDate = expiryDate
    }
}


public struct BasicMessageResponse: Codable {
    public var message: String
    
    enum CodingKeys: String, CodingKey {
        case message = "message"
    }
}

public struct BasicResponse: Codable {
    public var status: String
    public var message: String?

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case message = "message"
    }
}

public struct MobileVerifyResponse: Codable {
    public var status: String
    public var message: String?
    public var requestId: String?
    
    enum CodingKeys: String, CodingKey {
        case status = "status"
        case message = "message"
        case requestId = "verificationRequestId"
    }
}


public struct PaymentStatusResponse: Codable {
    public var status: String
    public var paymentId: String?
    public var paymentStatus: String?
    public var message: String?

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case paymentId = "paymentId"
        case paymentStatus = "paymentStatus"
        case message = "message"
    }
}

public struct SupportResponse: Codable {
    public var request: SupportRequest?
    public var error: String?
    public var description: String?

    enum CodingKeys: String, CodingKey {
        case request = "request"
        case error = "error"
        case description = "description"
    }
}

public struct SupportRequest: Codable {
    public var id: Int
    public var status: String

    enum CodingKeys: String, CodingKey {
        case id = "id"
        case status = "status"
    }
}

public struct PasswordPolicy {
    public var regularExpression: String?
    public var message: String

    public init(regularExpression: String? = nil, message: String) {
        self.regularExpression = regularExpression
        self.message = message
    }
}

public struct UserNotificationsSettings: Codable {
    
    public var notifications: Bool
    public var notificationsGamesWatchlist: Bool
    public var notificationsCompetitionsWatchlist: Bool
    public var notificationsGoal: Bool
    public var notificationsStartGame: Bool
    public var notificationsHalftime: Bool
    public var notificationsFulltime: Bool
    public var notificationsSecondHalf: Bool
    public var notificationsRedcard: Bool
    public var notificationsBets: Bool
    public var notificationsBetSelections: Bool
    public var notificationsEmail: Bool
    public var notificationsSms: Bool
    public var notificationsChats: Bool
    public var notificationsNews: Bool
    
    public init(notifications: Bool,
                notificationsGamesWatchlist: Bool,
                notificationsCompetitionsWatchlist: Bool,
                notificationsGoal: Bool,
                notificationsStartGame: Bool,
                notificationsHalftime: Bool,
                notificationsFulltime: Bool,
                notificationsSecondHalf: Bool,
                notificationsRedcard: Bool,
                notificationsBets: Bool,
                notificationsBetSelections: Bool,
                notificationsEmail: Bool,
                notificationsSms: Bool,
                notificationsChats: Bool,
                notificationsNews: Bool)
    {
        self.notifications = notifications
        self.notificationsGamesWatchlist = notificationsGamesWatchlist
        self.notificationsCompetitionsWatchlist = notificationsCompetitionsWatchlist
        self.notificationsGoal = notificationsGoal
        self.notificationsStartGame = notificationsStartGame
        self.notificationsHalftime = notificationsHalftime
        self.notificationsFulltime = notificationsFulltime
        self.notificationsSecondHalf = notificationsSecondHalf
        self.notificationsRedcard = notificationsRedcard
        self.notificationsBets = notificationsBets
        self.notificationsBetSelections = notificationsBetSelections
        self.notificationsEmail = notificationsEmail
        self.notificationsSms = notificationsSms
        self.notificationsChats = notificationsChats
        self.notificationsNews = notificationsNews
    }
    
}
````

## File: Sources/ServicesProvider/Network/Endpoint.swift
````swift
//
//  Endpoint.swift
//  
//
//  Created by Ruben Roques on 24/10/2022.
//

import Foundation

protocol Endpoint {
    var url: String { get }
    var endpoint: String { get }
    var query: [URLQueryItem]? { get }
    var headers: HTTP.Headers? { get }
    var cachePolicy: URLRequest.CachePolicy { get }
    var method: HTTP.Method { get }
    var body: Data? { get }
    var timeout: TimeInterval { get }
    var requireSessionKey: Bool { get }
    var comment: String? { get }
}

extension Endpoint {
    func request(aditionalQueryItems: [URLQueryItem] = [],
                 aditionalHeaders: HTTP.Headers? = nil) -> URLRequest? {

        guard var urlComponents = URLComponents(string: url) else { return nil }
        urlComponents.path = self.endpoint
        
        var fullQuery = self.query ?? []
        fullQuery.append(contentsOf: aditionalQueryItems)
        urlComponents.queryItems = fullQuery

        urlComponents.percentEncodedQuery = urlComponents.percentEncodedQuery?
            .replacingOccurrences(of: "+", with: "%2B")
        
        guard let completedURL = urlComponents.url else { return nil }

        var request = URLRequest(url: completedURL)
        request.httpMethod = self.method.value()
        request.timeoutInterval = self.timeout
        request.httpBody = self.body
        
        if let headersValue = self.headers {
            for (key, value) in headersValue {
                request.setValue(value, forHTTPHeaderField: key)
            }
        }
        
        if let aditionalHeadersValue = aditionalHeaders {
            for (key, value) in aditionalHeadersValue {
                request.setValue(value, forHTTPHeaderField: key)
            }
        }

        
        // print("NetworkLogs: [\(self.comment ?? "")]\n",
        //      "NetworkLogs: ", request.cURL(pretty: true),
        //     "\nNetworkLogs: =========================",
        //      "\nNetworkLogs")
        

        return request
    }
}
````

## File: Sources/ServicesProvider/Network/HTTPTypes.swift
````swift
//
//  HTTP.swift
//  
//
//  Created by Ruben Roques on 24/10/2022.
//

import Foundation

struct HTTP {
    enum Method {
        case get
        case post
        case delete
        case put

        func value() -> String {
            switch self {
            case .get:
                return "GET"
            case .post:
                return "POST"
            case .delete:
                return "DELETE"
            case .put:
                return "PUT"
            }
        }
    }

    typealias Headers = [String: String]

    typealias Parameters = [String: String]
}
````

## File: Sources/ServicesProvider/Network/MultipartRequest.swift
````swift
//
//  MultipartRequest.swift
//  
//
//  Created by André Lascas on 25/01/2023.
//

import Foundation

public struct MultipartRequest {

    public let boundary: String

    private let separator: String = "\r\n"
    private var data: Data

    public init(boundary: String = UUID().uuidString) {
        self.boundary = boundary
        self.data = .init()
    }

    private mutating func appendBoundarySeparator() {
        data.append("--\(boundary)\(separator)")
    }

    private mutating func appendSeparator() {
        data.append(separator)
    }

    private func disposition(_ key: String) -> String {
        "Content-Disposition: form-data; name=\"\(key)\""
    }

    public mutating func add(
        key: String,
        value: String
    ) {
        appendBoundarySeparator()
        data.append(disposition(key) + separator)
        appendSeparator()
        data.append(value + separator)
    }

    public mutating func add(
        key: String,
        fileName: String,
        fileMimeType: String,
        fileData: Data
    ) {
        appendBoundarySeparator()
        data.append(disposition(key) + "; filename=\"\(fileName)\"" + separator)
        data.append("Content-Type: \(fileMimeType)" + separator + separator)
        data.append(fileData)
        appendSeparator()
    }

    public var httpContentTypeHeaderValue: String {
        "multipart/form-data; boundary=\(boundary)"
    }

    public var httpBody: Data {
        var bodyData = data
        bodyData.append("--\(boundary)--")
        return bodyData
    }
}

public func mimeType(for data: Data) -> String {

    var b: UInt8 = 0
    data.copyBytes(to: &b, count: 1)

    switch b {
    case 0xFF:
        return "image/jpeg"
    case 0x89:
        return "image/png"
    case 0x47:
        return "image/gif"
    case 0x4D, 0x49:
        return "image/tiff"
    case 0x25:
        return "application/pdf"
    case 0xD0:
        return "application/vnd"
    case 0x46:
        return "text/plain"
    default:
        return "application/octet-stream"
    }
}

public extension Data {

    mutating func append(
        _ string: String,
        encoding: String.Encoding = .utf8
    ) {
        guard let data = string.data(using: encoding) else {
            return
        }
        append(data)
    }
}
````

## File: Sources/ServicesProvider/Network/NetworkManager.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 25/10/2022.
//

import Foundation
import Combine

class NetworkManager {
    
    private let session: URLSession
    private let decoder: JSONDecoder
    
    init(session: URLSession = URLSession(configuration: URLSessionConfiguration.default), decoder: JSONDecoder = JSONDecoder()) {
        self.session = session
        self.decoder = decoder
        
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss" // 2003-12-31 00:00:00
        self.decoder.dateDecodingStrategy = .formatted(dateFormatter)
    }

    func request<T: Codable>(_ endpoint: Endpoint) -> AnyPublisher<T, ServiceProviderError> {
       
        guard
            let request = endpoint.request()
        else {
            let error = ServiceProviderError.invalidRequestFormat
            return AnyPublisher(Fail<T, ServiceProviderError>(error: error))
        }
        
        return self.session.dataTaskPublisher(for: request)
            .tryMap { result in
                if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 401 {
                    throw ServiceProviderError.unauthorized
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 403 {
                    throw ServiceProviderError.forbidden
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode != 200 {
                    throw ServiceProviderError.unknown
                }
                return result.data
            }
        
            // Debug helper
//            .handleEvents(receiveOutput: { data in
//                print("ServiceProvider-NetworkManager [[ requesting ]] ", request,
//                      " [[ response ]] ", String(data: data, encoding: .utf8) ?? "!?" )
//            })
        
            .decode(type: T.self, decoder: self.decoder)
            .mapError { error in
                // Debug helper
                // print("ServiceProvider-NetworkManager Error \(error)")
                return ServiceProviderError.invalidResponse
            }
            .eraseToAnyPublisher()
    }
    
}
````

## File: Sources/ServicesProvider/Network/WebSocketClientStream.swift
````swift
//
//  WebSocketClientStream.swift
//  
//
//  Created by Ruben Roques on 30/08/2023.
//

import Foundation
import Combine

public enum WebSocketAsyncEventMessage {
    case connected
    case text(String)
    case binary(Data)
    case disconnected
}

public typealias WebSocketAsyncStream = AsyncThrowingStream<WebSocketAsyncEventMessage, Error>

public class WebSocketClientStream: NSObject, AsyncSequence {
    public typealias AsyncIterator = WebSocketAsyncStream.Iterator
    public typealias Element = WebSocketAsyncEventMessage

    private let url: URL

    private var urlSession = URLSession(configuration: .default)
    private var webSocketTask: URLSessionWebSocketTask?

    private var continuation: WebSocketAsyncStream.Continuation?

    private lazy var stream: WebSocketAsyncStream = {
        return WebSocketAsyncStream { continuation in
            self.continuation = continuation
            self.waitForNextValue()
        }
    }()

    private func waitForNextValue() {
        guard let webSocketTask = self.webSocketTask else {
            self.continuation?.finish()
            return
        }

        guard webSocketTask.closeCode == .invalid else {
            self.continuation?.finish()
            return
        }
        
        webSocketTask.receive { [weak self] result in
            guard let self = self else {
                return
            }
            
            do {
                let message = try result.get()
                switch message {
                case .string(let string):
                    self.continuation?.yield(.text(string))
                case .data(let data):
                    self.continuation?.yield(.binary(data))
                @unknown default:
                    break
                }
                self.waitForNextValue()
            } catch {
                self.continuation?.finish(throwing: error)
            }
            
        }

    }

    public init(url: URL) {
        self.url = url

        super.init()

        let request = URLRequest(url: self.url)
        let session = URLSession(configuration: URLSessionConfiguration.default, delegate: self, delegateQueue: nil)
        self.webSocketTask = session.webSocketTask(with: request)

        // Set the maximum message size to 250 MB
        let maximumMessageSize: Int = 250 * 1024 * 1024 // 25 MB in bytes
        self.webSocketTask?.maximumMessageSize = maximumMessageSize
    }

    deinit {
        self.continuation?.finish()
    }

    public func makeAsyncIterator() -> AsyncIterator {
        return self.stream.makeAsyncIterator()
    }

    public func connect() {
        self.webSocketTask?.resume()
    }

    public func close() {
        self.webSocketTask?.cancel(with: .goingAway, reason: nil)
        self.continuation?.yield(.disconnected)
        self.continuation?.finish()
    }

    public func send(remoteMessage: String) async throws {
        try await self.webSocketTask?.send(.string(remoteMessage))
    }

}

extension WebSocketClientStream: URLSessionWebSocketDelegate {

    public func urlSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didOpenWithProtocol protocol: String?) {
        self.continuation?.yield(.connected)
    }

    public func urlSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didCloseWith closeCode: URLSessionWebSocketTask.CloseCode, reason: Data?) {
        self.continuation?.yield(.disconnected)
    }

}
````

## File: Sources/ServicesProvider/Protocols/AnalyticsProvider.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 14/05/2024.
//

import Foundation
import Combine

protocol AnalyticsEvent {
    var type: String { get }
    var data: [String: Any]? { get }
}

protocol AnalyticsProvider {
    func trackEvent(_ event: AnalyticsEvent, userIdentifer: String?) -> AnyPublisher<Void, ServiceProviderError>
}
````

## File: Sources/ServicesProvider/Protocols/BettingProvider.swift
````swift
//
//  BettingProvider.swift
//
//
//  Created by Ruben Roques on 29/09/2022.
//

import Foundation
import Combine

protocol BettingProvider: Connector {

    func getBetHistory(pageIndex: Int) -> AnyPublisher<BettingHistory, ServiceProviderError>
    func getBetDetails(identifier: String) -> AnyPublisher<Bet, ServiceProviderError>

    func getOpenBetsHistory(pageIndex: Int, startDate: String?, endDate: String?) -> AnyPublisher<BettingHistory, ServiceProviderError>
    func getResolvedBetsHistory(pageIndex: Int, startDate: String?, endDate: String?) -> AnyPublisher<BettingHistory, ServiceProviderError>
    func getWonBetsHistory(pageIndex: Int, startDate: String?, endDate: String?) -> AnyPublisher<BettingHistory, ServiceProviderError>

    func getAllowedBetTypes(withBetTicketSelections betTicketSelections: [BetTicketSelection]) -> AnyPublisher<[BetType], ServiceProviderError>

    func calculatePotentialReturn(forBetTicket betTicket: BetTicket) -> AnyPublisher<BetslipPotentialReturn, ServiceProviderError>

    func placeBets(betTickets: [BetTicket], useFreebetBalance: Bool) -> AnyPublisher<PlacedBetsResponse, ServiceProviderError>

    // BetBuilder
    func calculateBetBuilderPotentialReturn(forBetTicket betTicket: BetTicket) -> AnyPublisher<BetBuilderPotentialReturn, ServiceProviderError>
    func placeBetBuilderBet(betTicket: BetTicket, calculatedOdd: Double) -> AnyPublisher<PlacedBetsResponse, ServiceProviderError>

    func confirmBoostedBet(identifier: String) -> AnyPublisher<Bool, ServiceProviderError>
    func rejectBoostedBet(identifier: String) -> AnyPublisher<Bool, ServiceProviderError>

    func calculateCashout(betId: String, stakeValue: String?) -> AnyPublisher<Cashout, ServiceProviderError>

    func cashoutBet(betId: String, cashoutValue: Double, stakeValue: Double?) -> AnyPublisher<CashoutResult, ServiceProviderError>
    func allowedCashoutBetIds() -> AnyPublisher<[String], ServiceProviderError>

    func calculateCashback(forBetTicket betTicket: BetTicket)  -> AnyPublisher<CashbackResult, ServiceProviderError>

    func getBetslipSettings() -> AnyPublisher<BetslipSettings?, Never>
    func updateBetslipSettings(_ betslipSettings: BetslipSettings) -> AnyPublisher<Bool, Never>

    func getFreebet() -> AnyPublisher<FreebetBalance, ServiceProviderError>

    func getSharedTicket(betslipId: String) -> AnyPublisher<SharedTicketResponse, ServiceProviderError>

    func getTicketSelection(ticketSelectionId: String) -> AnyPublisher<TicketSelection, ServiceProviderError>

    func updateTicketOdds(betId: String) -> AnyPublisher<Bet, ServiceProviderError>
    func getTicketQRCode(betId: String) -> AnyPublisher<BetQRCode, ServiceProviderError>
    func getSocialSharedTicket(shareId: String) -> AnyPublisher<Bet, ServiceProviderError>
    func deleteTicket(betId: String) -> AnyPublisher<Bool, ServiceProviderError>
    func updateTicket(betId: String, betTicket: BetTicket) -> AnyPublisher<PlacedBetsResponse, ServiceProviderError>

}
````

## File: Sources/ServicesProvider/Protocols/Connector.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 07/10/2022.
//

import Foundation
import Combine

public enum ConnectorState {
    case connected
    case disconnected
}

protocol Connector {
 
    var connectionStatePublisher: AnyPublisher<ConnectorState, Never> { get }
    
}
````

## File: Sources/ServicesProvider/Protocols/EventsProvider.swift
````swift
//
//  EventsProvider.swift
//
//
//  Created by Ruben Roques on 29/09/2022.
//

import Foundation
import Combine

protocol EventsProvider: Connector {

    //
    func reconnectIfNeeded()

    //
    func subscribeLiveMatches(forSportType sportType: SportType) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError>
    func requestLiveMatchesNextPage(forSportType sportType: SportType) -> AnyPublisher<Bool, ServiceProviderError>

    //
    func subscribePreLiveMatches(forSportType sportType: SportType, initialDate: Date?, endDate: Date?,  eventCount: Int?, sortType: EventListSort) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError>
    func requestPreLiveMatchesNextPage(forSportType sportType: SportType, initialDate: Date?, endDate: Date?, sortType: EventListSort) -> AnyPublisher<Bool, ServiceProviderError>

    //
    func subscribeEndedMatches(forSportType sportType: SportType) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError>
    func requestEndedMatchesNextPage(forSportType sportType: SportType) -> AnyPublisher<Bool, ServiceProviderError>
    
    //
    //
    func subscribeCompetitionMatches(forMarketGroupId marketGroupId: String) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError>

    //
    //
    func subscribeToMarketDetails(withId marketId: String, onEventId eventId:String) -> AnyPublisher<SubscribableContent<Market>, ServiceProviderError>
    func subscribeEventDetails(eventId: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError>
    func subscribeEventSummary(eventId: String) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError>
    func subscribeOutrightMarkets(forMarketGroupId marketGroupId: String) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError>
    func subscribeOutrightEvent(forMarketGroupId marketGroupId: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError>

    //
    //
    // TODO: SP Merge - subscribePreLiveSportTypes , subscribeAllSportTypes and subscribeLiveSportTypes should all be merged into -> subscribeSportTypes
    func subscribeSportTypes() -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError>
    // <->
    func subscribePreLiveSportTypes(initialDate: Date?, endDate: Date?) -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError>
    func subscribeLiveSportTypes() -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError>
    func subscribeAllSportTypes() -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError>

    //
    // Live Data extended info independent from the lists
    // This one creates a new subscription
    func subscribeToLiveDataUpdates(forEventWithId id: String) -> AnyPublisher<SubscribableContent<EventLiveData>, ServiceProviderError>

    // Publishers associated with the events lists (prelive and live)
    // Those publishers come from the paginator events
    func subscribeToEventOnListsLiveDataUpdates(withId id: String) -> AnyPublisher<Event?, ServiceProviderError>
    func subscribeToEventOnListsMarketUpdates(withId id: String) -> AnyPublisher<Market?, ServiceProviderError>
    func subscribeToEventOnListsOutcomeUpdates(withId id: String) -> AnyPublisher<Outcome?, ServiceProviderError>


    //
    //
    func getAvailableSportTypes(initialDate: Date?, endDate: Date?) -> AnyPublisher<[SportType], ServiceProviderError>

    func getMarketGroups(forEvent: Event) -> AnyPublisher<[MarketGroup], Never>

    func getFieldWidgetId(eventId: String) -> AnyPublisher<FieldWidget, ServiceProviderError>

    func getFieldWidget(eventId: String, isDarkTheme: Bool?) -> AnyPublisher<FieldWidgetRenderDataType, ServiceProviderError>

    func getStatsWidget(eventId: String, marketTypeName: String, isDarkTheme: Bool?) -> AnyPublisher<StatsWidgetRenderDataType, ServiceProviderError>

    func getSportRegions(sportId: String) -> AnyPublisher<SportNodeInfo, ServiceProviderError>

    func getRegionCompetitions(regionId: String) -> AnyPublisher<SportRegionInfo, ServiceProviderError>

    func getCompetitionMarketGroups(competitionId: String) -> AnyPublisher<SportCompetitionInfo, ServiceProviderError>

    func getSearchEvents(query: String, resultLimit: String, page: String, isLive: Bool) -> AnyPublisher<EventsGroup, ServiceProviderError>

    func getEventSummary(eventId: String, marketLimit: Int?) -> AnyPublisher<Event, ServiceProviderError>
    func getEventSummary(forMarketId: String) -> AnyPublisher<Event, ServiceProviderError>

    func getMarketInfo(marketId: String) -> AnyPublisher<Market, ServiceProviderError>

    func getHomeSliders() -> AnyPublisher<BannerResponse, ServiceProviderError>

    func getPromotionalTopBanners() -> AnyPublisher<[PromotionalBanner], ServiceProviderError>
    func getPromotionalSlidingTopEvents() -> AnyPublisher<[Event], ServiceProviderError>
    func getPromotionalTopStories() -> AnyPublisher<[PromotionalStory], ServiceProviderError>

    func getHighlightedBoostedEvents() -> AnyPublisher<[Event], ServiceProviderError>
    func getHighlightedVisualImageEvents() -> AnyPublisher<[Event], ServiceProviderError>

    func getHighlightedMarkets() -> AnyPublisher<[HighlightMarket], ServiceProviderError>

    func getHeroGameEvent() -> AnyPublisher<[Event], ServiceProviderError>

    func getPromotedSports() -> AnyPublisher<[PromotedSport], ServiceProviderError>

    func getCashbackSuccessBanner() -> AnyPublisher<BannerResponse, ServiceProviderError>

    func getTopCompetitionsPointers() -> AnyPublisher<[TopCompetitionPointer], ServiceProviderError>

    func getTopCompetitions() -> AnyPublisher<[TopCompetition], ServiceProviderError>

    func getEventsForEventGroup(withId eventGroupId: String) -> AnyPublisher<EventsGroup, ServiceProviderError>

    func getEventForMarketGroup(withId marketGroupId: String) -> AnyPublisher<Event, ServiceProviderError>

    func getEventDetails(eventId: String) -> AnyPublisher<Event, ServiceProviderError>

    func getEventSecundaryMarkets(eventId: String) -> AnyPublisher<Event, ServiceProviderError>

    func getEventLiveData(eventId: String) -> AnyPublisher<EventLiveData, ServiceProviderError>

    // Only the secundary markets updates
    func subscribeEventMarkets(eventId: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError>

    // Event and markets updates
    func subscribeToEventAndSecondaryMarkets(withId id: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError>

    func getHighlightedLiveEventsPointers(eventCount: Int, userId: String?) -> AnyPublisher<[String], ServiceProviderError>
    func getHighlightedLiveEvents(eventCount: Int, userId: String?) -> AnyPublisher<[Event], ServiceProviderError>

    func getPromotedBetslips(userId: String?) -> AnyPublisher<[PromotedBetslip], ServiceProviderError>

    //
    // Favorites
    func getFavoritesList() -> AnyPublisher<FavoritesListResponse, ServiceProviderError>
    func addFavoritesList(name: String) -> AnyPublisher<FavoritesListAddResponse, ServiceProviderError>
    func deleteFavoritesList(listId: Int) -> AnyPublisher<FavoritesListDeleteResponse, ServiceProviderError>
    func addFavoriteToList(listId: Int, eventId: String) -> AnyPublisher<FavoriteAddResponse, ServiceProviderError>
    func getFavoritesFromList(listId: Int) -> AnyPublisher<FavoriteEventResponse, ServiceProviderError>
    func deleteFavoriteFromList(eventId: Int) -> AnyPublisher<FavoritesListDeleteResponse, ServiceProviderError>

    //
    // Utilities
    func getDatesFilter(timeRange: String) -> [Date]

    func getAlertBanners() -> AnyPublisher<[AlertBanner], ServiceProviderError>
    func getNews() -> AnyPublisher<[News], ServiceProviderError>
    func getPromotedEventGroupsPointers() -> AnyPublisher<[EventGroupPointer], ServiceProviderError>
    func getPromotedEventsGroups() -> AnyPublisher<[EventsGroup], ServiceProviderError>
    func getPromotionalSlidingTopEventsPointers() -> AnyPublisher<[EventMetadataPointer], ServiceProviderError>
    func getHighlightedBoostedEventsPointers() -> AnyPublisher<[EventMetadataPointer], ServiceProviderError>
    func getHighlightedVisualImageEventsPointers() -> AnyPublisher<[EventMetadataPointer], ServiceProviderError>
    func getPromotedEventsBySport() -> AnyPublisher<[SportType: [Event]], ServiceProviderError>
    func addFavoriteItem(favoriteId: Int, type: String) -> AnyPublisher<BasicMessageResponse, ServiceProviderError>
    func deleteFavoriteItem(favoriteId: Int, type: String) -> AnyPublisher<BasicMessageResponse, ServiceProviderError>
    func getFeaturedTips(page: Int?, limit: Int?, topTips: Bool?, followersTips: Bool?, friendsTips: Bool?, userId: String?, homeTips: Bool?) -> AnyPublisher<FeaturedTips, ServiceProviderError>

}
````

## File: Sources/ServicesProvider/Protocols/ManagedContentProvider.swift
````swift
//
//  ManagedContentProvider.swift
//
//
//  Created on: May 15, 2024
//

import Foundation
import Combine

/// Protocol for accessing managed content from external CMS systems
///
/// This protocol provides methods for retrieving promotional and templated content
/// used throughout the application, including banners, stories, news, and other promotional items.
protocol ManagedContentProvider: Connector {

    // MARK: - Home Template

    /// Retrieves the home template configuration for the current platform
    /// - Returns: Publisher that emits the home template or an error
    func getHomeTemplate() -> AnyPublisher<HomeTemplate, ServiceProviderError>

    // MARK: - Alert Banner

    /// Retrieves the currently active alert banner, if any
    /// - Returns: Publisher that emits the alert banner or nil if none is active
    func getAlertBanner() -> AnyPublisher<AlertBanner?, ServiceProviderError>

    // MARK: - Banners

    /// Retrieves promotional banners
    /// - Returns: Publisher that emits an array of banners
    func getBanners() -> AnyPublisher<[Banner], ServiceProviderError>

    // MARK: - Sport Banners

    /// Retrieves sport-specific promotional banners
    /// - Returns: Publisher that emits an array of sport banners
    func getSportBanners() -> AnyPublisher<[SportBanner], ServiceProviderError>

    // MARK: - Boosted Odds

    /// Retrieves boosted odds banners
    /// - Returns: Publisher that emits an array of boosted odds banners
    func getBoostedOddsBanners() -> AnyPublisher<[BoostedOddsBanner], ServiceProviderError>

    // MARK: - Hero Cards

    /// Retrieves hero cards for featured promotions
    /// - Returns: Publisher that emits an array of hero cards
    func getHeroCards() -> AnyPublisher<[HeroCard], ServiceProviderError>

    // MARK: - Stories

    /// Retrieves ephemeral promotional stories
    /// - Returns: Publisher that emits an array of stories
    func getStories() -> AnyPublisher<[Story], ServiceProviderError>

    // MARK: - News

    /// Retrieves news articles
    /// - Parameters:
    ///   - pageIndex: The page index for pagination (starting at 0)
    ///   - pageSize: The number of items per page
    /// - Returns: Publisher that emits an array of news items
    func getNews(pageIndex: Int, pageSize: Int) -> AnyPublisher<[NewsItem], ServiceProviderError>

    // MARK: - Pro Choices

    /// Retrieves expert betting tips
    /// - Returns: Publisher that emits an array of pro choices
    func getProChoices() -> AnyPublisher<[ProChoice], ServiceProviderError>

}
````

## File: Sources/ServicesProvider/Protocols/new_managed_content_provider.md
````markdown
# Sportsbook iOS Integration Guide
## Promotions and Home Template API Reference

This document provides a comprehensive reference for integrating the promotions and home template features of the Sportsbook Backend API into your iOS application. It includes detailed information about available endpoints, request parameters, authentication requirements, and response structures.

## Table of Contents

1. [Authentication](#authentication)
2. [Common Parameters](#common-parameters)
3. [Home Template API](#home-template-api)
4. [Promotions APIs](#promotions-apis)
   - [All Promotions](#all-promotions)
   - [Alert Banner](#alert-banner)
   - [Banners](#banners)
   - [Sport Banners](#sport-banners)
   - [Boosted Odds Banners](#boosted-odds-banners)
   - [Hero Cards](#hero-cards)
   - [Stories](#stories)
   - [News](#news)
   - [Pro Choices](#pro-choices)
5. [Data Models](#data-models)
6. [Error Handling](#error-handling)
7. [Caching Strategies](#caching-strategies)
8. [Sample Swift Code](#sample-swift-code)

---

## Authentication

All API endpoints require authentication using Laravel Sanctum. You need to include a valid Bearer token in the Authorization header.

### Authentication Request

```http
POST /api/auth/v1/login
Content-Type: application/json

{
  "username": "user@example.com",
  "password": "password"
}
```

### Authentication Response

```json
{
  "token": "YOUR_API_TOKEN",
  "user": {
    "id": 1,
    "name": "User Name",
    // other user details
  }
}
```

### Using the Token

In all subsequent requests, include the token in the Authorization header:

```
Authorization: Bearer YOUR_API_TOKEN
```

---

## Common Parameters

These parameters are common to most promotional endpoints:

| Parameter  | Type   | Required | Description                                         |
|------------|--------|----------|-----------------------------------------------------|
| `client_id`| Number | Optional | Identifies the client application making the request |
| `platform` | String | Optional | One of: `web`, `ios`, `android`, `mobile`           |
| `user_type`| String | Optional | Type of user making the request                     |

---

## Home Template API

The Home Template API returns a configuration object that defines how the home screen should be structured based on the platform.

### Endpoint

```
GET /api/home/v1/template
```

### Parameters

| Parameter  | Type   | Required | Description                                                 |
|------------|--------|----------|-------------------------------------------------------------|
| `client_id`| Number | Optional | Identifies the client application making the request         |
| `platform` | String | Required | One of: `web`, `ios`, `android`, `mobile`. Use `ios` for iOS apps |
| `user_type`| String | Optional | Type of user making the request                             |

### Response

```json
{
  "id": 1,
  "client_id": 1,
  "title": "iOS Home Template",
  "platform": "ios",
  "sections": [
    {
      "type": "hero_carousel",
      "title": "Featured",
      "source": "promotions/v1/hero-cards",
      "options": {
        "autoplay": true,
        "interval": 5000
      }
    },
    {
      "type": "sport_banners",
      "title": "Today's Top Events",
      "source": "promotions/v1/sport-banners",
      "options": {
        "layout": "horizontal"
      }
    },
    {
      "type": "stories",
      "title": "Stories",
      "source": "promotions/v1/stories",
      "options": {
        "item_count": 5
      }
    },
    {
      "type": "news",
      "title": "News",
      "source": "promotions/v1/news",
      "options": {
        "display_mode": "card"
      }
    }
  ],
  "created_at": "2023-10-15T14:30:00.000000Z",
  "updated_at": "2024-05-01T09:15:00.000000Z"
}
```

---

## Promotions APIs

### All Promotions

Returns a combination of all promotion types in a single request. Useful for initializing the home screen.

#### Endpoint

```
GET /api/promotions/v1
```

#### Response

```json
{
  "bannerAlert": { /* Alert banner data */ },
  "banners": [ /* Regular banners */ ],
  "sportBanners": [ /* Sport-specific banners */ ],
  "stories": [ /* Stories */ ]
}
```

### Alert Banner

Returns the active alert banner (if any) that should be displayed prominently.

#### Endpoint

```
GET /api/promotions/v1/alert-banner
```

#### Response

```json
{
  "id": 1,
  "title": "Special Offer",
  "content": "Get 50% bonus on your first deposit!",
  "background_color": "#FF5500",
  "text_color": "#FFFFFF",
  "action_type": "internal_link",
  "action_target": "/promotions/details/1",
  "start_date": "2024-05-01T00:00:00.000000Z",
  "end_date": "2024-05-31T23:59:59.000000Z",
  "status": "published",
  "image_url": "https://example.com/images/promo-banner.jpg"
}
```

### Banners

Returns rotational promotional banners that typically appear at the top of the home screen.

#### Endpoint

```
GET /api/promotions/v1/banners
```

#### Response

```json
[
  {
    "id": 1,
    "title": "Summer Promotion",
    "subtitle": "Hot Odds for Hot Days",
    "action_type": "internal_link",
    "action_target": "/promotions/summer",
    "start_date": "2024-05-01T00:00:00.000000Z",
    "end_date": "2024-08-31T23:59:59.000000Z",
    "status": "published",
    "image_url": "https://example.com/images/summer-promo.jpg"
  }
]
```

### Sport Banners

Returns promotional banners specific to sports events.

#### Endpoint

```
GET /api/promotions/v1/sport-banners
```

#### Response

```json
[
  {
    "id": 1,
    "title": "Champions League Final",
    "subtitle": "Real Madrid vs Liverpool",
    "start_date": "2024-05-01T00:00:00.000000Z",
    "end_date": "2024-05-31T23:59:59.000000Z",
    "status": "published",
    "image_url": "https://example.com/images/cl-final.jpg",
    "sport_event_id": 12345,
    "event": {
      "id": 12345,
      "sport_id": 1,
      "home_team_id": 101,
      "away_team_id": 102,
      "date_time": "2024-05-25T20:00:00.000000Z",
      "home_team": {
        "id": 101,
        "name": "Real Madrid",
        "logo": "https://example.com/teams/real-madrid.png"
      },
      "away_team": {
        "id": 102,
        "name": "Liverpool",
        "logo": "https://example.com/teams/liverpool.png"
      },
      "market": {
        "id": 201,
        "name": "1X2",
        "outcomes": [
          {
            "id": 301,
            "name": "1",
            "price": 2.1
          },
          {
            "id": 302,
            "name": "X",
            "price": 3.5
          },
          {
            "id": 303,
            "name": "2",
            "price": 2.8
          }
        ]
      }
    }
  }
]
```

### Boosted Odds Banners

Returns banners featuring boosted odds for specific events.

#### Endpoint

```
GET /api/promotions/v1/boosted-odds-banners
```

#### Response

```json
[
  {
    "id": 1,
    "title": "Boosted: Real Madrid to Win + Both Teams to Score",
    "original_odd": 3.5,
    "boosted_odd": 4.2,
    "start_date": "2024-05-20T00:00:00.000000Z",
    "end_date": "2024-05-25T19:59:59.000000Z",
    "status": "published",
    "image_url": "https://example.com/images/boosted-madrid.jpg",
    "sport_event_id": 12345,
    "event": {
      "id": 12345,
      // Event details similar to sport banners
    }
  }
]
```

### Hero Cards

Returns hero cards for featured events or promotions.

#### Endpoint

```
GET /api/promotions/v1/hero-cards
```

#### Response

```json
[
  {
    "id": 1,
    "title": "NBA Finals Game 7",
    "subtitle": "Celtics vs Lakers",
    "action_type": "event_link",
    "action_target": "12346",
    "start_date": "2024-06-15T00:00:00.000000Z",
    "end_date": "2024-06-18T23:59:59.000000Z",
    "status": "published",
    "image_url": "https://example.com/images/nba-finals.jpg",
    "event_id": 12346,
    "event_data": {
      // Event details if applicable
    }
  }
]
```

### Stories

Returns ephemeral promotional content in a stories format (similar to Instagram/Facebook stories).

#### Endpoint

```
GET /api/promotions/v1/stories
```

#### Response

```json
[
  {
    "id": 1,
    "title": "Player Spotlight: Ronaldo",
    "content": "Cristiano Ronaldo's career achievements",
    "action_type": "external_link",
    "action_target": "https://example.com/articles/ronaldo-career",
    "start_date": "2024-05-01T00:00:00.000000Z",
    "end_date": "2024-05-08T23:59:59.000000Z",
    "status": "published",
    "image_url": "https://example.com/images/ronaldo-story.jpg",
    "duration": 5
  }
]
```

### News

Returns sports news articles promoted within the app.

#### Endpoint

```
GET /api/promotions/v1/news
```

#### Response

```json
[
  {
    "id": 1,
    "title": "Transfer News: Mbappe to Real Madrid",
    "subtitle": "French superstar set to join Spanish giants",
    "content": "Paris Saint-Germain forward Kylian Mbappe has agreed to join Real Madrid...",
    "author": "Sports Desk",
    "published_date": "2024-05-15T09:30:00.000000Z",
    "status": "published",
    "image_url": "https://example.com/images/mbappe-transfer.jpg",
    "tags": ["transfer", "football", "LaLiga", "Ligue1"]
  }
]
```

### Pro Choices

Returns curated betting suggestions from professional tipsters.

#### Endpoint

```
GET /api/promotions/v1/pro-choices
```

#### Response

```json
[
  {
    "id": 1,
    "title": "Expert Pick of the Day",
    "tipster": {
      "id": 101,
      "name": "John Expert",
      "win_rate": 0.68,
      "avatar": "https://example.com/tipsters/john.jpg"
    },
    "event": {
      "id": 12345,
      "home_team": "Real Madrid",
      "away_team": "Liverpool",
      "date_time": "2024-05-25T20:00:00.000000Z"
    },
    "selection": {
      "market_name": "1X2",
      "outcome_name": "1",
      "odds": 2.1
    },
    "reasoning": "Real Madrid has a strong home record in Champions League finals..."
  }
]
```

---

## Data Models

Here are the key data structures you'll need to implement in Swift for your iOS app:

### HomeTemplate

```swift
struct HomeTemplate: Codable {
    let id: Int
    let clientId: Int
    let title: String
    let platform: String
    let sections: [TemplateSection]
    let createdAt: Date
    let updatedAt: Date

    enum CodingKeys: String, CodingKey {
        case id, title, platform, sections
        case clientId = "client_id"
        case createdAt = "created_at"
        case updatedAt = "updated_at"
    }
}

struct TemplateSection: Codable {
    let type: String
    let title: String
    let source: String
}
```

### Promotion Models

```swift
struct AlertBanner: Codable {
    let id: Int
    let title: String
    let content: String
    let backgroundColor: String
    let textColor: String
    let actionType: String
    let actionTarget: String
    let startDate: Date
    let endDate: Date
    let status: String
    let imageUrl: String?

    enum CodingKeys: String, CodingKey {
        case id, title, content, status
        case backgroundColor = "background_color"
        case textColor = "text_color"
        case actionType = "action_type"
        case actionTarget = "action_target"
        case startDate = "start_date"
        case endDate = "end_date"
        case imageUrl = "image_url"
    }
}

struct Banner: Codable {
    let id: Int
    let title: String
    let subtitle: String?
    let actionType: String
    let actionTarget: String
    let startDate: Date
    let endDate: Date
    let status: String
    let imageUrl: String?

    enum CodingKeys: String, CodingKey {
        case id, title, subtitle, status
        case actionType = "action_type"
        case actionTarget = "action_target"
        case startDate = "start_date"
        case endDate = "end_date"
        case imageUrl = "image_url"
    }
}

struct SportBanner: Codable {
    let id: Int
    let title: String
    let subtitle: String?
    let startDate: Date
    let endDate: Date
    let status: String
    let imageUrl: String?
    let sportEventId: Int
    let event: SportEvent?

    enum CodingKeys: String, CodingKey {
        case id, title, subtitle, status, event
        case startDate = "start_date"
        case endDate = "end_date"
        case imageUrl = "image_url"
        case sportEventId = "sport_event_id"
    }
}

struct Story: Codable {
    let id: Int
    let title: String
    let content: String
    let actionType: String
    let actionTarget: String
    let startDate: Date
    let endDate: Date
    let status: String
    let imageUrl: String?
    let duration: Int

    enum CodingKeys: String, CodingKey {
        case id, title, content, status, duration
        case actionType = "action_type"
        case actionTarget = "action_target"
        case startDate = "start_date"
        case endDate = "end_date"
        case imageUrl = "image_url"
    }
}

struct NewsItem: Codable {
    let id: Int
    let title: String
    let subtitle: String?
    let content: String
    let author: String
    let publishedDate: Date
    let status: String
    let imageUrl: String?
    let tags: [String]?

    enum CodingKeys: String, CodingKey {
        case id, title, subtitle, content, author, status, tags
        case publishedDate = "published_date"
        case imageUrl = "image_url"
    }
}

struct ProChoice: Codable {
    let id: Int
    let title: String
    let tipster: Tipster
    let event: EventSummary
    let selection: Selection
    let reasoning: String

    struct Tipster: Codable {
        let id: Int
        let name: String
        let winRate: Double
        let avatar: String?

        enum CodingKeys: String, CodingKey {
            case id, name, avatar
            case winRate = "win_rate"
        }
    }

    struct EventSummary: Codable {
        let id: Int
        let homeTeam: String
        let awayTeam: String
        let dateTime: Date

        enum CodingKeys: String, CodingKey {
            case id
            case homeTeam = "home_team"
            case awayTeam = "away_team"
            case dateTime = "date_time"
        }
    }

    struct Selection: Codable {
        let marketName: String
        let outcomeName: String
        let odds: Double

        enum CodingKeys: String, CodingKey {
            case marketName = "market_name"
            case outcomeName = "outcome_name"
            case odds
        }
    }
}
```

---

## Error Handling

All endpoints may return standard HTTP error responses:

- **401 Unauthorized**: Authentication token is missing or invalid
- **403 Forbidden**: Not authorized to access this resource
- **404 Not Found**: Resource not found
- **422 Unprocessable Entity**: Validation errors
- **500 Internal Server Error**: Server-side error

Example error response:

```json
{
  "message": "Unauthenticated",
  "errors": {
    "token": ["The token has expired"]
  }
}
```

---

## Caching Strategies

The backend API implements server-side caching for most endpoints. You should implement client-side caching to optimize performance:

1. Cache home template responses with a TTL of 1 hour
2. Cache promotional content with appropriate TTLs:
   - Alert banners: 5 minutes
   - General banners: 15 minutes
   - Sport banners: 15 minutes
   - Stories: 30 minutes
   - News: 1 hour

Implement cache invalidation when:
- User logs out
- App is restarted
- Cache TTL expires


This guide should provide all the information needed to integrate the promotions and home template features into your iOS application. The API endpoints are designed to be consistent and follow RESTful patterns, making integration straightforward with Swift's modern async/await capabilities.

If you have specific questions or need further clarification about any part of the integration, please don't hesitate to ask.
````

## File: Sources/ServicesProvider/Protocols/PrivilegedAccessManager.swift
````swift
//
//  PrivilegedAccessManager.swift
//
//
//  Created by Ruben Roques on 29/09/2022.
//

import Foundation
import Combine
import SharedModels

enum UserSessionStatus {
    case anonymous
    case logged
}

protocol PrivilegedAccessManager {

    var userSessionStatePublisher: AnyPublisher<UserSessionStatus, Error> { get }
    var userProfilePublisher: AnyPublisher<UserProfile?, Error> { get }

    var hasSecurityQuestions: Bool { get }

    func login(username: String, password: String) -> AnyPublisher<UserProfile, ServiceProviderError>

    func getUserProfile(withKycExpire: String?) -> AnyPublisher<UserProfile, ServiceProviderError>
    func updateUserProfile(form: UpdateUserProfileForm) -> AnyPublisher<Bool, ServiceProviderError>

    func checkEmailRegistered(_ email: String) -> AnyPublisher<Bool, ServiceProviderError>

    func validateUsername(_ username: String) -> AnyPublisher<UsernameValidation, ServiceProviderError>

    func simpleSignUp(form: SimpleSignUpForm) -> AnyPublisher<Bool, ServiceProviderError>
    func signUp(form: SignUpForm) -> AnyPublisher<SignUpResponse, ServiceProviderError>

    func updateExtraInfo(placeOfBirth: String?, address2: String?) -> AnyPublisher<BasicResponse, ServiceProviderError>
    func updateDeviceIdentifier(deviceIdentifier: String, appVersion: String) -> AnyPublisher<BasicResponse, ServiceProviderError>

    // TODO: SP Merge - We need to understand the difference between and rename it to better understand
    func getAllCountries() -> AnyPublisher<[SharedModels.Country], ServiceProviderError>
    func getCountries() -> AnyPublisher<[SharedModels.Country], ServiceProviderError>

    func getCurrentCountry() -> AnyPublisher<SharedModels.Country?, ServiceProviderError>

    func signupConfirmation(_ email: String, confirmationCode: String) -> AnyPublisher<Bool, ServiceProviderError>

    func forgotPassword(email: String, secretQuestion: String?, secretAnswer: String?) -> AnyPublisher<Bool, ServiceProviderError>
    func updatePassword(oldPassword: String, newPassword: String) -> AnyPublisher<Bool, ServiceProviderError>
    func getPasswordPolicy() -> AnyPublisher<PasswordPolicy, ServiceProviderError>

    func updateWeeklyDepositLimits(newLimit: Double) -> AnyPublisher<Bool, ServiceProviderError>
    func updateWeeklyBettingLimits(newLimit: Double) -> AnyPublisher<Bool, ServiceProviderError>
    func updateResponsibleGamingLimits(newLimit: Double, limitType: String, hasRollingWeeklyLimits: Bool) -> AnyPublisher<Bool, ServiceProviderError>
    func getPersonalDepositLimits() -> AnyPublisher<PersonalDepositLimitResponse, ServiceProviderError>
    func getLimits() -> AnyPublisher<LimitsResponse, ServiceProviderError>
    func getResponsibleGamingLimits(periodTypes: String?, limitTypes: String?) -> AnyPublisher<ResponsibleGamingLimitsResponse, ServiceProviderError>
    func lockPlayer(isPermanent: Bool?, lockPeriodUnit: String?, lockPeriod: String?) -> AnyPublisher<BasicResponse, ServiceProviderError>

    func getUserBalance() -> AnyPublisher<UserWallet, ServiceProviderError>
    func getUserCashbackBalance() -> AnyPublisher<CashbackBalance, ServiceProviderError>

    func signUpCompletion(form: UpdateUserProfileForm)  -> AnyPublisher<Bool, ServiceProviderError>

    func getDocumentTypes() -> AnyPublisher<DocumentTypesResponse, ServiceProviderError>
    func getUserDocuments() -> AnyPublisher<UserDocumentsResponse, ServiceProviderError>
    func uploadUserDocument(documentType: String, file: Data, fileName: String) -> AnyPublisher<UploadDocumentResponse, ServiceProviderError>
    func uploadMultipleUserDocuments(documentType: String, files: [String: Data]) -> AnyPublisher<UploadDocumentResponse, ServiceProviderError>

    func getPayments() -> AnyPublisher<SimplePaymentMethodsResponse, ServiceProviderError>
    func processDeposit(paymentMethod: String, amount: Double, option: String) -> AnyPublisher<ProcessDepositResponse, ServiceProviderError>
    func depositOnWallet(amount: Double) -> AnyPublisher<Bool, ServiceProviderError>
    func updatePayment(amount: Double, paymentId: String, type: String, returnUrl: String?, nameOnCard: String?, encryptedExpiryYear: String?, encryptedExpiryMonth: String?, encryptedSecurityCode: String?, encryptedCardNumber: String?) -> AnyPublisher<UpdatePaymentResponse, ServiceProviderError>
    func cancelDeposit(paymentId: String) -> AnyPublisher<BasicResponse, ServiceProviderError>
    func checkPaymentStatus(paymentMethod: String, paymentId: String) -> AnyPublisher<PaymentStatusResponse, ServiceProviderError>

    func getWithdrawalMethods() -> AnyPublisher<[WithdrawalMethod], ServiceProviderError>
    func processWithdrawal(paymentMethod: String, amount: Double, conversionId: String?) -> AnyPublisher<ProcessWithdrawalResponse, ServiceProviderError>
    func prepareWithdrawal(paymentMethod: String) -> AnyPublisher<PrepareWithdrawalResponse, ServiceProviderError>

    func getPendingWithdrawals() -> AnyPublisher<[PendingWithdrawal], ServiceProviderError>
    func cancelWithdrawal(paymentId: Int) -> AnyPublisher<CancelWithdrawalResponse, ServiceProviderError>
    func getPaymentInformation() -> AnyPublisher<PaymentInformation, ServiceProviderError>
    func addPaymentInformation(type: String, fields: String) -> AnyPublisher<AddPaymentInformationResponse, ServiceProviderError>

    func getTransactionsHistory(startDate: String, endDate: String, transactionTypes: [TransactionType]?, pageNumber: Int?) -> AnyPublisher<[TransactionDetail], ServiceProviderError>

    func getGrantedBonuses() -> AnyPublisher<[GrantedBonus], ServiceProviderError>
    func redeemBonus(code: String) -> AnyPublisher<RedeemBonusResponse, ServiceProviderError>
    func getAvailableBonuses() -> AnyPublisher<[AvailableBonus], ServiceProviderError>
    func redeemAvailableBonus(partyId: String, code: String) -> AnyPublisher<BasicResponse, ServiceProviderError>
    func cancelBonus(bonusId: String) -> AnyPublisher<BasicResponse, ServiceProviderError>
    func optOutBonus(partyId: String, code: String) -> AnyPublisher<BasicResponse, ServiceProviderError>

    // TODO: SP Merge - Extract this into a new "SupportProvider"
    func contactUs(firstName: String, lastName: String, email: String, subject: String, message: String) -> AnyPublisher<BasicResponse, ServiceProviderError>
    func contactSupport(userIdentifier: String, firstName: String, lastName: String, email: String, subject: String, subjectType: String , message: String, isLogged: Bool) -> AnyPublisher<SupportResponse, ServiceProviderError>

    func getAllConsents() -> AnyPublisher<[ConsentInfo], ServiceProviderError>

    func getUserConsents() -> AnyPublisher<[UserConsent], ServiceProviderError>

    func setUserConsents(consentVersionIds: [Int]?, unconsenVersionIds: [Int]?) -> AnyPublisher<BasicResponse, ServiceProviderError>

    func getSumsubAccessToken(userId: String, levelName: String) -> AnyPublisher<AccessTokenResponse, ServiceProviderError>

    func getSumsubApplicantData(userId: String) -> AnyPublisher<ApplicantDataResponse, ServiceProviderError>

    func generateDocumentTypeToken(docType: String) -> AnyPublisher<AccessTokenResponse, ServiceProviderError>

    func checkDocumentationData() -> AnyPublisher<ApplicantDataResponse, ServiceProviderError>

    func getMobileVerificationCode(forMobileNumber mobileNumber: String) -> AnyPublisher<MobileVerifyResponse, ServiceProviderError>
    func verifyMobileCode(code: String, requestId: String) -> AnyPublisher<MobileVerifyResponse, ServiceProviderError>

    func getReferralLink() -> AnyPublisher<ReferralLink, ServiceProviderError>
    func getReferees() -> AnyPublisher<[Referee], ServiceProviderError>

    func getFollowees() -> AnyPublisher<[Follower], ServiceProviderError>
    func getTotalFollowees() -> AnyPublisher<Int, ServiceProviderError>
    func getFollowers() -> AnyPublisher<[Follower], ServiceProviderError>
    func getTotalFollowers() -> AnyPublisher<Int, ServiceProviderError>
    func addFollowee(userId: String) -> AnyPublisher<[String], ServiceProviderError>
    func removeFollowee(userId: String) -> AnyPublisher<[String], ServiceProviderError>

    func getTipsRankings(type: String?, followers: Bool?) -> AnyPublisher<[TipRanking], ServiceProviderError>
    func getUserProfileInfo(userId: String) -> AnyPublisher<UserProfileInfo, ServiceProviderError>
    func getUserNotifications() -> AnyPublisher<UserNotificationsSettings, ServiceProviderError>
    func updateUserNotifications(settings: UserNotificationsSettings) -> AnyPublisher<Bool, ServiceProviderError>

    func getFriendRequests() -> AnyPublisher<[FriendRequest], ServiceProviderError>
    func getFriends() -> AnyPublisher<[GomaFriend], ServiceProviderError>
    func addFriends(userIds: [String], request: Bool) -> AnyPublisher<AddFriendResponse, ServiceProviderError>
    func removeFriend(userId: Int) -> AnyPublisher<String, ServiceProviderError>
    func getChatrooms() -> AnyPublisher<[ChatroomData], ServiceProviderError>
    func addGroup(name: String, userIds: [String]) -> AnyPublisher<ChatroomId, ServiceProviderError>
    func deleteGroup(id: Int) -> AnyPublisher<String, ServiceProviderError>
    func editGroup(id: Int, name: String) -> AnyPublisher<String, ServiceProviderError>
    func leaveGroup(id: Int) -> AnyPublisher<String, ServiceProviderError>
    func addUsersToGroup(groupId: Int, userIds: [String]) -> AnyPublisher<String, ServiceProviderError>
    func removeUsersToGroup(groupId: Int, userIds: [String]) -> AnyPublisher<String, ServiceProviderError>
    func searchUserWithCode(code: String) -> AnyPublisher<SearchUser, ServiceProviderError>
}
````

## File: Sources/ServicesProvider/Protocols/PromotionsProvider.swift
````swift
//
//  PromotionsProvider.swift
//  ServicesProvider
//
//  Created by Ruben Roques on 19/02/2025.
//


//
//  PromotionsProvider.swift
//  
//
//  Created by André Lascas on 16/08/2024.
//

import Foundation
import Combine
import SharedModels

protocol PromotionsProvider {
    
    var userSessionStatePublisher: AnyPublisher<UserSessionStatus, Error> { get }
    var userProfilePublisher: AnyPublisher<UserProfile?, Error> { get }
    var providerEnabled: Bool { get }
    
    func updateDeviceIdentifier(deviceIdentifier: String) -> AnyPublisher<BasicResponse, ServiceProviderError>
    
    func isPromotionsProviderEnabled(isEnabled: Bool) -> AnyPublisher<Bool, ServiceProviderError>
    
    func login(username: String, password: String) -> AnyPublisher<UserProfile, ServiceProviderError>
    
    func anonymousLogin() -> AnyPublisher<String, ServiceProviderError>
            
    func logoutUser() -> AnyPublisher<String, ServiceProviderError>
    
    func basicSignUp(form: SignUpForm) -> AnyPublisher<DetailedSignUpResponse, ServiceProviderError>
    
}
````

## File: Sources/ServicesProvider/Providers/Everymatrix/EverymatrixProvider.swift
````swift
//
//  EverymatrixProvider.swift
//  
//
//  Created by Ruben Roques on 29/09/2022.
//

import Foundation

class EverymatrixProvider {
    
}
//
//extension EverymatrixProvider: PrivilegedAccessManager {
//
//}
//
//extension EverymatrixProvider: BettingProvider {
//
//}
//
//extension EverymatrixProvider: EventsProvider {
//    func connect() {
//
//    }
//}
````

## File: Sources/ServicesProvider/Providers/Goma/APIs/GomaAPIClient.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 18/12/2023.
//

import Foundation

extension GomaAPIClient {
    enum ArgumentModels {
        
        struct BetSelection {
            let eventId: String
            let outcomeId: String
        }

    }
}

enum GomaAPIClient {
    case anonymousAuth(deviceId: String, pushToken: String?)
    case login(username: String, password: String, pushToken: String?)
    case register(name: String, email: String, username: String, password: String, avatarName: String, deviceToken: String? = nil)
    case requestPasswordResetEmail(email: String)
    case updatePassword(oldPassword: String, password: String, passwordConfirmation: String)
    case logout
    case getSports
    
    case getHomeContents
    case getHomeAlerts
    case getBanners
    case getStories
    case getHighlights
    case getPopularEventPointers
    case getPopularEvents
    case getEventsBanners
    case getFeaturedCompetitions
    case getAlertBanners
    case getNews
    case getHeroCards
    case getBoostedOddEvents
    
    case getTrendingEvents(sportCode: String, page: Int)
    case getUpcomingEvents(sportCode: String, page: Int)
    case getLiveEvents(sportCode: String, page: Int)
    case getEndedEvents(sportCode: String, page: Int)
    
    case getRegions(sportCode: String)
    
    case getCompetitionDetails(identifier: String)
    
    case getCompetitions(regionId: String)
    case getEventsFromCompetition(competitionId: String)
    
    case getEventDetails(identifier: String)
    case getEventMarkets(identifier: String, limit: Int?)
    
    case getFeaturedTips(page: Int?, limit: Int?, topTips: Bool?, followersTips: Bool?, friendsTips: Bool?, userId: String?, homeTips: Bool?)

    case getFavorites
    case addFavorite(favoriteId: Int, type: String)
    case deleteFavorite(favoriteId: Int, type: String)
    
    case getMyTickets(states: [GomaModels.MyTicketStatus]?, limit: String, page: String)
    case getTicketDetails(betId: String)
    case updateTicketOdds(betId: String)
    case getTicketQRCode(betId: String)
    case deleteTicket(betId: String)
    case updateTicket(betId: String, betTicket: BetTicket) // Specify selections

    case getSharedTicket(sharedId: String)
    
    case search(query: String)

    case getAllowedBetTypes(selections: [Self.ArgumentModels.BetSelection])
    case getCalculatePossibleBetResult(stake: Double, type: GomaModels.BetType, selections: [Self.ArgumentModels.BetSelection])

    case placeBetTicket(betTicket: BetTicket, useCashback: Bool)
    
    case getFollowees
    case getTotalFollowees
    case getFollowers
    case getTotalFollowers
    case addFollowee(userId: String)
    case removeFollowee(userId: String)

    case getTipsRankings(type: String?, followers: Bool?)

    case closeAccount

    case getUserProfile(userId: String)

    case getUserNotificationsSettings
    case updateUserNotificationsSettings(settings: GomaModels.UserNotificationsSettings)

    case updatePersonalInfo(fullname: String, avatar: String)

    case getUserWallet
    case addAmoutToUserWallet(amount: Double)
    
    //CHAT ENDPOINTS
    case getFriendRequests
    case getFriends
    case addFriends(userIds: [String], request: Bool)
    case removeFriend(userId: Int)
    case getChatrooms
    case addGroup(name: String, userIds: [String])
    case deleteGroup(id: Int)
    case editGroup(id: Int, name: String)
    case leaveGroup(id: Int)
    case addUsersFromGroup(groupId: Int, userIds: [String])
    case removeUsersFromGroup(groupId: Int, userIds: [String])
    case searchUserWithCode(code: String)
}

extension GomaAPIClient: Endpoint {
    
    var url: String {
        return "https://api.gomademo.com/"
    }
    
    private static var version: String {
        return "v1"
    }
    
    var endpoint: String {
        switch self {
        case .anonymousAuth:
            return "/api/auth/\(Self.version)"
        case .login:
            return "/api/auth/\(Self.version)/login"
        case .register:
            return "/api/auth/\(Self.version)/register"
        case .requestPasswordResetEmail:
            return "/api/users/\(Self.version)/password/forgot"
        case .updatePassword:
            return "/api/users/\(Self.version)/password"
        case .logout:
            return "/api/auth/\(Self.version)/logout"
        case .getSports:
            return "/api/sports/\(Self.version)"
        
        case .getHomeContents:
            return "/api/promotions/\(Self.version)/home"
        case .getHomeAlerts:
            return "/api/promotions/\(Self.version)/alert-banner"

        case .getBanners:
            return "/api/promotions/\(Self.version)/banners"
        case .getStories:
            return "/api/promotions/\(Self.version)/stories"
        case .getHighlights:
            return "/api/events/\(Self.version)/highlights"
        case .getPopularEventPointers:
            return "/api/events/\(Self.version)/popular"
        case .getPopularEvents:
            return "/api/events/\(Self.version)/popular"
        case .getAlertBanners:
            return "/api/promotions/\(Self.version)/alert-banner"
        case .getNews:
            return "/api/promotions/\(Self.version)/news"
        case .getHeroCards:
            return "/api/promotions/\(Self.version)/hero-cards"
        case .getBoostedOddEvents:
            return "/api/promotions/\(Self.version)/boosted-odds-banners"
            
        case .getEventsBanners:
            return "/api/promotions/\(Self.version)/sport-banners"
        case .getFeaturedCompetitions:
            return "/api/competitions/\(Self.version)/featured"
        
        
        case .getTrendingEvents:
            return "/api/events/\(Self.version)/trending"
        case .getUpcomingEvents:
            return "/api/events/\(Self.version)/upcoming"
        case .getLiveEvents:
            return "/api/events/\(Self.version)/live"
        case .getEndedEvents:
            return "/api/events/\(Self.version)/scores"
            
            
        case .getRegions:
            return "/api/regions/\(Self.version)"
        case .getCompetitions:
            return "/api/competitions/\(Self.version)"
        case .getCompetitionDetails(let identifier):
            return "/api/competitions/\(Self.version)/\(identifier)"
        case .getEventsFromCompetition(let competitionId):
            return "/api/competitions/\(Self.version)/\(competitionId)/events"
            
        case .getEventDetails(let identifier):
            return "/api/events/\(Self.version)/\(identifier)"
        case .getEventMarkets(let identifier, _):
            return "/api/events/\(Self.version)/\(identifier)/markets"
            
        case .getFeaturedTips:
            return "/api/tips/\(Self.version)"

        case .getFavorites:
            return "/api/events/\(Self.version)/favorites"
        case .addFavorite:
            return "/api/events/\(Self.version)/favorites"
        case .deleteFavorite:
            return "/api/events/\(Self.version)/favorites"
            
        case .getAllowedBetTypes:
            return "/api/tickets/\(Self.version)/allowed-types"
            
        case .getCalculatePossibleBetResult:
            return "/api/tickets/\(Self.version)/calculate"
            
        case .placeBetTicket:
            return "/api/tickets/\(Self.version)"

        case .getMyTickets:
            return "/api/tickets/\(Self.version)"
        case .getTicketDetails(let betId):
            return "/api/tickets/\(Self.version)/\(betId)"
        case .updateTicketOdds(let betId):
            return "/api/tickets/\(Self.version)/\(betId)/refresh"
        case .getTicketQRCode(let betId):
            return "/api/tickets/\(Self.version)/\(betId)/qrcode"
        case .deleteTicket(let betId):
            return "/api/tickets/\(Self.version)/\(betId)"
        case .updateTicket(let betId, _):
            return "/api/tickets/\(Self.version)/\(betId)"
        case .getSharedTicket(let sharedId):
            return "/api/tickets/\(Self.version)/share/\(sharedId)"
            
        case .search:
            return "/api/search/\(Self.version)"
            
        case .getFollowees:
            return "/api/social/\(Self.version)/followees"
        case .getTotalFollowees:
            return "/api/social/\(Self.version)/followees/total"
        case .getFollowers:
            return "/api/social/\(Self.version)/followers"
        case .getTotalFollowers:
            return "/api/social/\(Self.version)/followers/total"
        case .addFollowee:
            return "/api/social/\(Self.version)/followees"
        case .removeFollowee:
            return "/api/social/\(Self.version)/followees"
            
        case .getTipsRankings:
            return "/api/tips/\(Self.version)/rankings"
            
        case .closeAccount:
            return "/api/users/\(Self.version)"
            
        case .getUserProfile(let userId):
            return "/api/tips/\(Self.version)/user-profile/\(userId)"
        
        case .getUserNotificationsSettings:
            return "/api/users/\(Self.version)/settings"
        case .updateUserNotificationsSettings:
            return "/api/users/\(Self.version)/settings"
            
        case .updatePersonalInfo:
            return "/api/users/\(Self.version)"
            
        case .getUserWallet:
            return "/api/users/\(Self.version)/wallets"
        case .addAmoutToUserWallet:
            return "/api/users/\(Self.version)/wallets"
            
        case .getFriendRequests:
            return "/api/social/\(Self.version)/friends/pending"
        case .getFriends:
            return "/api/social/\(Self.version)/friends"
        case .addFriends:
            return "/api/social/\(Self.version)/friends"
        case .removeFriend(let userId):
            return "/api/social/\(Self.version)/friends/\(userId)"
        case .getChatrooms:
            return "/api/social/\(Self.version)/chatrooms"
        case .addGroup:
            return "/api/social/\(Self.version)/groups"
        case .deleteGroup(let id):
            return "/api/social/\(Self.version)/groups/\(id)"
        case .editGroup(let id, _):
            return "/api/social/\(Self.version)/groups/\(id)"
        case .leaveGroup(let id):
            return "/api/social/\(Self.version)/groups/\(id)/users/leave"
        case .addUsersFromGroup(let groupId, _):
            return "/api/social/\(Self.version)/groups/\(groupId)/users"
        case .removeUsersFromGroup(let groupId, _):
            return "/api/social/\(Self.version)/groups/\(groupId)/users"
        case .searchUserWithCode(let code):
            return "/api/users/v1/code/\(code)"
        }
    }
    
    var query: [URLQueryItem]? {
        switch self {
        case .anonymousAuth:
            return nil
        case .login:
            return nil
        case .register:
            return nil
        case .requestPasswordResetEmail:
            return nil    
        case .updatePassword:
            return nil
        case .logout:
            return nil
        case .getSports:
            return nil
        
        case .getHomeContents:
            return nil
        case .getHomeAlerts:
            return nil
        case .getBanners:
            return nil
        case .getStories:
            return nil
        case .getHighlights:
            return nil
        case .getPopularEventPointers:
            return nil
        case .getPopularEvents:
            return nil
        case .getEventsBanners:
            return nil
        case .getFeaturedCompetitions:
            return nil
        case .getAlertBanners:
            return nil
        case .getNews:
            return nil
        case .getHeroCards:
            return nil
        case .getBoostedOddEvents:
            return nil
            
        case .getTrendingEvents(let sportCode, let page):
            return [
                URLQueryItem(name: "sport_id", value: sportCode),
                URLQueryItem(name: "page", value: "\(page)")
            ]
        case .getUpcomingEvents(let sportCode, let page):
            return [
                URLQueryItem(name: "sport_id", value: sportCode),
                URLQueryItem(name: "page", value: "\(page)")
            ]
        case .getLiveEvents(let sportCode, let page):
            return [
                URLQueryItem(name: "sport_id", value: sportCode),
                URLQueryItem(name: "page", value: "\(page)")
            ]
        case .getEndedEvents(let sportCode, let page):
            return [
                URLQueryItem(name: "sport_id", value: sportCode),
                URLQueryItem(name: "page", value: "\(page)")
            ]
            
        case .getRegions(let sportCode):
            return [
                URLQueryItem(name: "sport_id", value: sportCode)
            ]
            
        case .getCompetitionDetails:
            return nil
        case .getCompetitions(let regionId):
            return [
                URLQueryItem(name: "region_id", value: regionId)
            ]
        case .getEventsFromCompetition:
            return nil
            
        case .getEventDetails:
            return nil
        case .getEventMarkets(_, let limit):
            
            var queryItemsURL: [URLQueryItem] = []

            if let limitValue = limit {
                let queryItem = URLQueryItem(name: "limit", value: "\(limitValue)")
                queryItemsURL.append(queryItem)
            }
            
            if !queryItemsURL.isEmpty {
                return queryItemsURL
            }
            
            return nil
            
        case .getFeaturedTips(let page, let limit, let topTips, let followersTips, let friendsTips, let userId, let homeTips):
            
            var queryItemsURL: [URLQueryItem] = []

            if let page {
                let queryItem = URLQueryItem(name: "page", value: "\(page)")
                queryItemsURL.append(queryItem)
            }
            
            if let limit {
                let queryItem = URLQueryItem(name: "limit", value: "\(limit)")
                queryItemsURL.append(queryItem)
            }
            
            if let topTips {
                let topValue = topTips ? 1 : 0
                let queryItem = URLQueryItem(name: "top", value: "\(topValue)")
                queryItemsURL.append(queryItem)
            }
            
            if let followersTips {
                let followersValue = followersTips ? 1 : 0
                let queryItem = URLQueryItem(name: "followers", value: "\(followersValue)")
                queryItemsURL.append(queryItem)
            }
            
            if let friendsTips {
                let friendsValue = friendsTips ? 1 : 0
                let queryItem = URLQueryItem(name: "friends", value: "\(friendsValue)")
                queryItemsURL.append(queryItem)
            }
            
            if let userId {
                let queryItem = URLQueryItem(name: "user_id", value: "\(userId)")
                queryItemsURL.append(queryItem)
            }
            
            if let homeTips {
                let homeValue = homeTips ? 1 : 0
                let queryItem = URLQueryItem(name: "home", value: "\(homeValue)")
                queryItemsURL.append(queryItem)
            }
            
            if !queryItemsURL.isEmpty {
                return queryItemsURL
            }
            
            return nil

        case .getFavorites:
            return nil
        case .addFavorite:
            return nil
        case .deleteFavorite:
            return nil
            
        case .getAllowedBetTypes(let selections):
            var queryItems = [URLQueryItem]()
            for (index, selection) in selections.enumerated() {
                queryItems.append(contentsOf: [
                    URLQueryItem(name: "selections[\(index)][sport_event_id]", value: selection.eventId),
                    URLQueryItem(name: "selections[\(index)][outcome_id]", value: selection.outcomeId)
                ])
            }
            return queryItems
            
        case .getCalculatePossibleBetResult(let stake, let type, let selections):
            var queryItems = [
                URLQueryItem(name: "stake", value: "\(stake)"),
                URLQueryItem(name: "type", value: type.identifier)
            ]
            for (index, selection) in selections.enumerated() {
                queryItems.append(contentsOf: [
                    URLQueryItem(name: "selections[\(index)][sport_event_id]", value: selection.eventId),
                    URLQueryItem(name: "selections[\(index)][outcome_id]", value: selection.outcomeId)
                ])
            }
            return queryItems
            
        case .placeBetTicket:
            return nil
            
        case .getMyTickets(let betStates, let limit, let page):
            
            var query: [URLQueryItem] = []
            
            if let betStates = betStates?.map(\.rawValue) {
                for betState in betStates {
                    query.append(URLQueryItem(name: "status[]", value: "\(betState)"))
                }
            }
            
            query.append(URLQueryItem(name: "limit", value: "\(limit)"))

            query.append(URLQueryItem(name: "page", value: "\(page)"))
            
            return query
        case .getTicketDetails:
            return nil
        case .updateTicketOdds:
            return nil
        case .getTicketQRCode:
            return nil
        case .deleteTicket:
            return nil
        case .updateTicket:
            return nil
        case .getSharedTicket:
            return nil
            
        case .search(let query):
            return [
                URLQueryItem(name: "value", value: query)
            ]
            
        case .getFollowees:
            return nil
        case .getTotalFollowees:
            return nil
        case .getFollowers:
            return nil
        case .getTotalFollowers:
            return nil
        case .addFollowee:
            return nil
        case .removeFollowee:
            return nil
            
        case .getTipsRankings(let type, let followers):
            
            var queryItemsURL: [URLQueryItem] = []

            if let type {
                let queryItem = URLQueryItem(name: "type", value: "\(type)")
                queryItemsURL.append(queryItem)
            }
            
            if let followers {
                let followersValue = followers ? 1 : 0
                let queryItem = URLQueryItem(name: "followers", value: "\(followersValue)")
                queryItemsURL.append(queryItem)
            }
            
            if !queryItemsURL.isEmpty {
                return queryItemsURL
            }
            
            return nil
            
        case .closeAccount:
            return nil
            
        case .getUserProfile:
            return nil

        case .getUserNotificationsSettings:
            return nil
        case .updateUserNotificationsSettings:
            return nil
            
        case .updatePersonalInfo:
            return nil
            
        case .getUserWallet:
            return nil
        case .addAmoutToUserWallet:
            return nil
            
        case .getFriendRequests:
            return nil
        case .getFriends:
            return nil
        case .addFriends:
            return nil
        case .removeFriend:
            return nil
        case .getChatrooms:
            return nil
        case .addGroup:
            return nil
        case .deleteGroup:
            return nil
        case .editGroup:
            return nil
        case .leaveGroup:
            return nil
        case .addUsersFromGroup:
            return nil
        case .removeUsersFromGroup:
            return nil
        case .searchUserWithCode:
            return nil
        }
        
    }
    
    var method: HTTP.Method {
        switch self {
        case .anonymousAuth: 
            return .post
        case .login:
            return .post
        case .register:
            return .post
        case .requestPasswordResetEmail:
            return .post  
        case .updatePassword:
            return .post
        case .logout:
            return .post
        case .getSports:
            return .get

        case .getHomeContents:
            return .get
        case .getHomeAlerts:
            return .get
        case .getBanners:
            return .get
        case .getStories:
            return .get
        case .getHighlights:
            return .get
        case .getPopularEventPointers:
            return .get
        case .getPopularEvents:
            return .get
        case .getAlertBanners:
            return .get
        case .getNews:
            return .get
        case .getHeroCards:
            return .get
        case .getBoostedOddEvents:
            return .get
            
        case .getEventsBanners:
            return .get
        case .getFeaturedCompetitions:
            return .get
            
        case .getTrendingEvents:
            return .get
        case .getUpcomingEvents:
            return .get
        case .getLiveEvents:
            return .get
        case .getEndedEvents:
            return .get
            
        case .getRegions:
            return .get
        case .getCompetitionDetails:
            return .get
        case .getCompetitions:
            return .get
        case .getEventsFromCompetition:
            return .get
            
        case .getEventDetails:
            return .get
        case .getEventMarkets:
            return .get
            
        case .getFeaturedTips:
            return .get

        case .getFavorites:
            return .get
        case .addFavorite:
            return .post
        case .deleteFavorite:
            return .delete
            
        case .getAllowedBetTypes:
            return .get
        case .getCalculatePossibleBetResult:
            return .get
        case .placeBetTicket:
            return .post

        case .getMyTickets:
            return .get
        case .getTicketDetails:
            return .get
        case .updateTicketOdds:
            return .post
        case .getTicketQRCode:
            return .get
        case .deleteTicket:
            return .delete
        case .updateTicket:
            return .post
        case .getSharedTicket:
            return .get
            
        case .search:
            return .get
            
        case .getFollowees:
            return .get
        case .getTotalFollowees:
            return .get
        case .getFollowers:
            return .get
        case .getTotalFollowers:
            return .get
        case .addFollowee:
            return .post
        case .removeFollowee:
            return .delete
            
        case .getTipsRankings:
            return .get
            
        case .closeAccount:
            return .delete
            
        case .getUserProfile:
            return .get

        case .getUserNotificationsSettings:
            return .get
        case .updateUserNotificationsSettings:
            return .post
            
        case .updatePersonalInfo:
            return .post
            
        case .getUserWallet:
            return .get
        case .addAmoutToUserWallet:
            return .post
            
        case .getFriendRequests:
            return .get
        case .getFriends:
            return .get
        case .addFriends:
            return .post
        case .removeFriend:
            return .delete
        case .getChatrooms:
            return .get
        case .addGroup:
            return .post
        case .deleteGroup:
            return .delete
        case .editGroup:
            return .post
        case .leaveGroup:
            return .post
        case .addUsersFromGroup:
            return .post
        case .removeUsersFromGroup:
            return .delete
        case .searchUserWithCode:
            return .get
        }
    }
    
    var body: Data? {
        switch self {
        case .anonymousAuth(let deviceId,
                            let pushToken):
            let body = """
                       {
                        "device_uuid": "\(deviceId)",
                        "device_type": "ios",
                        "device_token": "\(pushToken ?? "")"
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
        case .login(let username,
                    let password,
                    let pushToken):
            let body = """
                       {
                        "username": "\(username)",
                        "password": "\(password)",
                        "device_type": "ios",
                        "device_token": "\(pushToken ?? "")"
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
        case .register(let name,
                       let email,
                       let username,
                       let password,
                       let avatarName,
                       _):
            let body = """
                       {
                        "name": "\(name)",
                        "email": "\(email)",
                        "username": "\(username)",
                        "password": "\(password)",
                        "avatar": "\(avatarName)"
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
            
        case .requestPasswordResetEmail(let email):
            let body = """
                       {
                        "email": "\(email)"
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data    
        case .updatePassword(let oldPassword, let password, let passwordConfirmation):
            let body = """
                       {
                        "password": "\(password)",
                        "password_confirmation": "\(passwordConfirmation)",
                        "current_password": "\(oldPassword)"
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
        case .logout:
            return nil
        case .getSports:
            return nil
            
        case .getHomeContents:
            return nil
        case .getHomeAlerts:
            return nil
        case .getBanners:
            return nil
        case .getStories:
            return nil
        case .getHighlights:
            return nil
        case .getPopularEventPointers:
            return nil
        case .getPopularEvents:
            return nil
        case .getAlertBanners:
            return nil
        case .getNews:
            return nil
        case .getHeroCards:
            return nil
        case .getBoostedOddEvents:
            return nil
            
        case .getEventsBanners:
            return nil
        case .getFeaturedCompetitions:
            return nil
            
        case .getTrendingEvents:
            return nil
        case .getUpcomingEvents:
            return nil
        case .getLiveEvents:
            return nil
        case .getEndedEvents:
            return nil
            
        case .getRegions:
            return nil
        case .getCompetitionDetails:
            return nil
        case .getCompetitions:
            return nil
        case .getEventsFromCompetition:
            return nil
            
        case .getEventDetails:
            return nil
        case .getEventMarkets:
            return nil
            
        case .getFeaturedTips:
            return nil

        case .getFavorites:
            return nil    
        case .addFavorite(let favoriteId, let type):
            let body = """
                       {
                        "favorites": [
                            {
                                "favorite_id": "\(favoriteId)",
                                "type": "\(type)"
                            }
                        ]
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
        case .deleteFavorite(let favoriteId, let type):
            let body = """
                       {
                        "favorites": [
                            {
                                "favorite_id": "\(favoriteId)",
                                "type": "\(type)"
                            }
                        ]
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
            
        case .getAllowedBetTypes:
            return nil
        case .getCalculatePossibleBetResult:
            return nil
            
        case .placeBetTicket(let betTicket, let useCashback):
            let dataString = Self.jsonData(from: betTicket, withCashback: useCashback, withId: nil)
            return dataString.data(using: String.Encoding.utf8)!
        
        case .getMyTickets:
            return nil
        case .getTicketDetails:
            return nil
        case .updateTicketOdds:
            return nil
        case .getTicketQRCode:
            return nil
        case .deleteTicket:
            return nil
        case .updateTicket(let betTicketId , let betTicket):
            let dataString = Self.jsonData(from: betTicket, withCashback: nil, withId: betTicketId)
            return dataString.data(using: String.Encoding.utf8)!
        
        case .getSharedTicket:
            return nil
            
        case .search:
            return nil
            
        case .getFollowees:
            return nil
        case .getTotalFollowees:
            return nil
        case .getFollowers:
            return nil
        case .getTotalFollowers:
            return nil
        case.addFollowee(let userId):
            let body = """
                       {
                        "users_ids": [\(userId)]
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
        case .removeFollowee(let userId):
            let body = """
                       {
                        "users_ids": [\(userId)]
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
        
        case .getTipsRankings:
            return nil
            
        case .closeAccount:
            return nil
            
        case .getUserProfile:
            return nil

        case .getUserNotificationsSettings:
            return nil
        case .updateUserNotificationsSettings(let settings):
            let encoder = JSONEncoder()
            guard
                let jsonData = try? encoder.encode(settings)
            else {
                return nil
            }
            return jsonData
            
        case .updatePersonalInfo(let fullname, let avatar):
            let body = """
                       {
                        "name": "\(fullname)",
                        "avatar": "\(avatar)"
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
            
        case .getUserWallet:
            return nil
        case .addAmoutToUserWallet(let amount):
            let body = """
                       {
                        "value": "\(amount)"
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
            
        case .getFriendRequests:
            return nil
        case .getFriends:
            return nil
        case .addFriends(let userIds, let request):
            var body = """
                    {"users_ids":
                    \(userIds)
                    }
                    """
            
            if request {
                body = """
                        {"users_ids": \(userIds),
                        "request": 1
                        }
                        """
            }
            let data = body.data(using: String.Encoding.utf8)!
            return data
        case .removeFriend:
            return nil
        case .getChatrooms:
            return nil
        case .addGroup(let name, let userIds):
            let body = """
                    {
                    "name": "\(name)",
                    "users_ids": \(userIds)
                    }
                    """
            let data = body.data(using: String.Encoding.utf8)!
            return data
        case .deleteGroup:
            return nil
        case .editGroup(_, let name):
            let body = """
                    {
                    "name": "\(name)"
                    }
                    """
            let data = body.data(using: String.Encoding.utf8)!
            return data
        case .leaveGroup:
            return nil
        case .addUsersFromGroup(_, let userIds):
            let body = """
                    {"users_ids":
                    \(userIds)
                    }
                    """
            let data = body.data(using: String.Encoding.utf8)!
            return data
        case .removeUsersFromGroup(_, let userIds):
            let body = """
                    {"users_ids":
                    \(userIds)
                    }
                    """
            let data = body.data(using: String.Encoding.utf8)!
            return data
        case .searchUserWithCode:
            return nil
        }
        
    }
    
    var headers: HTTP.Headers? {
        switch self {
        default:
            let defaultHeaders = [
                "Content-Type": "application/json",
                "Accept": "application/json",
                "App-Origin": "ios",
//                "x-api-key": "J3uLrOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSFsTHbG"
            ]
            return defaultHeaders
        }
    }
    
    var cachePolicy: URLRequest.CachePolicy {
        return .reloadIgnoringLocalCacheData
    }
    
    var timeout: TimeInterval {
        return TimeInterval(20)
    }
    
    var requireSessionKey: Bool {
        switch self {
        case .anonymousAuth:
            return false
        default:
            return true
        }
    }
    
    var comment: String? {
        return nil
    }
    
}

extension GomaAPIClient {
    
    private static func jsonData(from betTicket: BetTicket, withCashback useCashback: Bool?, withId ticketId: String?) -> String {
        struct RequestBody: Codable {
            
            var stake: Double
            var type: String
            var selections: [Selection]
            var bettingTicketId: Int?
            var useCashback: Bool?
            
            enum CodingKeys: String, CodingKey {
                case stake = "stake"
                case type = "type"
                case selections = "selections"
                case bettingTicketId = "bettingTicket_id"
                case useCashback = "cashback"
            }
            
            init(stake: Double, type: String, selections: [Selection], bettingTicketId: Int? = nil, useCashback: Bool?) {
                self.stake = stake
                self.type = type
                self.selections = selections
                self.bettingTicketId = bettingTicketId
                self.useCashback = useCashback
            }
            
            
            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.stake = try container.decode(Double.self, forKey: .stake)
                self.type = try container.decode(String.self, forKey: .type)
                self.selections = try container.decode([Selection].self, forKey: .selections)
                self.bettingTicketId = try container.decode(Int.self, forKey: .bettingTicketId)
                self.useCashback = try container.decode(Bool.self, forKey: .useCashback)
            }
            
            func encode(to encoder: Encoder) throws {
                var container = encoder.container(keyedBy: CodingKeys.self)
                try container.encode(self.stake, forKey: .stake)
                try container.encode(self.type, forKey: .type)
                try container.encode(self.selections, forKey: .selections)
                if let bettingTicketId = self.bettingTicketId {
                    try container.encode(bettingTicketId, forKey: .bettingTicketId)
                }
                if let useCashback = self.useCashback {
                    try container.encode(useCashback, forKey: .useCashback)
                }
            }
        }

        struct Selection: Codable {
            var sport_event_id: String
            var outcome_id: String
        }

        let selections = betTicket.tickets.compactMap { ticket -> Selection? in
            guard 
                let eventId = ticket.eventId,
                let outcomeId = ticket.outcomeId
            else {
                return nil
            }
            return Selection(sport_event_id: eventId, outcome_id: outcomeId)
        }
        
        let bettingTicketIdInt: Int? = Int(ticketId ?? "")
        let requestBody = RequestBody(
            stake: betTicket.globalStake ?? 0, // Assuming a default stake if not provided
            type: betTicket.betGroupingType.identifier,
            selections: selections,
            bettingTicketId: bettingTicketIdInt,
            useCashback: useCashback
        )
        
        let encoder = JSONEncoder()
        encoder.outputFormatting = .prettyPrinted // Optional: to make the JSON easier to read; remove if not needed
        guard let jsonData = try? encoder.encode(requestBody) else { return "" }
        return String(data: jsonData, encoding: .utf8) ?? ""
    }
    
    
}
````

## File: Sources/ServicesProvider/Providers/Goma/APIs/GomaPromotionsAPIClient.swift
````swift
//
//  GomaPromotionsAPIClient.swift
//
//
//  Created on: May 15, 2024
//

import Foundation

enum GomaPromotionsAPIClient {
    // Home Template
    case homeTemplate(platform: String, clientId: Int?, userType: String?)

    // Promotions
    case allPromotions(clientId: Int?, platform: String?, userType: String?)
    case alertBanner(clientId: Int?, platform: String?, userType: String?)
    case banners(clientId: Int?, platform: String?, userType: String?)
    case sportBanners(clientId: Int?, platform: String?, userType: String?)
    case boostedOddsBanners(clientId: Int?, platform: String?, userType: String?)
    case heroCards(clientId: Int?, platform: String?, userType: String?)
    case stories(clientId: Int?, platform: String?, userType: String?)
    case news(clientId: Int?, platform: String?, userType: String?, pageIndex: Int, pageSize: Int)
    case proChoices(clientId: Int?, platform: String?, userType: String?)
}

extension GomaPromotionsAPIClient: Endpoint {
    var url: String {
        return SportRadarConfiguration.shared.clientBaseUrl
    }

    var endpoint: String {
        switch self {
        case .homeTemplate:
            return "/api/home/v1/template"
        case .allPromotions:
            return "/api/promotions/v1"
        case .alertBanner:
            return "/api/promotions/v1/alert-banner"
        case .banners:
            return "/api/promotions/v1/banners"
        case .sportBanners:
            return "/api/promotions/v1/sport-banners"
        case .boostedOddsBanners:
            return "/api/promotions/v1/boosted-odds-banners"
        case .heroCards:
            return "/api/promotions/v1/hero-cards"
        case .stories:
            return "/api/promotions/v1/stories"
        case .news:
            return "/api/promotions/v1/news"
        case .proChoices:
            return "/api/promotions/v1/pro-choices"
        }
    }

    var query: [URLQueryItem]? {
        var queryItems: [URLQueryItem] = []

        switch self {
        case .homeTemplate(let platform, let clientId, let userType):
            queryItems.append(URLQueryItem(name: "platform", value: platform))

            if let clientId = clientId {
                queryItems.append(URLQueryItem(name: "client_id", value: "\(clientId)"))
            }

            if let userType = userType {
                queryItems.append(URLQueryItem(name: "user_type", value: userType))
            }

        case .allPromotions(let clientId, let platform, let userType),
             .alertBanner(let clientId, let platform, let userType),
             .banners(let clientId, let platform, let userType),
             .sportBanners(let clientId, let platform, let userType),
             .boostedOddsBanners(let clientId, let platform, let userType),
             .heroCards(let clientId, let platform, let userType),
             .stories(let clientId, let platform, let userType),
             .proChoices(let clientId, let platform, let userType):

            if let clientId = clientId {
                queryItems.append(URLQueryItem(name: "client_id", value: "\(clientId)"))
            }

            if let platform = platform {
                queryItems.append(URLQueryItem(name: "platform", value: platform))
            }

            if let userType = userType {
                queryItems.append(URLQueryItem(name: "user_type", value: userType))
            }

        case .news(let clientId, let platform, let userType, let pageIndex, let pageSize):
            if let clientId = clientId {
                queryItems.append(URLQueryItem(name: "client_id", value: "\(clientId)"))
            }

            if let platform = platform {
                queryItems.append(URLQueryItem(name: "platform", value: platform))
            }

            if let userType = userType {
                queryItems.append(URLQueryItem(name: "user_type", value: userType))
            }

            queryItems.append(URLQueryItem(name: "page", value: "\(pageIndex)"))
            queryItems.append(URLQueryItem(name: "page_size", value: "\(pageSize)"))
        }

        return queryItems.isEmpty ? nil : queryItems
    }

    var headers: HTTP.Headers? {
        // Common headers for all API requests
        return [
            "Accept": "application/json",
            "Content-Type": "application/json"
        ]
    }

    var method: HTTP.Method {
        return .get // All endpoints use GET method
    }

    var body: Data? {
        return nil // None of these endpoints require a request body
    }

    var cachePolicy: URLRequest.CachePolicy {
        return .useProtocolCachePolicy
    }

    var timeout: TimeInterval {
        switch self {
        case .homeTemplate:
            return 15.0
        case .allPromotions:
            return 30.0
        case .news:
            return 20.0
        default:
            return 10.0
        }
    }

    var requireSessionKey: Bool {
        return true // Require authentication for all endpoints
    }

    var comment: String? {
        switch self {
        case .homeTemplate:
            return "Get home template configuration"
        case .allPromotions:
            return "Get all promotional content"
        case .alertBanner:
            return "Get alert banner"
        case .banners:
            return "Get promotional banners"
        case .sportBanners:
            return "Get sport banners"
        case .boostedOddsBanners:
            return "Get boosted odds banners"
        case .heroCards:
            return "Get hero cards"
        case .stories:
            return "Get promotional stories"
        case .news:
            return "Get news articles"
        case .proChoices:
            return "Get pro betting choices"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/Mappers/GomaModelMapper.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 21/12/2023.
//

import Foundation

struct GomaModelMapper {
    
    // Shared ISO8601DateFormatter for use across all mapping methods
    // This is more efficient than creating a new formatter in each method
    static let isoDateFormatter: ISO8601DateFormatter = {
        let formatter = ISO8601DateFormatter() // 2024-04-01T12:34:56.789Z
        return formatter
    }()
    
    static func parseDateString(dateString: String) -> Date? {
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSSSSZ"
        return dateFormatter.date(from: dateString)
    }

    static func basicRegisterResponse(fromInternalBasicRegisterResponse basicRegisterResponse: GomaModels.BasicRegisterResponse) -> DetailedSignUpResponse {

        let userData = SignUpUserData(id: basicRegisterResponse.id,
                                      name: basicRegisterResponse.name,
                                      email: basicRegisterResponse.email,
                                      username: basicRegisterResponse.username,
                                      avatarName: basicRegisterResponse.avatar ?? "")
        
        let signUpResponse = DetailedSignUpResponse(successful: true, errors: nil, userData: userData)
        return signUpResponse
    }
    
    static func loginResponse(fromInternalLoginResponse loginResponse: GomaModels.LoginResponse) -> LoginResponse {
            let userProfile = UserProfile(userIdentifier: "\(loginResponse.userData.id)",
                                        sessionKey: "",
                                        username: loginResponse.userData.username,
                                        email: loginResponse.userData.email,
                                        firstName: loginResponse.userData.name,
                                        middleName: nil,  // Added
                                        lastName: nil,
                                        birthDate: Date(),
                                        gender: nil,
                                        nationalityCode: nil,
                                        countryCode: nil,
                                        personalIdNumber: nil,
                                        address: nil,
                                        province: nil,
                                        city: nil,
                                        postalCode: nil,
                                        birthDepartment: nil,
                                        streetNumber: nil,
                                        phoneNumber: nil,
                                        mobilePhone: nil,
                                        mobileCountryCode: nil,
                                        mobileLocalNumber: nil,
                                        avatarName: loginResponse.userData.avatar,
                                        godfatherCode: loginResponse.userData.code,
                                        placeOfBirth: nil,
                                        additionalStreetLine: nil,
                                        emailVerificationStatus: .verified,
                                        userRegistrationStatus: .completed,
                                        kycStatus: .pass,
                                        lockedStatus: .notLocked,  // Added
                                        hasMadeDeposit: false,    // Added
                                        kycExpiryDate: nil,      // Added
                                        currency: nil)
            
        let mappedLoginResponse = LoginResponse(token: loginResponse.token,
                                                userProfile: userProfile)
        
        return mappedLoginResponse
    }
    
    static func favoriteList(fromInternalFavoriteItem favoriteItem: GomaModels.FavoriteItem) -> FavoriteList {
        
        let type = favoriteItem.type.typeString
        
        let favoriteList = FavoriteList(id: favoriteItem.favoriteId, name: type, customerId: favoriteItem.userId)
        
        return favoriteList
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/Mappers/GomaModelMapper+Banners.swift
````swift
//
//  File.swift
//
//
//  Created by Ruben Roques on 08/01/2024.
//

import Foundation

extension GomaModelMapper {

    static func promotionalBanners(fromBanners banners: [GomaModels.Banner]) -> [PromotionalBanner] {
        return banners.map(Self.promotionalBanner(fromBanner:))
    }

    static func promotionalBanner(fromBanner banner: GomaModels.Banner) -> PromotionalBanner {
        var action: BannerSpecialAction = .none
        if let url = banner.callToActionUrl, let text = banner.callToActionText {
            action = .callToAction(url: url, text: text)
        }

        return PromotionalBanner(id: banner.identifier,
                                 name: banner.title,
                                 bannerType: nil,
                                 imageURL: banner.imageUrl,
                                 bannerDisplay: nil,
                                 linkType: banner.callToActionUrl,
                                 location: nil,
                                 bannerContents: nil,
                                 specialAction: action)
    }

    static func promotionalStories(fromStories stories: [GomaModels.Story]) -> [PromotionalStory] {
        return stories.map(Self.promotionalStory(fromStory:))
    }

    static func promotionalStory(fromStory story: GomaModels.Story) -> PromotionalStory {
        return PromotionalStory(id: story.identifier,
                                title: story.title,
                                imageUrl: story.iconUrl,
                                linkUrl: story.callToActionUrl,
                                bodyText: story.mediaUrl,
                                callToActionText: story.callToActionText)
    }

    static func alertBanners(fromAlertBanners alertBanners: [GomaModels.AlertBanner]) -> [AlertBanner] {
        return alertBanners.map(Self.alertBanner(fromAlertBanner:))
    }

    static func alertBanner(fromAlertBanner alertBanner: GomaModels.AlertBanner) -> AlertBanner {
        // Convert callToActionUrl to URL if present
        let imageUrl: URL? = nil // GomaModels.AlertBanner doesn't have an imageUrl property

        return AlertBanner(
            id: alertBanner.identifier,
            title: alertBanner.title,
            subtitle: alertBanner.subtitle,
            content: nil, // No content in GomaModels.AlertBanner
            backgroundColor: nil, // No backgroundColor in GomaModels.AlertBanner
            textColor: nil, // No textColor in GomaModels.AlertBanner
            callToActionText: alertBanner.callToActionText,
            actionType: alertBanner.callToActionUrl != nil ? "url" : nil,
            actionTarget: alertBanner.callToActionUrl,
            isActive: (alertBanner.isActive ?? 0) == 1,
            startDate: nil, // No startDate in GomaModels.AlertBanner
            endDate: nil, // No endDate in GomaModels.AlertBanner
            status: nil, // No status in GomaModels.AlertBanner
            imageUrl: imageUrl
        )
    }

    static func bannerAlert(fromBannerAlert bannerAlert: GomaModels.BannerAlert) -> BannerAlert {

        return BannerAlert(identifier: bannerAlert.identifier, title: bannerAlert.title, subtitle: bannerAlert.subtitle, ctaText: bannerAlert.callToActionText, ctaUrl: bannerAlert.callToActionUrl, isActive: bannerAlert.isActive, createdAt: bannerAlert.createdAt, updatedAt: bannerAlert.updatedAt)
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/Mappers/GomaModelMapper+Betting.swift
````swift
//
//  File.swift
//
//
//  Created by Ruben Roques on 19/01/2024.
//

import Foundation

extension GomaModelMapper {
    
    static func betTypes(fromGomaBetTypes betTypes: [GomaModels.BetType]) -> [BetType] {
        return betTypes.map(Self.betType(fromGomaBetType:))
    }
    
    static func betType(fromGomaBetType betType: GomaModels.BetType) -> BetType {
        
        var numberOfBets: Int = 0
        var betGroupingType: BetGroupingType = .single(identifier: betType.identifier)
        
        switch betType {
        case .single:
            numberOfBets = 1
            betGroupingType = .single(identifier: betType.identifier)
        case .multiple:
            numberOfBets = .max
            betGroupingType = .multiple(identifier: betType.identifier)
        case .system:
            betGroupingType = .system(identifier: betType.identifier, name: betType.name, numberOfBets: 1)
        }
        
        return BetType(name: betType.name,
                       grouping: betGroupingType,
                       code: betType.identifier,
                       numberOfBets: numberOfBets,
                       potencialReturn: 0.0,
                       totalStake: nil)
    }
    
    static func gomaBetType(fromBetGroupingType betGroupingType: BetGroupingType) -> GomaModels.BetType {
        
        switch betGroupingType {
        case .single:
            return .single
        case .multiple:
            return .multiple
        case .system(let identifier, let name, _):
            return .system(type: GomaModels.SystemBetType(type: identifier, label: name))
        }
        
    }
    
    static func placedBetsResponse(fromPlaceBetTicketsResponses placeBetTicketsResponses: [GomaModels.PlaceBetTicketResponse] ) -> PlacedBetsResponse {
        let bets = placeBetTicketsResponses.map(Self.bet(fromPlaceBetTicketResponse:))
        let totalStake = placeBetTicketsResponses.map(\.stake).reduce(1, *)
        return PlacedBetsResponse(identifier: "", bets: [], detailedBets: bets, requiredConfirmation: false, totalStake: totalStake)
    }
    
//
//    static func placedBetsResponse(fromPlaceBetTicketResponse placedBet :GomaModels.PlaceBetTicketResponse) -> PlacedBetsResponse {
//        
//        
//        let selections = placedBet.selections.map({
//            Self.betSelection(fromMyTicketSelection: $0)
//        })
//        
//        let bet = Self.bet(fromMyTicket: myTicket)
//        return PlacedBetsResponse(identifier: "\(myTicket.id)", bets: [], detailedBets: [bet])
//    }
//    
    static func placedBetsResponse(fromMyTicket myTicket :GomaModels.MyTicket) -> PlacedBetsResponse {
        let bet = Self.bet(fromMyTicket: myTicket)
        return PlacedBetsResponse(identifier: "\(myTicket.id)", bets: [], detailedBets: [bet], requiredConfirmation: false, totalStake: bet.stake)
    }
        
    static func bet(fromPlaceBetTicketResponse placeBetTicketResponse: GomaModels.PlaceBetTicketResponse) -> Bet {
        
        let betState = BetState(rawValue: placeBetTicketResponse.status) ?? .undefined

        
        let selections = placeBetTicketResponse.selections.map({
            Self.betSelection(fromMyTicketSelection: $0)
        })
        
        var betDate = Date()
        let dateString = placeBetTicketResponse.createdAt ?? ""

        // Attempt to parse the string into a Date object
        if let date = Self.parseDateString(dateString: dateString) {
            betDate = date
        }
                
        return Bet(identifier: "\(placeBetTicketResponse.id)",
                   type: placeBetTicketResponse.type,
                   state: betState,
                   result: .notSpecified,
                   globalState: betState,
                   stake: placeBetTicketResponse.stake,
                   totalOdd: placeBetTicketResponse.odds,
                   selections: selections,
                   potentialReturn: placeBetTicketResponse.possibleWinnings,
                   date: betDate,
                   freebet: false,
                   shareId: placeBetTicketResponse.shareId)
        
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/Mappers/GomaModelMapper+Events.swift
````swift
//
//  File.swift
//
//
//  Created by Ruben Roques on 21/12/2023.
//

import Foundation
import SharedModels

extension GomaModelMapper {

    static func eventsGroup(fromInternalEvents internalEvents: [GomaModels.Event]) -> EventsGroup {
        let events = internalEvents.map(Self.event(fromInternalEvent:))
        return EventsGroup(events: events, marketGroupId: nil, title: nil)
    }

    static func events(fromInternalEvents internalEvents: [GomaModels.Event]) -> [Event] {
        let events = internalEvents.map(Self.event(fromInternalEvent:))
        return events
    }

    static func event(fromInternalEvent internalEvent: GomaModels.Event) -> Event {

        var country: Country?
        if let regionIsoCode = internalEvent.region.isoCode {
            country = Country.country(withISOCode: regionIsoCode)
        }
        else {
            country = Country.country(withName: internalEvent.region.name)
        }

        //
        var eventName: String?
        if !internalEvent.homeName.isEmpty, !internalEvent.awayName.isEmpty {
            eventName = "\(internalEvent.homeName) x \(internalEvent.awayName)"
        }
        else {
            eventName = internalEvent.competition.name
        }

        let hasLiveOdds = internalEvent.isLive

        //
//        let mappedMarkets = internalEvent.markets.map(Self.market(fromInternalMarket:))

        let mappedMarkets = internalEvent.markets.map({
            Self.market(fromInternalMarket: $0, withLiveOdds: hasLiveOdds)
        })

        mappedMarkets.forEach { market in
            market.homeParticipant = internalEvent.homeName
            market.awayParticipant = internalEvent.awayName
            market.eventId = internalEvent.identifier
            market.eventName = eventName
        }

        let sportType = Self.sportType(fromSport: internalEvent.sport)

        let event = Event(id: internalEvent.identifier,
                          homeTeamName: internalEvent.homeName,
                          awayTeamName: internalEvent.awayName,
                          homeTeamScore: internalEvent.homeScore,
                          awayTeamScore: internalEvent.awayScore,
                          homeTeamLogoUrl: internalEvent.homeLogoUrl,
                          awayTeamLogoUrl: internalEvent.awayLogoUrl,
                          competitionId: internalEvent.competition.identifier,
                          competitionName: internalEvent.competition.name,
                          sport: sportType,
                          sportIdCode: sportType.numericId,
                          startDate: internalEvent.startDate,
                          markets: mappedMarkets,
                          venueCountry: country,
                          numberMarkets: mappedMarkets.count,
                          name: eventName,
                          trackableReference: nil,
                          status: Self.eventStatus(fromInternalEvent: internalEvent.status),
                          matchTime: internalEvent.matchTime,
                          activePlayerServing: nil,
                          boostedMarket: nil,
                          promoImageURL: internalEvent.metaDetails?.imageUrl,
                          scores: internalEvent.scores)

        return event
    }

    static func eventStatus(fromInternalEvent internalEventStatus: GomaModels.EventStatus) -> EventStatus? {
        switch internalEventStatus {
        case .unknown:
            return nil
        case .notStarted:
            return EventStatus.notStarted
        case .inProgress(let detail):
            return EventStatus.inProgress(detail)
        case .ended(let detail):
            return EventStatus.ended(detail ?? "")
        }
    }

    static func market(fromInternalMarket internalMarket: GomaModels.Market, withLiveOdds: Bool = false) -> Market {
        var mappedStats: Stats?
        if let stats = internalMarket.stats {
            mappedStats = Self.stats(fromInternalStats: stats)
        }

//        let outcomes = internalMarket.outcomes.map(Self.outcome(fromInternalOutcome:))

        let outcomes = internalMarket.outcomes.map({
            Self.outcome(fromInternalOutcome: $0, withLiveOdds: withLiveOdds)
        })

        return Market(id: internalMarket.identifier,
                      name: internalMarket.name,
                      outcomes: outcomes,
                      marketTypeId: internalMarket.groupId,
                      marketFilterId: internalMarket.groupId,
                      eventMarketTypeId: internalMarket.groupId,
                      eventName: nil,
                      isMainOutright: false,
                      eventMarketCount: nil,
                      isTradable: true,
                      startDate: nil,
                      homeParticipant: nil,
                      awayParticipant: nil,
                      eventId: nil,
                      marketDigitLine: nil,
                      outcomesOrder: .none,
                      competitionId: nil,
                      competitionName: nil,
                      sport: nil,
                      sportIdCode: nil,
                      venueCountry: nil,
                      customBetAvailable: nil,
                      isMainMarket: false,
                      stats: mappedStats)
    }

    static func outcome(fromInternalOutcome internalOutcome: GomaModels.Outcome, withLiveOdds: Bool = false) -> Outcome {

        var odd = internalOutcome.odd

        if withLiveOdds {
            odd = internalOutcome.oddLive ?? odd
        }

        return Outcome(id: internalOutcome.identifier,
                       name: internalOutcome.name,
                       odd: odd,
                       marketId: internalOutcome.identifier,
                       bettingOfferId: internalOutcome.identifier,
                       orderValue: internalOutcome.code,
                       externalReference: nil,
                       isTradable: true,
                       isTerminated: false,
                       customBetAvailableMarket: nil)
    }


}


extension GomaModelMapper {

    static func events(fromSportAssociatedEventBanners eventBanners: [GomaModels.SportAssociatedEventBanner]) -> [Event] {
        return eventBanners.map(Self.event(fromSportAssociatedEventBanner:)).compactMap({ $0 })
    }

    static func event(fromSportAssociatedEventBanner eventBanner: GomaModels.SportAssociatedEventBanner) -> Event? {
        let associatedEvent = eventBanner.event
        let convertedEvent: Event = Self.event(fromInternalEvent: associatedEvent)
        convertedEvent.promoImageURL = eventBanner.imageUrl
        return convertedEvent
    }

}


extension GomaModelMapper {

    static func topCompetitions(fromCompetitions competitions: [GomaModels.Competition]) -> [TopCompetition] {
        return competitions.map(Self.topCompetition(fromCompetition:)).compactMap({ $0 })
    }

    static func topCompetition(fromCompetition competition: GomaModels.Competition) -> TopCompetition? {

        guard
            let sport = competition.sport
        else {
            return nil
        }

        let convertedSport = Self.sportType(fromSport: sport)

        var convertedCountry: Country?
        if let regionIsoCode = competition.region?.isoCode {
            convertedCountry = Country.country(withISOCode: regionIsoCode)
        }
        else {
            convertedCountry = Country.country(withName: competition.region?.name ?? "")
        }

        return TopCompetition(id: competition.identifier,
                              name: competition.name,
                              country: convertedCountry,
                              sportType: convertedSport)

    }

    static func topCompetitionsPointers(fromCompetitions competitions: [GomaModels.Competition]) -> [TopCompetitionPointer] {
        return competitions.map(Self.topCompetitionPointer(fromCompetition:)).compactMap({ $0 })
    }

    static func topCompetitionPointer(fromCompetition competition: GomaModels.Competition) -> TopCompetitionPointer? {
        guard
            let sport = competition.sport
        else {
            return nil
        }

        return TopCompetitionPointer(id: sport.name, name: competition.name, competitionId: competition.identifier)
    }

    static func eventMetadataPointer(fromInternalEventMetadataPointer eventMetadataPointer: GomaModels.EventMetadataPointer) -> EventMetadataPointer {

        return EventMetadataPointer(id: eventMetadataPointer.id,
                                    eventId: eventMetadataPointer.eventId,
                                    eventMarketId: eventMetadataPointer.eventMarketId,
                                    callToActionURL: eventMetadataPointer.callToActionURL,
                                    imageURL: eventMetadataPointer.imageURL)
    }

}


extension GomaModelMapper {

    static func sportRegions(fromRegions regions: [GomaModels.Region]) -> [SportRegion] {
        return regions.map(Self.sportRegion(fromRegion:))
    }

    static func sportRegion(fromRegion region: GomaModels.Region) -> SportRegion {

        var convertedCountry: Country? = Country.country(withName: region.name)
        if let regionIsoCode = region.isoCode {
            convertedCountry = Country.country(withISOCode: regionIsoCode)
        }
        else {
            convertedCountry = Country.country(withName: region.name)
        }

        return SportRegion(id: region.identifier,
                           name: region.name,
                           numberEvents: "\(region.preLiveEventsCount ?? 0)",
                           numberOutrightEvents: "0",
                           country: convertedCountry)
    }

    static func sportCompetitions(fromCompetitions competitions: [GomaModels.Competition]) -> [SportCompetition] {
        return competitions.map(Self.sportCompetition(fromCompetition:))
    }

    static func sportCompetition(fromCompetition competition: GomaModels.Competition) -> SportCompetition {
        return SportCompetition(id: competition.identifier,
                                name: competition.name,
                                numberEvents: "\(competition.preLiveEventsCount ?? 0)",
                                numberOutrightEvents: "0")
    }

}

// Stats
extension GomaModelMapper {
    static func stats(fromInternalStats internalStats: GomaModels.Stats) -> Stats {
        return Stats(homeParticipant: Self.participantStats(fromInternalParticipantStats: internalStats.homeParticipant),
                     awayParticipant: Self.participantStats(fromInternalParticipantStats: internalStats.awayParticipant))
    }
    
    static func participantStats(fromInternalParticipantStats internalParticipantStats: GomaModels.ParticipantStats)
    -> ParticipantStats {
        return ParticipantStats(total: internalParticipantStats.total,
                                wins: internalParticipantStats.wins,
                                draws: internalParticipantStats.draws,
                                losses: internalParticipantStats.losses,
                                over: internalParticipantStats.over,
                                under: internalParticipantStats.under)
    }
    
    static func event(fromInternalHeroCardEvent heroCardEvent: GomaModels.HeroCardEvents) -> Event {
        let mappedEvent = Self.event(fromInternalEvent: heroCardEvent.event)
        mappedEvent.promoImageURL = heroCardEvent.imageUrl
        return mappedEvent
    }
    
    static func event(fromInternalBoostedEvent boostedEvent: GomaModels.BoostedEvent) -> Event {
        let mappedEvent = Self.event(fromInternalEvent: boostedEvent.event)
        let mappedBoostedMarket = Self.market(fromInternalMarket: boostedEvent.boostedMarket)
        mappedEvent.promoImageURL = boostedEvent.imageUrl
        mappedEvent.boostedMarket = mappedBoostedMarket
        mappedEvent.oldMainMarketId = boostedEvent.event.markets.first?.identifier
        return mappedEvent
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/Mappers/GomaModelMapper+FeaturedTips.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 17/01/2024.
//

import Foundation

extension GomaModelMapper {
    
    static func featuredTips(fromInternaFeaturedTips internalFeaturedTips: [GomaModels.FeaturedTip]) -> [FeaturedTip] {
        return internalFeaturedTips.map(Self.featuredTip(fromInternaFeaturedTip:))
    }
    
    static func featuredTip(fromInternaFeaturedTip internalFeaturedTip: GomaModels.FeaturedTip) -> FeaturedTip {
    
        let tipUser = FeaturedTipUser(id: "\(internalFeaturedTip.user.id)",
                name: internalFeaturedTip.user.name,
                code: internalFeaturedTip.user.code,
                avatar: internalFeaturedTip.user.avatar)
        
        let selections = internalFeaturedTip.selections.map(Self.featuredTipSelection(fromInternalTipSelection:))
        
        return FeaturedTip(id: "\(internalFeaturedTip.id)",
                    stake: internalFeaturedTip.stake,
                    odd: internalFeaturedTip.odds,
                    status: internalFeaturedTip.status,
                    type: internalFeaturedTip.type,
                    selections: selections,
                    user: tipUser)
    }
    
    static func featuredTipSelection(fromInternalTipSelection featuredTipSelection: GomaModels.FeaturedTipSelection) -> FeaturedTipSelection {
        let mappedEvent = Self.event(fromInternalEvent: featuredTipSelection.event)
        return FeaturedTipSelection(id: "\(featuredTipSelection.id)",
                                    marketId: "\(featuredTipSelection.outcome.market.id)",
                                    outcomeId: "\(featuredTipSelection.outcome.id)",
                                    marketName: featuredTipSelection.outcome.market.name,
                                    outcomeName: featuredTipSelection.outcome.name,
                                    odd: featuredTipSelection.odd,
                                    event: mappedEvent)
    }
        
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/Mappers/GomaModelMapper+MyTickets.swift
````swift
//
//  GomaModelMapper+MyTickets.swift
//
//
//  Created by André Lascas on 22/01/2024.
//

import Foundation
import SharedModels

extension GomaModelMapper {
    
    static func bettingHistory(fromMyTicketsResponse myTicketsResponse: GomaModels.MyTicketsResponse) -> BettingHistory {
        let bets = myTicketsResponse.data.map({
            Self.bet(fromMyTicket: $0)
        })
        let bettingHistory = BettingHistory(bets: bets)
        return bettingHistory
    }
    
    static func bet(fromMyTicket myTicket: GomaModels.MyTicket) -> Bet {
        
        let betState = Self.betState(fromMyTicketStatus: myTicket.status)
        
        let selections = myTicket.selections.map({
            Self.betSelection(fromMyTicketSelection: $0)
        })
        
        var betDate = Date()
        let dateString = myTicket.createdAt ?? ""

        // Attempt to parse the string into a Date object
        if let date = self.parseDateString(dateString: dateString) {
            betDate = date
        } else {
            print("Unable to parse the date string from my ticket bet.")
        }
                
        return Bet(identifier: "\(myTicket.id)",
                   type: myTicket.type,
                   state: betState,
                   result: .notSpecified,
                   globalState: betState,
                   stake: myTicket.stake,
                   totalOdd: myTicket.odds,
                   selections: selections,
                   potentialReturn: myTicket.possibleWinnings,
                   date: betDate,
                   freebet: false,
                   shareId: myTicket.shareId)
    }
    
    /// Maps a Goma MyTicketSelection to the unified BetSelection model
    /// - Parameter myTicketSelection: The source Goma ticket selection
    /// - Returns: A unified BetSelection instance
    static func betSelection(fromMyTicketSelection myTicketSelection: GomaModels.MyTicketSelection) -> BetSelection {
        // Map bet state from ticket status
        let betState = Self.betState(fromMyTicketStatus: myTicketSelection.status)
        
        // Map country from region, defaulting to empty string if no region
        let country = Country(isoCode: myTicketSelection.event.region?.isoCode ?? "")
        
        // Convert scores to string representation
        var homeScore: String? = nil
        var awayScore: String? = nil
        
        if let betHomeScore = myTicketSelection.event.homeScore {
            homeScore = "\(betHomeScore)"
        }
        
        if let betAwayScore = myTicketSelection.event.awayScore {
            awayScore = "\(betAwayScore)"
        }
        
        // Map sport type using the existing helper
        let mappedSportType = Self.sportType(fromSport: myTicketSelection.event.sport)
        
        // Create event name by combining home and away team names
        let eventName = "\(myTicketSelection.event.homeTeam) x \(myTicketSelection.event.awayTeam)"
        
        return BetSelection(
            // Core properties
            identifier: "\(myTicketSelection.id)",
            state: betState,
            result: .notSpecified,
            globalState: betState,
            eventName: eventName,
            homeTeamName: myTicketSelection.event.homeTeam,
            awayTeamName: myTicketSelection.event.awayTeam,
            marketName: myTicketSelection.outcome.market.name,
            outcomeName: myTicketSelection.outcome.name,
            odd: .decimal(odd: myTicketSelection.odd),
            
            // Score properties
            homeResult: homeScore,
            awayResult: awayScore,
            
            // Event properties
            eventId: "\(myTicketSelection.sportEventId)",
            eventDate: myTicketSelection.event.dateTime,
            country: country,
            
            // Sport properties
            sportType: mappedSportType,
            tournamentName: myTicketSelection.event.competition?.name ?? "",
            
            // Market and outcome IDs
            marketId: "\(myTicketSelection.outcome.market.id)",
            outcomeId: "\(myTicketSelection.outcome.id)",
            
            // Team logo properties
            homeLogoUrl: myTicketSelection.event.homeLogoUrl,
            awayLogoUrl: myTicketSelection.event.awayLogoUrl
        )
    }
    
    static func betState(fromMyTicketStatus myTicketStatus: GomaModels.MyTicketStatus) -> BetState {
        
        switch myTicketStatus {
        case .pending:
            return .opened
        case .won:
            return .won
        case .lost:
            return .lost
        case .push:
            return .void
        case .undefined:
            return .undefined
        }
    }
    
    static func betResult(fromMyTicketResult myTicketResult: GomaModels.MyTicketResult) -> BetResult {
        switch myTicketResult {
        case .pending:
            return .pending
        case .won:
            return .won
        case .lost:
            return .lost
        case .push:
            return .void
        case .undefined:
            return .notSpecified
        }
    }
    
    static func betQRCode(fromMyTicketQRCode myTicketQRCode: GomaModels.MyTicketQRCode) -> BetQRCode {
        
        let betQRCode = BetQRCode(qrCode: myTicketQRCode.qrCode,
                                  expirationDate: myTicketQRCode.expirationDate, message: myTicketQRCode.message)
        
        return betQRCode
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/Mappers/GomaModelMapper+News.swift
````swift
//
//  GomaModelMapper+News.swift
//
//
//  Created by André Lascas on 05/06/2024.
//

import Foundation

extension GomaModelMapper {
    
    static func news(fromNews news: GomaModels.News) -> News {
        
        var event: Event? = nil
        
        if let newsEvent = news.event {
            event = GomaModelMapper.event(fromInternalEvent: newsEvent)
        }
        
        return News(id: news.id, title: news.title, slug: news.slug, image: news.image, content: news.content, sportEventId: news.sportEventId, status: news.status, startDate: news.startDate, endDate: news.endDate, userType: news.userType, order: news.order, event: event)
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/Mappers/GomaModelMapper+Promotions.swift
````swift
//
//  GomaModelMapper+Promotions.swift
//
//
//  Created on: May 15, 2024
//

import Foundation

extension GomaModelMapper {

    // MARK: - Model mapper Home Template
    static func homeTemplate(fromInternalHomeTemplate template: GomaModels.HomeTemplate) -> HomeTemplate {
        let widgets = template.widgets.compactMap { internalWidget -> HomeWidget? in
            // Initialize using the failable initializer
            return HomeWidget(
                id: Int(internalWidget.id) ?? 0,
                type: internalWidget.type,
                description: internalWidget.description,
                userState: internalWidget.userType,
                sortOrder: internalWidget.sortOrder,
                orientation: internalWidget.orientation)
        }

        return HomeTemplate(id: template.id, type: template.type, widgets: widgets)
    }

    // MARK: - Alert Banner
    static func alertBanner(fromInternalAlertBanner banner: GomaModels.AlertBannerData) -> AlertBanner {
        return AlertBanner(
            id: String(banner.id),
            title: banner.title,
            subtitle: nil,
            content: banner.content,
            backgroundColor: banner.backgroundColor,
            textColor: banner.textColor,
            callToActionText: nil,
            actionType: banner.actionType,
            actionTarget: banner.actionTarget,
            isActive: banner.status.lowercased() == "active",
            startDate: isoDateFormatter.date(from: banner.startDate),
            endDate: isoDateFormatter.date(from: banner.endDate),
            status: banner.status,
            imageUrl: banner.imageUrl != nil ? URL(string: banner.imageUrl!) : nil)
    }

    // MARK: - Banners

    static func banners(fromInternalBanners banners: [GomaModels.BannerData]) -> [Banner] {
        return banners.map { banner(fromInternalBanner: $0) }
    }

    static func banner(fromInternalBanner banner: GomaModels.BannerData) -> Banner {
        return Banner(
            id: String(banner.id),
            title: banner.title,
            subtitle: banner.subtitle,
            actionType: banner.actionType,
            actionTarget: banner.actionTarget,
            callToActionText: nil,
            isActive: banner.status.lowercased() == "active",
            startDate: isoDateFormatter.date(from: banner.startDate),
            endDate: isoDateFormatter.date(from: banner.endDate),
            status: banner.status,
            imageUrl: banner.imageUrl != nil ? URL(string: banner.imageUrl!) : nil
        )
    }

    // MARK: - Sport Banners

    static func sportBanners(fromInternalSportBanners banners: [GomaModels.SportBannerData]) -> [SportBanner] {
        return banners.map { sportBanner(fromInternalSportBanner: $0) }
    }

    static func sportBanner(fromInternalSportBanner banner: GomaModels.SportBannerData) -> SportBanner {
        return SportBanner(
            id: banner.id,
            title: banner.title,
            subtitle: banner.subtitle,
            sportEventId: banner.sportEventId,
            startDate: isoDateFormatter.date(from: banner.startDate) ?? Date(),
            endDate: isoDateFormatter.date(from: banner.endDate) ?? Date(),
            status: banner.status,
            imageUrl: banner.imageUrl != nil ? URL(string: banner.imageUrl!) : nil,
            event: banner.event != nil ? sportEventSummary(fromInternalSportEvent: banner.event!) : nil
        )
    }

    static func sportEventSummary(fromInternalSportEvent event: GomaModels.SportEventData) -> SportEventSummary {
        return SportEventSummary(
            id: event.id,
            sportId: event.sportId,
            homeTeamId: event.homeTeamId,
            awayTeamId: event.awayTeamId,
            dateTime: isoDateFormatter.date(from: event.dateTime) ?? Date(),
            homeTeam: event.homeTeam.name,
            awayTeam: event.awayTeam.name,
            homeTeamLogo: event.homeTeam.logo != nil ? URL(string: event.homeTeam.logo!) : nil,
            awayTeamLogo: event.awayTeam.logo != nil ? URL(string: event.awayTeam.logo!) : nil
        )
    }

    // MARK: - Boosted Odds Banners

    static func boostedOddsBanners(fromInternalBoostedOddsBanners banners: [GomaModels.BoostedOddsBannerData]) -> [BoostedOddsBanner] {
        return banners.map { boostedOddsBanner(fromInternalBoostedOddsBanner: $0) }
    }

    static func boostedOddsBanner(fromInternalBoostedOddsBanner banner: GomaModels.BoostedOddsBannerData) -> BoostedOddsBanner {
        return BoostedOddsBanner(
            id: banner.id,
            title: banner.title,
            originalOdd: banner.originalOdd,
            boostedOdd: banner.boostedOdd,
            sportEventId: banner.sportEventId,
            startDate: isoDateFormatter.date(from: banner.startDate) ?? Date(),
            endDate: isoDateFormatter.date(from: banner.endDate) ?? Date(),
            status: banner.status,
            imageUrl: banner.imageUrl != nil ? URL(string: banner.imageUrl!) : nil,
            event: banner.event != nil ? sportEventSummary(fromInternalSportEvent: banner.event!) : nil
        )
    }

    // MARK: - Hero Cards

    static func heroCards(fromInternalHeroCards cards: [GomaModels.HeroCardData]) -> [HeroCard] {
        return cards.map { heroCard(fromInternalHeroCard: $0) }
    }

    static func heroCard(fromInternalHeroCard card: GomaModels.HeroCardData) -> HeroCard {
        return HeroCard(
            id: card.id,
            title: card.title,
            subtitle: card.subtitle,
            actionType: card.actionType,
            actionTarget: card.actionTarget,
            startDate: isoDateFormatter.date(from: card.startDate) ?? Date(),
            endDate: isoDateFormatter.date(from: card.endDate) ?? Date(),
            status: card.status,
            imageUrl: card.imageUrl != nil ? URL(string: card.imageUrl!) : nil,
            eventId: card.eventId
        )
    }

    // MARK: - Stories

    static func stories(fromInternalStories stories: [GomaModels.StoryData]) -> [Story] {
        return stories.map { story(fromInternalStory: $0) }
    }

    static func story(fromInternalStory story: GomaModels.StoryData) -> Story {
        return Story(
            id: story.id,
            title: story.title,
            content: story.content,
            actionType: story.actionType,
            actionTarget: story.actionTarget,
            startDate: isoDateFormatter.date(from: story.startDate) ?? Date(),
            endDate: isoDateFormatter.date(from: story.endDate) ?? Date(),
            status: story.status,
            imageUrl: story.imageUrl != nil ? URL(string: story.imageUrl!) : nil,
            duration: story.duration
        )
    }

    // MARK: - News

    static func newsItems(fromInternalNewsItems items: [GomaModels.NewsItemData]) -> [NewsItem] {
        return items.map { newsItem(fromInternalNewsItem: $0) }
    }

    static func newsItem(fromInternalNewsItem item: GomaModels.NewsItemData) -> NewsItem {
        return NewsItem(
            id: item.id,
            title: item.title,
            subtitle: item.subtitle,
            content: item.content,
            author: item.author,
            publishedDate: isoDateFormatter.date(from: item.publishedDate) ?? Date(),
            status: item.status,
            imageUrl: item.imageUrl != nil ? URL(string: item.imageUrl!) : nil,
            tags: item.tags ?? []
        )
    }

    // MARK: - Pro Choices

    static func proChoices(fromInternalProChoices choices: [GomaModels.ProChoiceData]) -> [ProChoice] {
        return choices.map { proChoice(fromInternalProChoice: $0) }
    }

    static func proChoice(fromInternalProChoice choice: GomaModels.ProChoiceData) -> ProChoice {
        return ProChoice(
            id: choice.id,
            title: choice.title,
            tipster: tipster(fromInternalTipster: choice.tipster),
            event: eventSummary(fromInternalEventSummary: choice.event),
            selection: selection(fromInternalSelection: choice.selection),
            reasoning: choice.reasoning
        )
    }

    static func tipster(fromInternalTipster tipster: GomaModels.ProChoiceData.TipsterData) -> Tipster {
        return Tipster(
            id: tipster.id,
            name: tipster.name,
            winRate: tipster.winRate,
            avatar: tipster.avatar != nil ? URL(string: tipster.avatar!) : nil
        )
    }

    static func eventSummary(fromInternalEventSummary event: GomaModels.ProChoiceData.EventSummaryData) -> EventSummary {
        return EventSummary(
            id: event.id,
            homeTeam: event.homeTeam,
            awayTeam: event.awayTeam,
            dateTime: isoDateFormatter.date(from: event.dateTime) ?? Date()
        )
    }

    static func selection(fromInternalSelection selection: GomaModels.ProChoiceData.SelectionData) -> Selection {
        return Selection(
            marketName: selection.marketName,
            outcomeName: selection.outcomeName,
            odds: selection.odds
        )
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/Mappers/GomaModelMapper+Social.swift
````swift
//
//  GomaModelMapper+Social.swift
//
//
//  Created by André Lascas on 15/02/2024.
//

import Foundation

extension GomaModelMapper {
    
    static func follower(fromFollower follower: GomaModels.Follower) -> Follower {
        
        return Follower(id: follower.id, name: follower.name)
    }
    
    static func tipRanking(fromTipRanking tipRanking: GomaModels.TipRanking) -> TipRanking {
        return TipRanking(position: tipRanking.position, result: tipRanking.result, userId: tipRanking.userId, name: tipRanking.name, code: tipRanking.code, avatar: tipRanking.avatar, anonymous: tipRanking.anonymous)
    }
    
    static func userProfileInfo(fromUserProfileInfo userProfileInfo: GomaModels.UserProfileInfo) -> UserProfileInfo {
        
        let rankings = Self.userRanking(fromUserRanking: userProfileInfo.rankings)
        
        let sportsPerc = userProfileInfo.sportsPerc.map({
            
            return Self.userSportsData(fromUserSportsData: $0)
        })
        
        return UserProfileInfo(name: userProfileInfo.name, avatar: userProfileInfo.avatar, following: userProfileInfo.following, followers: userProfileInfo.followers, rankings: rankings, sportsPerc: sportsPerc)
    }
    
    static func userRanking(fromUserRanking userRanking: GomaModels.UserProfileRanking) -> UserProfileRanking {
        
        return UserProfileRanking(consecutiveWins: userRanking.consecutiveWins, accumulatedWins: userRanking.accumulatedWins, highestOdd: userRanking.highestOdd)
    }
    
    static func userSportsData(fromUserSportsData userSportsData: GomaModels.UserProfileSportsData) -> UserProfileSportsData {
        
        return UserProfileSportsData(sportId: userSportsData.sportId, percentage: userSportsData.percentage, sportIdIcon: userSportsData.sportIdIcon)
    }
    
    static func friendRequest(fromFriendRequest friendRequest: GomaModels.FriendRequest) -> FriendRequest {
        
        return FriendRequest(id: friendRequest.id, name: friendRequest.name, username: friendRequest.username)
    }
    
    static func userFriend(fromGomaFriend userFriend: GomaModels.GomaFriend) -> GomaFriend {
        
        return GomaFriend(id: userFriend.id, name: userFriend.name, avatar: userFriend.avatar, isAdmin: userFriend.isAdmin)
    }
    
    static func chatroomData(fromChatroomData chatroomData: GomaModels.ChatroomData) -> ChatroomData {
        
        let chatroom = Self.chatroom(fromChatroom: chatroomData.chatroom)
        
        let userFriends = chatroomData.users.map({
            return Self.userFriend(fromGomaFriend: $0)
        })
        
        return ChatroomData(chatroom: chatroom, users: userFriends)
    }
    
    static func chatroom(fromChatroom chatroom: GomaModels.Chatroom) -> Chatroom {
        
        return Chatroom(id: chatroom.id, name: chatroom.name, type: chatroom.type, creationTimestamp: chatroom.creationTimestamp)
    }
    
    static func searchUser(fromSearchUser searchUser: GomaModels.SearchUser) -> SearchUser {
        
        return SearchUser(id: searchUser.id, username: searchUser.username, avatar: searchUser.avatar)
    }
    
    static func addFriendResponse(fromAddFriendResponse addFriendResponse: GomaModels.AddFriendResponse) -> AddFriendResponse {
        
        return AddFriendResponse(chatroomIds: addFriendResponse.chatroomIds)
    }
    
    static func chatroomId(fromChatroomId chatroomId: GomaModels.ChatroomId) -> ChatroomId {
        
        return ChatroomId(id: chatroomId.id)
    }
    
    static func deleteGroupResponse(fromDeleteGroupResponse deleteGroupResponse: GomaModels.DeleteGroupResponse) -> DeleteGroupResponse {
        
        return DeleteGroupResponse(status: deleteGroupResponse.status, message: deleteGroupResponse.message)
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/Mappers/GomaModelMapper+Sports.swift
````swift
//
//  File.swift
//
//
//  Created by Ruben Roques on 21/12/2023.
//

import Foundation
import SharedModels

extension GomaModelMapper {
    
    static func sportsType(fromSports sports: GomaModels.Sports) -> [SportType] {
        
        return sports.map(Self.sportType(fromSport:))
        
    }
    
    static func sportType(fromSport sport: GomaModels.Sport) -> SportType {
        
        var iconIdentifier = sport.iconIdentifier
        if iconIdentifier == nil {
            iconIdentifier = Self.sportIconId(forNumericIdentifier: sport.identifier)
        }
        
        let sportType = SportType(name: sport.name,
                                  numericId: sport.identifier,
                                  alphaId: sport.identifier,
                                  iconId: iconIdentifier,
                                  showEventCategory: false,
                                  numberEvents: sport.preLiveEventsCount ?? 0,
                                  numberOutrightEvents: 0,
                                  numberOutrightMarkets: 0,
                                  numberLiveEvents: sport.liveEventsCount ?? 0)
        return sportType
    }
    
    private static func simplify(string: String) -> String {
        let validChars = Set("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLKMNOPQRSTUVWXYZ1234567890")
        return string.filter { validChars.contains($0) }.lowercased()
    }
    
    static func sportIconId(forNumericIdentifier numericIdentifier: String) -> String? {
        switch numericIdentifier {
        case "4": return "1"    // "name": "Futebol"
        case "1": return "8"    // "name": "Basquetebol"
        case "2": return "3"    // "name": "Tenis"
        case "3": return "20"   // "name": "Voleibol"
        case "5": return "6"    // "name": "Hoquei Gelo"
        case "6": return "28"   // "name": "Rugby"
        case "7": return "7"    // "name": "Andebol"
        case "8": return "49"   // "name": "Futsal"
        case "9": return "5"    // "name": "Fut. Americano"
        case "10": return "902" // "name": "Hoquei Patins"
        case "11": return "66"  // "name": "Futebol Praia"
        default: return nil
        }
        
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/Mappers/GomaModelMapper+Users.swift
````swift
//
//  File.swift
//
//
//  Created by Ruben Roques on 15/01/2024.
//

import Foundation

extension GomaModelMapper {
    
    static func internalUserNotificationsSettings(fromUserNotificationsSettings settings: UserNotificationsSettings) -> GomaModels.UserNotificationsSettings {
        return GomaModels.UserNotificationsSettings(notifications: settings.notifications,
                                                    notificationsGamesWatchlist: settings.notificationsGamesWatchlist,
                                                    notificationsCompetitionsWatchlist: settings.notificationsCompetitionsWatchlist,
                                                    notificationsGoal: settings.notificationsGoal,
                                                    notificationsStartGame: settings.notificationsStartGame,
                                                    notificationsHalftime: settings.notificationsHalftime,
                                                    notificationsFulltime: settings.notificationsFulltime,
                                                    notificationsSecondHalf: settings.notificationsSecondHalf,
                                                    notificationsRedcard: settings.notificationsRedcard,
                                                    notificationsBets: settings.notificationsBets,
                                                    notificationsBetSelections: settings.notificationsBetSelections,
                                                    notificationsEmail: settings.notificationsEmail,
                                                    notificationsSms: settings.notificationsSms,
                                                    notificationsChats: settings.notificationsChats,
                                                    notificationsNews: settings.notificationsNews)
    }
    
    static func userNotificationsSettings(fromInternalUserNotificationsSettings settings: GomaModels.UserNotificationsSettings) -> UserNotificationsSettings {
        return UserNotificationsSettings(notifications: settings.notifications == 1,
                                         notificationsGamesWatchlist: settings.notificationsGamesWatchlist == 1,
                                         notificationsCompetitionsWatchlist: settings.notificationsCompetitionsWatchlist == 1,
                                         notificationsGoal: settings.notificationsGoal == 1,
                                         notificationsStartGame: settings.notificationsStartGame == 1,
                                         notificationsHalftime: settings.notificationsHalftime == 1,
                                         notificationsFulltime: settings.notificationsFulltime == 1,
                                         notificationsSecondHalf: settings.notificationsSecondHalf == 1,
                                         notificationsRedcard: settings.notificationsRedcard == 1,
                                         notificationsBets: settings.notificationsBets == 1,
                                         notificationsBetSelections: settings.notificationsBetSelections == 1,
                                         notificationsEmail: settings.notificationsEmail == 1,
                                         notificationsSms: settings.notificationsSms == 1,
                                         notificationsChats: settings.notificationsChats == 1,
                                         notificationsNews: settings.notificationsNews == 1)
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/GomaModels.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 21/12/2023.
//

import Foundation

enum GomaModels {
    
    struct GomaResponse<T: Codable>: Codable {
        let message: String?
        let data: T
        
        enum CodingKeys: String, CodingKey {
            case message = "message"
            case data = "data"
            
        }
        
    }
    
    struct BasicRegisterResponse: Codable {
        
        let id: Int
        let email: String
        let username: String
        let name: String
        let deviceId: String?
        let deviceType: String?
        let type: String?
        let code: String?
        let avatar: String?
        let createdAt: String?
        let updatedAt: String?
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case email = "email"
            case username = "username"
            case name = "name"
            case deviceId = "device_uuid"
            case deviceType = "device_type"
            case type = "type"
            case code = "code"
            case avatar = "avatar"
            case createdAt = "created_at"
            case updatedAt = "updated_at"
            
        }
    }
    
    struct LoginResponse: Codable {
        let token: String
        let userData: BasicRegisterResponse
        
        enum CodingKeys: String, CodingKey {
            case token = "token"
            case userData = "user"
        }
    }
    
    struct AnonymousLoginResponse: Codable {
        let token: String
        
        enum CodingKeys: String, CodingKey {
            case token = "token"
        }
    }
    
    struct LogoutResponse: Codable {
        let message: String
        
        enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }
    
    struct FavoriteItem: Codable {
        let id: Int
        let userId: Int
        let favoriteId: Int
        let type: FavorityItemType
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case userId = "user_id"
            case favoriteId = "favorite_id"
            case type = "favorite_type"
        }
        
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.id = try container.decode(Int.self, forKey: .id)
            self.userId = try container.decode(Int.self, forKey: .userId)
            self.favoriteId = try container.decode(Int.self, forKey: .favoriteId)
            
            let typeString = try container.decode(String.self, forKey: .type)
            
            if let favoriteItemType = FavorityItemType(typeString: typeString) {
                self.type = favoriteItemType
            } else {
                self.type = .event
            }
        }
        
    }
    
    enum FavorityItemType: Codable {
        case event
        case competition
        
        init?(typeString: String) {
            switch typeString {
            case "event":
                self = .event
            case "competition":
                self = .competition
            default:
                return nil
            }
        }
        
        var typeString: String {
            switch self {
            case .event:
                return "event"
            case .competition:
                return "competition"
            }
        }
    }
    
    struct FavoriteItemAddResponse: Codable {
        let message: String
        
        enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }
    
    struct FavoriteItemDeleteResponse: Codable {
        let message: String
        
        enum CodingKeys: String, CodingKey {
            case message = "message"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/GomaModels+Banners.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 08/01/2024.
//

import Foundation

extension GomaModels {
    
    // MARK: - BannerAlert
    struct BannerAlert: Codable {
        var identifier: String
        var title: String?
        var subtitle: String?
        var callToActionText: String?
        var callToActionUrl: String?
        var isActive: Int?
        var createdAt: String?
        var updatedAt: String?
        
        enum CodingKeys: String, CodingKey {
            case identifier = "id"
            case title = "title"
            case subtitle = "subtitle"
            case callToActionText = "cta_text"
            case callToActionUrl = "cta_url"
            case isActive = "is_active"
            case createdAt = "created_at"
            case updatedAt = "updated_at"
        }
        
        init(identifier: String,
             title: String,
             subtitle: String,
             ctaText: String,
             ctaUrl: String,
             isActive: Int,
             createdAt: String,
             updatedAt: String)
        {
            self.identifier = identifier
            self.title = title
            self.subtitle = subtitle
            self.callToActionText = ctaText
            self.callToActionUrl = ctaUrl
            self.isActive = isActive
            self.createdAt = createdAt
            self.updatedAt = updatedAt
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.BannerAlert.CodingKeys> = try decoder.container(keyedBy: GomaModels.BannerAlert.CodingKeys.self)
            
            if let idValue = try? container.decode(Int.self, forKey: CodingKeys.identifier) {
                self.identifier = String(idValue)
            }
            else if let idStringValue = try? container.decode(String.self, forKey: CodingKeys.identifier) {
                self.identifier = idStringValue
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.identifier, context)
                throw error
            }
            
            self.title = try container.decodeIfPresent(String.self, forKey: GomaModels.BannerAlert.CodingKeys.title)
            self.subtitle = try container.decodeIfPresent(String.self, forKey: GomaModels.BannerAlert.CodingKeys.subtitle)
            self.callToActionText = try container.decodeIfPresent(String.self, forKey: GomaModels.BannerAlert.CodingKeys.callToActionText)
            self.callToActionUrl = try container.decodeIfPresent(String.self, forKey: GomaModels.BannerAlert.CodingKeys.callToActionUrl)
            self.isActive = try container.decodeIfPresent(Int.self, forKey: GomaModels.BannerAlert.CodingKeys.isActive)
            self.createdAt = try container.decodeIfPresent(String.self, forKey: GomaModels.BannerAlert.CodingKeys.createdAt)
            self.updatedAt = try container.decodeIfPresent(String.self, forKey: GomaModels.BannerAlert.CodingKeys.updatedAt)
        }
    }
    
    // MARK: - Banner
    struct Banner: Codable {
        var identifier: String
        var title: String?
        var subtitle: String?
        var imageUrl: String?
        var callToActionText: String?
        var callToActionUrl: String?
        var isActive: Int?
        
        enum CodingKeys: String, CodingKey {
            case identifier = "id"
            case title = "title"
            case subtitle = "subtitle"
            case imageUrl = "image_url"
            case callToActionText = "cta_text"
            case callToActionUrl = "cta_url"
            case isActive = "is_active"
        }
        
        init(identifier: String,
             title: String,
             subtitle: String,
             imageUrl: String,
             ctaText: String,
             ctaUrl: String,
             isActive: Int)
        {
            self.identifier = identifier
            self.title = title
            self.subtitle = subtitle
            self.imageUrl = imageUrl
            self.callToActionText = ctaText
            self.callToActionUrl = ctaUrl
            self.isActive = isActive
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.Banner.CodingKeys> = try decoder.container(keyedBy: GomaModels.Banner.CodingKeys.self)
            
            if let idValue = try? container.decode(Int.self, forKey: CodingKeys.identifier) {
                self.identifier = String(idValue)
            }
            else if let idStringValue = try? container.decode(String.self, forKey: CodingKeys.identifier) {
                self.identifier = idStringValue
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.identifier, context)
                throw error
            }
            
            self.title = try container.decodeIfPresent(String.self, forKey: GomaModels.Banner.CodingKeys.title)
            self.subtitle = try container.decodeIfPresent(String.self, forKey: GomaModels.Banner.CodingKeys.subtitle)
            self.imageUrl = try container.decodeIfPresent(String.self, forKey: GomaModels.Banner.CodingKeys.imageUrl)
            self.callToActionText = try container.decodeIfPresent(String.self, forKey: GomaModels.Banner.CodingKeys.callToActionText)
            self.callToActionUrl = try container.decodeIfPresent(String.self, forKey: GomaModels.Banner.CodingKeys.callToActionUrl)
            self.isActive = try container.decodeIfPresent(Int.self, forKey: GomaModels.Banner.CodingKeys.isActive)
        }
        
    }
    
    // MARK: - Banner
    struct AlertBanner: Codable {
        var identifier: String
        var title: String
        var subtitle: String?
        var callToActionText: String?
        var callToActionUrl: String?
        var isActive: Int?
        
        enum CodingKeys: String, CodingKey {
            case identifier = "id"
            case title = "title"
            case subtitle = "subtitle"
            case callToActionText = "cta_text"
            case callToActionUrl = "cta_url"
            case isActive = "is_active"
        }
        
        init(identifier: String,
             title: String,
             subtitle: String,
             ctaText: String,
             ctaUrl: String,
             isActive: Int)
        {
            self.identifier = identifier
            self.title = title
            self.subtitle = subtitle
            self.callToActionText = ctaText
            self.callToActionUrl = ctaUrl
            self.isActive = isActive
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)
            
            if let idValue = try? container.decode(Int.self, forKey: CodingKeys.identifier) {
                self.identifier = String(idValue)
            }
            else if let idStringValue = try? container.decode(String.self, forKey: CodingKeys.identifier) {
                self.identifier = idStringValue
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.identifier, context)
                throw error
            }
            
            self.title = try container.decode(String.self, forKey: CodingKeys.title)
            self.subtitle = try container.decodeIfPresent(String.self, forKey: CodingKeys.subtitle)
            self.callToActionText = try container.decodeIfPresent(String.self, forKey: CodingKeys.callToActionText)
            self.callToActionUrl = try container.decodeIfPresent(String.self, forKey: CodingKeys.callToActionUrl)
            self.isActive = try container.decodeIfPresent(Int.self, forKey: CodingKeys.isActive)
        }
        
    }
    
    struct Story: Codable {
        
        var identifier: String
        var title: String
        var iconUrl: String
        var mediaUrl: String
        var mediaType: String
        var callToActionText: String
        var callToActionUrl: String
        var isActive: Int
        var createdAt: String
        var updatedAt: String

        enum CodingKeys: String, CodingKey {
            case identifier = "id"
            case title = "title"
            case iconUrl = "icon_url"
            case mediaUrl = "media_url"
            case mediaType = "media_type"
            case callToActionText = "cta_text"
            case callToActionUrl = "cta_url"
            case isActive = "is_active"
            case createdAt = "created_at"
            case updatedAt = "updated_at"
        }

        init(identifier: String,
             title: String,
             iconUrl: String,
             mediaUrl: String,
             mediaType: String,
             callToActionText: String,
             callToActionUrl: String,
             isActive: Int,
             createdAt: String,
             updatedAt: String)
        {
            self.identifier = identifier
            self.title = title
            self.iconUrl = iconUrl
            self.mediaUrl = mediaUrl
            self.mediaType = mediaType
            self.callToActionText = callToActionText
            self.callToActionUrl = callToActionUrl
            self.isActive = isActive
            self.createdAt = createdAt
            self.updatedAt = updatedAt
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.Story.CodingKeys> = try decoder.container(keyedBy: GomaModels.Story.CodingKeys.self)
            
            if let idValue = try? container.decode(Int.self, forKey: CodingKeys.identifier) {
                self.identifier = String(idValue)
            }
            else if let idStringValue = try? container.decode(String.self, forKey: CodingKeys.identifier) {
                self.identifier = idStringValue
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.identifier, context)
                throw error
            }
            
            self.title = try container.decode(String.self, forKey: GomaModels.Story.CodingKeys.title)
            self.iconUrl = try container.decode(String.self, forKey: GomaModels.Story.CodingKeys.iconUrl)
            self.mediaUrl = try container.decode(String.self, forKey: GomaModels.Story.CodingKeys.mediaUrl)
            self.mediaType = try container.decode(String.self, forKey: GomaModels.Story.CodingKeys.mediaType)
            self.callToActionText = try container.decode(String.self, forKey: GomaModels.Story.CodingKeys.callToActionText)
            self.callToActionUrl = try container.decode(String.self, forKey: GomaModels.Story.CodingKeys.callToActionUrl)
            self.isActive = try container.decode(Int.self, forKey: GomaModels.Story.CodingKeys.isActive)
            self.createdAt = try container.decode(String.self, forKey: GomaModels.Story.CodingKeys.createdAt)
            self.updatedAt = try container.decode(String.self, forKey: GomaModels.Story.CodingKeys.updatedAt)
        }
        
    }
    
    class SportAssociatedEventBanner: Codable {
        
        var identifier: String
        var title: String?
        var sportEventId: Int?
        var imageUrl: String?
        var callToActionUrl: String?
        var isActive: Int?
        var createdAt: String?
        var updatedAt: String?
        var event: Event

        enum CodingKeys: String, CodingKey {
            case identifier = "id"
            case title = "title"
            case sportEventId = "sport_event_id"
            case imageUrl = "image_url"
            case callToActionUrl = "cta_url"
            case isActive = "is_active"
            case createdAt = "created_at"
            case updatedAt = "updated_at"
            case event = "event"
        }

        init(identifier: String,
             title: String?,
             sportEventId: Int?,
             imageUrl: String?,
             callToActionUrl: String?,
             isActive: Int?,
             createdAt: String?,
             updatedAt: String?,
             event: Event)
        {
            self.identifier = identifier
            self.title = title
            self.sportEventId = sportEventId
            self.imageUrl = imageUrl
            self.callToActionUrl = callToActionUrl
            self.isActive = isActive
            self.createdAt = createdAt
            self.updatedAt = updatedAt
            self.event = event
        }
        
        required init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            if let idValue = try? container.decode(Int.self, forKey: CodingKeys.identifier) {
                self.identifier = String(idValue)
            }
            else if let idStringValue = try? container.decode(String.self, forKey: CodingKeys.identifier) {
                self.identifier = idStringValue
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.identifier, context)
                throw error
            }
            
            self.title = try container.decodeIfPresent(String.self, forKey: CodingKeys.title)
            self.sportEventId = try container.decodeIfPresent(Int.self, forKey: CodingKeys.sportEventId)
            self.imageUrl = try container.decodeIfPresent(String.self, forKey: CodingKeys.imageUrl)
            self.callToActionUrl = try container.decodeIfPresent(String.self, forKey: CodingKeys.callToActionUrl)
            self.isActive = try container.decodeIfPresent(Int.self, forKey: CodingKeys.isActive)
            self.createdAt = try container.decodeIfPresent(String.self, forKey: CodingKeys.createdAt)
            self.updatedAt = try container.decodeIfPresent(String.self, forKey: CodingKeys.updatedAt)
            self.event = try container.decode(GomaModels.Event.self, forKey: CodingKeys.event)
        }
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/GomaModels+Betting.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 19/01/2024.
//

import Foundation
import Extensions

extension GomaModels {
    
    struct PlaceBetTicketResponse: Codable {
        
        let id: String
        let userId: String
        let type: String
        let stake: Double
        let odds: Double
        let possibleWinnings: Double
        let shareId: String
        let status: String
        let selections: [MyTicketSelection]
        var createdAt: String?
        
        init(id: String,
             userId: String,
             type: String,
             stake: Double,
             odds: Double,
             possibleWinnings: Double,
             shareId: String,
             status: String,
             selections: [MyTicketSelection]) {
            self.userId = userId
            self.type = type
            self.stake = stake
            self.odds = odds
            self.possibleWinnings = possibleWinnings
            self.shareId = shareId
            self.id = id
            self.status = status
            self.selections = selections
        }
        
        enum CodingKeys: String, CodingKey {
            case id
            case userId = "user_id"
            case shareId = "share_id"
            case possibleWinnings = "possible_winnings"
            case type
            case stake
            case odds = "odds"
            case status
            case selections = "selections"
            case createdAt = "created_at"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.PlaceBetTicketResponse.CodingKeys> = try decoder.container(keyedBy: GomaModels.PlaceBetTicketResponse.CodingKeys.self)
            self.type = try container.decode(String.self, forKey: GomaModels.PlaceBetTicketResponse.CodingKeys.type)
            self.stake = try container.decode(Double.self, forKey: GomaModels.PlaceBetTicketResponse.CodingKeys.stake)
            
            // Decode Odd
            if let priceValue = try? container.decode(Double.self, forKey: .odds) {
                self.odds = priceValue
            } else if let priceString = try? container.decode(String.self, forKey: .odds), let priceValue = Double(priceString) {
                self.odds = priceValue
            } else {
                throw DecodingError.dataCorruptedError(forKey: .odds, in: container, debugDescription: "Odds is not a Double or String")
            }
            
            self.possibleWinnings = try container.decode(Double.self, forKey: GomaModels.PlaceBetTicketResponse.CodingKeys.possibleWinnings)
            self.shareId = try container.decode(String.self, forKey: GomaModels.PlaceBetTicketResponse.CodingKeys.shareId)
            self.status = try container.decode(String.self, forKey: GomaModels.PlaceBetTicketResponse.CodingKeys.status)
            
            if let userIdInt = try? container.decode(Int.self, forKey: .userId) {
                self.userId = String(userIdInt)
            } else {
                self.userId = try container.decode(String.self, forKey: .userId)
            }
            
            if let idInt = try? container.decode(Int.self, forKey: .id) {
                self.id = String(idInt)
            } else {
                self.id = try container.decode(String.self, forKey: .id)
            }
            
            let rawSelections = try container.decode([FailableDecodable<MyTicketSelection>].self, forKey: .selections)
            self.selections = rawSelections.compactMap({ $0.content })
            
            self.createdAt = try container.decodeIfPresent(String.self, forKey: .createdAt)
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.userId, forKey: CodingKeys.userId)
            try container.encode(self.type, forKey: CodingKeys.type)
            try container.encode(self.stake, forKey: CodingKeys.stake)
            try container.encode(self.odds, forKey: CodingKeys.odds)
            try container.encode(self.possibleWinnings, forKey: CodingKeys.possibleWinnings)
            try container.encode(self.shareId, forKey: CodingKeys.shareId)
            try container.encode(self.id, forKey: CodingKeys.id)
            try container.encode(self.status, forKey: CodingKeys.status)
        }
    }

    
    struct AllowedBets: Codable {
        
        var allowedTypes: [BetType]
        var allowedStakes: [Double]
        
        enum CodingKeys: String, CodingKey {
            case allowedTypes = "allowed_types"
            case allowedStakes = "allowed_stakes"
            case allowedSystemBetTypes = "allowed_system_types"
        }

        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.AllowedBets.CodingKeys> = try decoder.container(keyedBy: GomaModels.AllowedBets.CodingKeys.self)
            
            self.allowedStakes = try container.decode([Double].self, forKey: GomaModels.AllowedBets.CodingKeys.allowedStakes)
            
            let allowedTypesStrings = try container.decode([String].self, forKey: GomaModels.AllowedBets.CodingKeys.allowedTypes)
            let allowedSystemBetTypes = try container.decode([GomaModels.SystemBetType].self, forKey: GomaModels.AllowedBets.CodingKeys.allowedSystemBetTypes)
            
            var allowedBetTypes: [BetType] = []
            
            for allowedTypeString in allowedTypesStrings {
                switch allowedTypeString.lowercased() {
                case "single":
                    allowedBetTypes.append(.single)
                case "multiple":
                    allowedBetTypes.append(.multiple)
                case "system":
                    for allowedSystemBetType in allowedSystemBetTypes {
                        allowedBetTypes.append(.system(type: allowedSystemBetType))
                    }
                default:
                    ()
                }
            }
            
            self.allowedTypes = allowedBetTypes
        }
        
        func encode(to encoder: Encoder) throws {
            
        }
        
        init(allowedTypes: [BetType], allowedStakes: [Double]) {
            self.allowedTypes = allowedTypes
            self.allowedStakes = allowedStakes
        }
        
    }

    
    enum BetType: Codable {
        case single
        case multiple
        case system(type: SystemBetType)
        
        var identifier: String {
            switch self {
            case .single:
                return "single"
            case .multiple:
                return "multiple"
            case .system(let systemType):
                return systemType.type
            }
        }
        
        var name: String {
            switch self {
            case .single:
                return "Single"
            case .multiple:
                return "Multiple"
            case .system(let systemType):
                return systemType.label
            }
        }
    }
    
    struct SystemBetType: Codable {
        var type: String
        var label: String
        
        enum CodingKeys: String, CodingKey {
            case type = "type"
            case label = "label"
        }
    }
    
    // MARK: - BetslipPotentialReturn
    struct BetslipPotentialReturn: Codable {
        var stake: Double
        var type: String
        var selections: [BettingSelection]
        var odds: Double
        var possibleWinnings: Double

        enum CodingKeys: String, CodingKey {
            case stake = "total_stake"
            case type = "type"
            case selections = "selections"
            case odds = "odds"
            case possibleWinnings = "possible_winnings"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.BetslipPotentialReturn.CodingKeys> = try decoder.container(keyedBy: GomaModels.BetslipPotentialReturn.CodingKeys.self)
            
            if let stakeString = try? container.decode(String.self, forKey: GomaModels.BetslipPotentialReturn.CodingKeys.stake),
               let stake = Double(stakeString) {
                self.stake = stake
            }
            else {
                let stakeDouble = try container.decode(Double.self, forKey: GomaModels.BetslipPotentialReturn.CodingKeys.stake)
                self.stake = stakeDouble
            }
            
            self.type = try container.decode(String.self, forKey: GomaModels.BetslipPotentialReturn.CodingKeys.type)
            self.selections = try container.decode([GomaModels.BettingSelection].self, forKey: GomaModels.BetslipPotentialReturn.CodingKeys.selections)
            self.possibleWinnings = try container.decode(Double.self, forKey: GomaModels.BetslipPotentialReturn.CodingKeys.possibleWinnings)
            
            // Decode Odd
            if let priceValue = try? container.decode(Double.self, forKey: .odds) {
                self.odds = priceValue
            } else if let priceString = try? container.decode(String.self, forKey: .odds), let priceValue = Double(priceString) {
                self.odds = priceValue
            } else {
                throw DecodingError.dataCorruptedError(forKey: .odds, in: container, debugDescription: "Odds is not a Double or String")
            }
            
        }
    }

    // MARK: - Selection
    struct BettingSelection: Codable {
        var sportEventId: String
        var outcomeId: String
        var odd: Double

        enum CodingKeys: String, CodingKey {
            case sportEventId = "sport_event_id"
            case outcomeId = "outcome_id"
            case odd = "odd"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.BettingSelection.CodingKeys> = try decoder.container(keyedBy: GomaModels.BettingSelection.CodingKeys.self)
            self.sportEventId = try container.decode(String.self, forKey: GomaModels.BettingSelection.CodingKeys.sportEventId)
            self.outcomeId = try container.decode(String.self, forKey: GomaModels.BettingSelection.CodingKeys.outcomeId)
            
            // Decode odds
            if let oddValue = try? container.decode(Double.self, forKey: .odd) {
                self.odd = oddValue
            } else if let oddString = try? container.decode(String.self, forKey: .odd), let oddValue = Double(oddString) {
                self.odd = oddValue
            } else {
                throw DecodingError.dataCorruptedError(forKey: .odd, in: container, debugDescription: "Odd is not a Double or String")
            }
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: GomaModels.BettingSelection.CodingKeys.self)
            try container.encode(self.sportEventId, forKey: GomaModels.BettingSelection.CodingKeys.sportEventId)
            try container.encode(self.outcomeId, forKey: GomaModels.BettingSelection.CodingKeys.outcomeId)
            try container.encode(self.odd, forKey: GomaModels.BettingSelection.CodingKeys.odd)
        }
    }

    
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/GomaModels+CMSInitialDump.swift
````swift
//
//  GomaModels+CMSInitialDump.swift
//
//
//  Created on: Feb 28, 2025
//

import Foundation

extension GomaModels {
    // MARK: - Home Template

}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/GomaModels+Events.swift
````swift
//
//  File.swift
//
//
//  Created by Ruben Roques on 22/12/2023.
//

import Foundation

extension GomaModels {
    
    
    struct EventMetadataPointer: Codable {
        var id: String?
        var eventId: String
        var eventMarketId: String
        var callToActionURL: String?
        var imageURL: String?
        
        enum CodingKeys: String, CodingKey {
            case id
            case eventId = "sport_event_id"
            case eventMarketId = "sport_event_market_id"
            case callToActionURL = "cta_url"
            case imageURL = "image_url"
            case meta
        }
        
        enum MetaKeys: String, CodingKey {
            case imgURL = "img_url"
        }

        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.id = try? container.decodeIfPresent(String.self, forKey: .id)
            self.eventId = try container.decode(String.self, forKey: .eventId)
            self.eventMarketId = try container.decode(String.self, forKey: .eventMarketId)
            self.callToActionURL = try? container.decodeIfPresent(String.self, forKey: .callToActionURL)
            self.imageURL = try? container.decodeIfPresent(String.self, forKey: .imageURL)

            if self.imageURL == nil, let metaContainer = try? container.nestedContainer(keyedBy: MetaKeys.self, forKey: .meta) {
                self.imageURL = try? metaContainer.decodeIfPresent(String.self, forKey: .imgURL)
            }
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            
            try container.encodeIfPresent(id, forKey: .id)
            try container.encode(eventId, forKey: .eventId)
            try container.encode(eventMarketId, forKey: .eventMarketId)
            try container.encodeIfPresent(callToActionURL, forKey: .callToActionURL)
            try container.encodeIfPresent(imageURL, forKey: .imageURL)
        }
        
    }

    
    struct GomaPagedResponse<T: Codable>: Codable {
        var data: T
        var currentPage: Int?
        var itemsPerPage: Int?
        
        enum CodingKeys: String, CodingKey {
            case data = "data"
            case currentPage = "current_page"
            case itemsPerPage = "per_page"
        }
    }
    
    struct EventsPointerGroup: Codable {
        var events: [String]
        var title: String?
        
        enum CodingKeys: String, CodingKey {
            case events = "events"
            case title = "title"
        }
        
        init(events: [String], title: String? = nil) {
            self.events = events
            self.title = title
        }
        
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.events = try container.decode([String].self, forKey: .events)
            self.title = try container.decodeIfPresent(String.self, forKey: .title)
        }
        
    }
    
    struct EventsGroup: Codable {
        var events: [Event]
        var marketGroupId: String?
        
        enum CodingKeys: String, CodingKey {
            case events = "events"
            case marketGroupId = "market_id"
        }
        
        init(events: [Event], marketGroupId: String?) {
            self.events = events
            self.marketGroupId = marketGroupId
        }
    }
    
    struct PopularEvent: Codable {
        var title: String?
        var events: [Event]
        
        enum CodingKeys: String, CodingKey {
            case title = "title"
            case events = "events"
        }
    }
    
    struct Event: Codable, Equatable {
        
        /*
         ,"home_team_meta":{"country":"Israel","name_livefeed":"Hapoel Haifa"},
         "away_team_meta":{"country":"Israel","name_livefeed":"Hapoel Hadera"},
         */
        
        var identifier: String
        
        var homeName: String
        var awayName: String
        
        var homeLogoUrl: String?
        var awayLogoUrl: String?
        
        var homeScore: Int?
        var awayScore: Int?
        
        var startDate: Date
        
        var sport: Sport
        var competition: Competition
        
        var status: EventStatus
        var isLive: Bool
        
        var placardInfo: PlacardInfo?
        var region: Region
        
        var matchTime: String?
        
        var markets: [Market]
        
        var metaDetails: MetaDetails?
        
        var scores: [String: Score]
        
        enum CodingKeys: String, CodingKey {
            case identifier = "id"
            case homeName = "home_team"
            case awayName = "away_team"
            
            case homeScore = "home_score"
            case awayScore = "away_score"
            
            case specialFTScore = "ft_score"
            case specialHTScore = "ht_score"
            case specialETScore = "et_score"
            
            case homeMetaInfo = "home_team_meta"
            case awayMetaInfo = "away_team_meta"
            
            case startDate = "date_time"
            
            case sport = "sport"
            case competition = "competition"
            case status = "status"
            case isLive = "is_live"
            
            case placardInfo = "placard_info"
            case region = "region"
            
            case matchTime = "timer"
            
            case markets = "markets"
            case market = "market"
            
            case metaDetails = "meta"
            
            case p1Score = "p1_score"
            case p2Score = "p2_score"
            case p3Score = "p3_score"
            case p4Score = "p4_score"
            case p5Score = "p5_score"
                   
        }
        
        enum TeamsMetaCodingKeys: String, CodingKey {
            case country = "country"
            case name = "name_livefeed"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)
            if let idValue = try? container.decode(Int.self, forKey: CodingKeys.identifier) {
                self.identifier = String(idValue)
            }
            else if let idStringValue = try? container.decode(String.self, forKey: CodingKeys.identifier) {
                self.identifier = idStringValue
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.identifier, context)
                throw error
            }
            
            self.homeName = try container.decode(String.self, forKey: CodingKeys.homeName)
            self.awayName = try container.decode(String.self, forKey: CodingKeys.awayName)
            
            self.startDate = try container.decode(Date.self, forKey: CodingKeys.startDate)
            
            self.sport = try container.decode(GomaModels.Sport.self, forKey: CodingKeys.sport)
            self.competition = try container.decode(GomaModels.Competition.self, forKey: CodingKeys.competition)
            
            self.isLive = false
            if let isLiveIntValue = try? container.decode(Int.self, forKey: CodingKeys.isLive) {
                self.isLive = isLiveIntValue != 0
            }
            else if let isLiveValue = try? container.decode(Bool.self, forKey: CodingKeys.isLive) {
                self.isLive = isLiveValue
            }
            
            if let statusString = try? container.decode(String.self, forKey: CodingKeys.status) {
                self.status = EventStatus(value: statusString, isLive: self.isLive)
            }
            else {
                self.status = .unknown
            }
            
            self.placardInfo = try container.decodeIfPresent(GomaModels.PlacardInfo.self, forKey: CodingKeys.placardInfo)
            self.region = try container.decode(GomaModels.Region.self, forKey: CodingKeys.region)
            
            self.matchTime = try container.decodeIfPresent(String.self, forKey: CodingKeys.matchTime)
            
            if let singleMarket = try? container.decode(GomaModels.Market.self, forKey: CodingKeys.market) {
                self.markets = [singleMarket]
            }
            else if let multipleMarkets = try? container.decode([GomaModels.Market].self, forKey: CodingKeys.markets) {
                self.markets = multipleMarkets
            }
            else {
                self.markets = []
            }
            
            if let homeMetaContainer = try? container.nestedContainer(keyedBy: TeamsMetaCodingKeys.self, forKey: .homeMetaInfo) {
                let country = try homeMetaContainer.decodeIfPresent(String.self, forKey: TeamsMetaCodingKeys.country)
                let name = try homeMetaContainer.decodeIfPresent(String.self, forKey: TeamsMetaCodingKeys.name)
                
                self.homeLogoUrl = "/\(country ?? "")/\(name ?? "")"
            }
            
            if let awayMetaContainer = try? container.nestedContainer(keyedBy: TeamsMetaCodingKeys.self, forKey: .awayMetaInfo) {
                let country = try awayMetaContainer.decodeIfPresent(String.self, forKey: TeamsMetaCodingKeys.country)
                let name = try awayMetaContainer.decodeIfPresent(String.self, forKey: TeamsMetaCodingKeys.name)
                
                self.awayLogoUrl = "/\(country ?? "")/\(name ?? "")"
            }
            
            self.metaDetails = try container.decodeIfPresent(MetaDetails.self, forKey: CodingKeys.metaDetails)
            
            self.homeScore = try container.decodeIfPresent(Int.self, forKey: CodingKeys.homeScore)
            self.awayScore = try container.decodeIfPresent(Int.self, forKey: CodingKeys.awayScore)
            
            // NEW SCORES
            var newScores = [String: Score]()
            
            // Current Score
            let score = Score.matchFull(home: self.homeScore, away: self.awayScore)
            newScores["matchFull"] = score
            
            // Part scores
            if let p1Score = try container.decodeIfPresent(String.self, forKey: CodingKeys.p1Score) {
                var homeScore = 0
                var awayScore = 0
                
                let stringWithoutBrackets = p1Score.replacingOccurrences(of: "[", with: "").replacingOccurrences(of: "]", with: "")
                let numbers = stringWithoutBrackets.components(separatedBy: "-")

                // Convert the strings to integers
                if let home = Int(numbers[0]), let away = Int(numbers[1]) {
                    homeScore = home
                    awayScore = away
                }
                
                let p1NewScore = Score.set(index: 0, home: homeScore, away: awayScore)
                newScores["set1"] = p1NewScore

            }
            
            if let p2Score = try container.decodeIfPresent(String.self, forKey: CodingKeys.p2Score) {
                var homeScore = 0
                var awayScore = 0
                
                let stringWithoutBrackets = p2Score.replacingOccurrences(of: "[", with: "").replacingOccurrences(of: "]", with: "")
                let numbers = stringWithoutBrackets.components(separatedBy: "-")

                // Convert the strings to integers
                if let home = Int(numbers[0]), let away = Int(numbers[1]) {
                    homeScore = home
                    awayScore = away
                }
                
                let p2NewScore = Score.set(index: 1, home: homeScore, away: awayScore)
                newScores["set2"] = p2NewScore

            }
            
            if let p3Score = try container.decodeIfPresent(String.self, forKey: CodingKeys.p3Score) {
                var homeScore = 0
                var awayScore = 0
                
                let stringWithoutBrackets = p3Score.replacingOccurrences(of: "[", with: "").replacingOccurrences(of: "]", with: "")
                let numbers = stringWithoutBrackets.components(separatedBy: "-")

                // Convert the strings to integers
                if let home = Int(numbers[0]), let away = Int(numbers[1]) {
                    homeScore = home
                    awayScore = away
                }
                
                let p3NewScore = Score.set(index: 2, home: homeScore, away: awayScore)
                newScores["set3"] = p3NewScore

            }
            
            if let p4Score = try container.decodeIfPresent(String.self, forKey: CodingKeys.p4Score) {
                var homeScore = 0
                var awayScore = 0
                
                let stringWithoutBrackets = p4Score.replacingOccurrences(of: "[", with: "").replacingOccurrences(of: "]", with: "")
                let numbers = stringWithoutBrackets.components(separatedBy: "-")

                // Convert the strings to integers
                if let home = Int(numbers[0]), let away = Int(numbers[1]) {
                    homeScore = home
                    awayScore = away
                }
                
                let p4NewScore = Score.set(index: 3, home: homeScore, away: awayScore)
                newScores["set4"] = p4NewScore

            }
            
            if let p5Score = try container.decodeIfPresent(String.self, forKey: CodingKeys.p5Score) {
                var homeScore = 0
                var awayScore = 0
                
                let stringWithoutBrackets = p5Score.replacingOccurrences(of: "[", with: "").replacingOccurrences(of: "]", with: "")
                let numbers = stringWithoutBrackets.components(separatedBy: "-")

                // Convert the strings to integers
                if let home = Int(numbers[0]), let away = Int(numbers[1]) {
                    homeScore = home
                    awayScore = away
                }
                
                let p5NewScore = Score.set(index: 4, home: homeScore, away: awayScore)
                newScores["set5"] = p5NewScore

            }
            
            // Tennis
            // TODO: Add game_score when available
            if self.sport.identifier == "2" {
                let score = Score.gamePart(home: self.homeScore, away: self.awayScore)
                newScores["gamePart"] = score
            }
            
            self.scores = newScores
            
            switch self.status {
            case .unknown, .notStarted, .inProgress:
                self.homeScore = try container.decodeIfPresent(Int.self, forKey: CodingKeys.homeScore)
                self.awayScore = try container.decodeIfPresent(Int.self, forKey: CodingKeys.awayScore)
                
            case .ended(let details):
                var scoreString: String = ""
                
                switch details?.lowercased() {
                case "ft":
                    scoreString = (try? container.decode(String.self, forKey: CodingKeys.specialFTScore)) ?? ""
                case "et":
                    scoreString = (try? container.decode(String.self, forKey: CodingKeys.specialETScore)) ?? ""
                case "ht":
                    scoreString = (try? container.decode(String.self, forKey: CodingKeys.specialHTScore)) ?? ""
                default:
                    scoreString = "\(self.homeScore ?? 0)-\(self.awayScore ?? 0)"
                }
                
                scoreString = scoreString.replacingOccurrences(of: "[", with: "")
                scoreString = scoreString.replacingOccurrences(of: "]", with: "")
                let resultParts = scoreString.components(separatedBy: "-")
                let homeScoreString = resultParts.first ?? ""
                let awayScoreString = resultParts.last ?? ""
                
                self.homeScore = Int(homeScoreString)
                self.awayScore = Int(awayScoreString)

            }
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.identifier, forKey: CodingKeys.identifier)
            try container.encodeIfPresent(self.homeName, forKey: CodingKeys.homeName)
            try container.encodeIfPresent(self.awayName, forKey: CodingKeys.awayName)
            try container.encodeIfPresent(self.startDate, forKey: CodingKeys.startDate)
            try container.encode(self.sport, forKey: CodingKeys.sport)
            try container.encode(self.competition, forKey: CodingKeys.competition)
            try container.encode(self.markets, forKey: CodingKeys.markets)
        }
        
    }
    
    struct Region: Codable, Equatable {
        var identifier: String
        var name: String
        var isoCode: String?
        var preLiveEventsCount: Int?
        var liveEventsCount: Int?
        
        enum CodingKeys: String, CodingKey {
            case identifier = "id"
            case name = "name"
            case isoCode = "iso_code"
            case preLiveEventsCount = "pre_live_count"
            case liveEventsCount = "live_count"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.Region.CodingKeys> = try decoder.container(keyedBy: GomaModels.Region.CodingKeys.self)
            
            if let idValue = try? container.decode(Int.self, forKey: GomaModels.Region.CodingKeys.identifier) {
                self.identifier = String(idValue)
            }
            else if let idStringValue = try? container.decode(String.self, forKey: GomaModels.Region.CodingKeys.identifier) {
                self.identifier = idStringValue
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.identifier, context)
                throw error
            }
            
            self.name = try container.decode(String.self, forKey: GomaModels.Region.CodingKeys.name)
            self.isoCode = try container.decodeIfPresent(String.self, forKey: GomaModels.Region.CodingKeys.isoCode)
            
            if let countString = try? container.decode(String.self, forKey: .preLiveEventsCount), let count = Int(countString) {
                self.preLiveEventsCount = count
            } else if let countInt = try container.decodeIfPresent(Int.self, forKey: .preLiveEventsCount) {
                self.preLiveEventsCount = countInt
            }
            else {
                self.preLiveEventsCount = 0
            }
            
            if let countString = try? container.decode(String.self, forKey: .liveEventsCount), let count = Int(countString) {
                self.liveEventsCount = count
            } else if let countInt = try container.decodeIfPresent(Int.self, forKey: .liveEventsCount) {
                self.liveEventsCount = countInt
            }
            else {
                self.liveEventsCount = 0
            }
        }
        
    }
    
    struct PlacardInfo: Codable, Equatable {
        var eventCode: String
        var tvChannelCode: String
        
        enum CodingKeys: String, CodingKey {
            case eventCode = "event_code"
            case tvChannelCode = "tv_channel"
        }
        
    }
    
    struct Competition: Codable, Equatable {
        var identifier: String
        var name: String
        var region: Region?
        var sport: Sport?
        var preLiveEventsCount: Int?
        var liveEventsCount: Int?
        
        enum CodingKeys: String, CodingKey {
            case identifier = "id"
            case name = "name"
            case region = "region"
            case sport = "sport"
            case preLiveEventsCount = "pre_live_count"
            case liveEventsCount = "live_count"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.Competition.CodingKeys> = try decoder.container(keyedBy: GomaModels.Competition.CodingKeys.self)
            
            if let idValue = try? container.decode(Int.self, forKey: GomaModels.Competition.CodingKeys.identifier) {
                self.identifier = String(idValue)
            }
            else if let idStringValue = try? container.decode(String.self, forKey: GomaModels.Competition.CodingKeys.identifier) {
                self.identifier = idStringValue
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.identifier, context)
                throw error
            }
            
            self.name = try container.decode(String.self, forKey: GomaModels.Competition.CodingKeys.name)
            
            if let regionContainer = try? container.nestedContainer(keyedBy: CodingKeys.self, forKey: .region) {
                self.sport = try regionContainer.decodeIfPresent(Sport.self, forKey: GomaModels.Competition.CodingKeys.sport)
                self.region = try container.decode(Region.self, forKey: GomaModels.Competition.CodingKeys.region)
            }
            
            if let countString = try? container.decode(String.self, forKey: .preLiveEventsCount), let count = Int(countString) {
                self.preLiveEventsCount = count
            } else if let countInt = try container.decodeIfPresent(Int.self, forKey: .preLiveEventsCount) {
                self.preLiveEventsCount = countInt
            }
            else {
                self.preLiveEventsCount = nil
            }
            
            if let countString = try? container.decode(String.self, forKey: .liveEventsCount), let count = Int(countString) {
                self.liveEventsCount = count
            } else if let countInt = try container.decodeIfPresent(Int.self, forKey: .liveEventsCount) {
                self.liveEventsCount = countInt
            }
            else {
                self.liveEventsCount = nil
            }
            
        }
        
    }
    
    enum EventStatus: Codable, Equatable {
        case unknown
        case notStarted
        case inProgress(String)
        case ended(details: String?)
        
        init(value: String, isLive: Bool) {
            if value.lowercased() == "not_started" {
                self = .notStarted
            }
            else if isLive {
                self = .inProgress(value)
            }
            else {
                self = .ended(details: value.lowercased())
            }
        }
        
        var stringValue: String {
            switch self {
            case .notStarted: return "not_started"
            case .ended(let details): return "ended(\(details ?? "")"
            case .inProgress(let value): return value
            case .unknown: return ""
            }
        }
        
    }
    
    
    struct Market: Codable, Equatable {
        
        var identifier: String
        var name: String
        var groupId: String
        var outcomes: [Outcome]
        var stats: Stats?
        
        enum CodingKeys: String, CodingKey {
            case identifier = "id"
            case name = "name"
            case groupId = "sport_event_market_id"
            case outcomes = "outcomes"
            case stats = "stats"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.Market.CodingKeys> = try decoder.container(keyedBy: GomaModels.Market.CodingKeys.self)
            
            // Check if the identifier is Int or String
            if let idValue = try? container.decode(Int.self, forKey: CodingKeys.identifier) {
                self.identifier = String(idValue)
            }
            else if let idStringValue = try? container.decode(String.self, forKey: CodingKeys.identifier) {
                self.identifier = idStringValue
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.identifier, context)
                throw error
            }
            
            self.name = try container.decode(String.self, forKey: CodingKeys.name)
            
            if let singleOutcome = try? container.decode(GomaModels.Outcome.self, forKey: CodingKeys.outcomes) {
                self.outcomes = [singleOutcome]
            }
            else if let multipleOutcomes = try? container.decode([GomaModels.Outcome].self, forKey: CodingKeys.outcomes) {
                self.outcomes = multipleOutcomes
            }
            else {
                self.outcomes = []
            }
            
            self.stats = try? container.decode(Stats.self, forKey: CodingKeys.stats)
            
            if let groupId = try container.decodeIfPresent(Int.self, forKey: .groupId) {
                self.groupId = "\(groupId)"
            } else if let groupId = try container.decodeIfPresent(String.self, forKey: .groupId) {
                self.groupId = groupId
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.groupId, context)
                throw error
            }
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: GomaModels.Market.CodingKeys.self)
            try container.encode(self.identifier, forKey: GomaModels.Market.CodingKeys.identifier)
            try container.encode(self.name, forKey: GomaModels.Market.CodingKeys.name)
            try container.encode(self.outcomes, forKey: GomaModels.Market.CodingKeys.outcomes)
        }
        
    }
    
    struct Outcome: Codable, Equatable {
        
        var identifier: String
        var name: String
        var code: String
        var odd: OddFormat
        var oddLive: OddFormat?
        
        enum CodingKeys: String, CodingKey {
            case identifier = "id"
            case name = "name"
            case code = "code"
            case oddValue = "price"
            case oddLiveValue = "price_live"
        }
        
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            // Check if the identifier is Int or String
            if let idValue = try? container.decode(Int.self, forKey: CodingKeys.identifier) {
                self.identifier = String(idValue)
            }
            else if let idStringValue = try? container.decode(String.self, forKey: CodingKeys.identifier) {
                self.identifier = idStringValue
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.identifier, context)
                throw error
            }
            
            self.name = try container.decode(String.self, forKey: .name)
            
            self.code = try container.decode(String.self, forKey: .code)
            
            if let oddValue = try? container.decode(String.self, forKey: CodingKeys.oddValue), let oddValueDouble = Double(oddValue) {
                self.odd = OddFormat.decimal(odd: oddValueDouble)
            }
            else if let oddValue = try? container.decode(Double.self, forKey: CodingKeys.oddValue) {
                self.odd = OddFormat.decimal(odd: oddValue)
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.oddValue, context)
                throw error
            }
            
            if let oddLiveValue = try? container.decode(String.self, forKey: CodingKeys.oddLiveValue), let oddLiveValueDouble = Double(oddLiveValue) {
                self.oddLive = OddFormat.decimal(odd: oddLiveValueDouble)
            }
            else if let oddLiveValue = try? container.decode(Double.self, forKey: CodingKeys.oddLiveValue) {
                self.oddLive = OddFormat.decimal(odd: oddLiveValue)
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.oddLiveValue, context)
                throw error
            }
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.identifier, forKey: .identifier)
            try container.encode(self.name, forKey: .name)
            try container.encode(self.code, forKey: .code)
            try container.encode(self.odd.decimalOdd, forKey: .oddValue)
        }
        
    }
    
    
    // MARK: - Meta
    struct MetaDetails: Codable, Equatable {
        var imageUrl: String
        
        enum CodingKeys: String, CodingKey {
            case imageUrl = "img_url"
        }
        
        init(imageUrl: String) {
            self.imageUrl = imageUrl
        }
    }
    
    struct Stats: Codable, Equatable {
        
        let awayParticipant: ParticipantStats
        let homeParticipant: ParticipantStats
        
        enum CodingKeys: String, CodingKey {
            case statsString = "stats"
            case data = "data"
        }
        
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            let statsString = try container.decode(String.self, forKey: .statsString)
            
            let statsData = statsString.data(using: .utf8) ?? Data()
            let statsJSON = try JSONSerialization.jsonObject(with: statsData, options: []) as! [String: Any]
            
            let normalJSONData = try JSONSerialization.data(withJSONObject: statsJSON, options: [.prettyPrinted])
      
            let statsDataContainer = try JSONDecoder().decode(StatsDataContainer.self, from: normalJSONData)
            
            self.homeParticipant = statsDataContainer.data.homeParticipant
            self.awayParticipant = statsDataContainer.data.awayParticipant
        }
        
        func encode(to encoder: Encoder) throws {
            
        }
        
    }
    
    struct StatsDataContainer: Codable {
        var data: StatsData
    }

    struct StatsData: Codable {
        let homeParticipant: ParticipantStats
        let awayParticipant: ParticipantStats
        
        enum CodingKeys: String, CodingKey {
            case homeParticipant = "home_participant"
            case awayParticipant = "away_participant"
        }
        
    }

    struct ParticipantStats: Codable, Equatable {
        let total: Int
        let wins: Int?
        let draws: Int?
        let losses: Int?
        let over: Int?
        let under: Int?
        
        private enum CodingKeys: String, CodingKey {
            case total = "Total"
            case wins = "Wins"
            case draws = "Draws"
            case losses = "Losses"
            case over = "Over"
            case under = "Under"
            case yes = "Yes"
            case no = "No"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.ParticipantStats.CodingKeys> = try decoder.container(keyedBy: GomaModels.ParticipantStats.CodingKeys.self)
            self.total = try container.decode(Int.self, forKey: GomaModels.ParticipantStats.CodingKeys.total)
            self.wins = try container.decodeIfPresent(Int.self, forKey: GomaModels.ParticipantStats.CodingKeys.wins)
            self.draws = try container.decodeIfPresent(Int.self, forKey: GomaModels.ParticipantStats.CodingKeys.draws)
            self.losses = try container.decodeIfPresent(Int.self, forKey: GomaModels.ParticipantStats.CodingKeys.losses)
            
            if let overValue = try container.decodeIfPresent(Int.self, forKey: GomaModels.ParticipantStats.CodingKeys.over) {
                self.over = overValue
            }
            else if let yesValue = try container.decodeIfPresent(Int.self, forKey: GomaModels.ParticipantStats.CodingKeys.yes) {
                self.over = yesValue
            }
            else {
                self.over = nil
            }
            
            if let underValue = try container.decodeIfPresent(Int.self, forKey: GomaModels.ParticipantStats.CodingKeys.under) {
                self.under = underValue
            }
            else if let noValue = try container.decodeIfPresent(Int.self, forKey: GomaModels.ParticipantStats.CodingKeys.no) {
                self.under = noValue
            }
            else {
                self.under = nil
            }
            
        }
        
        init(total: Int, wins: Int?, draws: Int?, losses: Int?, over: Int?, under: Int?) {
            self.total = total
            self.wins = wins
            self.draws = draws
            self.losses = losses
            self.over = over
            self.under = under
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: GomaModels.ParticipantStats.CodingKeys.self)
            try container.encode(self.total, forKey: GomaModels.ParticipantStats.CodingKeys.total)
            try container.encodeIfPresent(self.wins, forKey: GomaModels.ParticipantStats.CodingKeys.wins)
            try container.encodeIfPresent(self.draws, forKey: GomaModels.ParticipantStats.CodingKeys.draws)
            try container.encodeIfPresent(self.losses, forKey: GomaModels.ParticipantStats.CodingKeys.losses)
            try container.encodeIfPresent(self.over, forKey: GomaModels.ParticipantStats.CodingKeys.over)
            try container.encodeIfPresent(self.under, forKey: GomaModels.ParticipantStats.CodingKeys.under)
        }
    }
    
    struct BoostedEvent: Codable {
        let id: Int
        let name: String?
        let title: String?
        let ctaUrl: String?
        let imageUrl: String?
        let event: Event
        let boostedMarket: Market
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case title = "title"
            case ctaUrl = "cta_url"
            case imageUrl = "image_url"
            case event = "event"
            case boostedMarket = "boosted_market"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/GomaModels+FeaturedTips.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 17/01/2024.
//

import Foundation

extension GomaModels {
    
    struct FeaturedTipsPagedResponse: Codable {
        var currentPage: Int
        var featuredTips: [FeaturedTip]
        var perPage: Int
        
        enum CodingKeys: String, CodingKey {
            case currentPage = "current_page"
            case featuredTips = "data"
            case perPage = "per_page"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.FeaturedTipsPagedResponse.CodingKeys> = try decoder.container(keyedBy: GomaModels.FeaturedTipsPagedResponse.CodingKeys.self)
            self.currentPage = try container.decode(Int.self, forKey: GomaModels.FeaturedTipsPagedResponse.CodingKeys.currentPage)
            self.featuredTips = try container.decode([GomaModels.FeaturedTip].self, forKey: GomaModels.FeaturedTipsPagedResponse.CodingKeys.featuredTips)
            self.perPage = try container.decode(Int.self, forKey: GomaModels.FeaturedTipsPagedResponse.CodingKeys.perPage)
        }
        
        init(currentPage: Int, featuredTips: [FeaturedTip], perPage: Int) {
            self.currentPage = currentPage
            self.featuredTips = featuredTips
            self.perPage = perPage
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: GomaModels.FeaturedTipsPagedResponse.CodingKeys.self)
            try container.encode(self.currentPage, forKey: GomaModels.FeaturedTipsPagedResponse.CodingKeys.currentPage)
            try container.encode(self.featuredTips, forKey: GomaModels.FeaturedTipsPagedResponse.CodingKeys.featuredTips)
            try container.encode(self.perPage, forKey: GomaModels.FeaturedTipsPagedResponse.CodingKeys.perPage)
        }
        
    }
    
    struct FeaturedTip: Codable {
        var id: Int
        var stake: Double
        var odds: Double
        var possibleWinnings: Double
        var winnings: Double?
        var status: String
        var type: String
        var shareId: String
        var selections: [FeaturedTipSelection]
        var user: TipUser
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case stake = "stake"
            case odds = "odds"
            case possibleWinnings = "possible_winnings"
            case winnings = "winnings"
            case status = "status"
            case type = "type"
            case shareId = "share_id"
            case selections = "selections"
            case user = "user"
        }
        
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            self.id = try container.decode(Int.self, forKey: .id)
            self.status = try container.decode(String.self, forKey: .status)
            self.type = try container.decode(String.self, forKey: .type)
            self.shareId = try container.decode(String.self, forKey: .shareId)
            self.selections = try container.decode([FeaturedTipSelection].self, forKey: .selections)
            self.user = try container.decode(TipUser.self, forKey: .user)

            // Decode stake
            if let stakeValue = try? container.decode(Double.self, forKey: .stake) {
                self.stake = stakeValue
            } else if let stakeString = try? container.decode(String.self, forKey: .stake), let stakeValue = Double(stakeString) {
                self.stake = stakeValue
            } else {
                throw DecodingError.dataCorruptedError(forKey: .stake, in: container, debugDescription: "Stake is not a Double or String")
            }

            // Decode odds
            if let oddsValue = try? container.decode(Double.self, forKey: .odds) {
                self.odds = oddsValue
            } else if let oddsString = try? container.decode(String.self, forKey: .odds), let oddsValue = Double(oddsString) {
                self.odds = oddsValue
            } else {
                throw DecodingError.dataCorruptedError(forKey: .odds, in: container, debugDescription: "Odds is not a Double or String")
            }

            // Decode possibleWinnings
            if let possibleWinningsValue = try? container.decode(Double.self, forKey: .possibleWinnings) {
                self.possibleWinnings = possibleWinningsValue
            } else if let possibleWinningsString = try? container.decode(String.self, forKey: .possibleWinnings), let possibleWinningsValue = Double(possibleWinningsString) {
                self.possibleWinnings = possibleWinningsValue
            } else {
                throw DecodingError.dataCorruptedError(forKey: .possibleWinnings, in: container, debugDescription: "Possible Winnings is not a Double or String")
            }

            // Decode winnings
            if let winningsValue = try? container.decode(Double.self, forKey: .winnings) {
                self.winnings = winningsValue
            } else if let winningsString = try? container.decode(String.self, forKey: .winnings), let winningsValue = Double(winningsString) {
                self.winnings = winningsValue
            } else {
                self.winnings = nil // It's optional, so it's okay if it doesn't exist
            }
        }

        
        init(id: Int,
             stake: Double,
             odds: Double,
             possibleWinnings: Double,
             winnings: Double?,
             status: String,
             type: String,
             shareId: String,
             selections: [FeaturedTipSelection],
             user: TipUser) {
            self.id = id
            self.stake = stake
            self.odds = odds
            self.possibleWinnings = possibleWinnings
            self.winnings = winnings
            self.status = status
            self.type = type
            self.shareId = shareId
            self.selections = selections
            self.user = user
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: GomaModels.FeaturedTip.CodingKeys.self)
            try container.encode(self.id, forKey: GomaModels.FeaturedTip.CodingKeys.id)
            try container.encode(self.stake, forKey: GomaModels.FeaturedTip.CodingKeys.stake)
            try container.encode(self.odds, forKey: GomaModels.FeaturedTip.CodingKeys.odds)
            try container.encode(self.possibleWinnings, forKey: GomaModels.FeaturedTip.CodingKeys.possibleWinnings)
            try container.encodeIfPresent(self.winnings, forKey: GomaModels.FeaturedTip.CodingKeys.winnings)
            try container.encode(self.status, forKey: GomaModels.FeaturedTip.CodingKeys.status)
            try container.encode(self.type, forKey: GomaModels.FeaturedTip.CodingKeys.type)
            try container.encode(self.shareId, forKey: GomaModels.FeaturedTip.CodingKeys.shareId)
            try container.encode(self.selections, forKey: GomaModels.FeaturedTip.CodingKeys.selections)
            try container.encode(self.user, forKey: GomaModels.FeaturedTip.CodingKeys.user)
        }
        
    }
    
    struct FeaturedTipSelection: Codable {
        var id: Int
        var bettingTicketId: Int
        var sportEventId: Int
        var outcomeId: Int
        var odd: Double
        var status: String
        var outcome: TipOutcome
        var event: Event
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case bettingTicketId = "betting_ticket_id"
            case sportEventId = "sport_event_id"
            case outcomeId = "outcome_id"
            case odd = "odd"
            case status = "status"
            case outcome = "outcome"
            case event = "event"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.FeaturedTipSelection.CodingKeys> = try decoder.container(keyedBy: GomaModels.FeaturedTipSelection.CodingKeys.self)
            self.id = try container.decode(Int.self, forKey: GomaModels.FeaturedTipSelection.CodingKeys.id)
            self.bettingTicketId = try container.decode(Int.self, forKey: GomaModels.FeaturedTipSelection.CodingKeys.bettingTicketId)
            self.sportEventId = try container.decode(Int.self, forKey: GomaModels.FeaturedTipSelection.CodingKeys.sportEventId)
            self.outcomeId = try container.decode(Int.self, forKey: GomaModels.FeaturedTipSelection.CodingKeys.outcomeId)
            
            // Decode Odd
            if let oddValue = try? container.decode(Double.self, forKey: .odd) {
                self.odd = oddValue
            } else if let oddString = try? container.decode(String.self, forKey: .odd), let oddValue = Double(oddString) {
                self.odd = oddValue
            } else {
                throw DecodingError.dataCorruptedError(forKey: .odd, in: container, debugDescription: "Odd is not a Double or String")
            }
            
            self.status = try container.decode(String.self, forKey: GomaModels.FeaturedTipSelection.CodingKeys.status)
            self.outcome = try container.decode(GomaModels.TipOutcome.self, forKey: GomaModels.FeaturedTipSelection.CodingKeys.outcome)
            self.event = try container.decode(GomaModels.Event.self, forKey: GomaModels.FeaturedTipSelection.CodingKeys.event)
        }
        
        init(id: Int, bettingTicketId: Int, sportEventId: Int, outcomeId: Int, odd: Double, status: String, outcome: TipOutcome, event: Event) {
            self.id = id
            self.bettingTicketId = bettingTicketId
            self.sportEventId = sportEventId
            self.outcomeId = outcomeId
            self.odd = odd
            self.status = status
            self.outcome = outcome
            self.event = event
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: GomaModels.FeaturedTipSelection.CodingKeys.self)
            try container.encode(self.id, forKey: GomaModels.FeaturedTipSelection.CodingKeys.id)
            try container.encode(self.bettingTicketId, forKey: GomaModels.FeaturedTipSelection.CodingKeys.bettingTicketId)
            try container.encode(self.sportEventId, forKey: GomaModels.FeaturedTipSelection.CodingKeys.sportEventId)
            try container.encode(self.outcomeId, forKey: GomaModels.FeaturedTipSelection.CodingKeys.outcomeId)
            try container.encode(self.odd, forKey: GomaModels.FeaturedTipSelection.CodingKeys.odd)
            try container.encode(self.status, forKey: GomaModels.FeaturedTipSelection.CodingKeys.status)
            try container.encode(self.outcome, forKey: GomaModels.FeaturedTipSelection.CodingKeys.outcome)
            try container.encode(self.event, forKey: GomaModels.FeaturedTipSelection.CodingKeys.event)
        }
        
    }
    
    
    // MARK: - Outcome
    struct TipOutcome: Codable {
        var id: Int
        var name: String
        var code: String
        var price: Double
        var market: TipMarket
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case code = "code"
            case price = "price"
            case market = "market"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.TipOutcome.CodingKeys> = try decoder.container(keyedBy: GomaModels.TipOutcome.CodingKeys.self)
            self.id = try container.decode(Int.self, forKey: GomaModels.TipOutcome.CodingKeys.id)
            self.name = try container.decode(String.self, forKey: GomaModels.TipOutcome.CodingKeys.name)
            self.code = try container.decode(String.self, forKey: GomaModels.TipOutcome.CodingKeys.code)
            self.market = try container.decode(GomaModels.TipMarket.self, forKey: GomaModels.TipOutcome.CodingKeys.market)
            
            // Decode Odd
            if let priceValue = try? container.decode(Double.self, forKey: .price) {
                self.price = priceValue
            } else if let priceString = try? container.decode(String.self, forKey: .price), let priceValue = Double(priceString) {
                self.price = priceValue
            } else {
                throw DecodingError.dataCorruptedError(forKey: .price, in: container, debugDescription: "Price is not a Double or String")
            }
            
        }
        
        init(id: Int, name: String, code: String, price: Double, market: TipMarket) {
            self.id = id
            self.name = name
            self.code = code
            self.price = price
            self.market = market
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: GomaModels.TipOutcome.CodingKeys.self)
            try container.encode(self.id, forKey: GomaModels.TipOutcome.CodingKeys.id)
            try container.encode(self.name, forKey: GomaModels.TipOutcome.CodingKeys.name)
            try container.encode(self.code, forKey: GomaModels.TipOutcome.CodingKeys.code)
            try container.encode(self.price, forKey: GomaModels.TipOutcome.CodingKeys.price)
            try container.encode(self.market, forKey: GomaModels.TipOutcome.CodingKeys.market)
        }
    }
    
    // MARK: - Market
    struct TipMarket: Codable {
        var id: Int
        var sportEventMarketId: Int
        var name: String
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case sportEventMarketId = "sport_event_market_id"
            case name = "name"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.TipMarket.CodingKeys> = try decoder.container(keyedBy: GomaModels.TipMarket.CodingKeys.self)
            self.id = try container.decode(Int.self, forKey: GomaModels.TipMarket.CodingKeys.id)
            self.sportEventMarketId = try container.decode(Int.self, forKey: GomaModels.TipMarket.CodingKeys.sportEventMarketId)
            self.name = try container.decode(String.self, forKey: GomaModels.TipMarket.CodingKeys.name)
        }
        
        init(id: Int, sportEventMarketId: Int, name: String) {
            self.id = id
            self.sportEventMarketId = sportEventMarketId
            self.name = name
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: GomaModels.TipMarket.CodingKeys.self)
            try container.encode(self.id, forKey: GomaModels.TipMarket.CodingKeys.id)
            try container.encode(self.sportEventMarketId, forKey: GomaModels.TipMarket.CodingKeys.sportEventMarketId)
            try container.encode(self.name, forKey: GomaModels.TipMarket.CodingKeys.name)
        }
        
    }
    
    // MARK: - User
    struct TipUser: Codable {
        var id: Int
        var name: String?
        var code: String?
        var avatar: String?
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case code = "code"
            case avatar = "avatar"
        }
             
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.TipUser.CodingKeys> = try decoder.container(keyedBy: GomaModels.TipUser.CodingKeys.self)
            self.id = try container.decode(Int.self, forKey: GomaModels.TipUser.CodingKeys.id)
            self.name = try container.decodeIfPresent(String.self, forKey: GomaModels.TipUser.CodingKeys.name)
            self.code = try container.decodeIfPresent(String.self, forKey: GomaModels.TipUser.CodingKeys.code)
            self.avatar = try container.decodeIfPresent(String.self, forKey: GomaModels.TipUser.CodingKeys.avatar)
        }
        
        init(id: Int, name: String?, code: String?, avatar: String?) {
            self.id = id
            self.name = name
            self.code = code
            self.avatar = avatar
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: GomaModels.TipUser.CodingKeys.self)
            try container.encode(self.id, forKey: GomaModels.TipUser.CodingKeys.id)
            try container.encodeIfPresent(self.name, forKey: GomaModels.TipUser.CodingKeys.name)
            try container.encodeIfPresent(self.code, forKey: GomaModels.TipUser.CodingKeys.code)
            try container.encodeIfPresent(self.avatar, forKey: GomaModels.TipUser.CodingKeys.avatar)
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/GomaModels+Home.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 08/01/2024.
//

import Foundation


extension GomaModels {
    
    // MARK: - BannerAlert
    // MARK: - HomeContents
    struct HomeContents: Codable {
        
        var bannerAlerts: [BannerAlert]
        var banners: [Banner]
        var sportAssociatedEventBanners: [SportAssociatedEventBanner]
        var stories: [Story]

        enum CodingKeys: String, CodingKey {
            case bannerAlerts = "bannerAlert"
            case banners = "banners"
            case sportAssociatedEventBanners = "sportBanners"
            case stories = "stories"
        }

        init(bannerAlerts: [BannerAlert],
             banners: [Banner],
             sportAssociatedEventBanners: [SportAssociatedEventBanner],
             stories: [Story]) 
        {
            self.bannerAlerts = bannerAlerts
            self.banners = banners
            self.sportAssociatedEventBanners = sportAssociatedEventBanners
            self.stories = stories
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.HomeContents.CodingKeys> = try decoder.container(keyedBy: GomaModels.HomeContents.CodingKeys.self)
            
            if let bannerActionsArray = try? container.decode([GomaModels.BannerAlert].self, forKey: GomaModels.HomeContents.CodingKeys.bannerAlerts) {
                self.bannerAlerts = bannerActionsArray
            }
            else if let bannerAction = try? container.decode(GomaModels.BannerAlert.self, forKey: GomaModels.HomeContents.CodingKeys.bannerAlerts) {
                self.bannerAlerts = [bannerAction]
            }
            else {
                self.bannerAlerts = []
            }
            
            self.banners = try container.decode([GomaModels.Banner].self, forKey: GomaModels.HomeContents.CodingKeys.banners)
            self.sportAssociatedEventBanners = try container.decode([GomaModels.SportAssociatedEventBanner].self, forKey: GomaModels.HomeContents.CodingKeys.sportAssociatedEventBanners)
            self.stories = try container.decode([GomaModels.Story].self, forKey: GomaModels.HomeContents.CodingKeys.stories)
        }
        
    }
    
    
    
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/GomaModels+News.swift
````swift
//
//  GomaModels+News.swift
//  
//
//  Created by André Lascas on 05/06/2024.
//

import Foundation

extension GomaModels {
    
    struct News: Codable {
        var id: Int
        var title: String
        var slug: String?
        var image: String?
        var content: String
        var sportEventId: Int?
        var status: String?
        var startDate: Date?
        var endDate: Date?
        var userType: String?
        var order: Int
        var event: Event?
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case title = "title"
            case slug = "slug"
            case image = "image"
            case content = "content"
            case sportEventId = "sport_event_id"
            case status = "status"
            case startDate = "start_date"
            case endDate = "end_date"
            case userType = "user_type"
            case order = "order"
            case event = "event"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/GomaModels+Promotions.swift
````swift
//
//  GomaModels+Promotions.swift
//
//
//  Created on: Feb 28, 2025
//

import Foundation

extension GomaModels {
    // MARK: - Home Template

    struct HomeTemplate: Codable {
        let id: Int
        let type: String
        let widgets: [HomeWidget]

        enum CodingKeys: String, CodingKey {
            case id
            case type = "name"
            case widgets
        }
    }

    struct HomeWidget: Codable {

        let id: String
        let type: String
        let description: String
        let userType: String
        let sortOrder: Int
        let orientation: String?

        enum CodingKeys: String, CodingKey {
            case id = "id"
            case type = "name"
            case description = "description"
            case userType = "user_type"
            case sortOrder = "sort_order"
            case orientation = "orientation"
        }
    }

    // MARK: - Alert Banner

    struct AlertBannerData: Codable {
        let id: Int
        let title: String
        let content: String
        let backgroundColor: String
        let textColor: String
        let actionType: String
        let actionTarget: String
        let startDate: String
        let endDate: String
        let status: String
        let imageUrl: String?

        enum CodingKeys: String, CodingKey {
            case id, title, content, status
            case backgroundColor = "background_color"
            case textColor = "text_color"
            case actionType = "action_type"
            case actionTarget = "action_target"
            case startDate = "start_date"
            case endDate = "end_date"
            case imageUrl = "image_url"
        }
    }

    // MARK: - Banners

    struct BannerData: Codable {
        let id: Int
        let title: String
        let subtitle: String?
        let actionType: String
        let actionTarget: String
        let startDate: String
        let endDate: String
        let status: String
        let imageUrl: String?

        enum CodingKeys: String, CodingKey {
            case id, title, subtitle, status
            case actionType = "action_type"
            case actionTarget = "action_target"
            case startDate = "start_date"
            case endDate = "end_date"
            case imageUrl = "image_url"
        }
    }

    // MARK: - Sport Banners

    struct SportBannerData: Codable {
        let id: Int
        let title: String
        let subtitle: String?
        let startDate: String
        let endDate: String
        let status: String
        let imageUrl: String?
        let sportEventId: Int
        let event: SportEventData?

        enum CodingKeys: String, CodingKey {
            case id, title, subtitle, status, event
            case startDate = "start_date"
            case endDate = "end_date"
            case imageUrl = "image_url"
            case sportEventId = "sport_event_id"
        }
    }

    struct SportEventData: Codable {
        let id: Int
        let sportId: Int
        let homeTeamId: Int
        let awayTeamId: Int
        let dateTime: String
        let homeTeam: TeamData
        let awayTeam: TeamData
        let market: MarketData?

        enum CodingKeys: String, CodingKey {
            case id
            case sportId = "sport_id"
            case homeTeamId = "home_team_id"
            case awayTeamId = "away_team_id"
            case dateTime = "date_time"
            case homeTeam = "home_team"
            case awayTeam = "away_team"
            case market
        }
    }

    struct TeamData: Codable {
        let id: Int
        let name: String
        let logo: String?
    }

    struct MarketData: Codable {
        let id: Int
        let name: String
        let outcomes: [OutcomeData]
    }

    struct OutcomeData: Codable {
        let id: Int
        let name: String
        let price: Double
    }

    // MARK: - Boosted Odds Banners

    struct BoostedOddsBannerData: Codable {
        let id: Int
        let title: String
        let originalOdd: Double
        let boostedOdd: Double
        let startDate: String
        let endDate: String
        let status: String
        let imageUrl: String?
        let sportEventId: Int
        let event: SportEventData?

        enum CodingKeys: String, CodingKey {
            case id, title, status, event
            case originalOdd = "original_odd"
            case boostedOdd = "boosted_odd"
            case startDate = "start_date"
            case endDate = "end_date"
            case imageUrl = "image_url"
            case sportEventId = "sport_event_id"
        }
    }

    // MARK: - Hero Cards

    struct HeroCardData: Codable {
        let id: Int
        let title: String
        let subtitle: String?
        let actionType: String
        let actionTarget: String
        let startDate: String
        let endDate: String
        let status: String
        let imageUrl: String?
        let eventId: Int?
        let eventData: SportEventData?

        enum CodingKeys: String, CodingKey {
            case id, title, subtitle, status
            case actionType = "action_type"
            case actionTarget = "action_target"
            case startDate = "start_date"
            case endDate = "end_date"
            case imageUrl = "image_url"
            case eventId = "event_id"
            case eventData = "event_data"
        }
    }

    // MARK: - Stories

    struct StoryData: Codable {
        let id: Int
        let title: String
        let content: String
        let actionType: String
        let actionTarget: String
        let startDate: String
        let endDate: String
        let status: String
        let imageUrl: String?
        let duration: Int

        enum CodingKeys: String, CodingKey {
            case id, title, content, status, duration
            case actionType = "action_type"
            case actionTarget = "action_target"
            case startDate = "start_date"
            case endDate = "end_date"
            case imageUrl = "image_url"
        }
    }

    // MARK: - News

    struct NewsItemData: Codable {
        let id: Int
        let title: String
        let subtitle: String?
        let content: String
        let author: String
        let publishedDate: String
        let status: String
        let imageUrl: String?
        let tags: [String]?

        enum CodingKeys: String, CodingKey {
            case id, title, subtitle, content, author, status, tags
            case publishedDate = "published_date"
            case imageUrl = "image_url"
        }
    }

    // MARK: - Pro Choices

    struct ProChoiceData: Codable {
        let id: Int
        let title: String
        let tipster: TipsterData
        let event: EventSummaryData
        let selection: SelectionData
        let reasoning: String

        struct TipsterData: Codable {
            let id: Int
            let name: String
            let winRate: Double
            let avatar: String?

            enum CodingKeys: String, CodingKey {
                case id, name, avatar
                case winRate = "win_rate"
            }
        }

        struct EventSummaryData: Codable {
            let id: Int
            let homeTeam: String
            let awayTeam: String
            let dateTime: String

            enum CodingKeys: String, CodingKey {
                case id
                case homeTeam = "home_team"
                case awayTeam = "away_team"
                case dateTime = "date_time"
            }
        }

        struct SelectionData: Codable {
            let marketName: String
            let outcomeName: String
            let odds: Double

            enum CodingKeys: String, CodingKey {
                case marketName = "market_name"
                case outcomeName = "outcome_name"
                case odds
            }
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/GomaModels+Social.swift
````swift
//
//  GomaModels+Social.swift
//
//
//  Created by André Lascas on 15/02/2024.
//

import Foundation

extension GomaModels {
    
    struct FolloweesResponse: Codable {
        var followees: [Follower]
        
        enum CodingKeys: String, CodingKey {
            case followees = "users_followed_ids"
        }
    }
    
    struct FollowersResponse: Codable {
        var followers: [Follower]
        
        enum CodingKeys: String, CodingKey {
            case followers = "users_followers_ids"
        }
    }
    
    struct Follower: Codable {
        var id: Int
        var name: String
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
        }
    }
    
    struct FolloweeActionResponse: Codable {
        var followeeIds: [Int]
        
        enum CodingKeys: String, CodingKey {
            case followeeIds = "users_followed_ids"
        }
    }
    
    struct TotalFolloweesResponse: Codable {
        var count: Int
        
        enum CodingKeys: String, CodingKey {
            case count = "users_followed_total"
        }
    }
    
    struct TotalFollowersResponse: Codable {
        var count: Int
        
        enum CodingKeys: String, CodingKey {
            case count = "users_followers_total"
        }
    }
    
    struct TipRanking: Codable {
        
        var position: Int
        var result: Double
        var userId: Int
        var name: String
        var code: String
        var avatar: String?
        var anonymous: Bool
        
        enum CodingKeys: String, CodingKey {
            case position = "position"
            case result = "result"
            case userId = "user_id"
            case name = "name"
            case code = "code"
            case avatar = "avatar"
            case anonymous = "anonymous"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.TipRanking.CodingKeys> = try decoder.container(keyedBy: GomaModels.TipRanking.CodingKeys.self)
            
            self.position = try container.decode(Int.self, forKey: GomaModels.TipRanking.CodingKeys.position)
            
            self.result = try container.decode(Double.self, forKey: GomaModels.TipRanking.CodingKeys.result)
            
            self.userId = try container.decode(Int.self, forKey: GomaModels.TipRanking.CodingKeys.userId)
            
            self.name = try container.decode(String.self, forKey: GomaModels.TipRanking.CodingKeys.name)

            self.code = try container.decode(String.self, forKey: GomaModels.TipRanking.CodingKeys.code)

            self.avatar = try container.decodeIfPresent(String.self, forKey: GomaModels.TipRanking.CodingKeys.avatar)

            let anonymousValue = try container.decode(Int.self, forKey: GomaModels.TipRanking.CodingKeys.anonymous)
            
            self.anonymous = anonymousValue == 1 ? true : false

            
        }
    }
    
    struct UserProfileInfo: Codable {
        var name: String
        var avatar: String?
        var following: Int
        var followers: Int
        var rankings: UserProfileRanking
        var sportsPerc: [UserProfileSportsData]

        enum CodingKeys: String, CodingKey {
            case name = "name"
            case avatar = "avatar"
            case following = "following"
            case followers = "followers"
            case rankings = "rankings"
            case sportsPerc = "sports_perc"
        }
    }

    struct UserProfileRanking: Codable {

        var consecutiveWins: Int
        var accumulatedWins: Double
        var highestOdd: Double

        enum CodingKeys: String, CodingKey {
            case consecutiveWins = "consecutive_wins"
            case accumulatedWins = "accumulated_wins"
            case highestOdd = "highest_odd"
        }
    }

    struct UserProfileSportsData: Codable {
        var sportId: Int
        var percentage: Double
        var sportIdIcon: String

        enum CodingKeys: String, CodingKey {
            case sportId = "sport_id"
            case percentage = "percentage"
            case sportIdIcon = "sport_id_icon"
        }
    }
    
    struct FriendRequest: Codable {
        var id: Int
        var name: String
        var username: String

        enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case username = "username"
        }
    }
    
    struct GomaFriend: Codable {
        var id: Int
        var name: String
        var avatar: String?
        var isAdmin: Bool?
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case avatar = "avatar"
            case isAdmin = "is_admin"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.GomaFriend.CodingKeys> = try decoder.container(keyedBy: GomaModels.GomaFriend.CodingKeys.self)
            
            self.id = try container.decode(Int.self, forKey: GomaModels.GomaFriend.CodingKeys.id)
            
            self.name = try container.decode(String.self, forKey: GomaModels.GomaFriend.CodingKeys.name)

            self.avatar = try container.decodeIfPresent(String.self, forKey: GomaModels.GomaFriend.CodingKeys.avatar)

            let isAdminValue = try container.decodeIfPresent(Int.self, forKey: GomaModels.GomaFriend.CodingKeys.isAdmin)
            
            self.isAdmin = isAdminValue == 1 ? true : false

        }
    }
    
    struct ChatroomData: Codable {
        let chatroom: Chatroom
        let users: [GomaFriend]

        enum CodingKeys: String, CodingKey {
            case chatroom = "chat_room"
            case users = "users"
        }
    }
    
    struct Chatroom: Codable {
        let id: Int
        let name: String
        let type: String
        let creationTimestamp: Int?

        enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case type = "type"
            case creationTimestamp = "created_at"
        }
    }
    
    struct SearchUser: Codable {
        let id: Int
        let username: String
        let avatar: String?

        enum CodignKeys: String, CodingKey {
            case id = "id"
            case username = "username"
            case avatar = "avatar"
        }
    }
    
    struct AddFriendResponse: Codable {
        var chatroomIds: [Int]?

        enum CodingKeys: String, CodingKey {
            case chatroomIds = "chat_room_ids"
        }
    }

    struct ChatroomId: Codable {
        let id: Int

        enum CodingKeys: String, CodingKey {
            case id = "id"
        }
    }
    
    struct DeleteGroupResponse: Codable {
        var status: String
        var message: String?

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case message = "message"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/GomaModels+Sports.swift
````swift
//
//  File.swift
//
//
//  Created by Ruben Roques on 21/12/2023.
//

import Foundation

extension GomaModels {
    
    typealias Sports = [Sport]
    
    struct Sport: Codable, Equatable {
        var identifier: String
        var name: String
        var iconIdentifier: String?
        var preLiveEventsCount: Int?
        var liveEventsCount: Int?
        
        enum CodingKeys: String, CodingKey {
            case identifier = "id"
            case name = "name"
            case iconIdentifier = "icon_id"
            case preLiveEventsCount = "pre_live_count"
            case liveEventsCount = "live_count"
        }
        
        
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.name = try container.decode(String.self, forKey: .name)
            self.iconIdentifier = try? container.decode(String.self, forKey: .iconIdentifier)
            
            // Check if the identifier is Int or String
            if let idInt = try? container.decode(Int.self, forKey: .identifier) {
                self.identifier = String(idInt)
            } else {
                self.identifier = try container.decode(String.self, forKey: .identifier)
            }
            
            if let countString = try? container.decode(String.self, forKey: .preLiveEventsCount), let count = Int(countString) {
                self.preLiveEventsCount = count
            } else if let countInt = try container.decodeIfPresent(Int.self, forKey: .preLiveEventsCount) {
                self.preLiveEventsCount = countInt
            }
            else {
                self.preLiveEventsCount = 0
            }
            
            if let countString = try? container.decode(String.self, forKey: .liveEventsCount), let count = Int(countString) {
                self.liveEventsCount = count
            } else if let countInt = try container.decodeIfPresent(Int.self, forKey: .liveEventsCount) {
                self.liveEventsCount = countInt
            }
            else {
                self.liveEventsCount = 0
            }
            
        }
        
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/GomaModels+Tickets.swift
````swift
//
//  File.swift
//  
//
//  Created by André Lascas on 22/01/2024.
//

import Foundation

extension GomaModels {
    
    struct MyTicketsResponse: Codable {
        var currentPage: Int
        var data: [MyTicket]
        
        enum CodingKeys: String, CodingKey {
            case currentPage = "current_page"
            case data = "data"
        }
    }
    
    struct MyTicket: Codable {
        var id: Int
        var userId: Int?
        var stake: Double
        var odds: Double
        var possibleWinnings: Double?
        var winnings: Double?
        var status: MyTicketStatus
        var type: String
        var shareId: String
        var createdAt: String?
        var updatedAt: String?
        var selections: [MyTicketSelection]
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case userId = "user_id"
            case stake = "stake"
            case odds = "odds"
            case possibleWinnings = "possible_winnings"
            case winnings = "winnings"
            case status = "status"
            case type = "type"
            case shareId = "share_id"
            case createdAt = "created_at"
            case updatedAt = "updated_at"
            case selections = "selections"
        }
        
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            if let idValue = try? container.decode(Int.self, forKey: CodingKeys.id) {
                self.id = idValue
            }
            else if let idStringValue = try? container.decode(String.self, forKey: CodingKeys.id) {
                self.id = Int(idStringValue) ?? 0
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.id, context)
                throw error
            }
            
            self.userId = try container.decodeIfPresent(Int.self, forKey: CodingKeys.userId)
            
            self.stake = try container.decode(Double.self, forKey: CodingKeys.stake)
            
            // Decode Odd
            if let priceValue = try? container.decode(Double.self, forKey: .odds) {
                self.odds = priceValue
            } else if let priceString = try? container.decode(String.self, forKey: .odds), let priceValue = Double(priceString) {
                self.odds = priceValue
            } else {
                throw DecodingError.dataCorruptedError(forKey: .odds, in: container, debugDescription: "Odds is not a Double or String")
            }
            
            self.possibleWinnings = try container.decodeIfPresent(Double.self, forKey: CodingKeys.possibleWinnings)
            self.winnings = try container.decodeIfPresent(Double.self, forKey: CodingKeys.winnings)
            
            if let statusString = try? container.decode(String.self, forKey: CodingKeys.status) {
                self.status = MyTicketStatus(rawValue: statusString)
            }
            else {
                self.status = .undefined
            }
            
            self.type = try container.decode(String.self, forKey: CodingKeys.type)
            self.shareId = try container.decode(String.self, forKey: CodingKeys.shareId)
            self.createdAt = try container.decodeIfPresent(String.self, forKey: CodingKeys.createdAt)
            
            self.updatedAt = try container.decodeIfPresent(String.self, forKey: CodingKeys.updatedAt)
            
            self.selections = try container.decode([MyTicketSelection].self, forKey: CodingKeys.selections)
            
        }
    }
    
    struct MyTicketSelection: Codable {
        var id: Int
        var bettingTicketId: Int
        var sportEventId: Int
        var outcomeId: Int
        var odd: Double
        var status: MyTicketStatus
        var createdAt: String?
        var updatedAt: String?
        var outcome: MyTicketOutcome
        var event: MyTicketEvent
        
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case bettingTicketId = "betting_ticket_id"
            case sportEventId = "sport_event_id"
            case outcomeId = "outcome_id"
            case odd = "odd"
            case status = "status"
            case createdAt = "created_at"
            case updatedAt = "updated_at"
            case outcome = "outcome"
            case event = "event"
        }
        
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            if let idValue = try? container.decode(Int.self, forKey: CodingKeys.id) {
                self.id = idValue
            }
            else if let idStringValue = try? container.decode(String.self, forKey: CodingKeys.id) {
                self.id = Int(idStringValue) ?? 0
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.id, context)
                throw error
            }
            
            self.bettingTicketId = try container.decode(Int.self, forKey: CodingKeys.bettingTicketId)
            self.sportEventId = try container.decode(Int.self, forKey: CodingKeys.sportEventId)
            self.outcomeId = try container.decode(Int.self, forKey: CodingKeys.outcomeId)
            // Decode Odd
            if let priceValue = try? container.decode(Double.self, forKey: .odd) {
                self.odd = priceValue
            } else if let priceString = try? container.decode(String.self, forKey: .odd), let priceValue = Double(priceString) {
                self.odd = priceValue
            } else {
                throw DecodingError.dataCorruptedError(forKey: .odd, in: container, debugDescription: "Odds is not a Double or String")
            }
            
            if let statusString = try? container.decode(String.self, forKey: CodingKeys.status) {
                self.status = MyTicketStatus(rawValue: statusString)
            }
            else {
                self.status = .undefined
            }
            
            self.createdAt = try container.decodeIfPresent(String.self, forKey: CodingKeys.createdAt)
            self.updatedAt = try container.decodeIfPresent(String.self, forKey: CodingKeys.updatedAt)
            
            self.outcome = try container.decode(MyTicketOutcome.self, forKey: CodingKeys.outcome)
            self.event = try container.decode(MyTicketEvent.self, forKey: CodingKeys.event)
        }
    }
    
    struct MyTicketOutcome: Codable {
        var id: Int
        var name: String
        var code: String?
        var price: Double
        var market: MyTicketMarket
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "name"
            case code = "code"
            case price = "price"
            case market = "market"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.MyTicketOutcome.CodingKeys> = try decoder.container(keyedBy: GomaModels.MyTicketOutcome.CodingKeys.self)
            self.id = try container.decode(Int.self, forKey: GomaModels.MyTicketOutcome.CodingKeys.id)
            self.name = try container.decode(String.self, forKey: GomaModels.MyTicketOutcome.CodingKeys.name)
            self.code = try container.decodeIfPresent(String.self, forKey: GomaModels.MyTicketOutcome.CodingKeys.code)
            self.market = try container.decode(GomaModels.MyTicketMarket.self, forKey: GomaModels.MyTicketOutcome.CodingKeys.market)
            
            // Decode Odd
            if let priceValue = try? container.decode(Double.self, forKey: .price) {
                self.price = priceValue
            } else if let priceString = try? container.decode(String.self, forKey: .price), let priceValue = Double(priceString) {
                self.price = priceValue
            } else {
                throw DecodingError.dataCorruptedError(forKey: .price, in: container, debugDescription: "Price is not a Double or String")
            }
        }
    }
    
    struct MyTicketMarket: Codable {
        var id: Int
        var sportEventMarketId: Int?
        var name: String
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case sportEventMarketId = "sport_event_market_id"
            case name = "name"
        }
    }
    
    struct MyTicketEvent: Codable {
        var id: Int
        var homeTeamId: Int
        var awayTeamId: Int
        var homeTeam: String
        var awayTeam: String
        var date: String
        var dateTime: Date
        var time: String
        var homeScore: Int?
        var awayScore: Int?
        var halfTimeScore: String?
        var fullTimeScore: String?
        var extraTimeScore: String?
        var timer: String?
        var status: EventStatus
        var isLive: Bool
        var p1Score: Int?
        var p2Score: Int?
        var p3Score: Int?
        var p4Score: Int?
        var p5Score: Int?
        var sport: Sport
        var region: Region?
        var competition: Competition?
        var placardInfo: PlacardInfo?
        var homeMetaInfo: String?
        var awayMetaInfo: String?
        var homeLogoUrl: String?
        var awayLogoUrl: String?
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case homeTeamId = "home_team_id"
            case awayTeamId = "away_team_id"
            case homeTeam = "home_team"
            case awayTeam = "away_team"
            case date = "date"
            case dateTime = "date_time"
            case time = "time"
            case homeScore = "home_score"
            case awayScore = "away_score"
            case halfTimeScore = "ht_score"
            case fullTimeScore = "ft_score"
            case extraTimeScore = "et_score"
            case timer = "timer"
            case status = "status"
            case isLive = "is_live"
            case p1Score = "p1_score"
            case p2Score = "p2_score"
            case p3Score = "p3_score"
            case p4Score = "p4_score"
            case p5Score = "p5_score"
            case sport = "sport"
            case region = "region"
            case competition = "competition"
            case placardInfo = "placard_info"
            case homeMetaInfo = "home_team_meta"
            case awayMetaInfo = "away_team_meta"
        }
        
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            if let idValue = try? container.decode(Int.self, forKey: CodingKeys.id) {
                self.id = idValue
            }
            else if let idStringValue = try? container.decode(String.self, forKey: CodingKeys.id) {
                self.id = Int(idStringValue) ?? 0
            }
            else {
                let context = DecodingError.Context(codingPath: [], debugDescription: "Key not found")
                let error = DecodingError.keyNotFound(CodingKeys.id, context)
                throw error
            }
            
            self.homeTeamId = try container.decode(Int.self, forKey: CodingKeys.homeTeamId)
            self.awayTeamId = try container.decode(Int.self, forKey: CodingKeys.awayTeamId)

            self.homeTeam = try container.decode(String.self, forKey: CodingKeys.homeTeam)
            self.awayTeam = try container.decode(String.self, forKey: CodingKeys.awayTeam)
            
            self.date = try container.decode(String.self, forKey: CodingKeys.date)
            self.dateTime = try container.decode(Date.self, forKey: CodingKeys.dateTime)
            self.time = try container.decode(String.self, forKey: CodingKeys.time)
            
            self.homeScore = try? container.decode(Int.self, forKey: CodingKeys.homeScore)
            self.awayScore = try? container.decode(Int.self, forKey: CodingKeys.awayScore)
            self.halfTimeScore = try? container.decode(String.self, forKey: CodingKeys.halfTimeScore)
            self.fullTimeScore = try? container.decode(String.self, forKey: CodingKeys.fullTimeScore)
            self.extraTimeScore = try? container.decode(String.self, forKey: CodingKeys.extraTimeScore)
            
            self.timer = try container.decodeIfPresent(String.self, forKey: CodingKeys.timer)
            
            self.isLive = false
            if let isLiveIntValue = try? container.decode(Int.self, forKey: CodingKeys.isLive) {
                self.isLive = isLiveIntValue != 0
            }
            else if let isLiveValue = try? container.decode(Bool.self, forKey: CodingKeys.isLive) {
                self.isLive = isLiveValue
            }
            
            if let statusString = try? container.decode(String.self, forKey: CodingKeys.status) {
                self.status = EventStatus(value: statusString, isLive: self.isLive)
            }
            else {
                self.status = .unknown
            }
            
            self.p1Score = try? container.decode(Int.self, forKey: CodingKeys.p1Score)
            self.p2Score = try? container.decode(Int.self, forKey: CodingKeys.p2Score)
            self.p3Score = try? container.decode(Int.self, forKey: CodingKeys.p3Score)
            self.p4Score = try? container.decode(Int.self, forKey: CodingKeys.p4Score)
            self.p5Score = try? container.decode(Int.self, forKey: CodingKeys.p5Score)

            self.sport = try container.decode(GomaModels.Sport.self, forKey: CodingKeys.sport)
            
            self.region = try container.decodeIfPresent(GomaModels.Region.self, forKey: CodingKeys.region)
            
            self.competition = try container.decodeIfPresent(GomaModels.Competition.self, forKey: CodingKeys.competition)
            
            self.placardInfo = try container.decodeIfPresent(GomaModels.PlacardInfo.self, forKey: CodingKeys.placardInfo)
            
            if let homeMetaContainer = try? container.nestedContainer(keyedBy: Event.TeamsMetaCodingKeys.self, forKey: .homeMetaInfo) {
                let country = try homeMetaContainer.decodeIfPresent(String.self, forKey: Event.TeamsMetaCodingKeys.country)
                let name = try homeMetaContainer.decodeIfPresent(String.self, forKey: Event.TeamsMetaCodingKeys.name)
                
                self.homeLogoUrl = "/\(country ?? "")/\(name ?? "")"
            }
            
            if let awayMetaContainer = try? container.nestedContainer(keyedBy: Event.TeamsMetaCodingKeys.self, forKey: .awayMetaInfo) {
                let country = try awayMetaContainer.decodeIfPresent(String.self, forKey: Event.TeamsMetaCodingKeys.country)
                let name = try awayMetaContainer.decodeIfPresent(String.self, forKey: Event.TeamsMetaCodingKeys.name)
                
                self.awayLogoUrl = "/\(country ?? "")/\(name ?? "")"
            }
        }
    }
    
    enum MyTicketResult: String, CaseIterable, Codable {
        case pending = "pending"
        case won = "win"
        case lost = "lost"
        case push = "push"
        case undefined = "undefined"
        
        init(rawValue: String) {
            switch rawValue.lowercased() {
            case "pending":
                self = .pending
            case "win":
                self = .won
            case "lost":
                self = .lost
            case "push":
                self = .push
            default:
                self = .undefined
            }
        }
    }
    
    enum MyTicketStatus: String, CaseIterable, Codable {
        case pending = "pending"
        case won = "win"
        case lost = "lost"
        case push = "push"
        case undefined = "undefined"

        init(rawValue: String) {
            switch rawValue.lowercased() {
            case "pending":
                self = .pending
            case "win":
                self = .won
            case "lost":
                self = .lost
            case "push":
                self = .push
            default:
                self = .undefined
            }
        }
    }
    
    struct MyTicketQRCode: Codable {
        var qrCode: String?
        var expirationDate: String?
        var message: String?
        
        enum CodingKeys: String, CodingKey {
            case qrCode = "qrCode"
            case expirationDate = "expirationDateTime"
            case message = "message"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/GomaModels+Users.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 15/01/2024.
//

import Foundation

extension GomaModels {
    
    struct UserWallet: Codable {
        
        let balance: Double
        let freeBalance: Double
        let cashbackBalance: Double
        
        enum CodingKeys: String, CodingKey {
            case balance = "balance"
            case freeBalance = "free_balance"
            case cashbackBalance = "cashback_balance"
        }
        
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.balance = try container.decode(Double.self, forKey: .balance)
            self.freeBalance = try container.decodeIfPresent(Double.self, forKey: .freeBalance) ?? 0.0
            self.cashbackBalance = try container.decodeIfPresent(Double.self, forKey: .cashbackBalance) ?? 0.0
        }
                
    }
    
    struct UserNotificationsSettings: Codable {
        let notifications: Int
        let notificationsGamesWatchlist: Int
        let notificationsCompetitionsWatchlist: Int
        let notificationsGoal: Int
        let notificationsStartGame: Int
        let notificationsHalftime: Int
        let notificationsFulltime: Int
        let notificationsSecondHalf: Int
        let notificationsRedcard: Int
        let notificationsBets: Int
        let notificationsBetSelections: Int
        let notificationsEmail: Int
        let notificationsSms: Int
        let notificationsChats: Int
        let notificationsNews: Int
        
        enum CodingKeys: String, CodingKey {
            case notifications = "notifications"
            case notificationsGamesWatchlist = "notifications_games_watchlist"
            case notificationsCompetitionsWatchlist = "notifications_competitions_watchlist"
            case notificationsGoal = "notifications_goal"
            case notificationsStartGame = "notifications_startgame"
            case notificationsHalftime = "notifications_halftime"
            case notificationsFulltime = "notifications_fulltime"
            case notificationsSecondHalf = "notifications_secondhalf"
            case notificationsRedcard = "notifications_redcard"
            case notificationsBets = "notifications_bets"
            case notificationsBetSelections = "notifications_bet_selections"
            case notificationsEmail = "notifications_email"
            case notificationsSms = "notifications_sms"
            case notificationsChats = "notifications_chats"
            case notificationsNews = "notifications_news"
        }
        
        init(notifications: Bool,
             notificationsGamesWatchlist: Bool,
             notificationsCompetitionsWatchlist: Bool,
             notificationsGoal: Bool,
             notificationsStartGame: Bool,
             notificationsHalftime: Bool,
             notificationsFulltime: Bool,
             notificationsSecondHalf: Bool,
             notificationsRedcard: Bool,
             notificationsBets: Bool,
             notificationsBetSelections: Bool,
             notificationsEmail: Bool,
             notificationsSms: Bool,
             notificationsChats: Bool,
             notificationsNews: Bool)
        {
            self.notifications = notifications ? 1 : 0
            self.notificationsGamesWatchlist = notificationsGamesWatchlist ? 1 : 0
            self.notificationsCompetitionsWatchlist = notificationsCompetitionsWatchlist ? 1 : 0
            self.notificationsGoal = notificationsGoal ? 1 : 0
            self.notificationsStartGame = notificationsStartGame ? 1 : 0
            self.notificationsHalftime = notificationsHalftime ? 1 : 0
            self.notificationsFulltime = notificationsFulltime ? 1 : 0
            self.notificationsSecondHalf = notificationsSecondHalf ? 1 : 0
            self.notificationsRedcard = notificationsRedcard ? 1 : 0
            self.notificationsBets = notificationsBets ? 1 : 0
            self.notificationsBetSelections = notificationsBetSelections ? 1 : 0
            self.notificationsEmail = notificationsEmail ? 1 : 0
            self.notificationsSms = notificationsSms ? 1 : 0
            self.notificationsChats = notificationsChats ? 1 : 0
            self.notificationsNews = notificationsNews ? 1 : 0
        }
        
        init(notifications: Int,
             notificationsGamesWatchlist: Int,
             notificationsCompetitionsWatchlist: Int,
             notificationsGoal: Int,
             notificationsStartGame: Int,
             notificationsHalftime: Int,
             notificationsFulltime: Int,
             notificationsSecondHalf: Int,
             notificationsRedcard: Int,
             notificationsBets: Int,
             notificationsBetSelections: Int,
             notificationsEmail: Int,
             notificationsSms: Int,
             notificationsChats: Int,
             notificationsNews: Int)
        {
            self.notifications = notifications
            self.notificationsGamesWatchlist = notificationsGamesWatchlist
            self.notificationsCompetitionsWatchlist = notificationsCompetitionsWatchlist
            self.notificationsGoal = notificationsGoal
            self.notificationsStartGame = notificationsStartGame
            self.notificationsHalftime = notificationsHalftime
            self.notificationsFulltime = notificationsFulltime
            self.notificationsSecondHalf = notificationsSecondHalf
            self.notificationsRedcard = notificationsRedcard
            self.notificationsBets = notificationsBets
            self.notificationsBetSelections = notificationsBetSelections
            self.notificationsEmail = notificationsEmail
            self.notificationsSms = notificationsSms
            self.notificationsChats = notificationsChats
            self.notificationsNews = notificationsNews
        }
     
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<GomaModels.UserNotificationsSettings.CodingKeys> = try decoder.container(keyedBy: GomaModels.UserNotificationsSettings.CodingKeys.self)
            
            self.notifications = (try? container.decodeIntFromBoolOrInt(forKey: .notifications)) ?? 0
            self.notificationsGamesWatchlist = (try? container.decodeIntFromBoolOrInt(forKey: .notificationsGamesWatchlist)) ?? 0
            self.notificationsCompetitionsWatchlist = (try? container.decodeIntFromBoolOrInt(forKey: .notificationsCompetitionsWatchlist)) ?? 0
            self.notificationsGoal = (try? container.decodeIntFromBoolOrInt(forKey: .notificationsGoal)) ?? 0
            self.notificationsStartGame = (try? container.decodeIntFromBoolOrInt(forKey: .notificationsStartGame)) ?? 0
            self.notificationsHalftime = (try? container.decodeIntFromBoolOrInt(forKey: .notificationsHalftime)) ?? 0
            self.notificationsFulltime = (try? container.decodeIntFromBoolOrInt(forKey: .notificationsFulltime)) ?? 0
            self.notificationsSecondHalf = (try? container.decodeIntFromBoolOrInt(forKey: .notificationsSecondHalf)) ?? 0
            self.notificationsRedcard = (try? container.decodeIntFromBoolOrInt(forKey: .notificationsRedcard)) ?? 0
            self.notificationsBets = (try? container.decodeIntFromBoolOrInt(forKey: .notificationsBets)) ?? 0
            self.notificationsBetSelections = (try? container.decodeIntFromBoolOrInt(forKey: .notificationsBetSelections)) ?? 0
            self.notificationsEmail = (try? container.decodeIntFromBoolOrInt(forKey: .notificationsEmail)) ?? 0
            self.notificationsSms = (try? container.decodeIntFromBoolOrInt(forKey: .notificationsSms)) ?? 0
            self.notificationsChats = (try? container.decodeIntFromBoolOrInt(forKey: .notificationsChats)) ?? 0
            self.notificationsNews = (try? container.decodeIntFromBoolOrInt(forKey: .notificationsNews)) ?? 0
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: GomaModels.UserNotificationsSettings.CodingKeys.self)

            try container.encode(self.notifications, forKey: .notifications)
            try container.encode(self.notificationsGamesWatchlist, forKey: .notificationsGamesWatchlist)
            try container.encode(self.notificationsCompetitionsWatchlist, forKey: .notificationsCompetitionsWatchlist)
            try container.encode(self.notificationsGoal, forKey: .notificationsGoal)
            try container.encode(self.notificationsStartGame, forKey: .notificationsStartGame)
            try container.encode(self.notificationsHalftime, forKey: .notificationsHalftime)
            try container.encode(self.notificationsFulltime, forKey: .notificationsFulltime)
            try container.encode(self.notificationsSecondHalf, forKey: .notificationsSecondHalf)
            try container.encode(self.notificationsRedcard, forKey: .notificationsRedcard)
            try container.encode(self.notificationsBets, forKey: .notificationsBets)
            try container.encode(self.notificationsBetSelections, forKey: .notificationsBetSelections)
            try container.encode(self.notificationsEmail, forKey: .notificationsEmail)
            try container.encode(self.notificationsSms, forKey: .notificationsSms)
            try container.encode(self.notificationsChats, forKey: .notificationsChats)
            try container.encode(self.notificationsNews, forKey: .notificationsNews)
        }
        
    }
    
}

extension KeyedDecodingContainer {
    func decodeBoolFromBoolOrInt(forKey key: K) throws -> Bool {
        if let intValue = try? decode(Int.self, forKey: key) {
            return intValue != 0
        } else {
            return try decode(Bool.self, forKey: key)
        }
    }
    
    func decodeIntFromBoolOrInt(forKey key: K) throws -> Int {
        if let boolValue = try? decode(Bool.self, forKey: key) {
            return boolValue ? 1 : 0
        } else {
            return try decode(Int.self, forKey: key)
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/Models/GomaModelsHeroCardEvents.swift
````swift
//
//  GomaModelsHeroCardEvents+.swift
//
//
//  Created by André Lascas on 23/09/2024.
//

import Foundation

extension GomaModels {
    
    struct HeroCardEvents: Codable {
        
        var id: Int
        var imageUrl: String
        var event: Event
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case imageUrl = "image_url"
            case event = "event"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/GomaAPIAuthenticator.swift
````swift
//
//  GomaAPIAuthenticator.swift
//
//
//  Created by Ruben Roques on 18/12/2023.
//

import Foundation
import Combine

class GomaAPIAuthenticator {

    var deviceIdentifier: String
    
    private let session: URLSession
    
    var pushNotificationsToken: String?
    
    private var token: GomaSessionAccessToken?
    private var credentials: GomaUserCredentials?
    
    private let queue = DispatchQueue(label: "GomaAPIAuthenticator.\(UUID().uuidString)")

    // This publisher is shared amongst all calls that request a token refresh
    private var refreshPublisher: AnyPublisher<GomaSessionAccessToken, Error>?

    init(deviceIdentifier: String, session: URLSession = URLSession.shared) {
        self.deviceIdentifier = deviceIdentifier
        self.session = session
    }
    
    func getToken() -> String? {
        return self.token?.hash
    }

    func updateToken(newToken: String?) {
        if let newToken = newToken {
            self.token = GomaSessionAccessToken(hash: newToken, type: "")
        }
        else {
            self.token = nil
        }
    }
    
    func updateCredentials(credentials: GomaUserCredentials?) {
        self.credentials = credentials
    }
    
    func updatePushNotificationToken(newToken: String?) {
        let shouldForceUpdateToken = (self.pushNotificationsToken == nil && newToken != nil )
        self.pushNotificationsToken = newToken
        
        // We need to force an auth or login in the next requests so we can send the PushToken
        if shouldForceUpdateToken {
            self.token = nil
        }
    }
    
    
    func publisherWithValidToken(forceRefresh: Bool = false) -> AnyPublisher<GomaSessionAccessToken, Error> {
        if let loggedUserCredentials = self.credentials {
            return self.loggedUserValidToken(deviceId: self.deviceIdentifier,
                                             pushToken: self.pushNotificationsToken,
                                             forceRefresh: forceRefresh,
                                             loggedUser: loggedUserCredentials)
        }
        else {
            return self.anonymousValidToken(deviceId: self.deviceIdentifier,
                                            pushToken: self.pushNotificationsToken,
                                            forceRefresh: forceRefresh)
        }
    }

    private func loggedUserValidToken(deviceId: String, pushToken: String?, forceRefresh: Bool = false, loggedUser: GomaUserCredentials) -> AnyPublisher<GomaSessionAccessToken, Error> {
        return self.queue.sync(execute: { [weak self] in
            
            var shouldForceRefresh = forceRefresh
            
            // We're already loading a new token
            if let publisher = self?.refreshPublisher {
                return publisher
            }
            
            // We don't have a token so we override the forceRefresh
            if let selfValue = self, selfValue.token == nil {
                shouldForceRefresh = true
            }
            
            
            // We already have a valid token and don't want to force a refresh
            if let selfValue = self, let token = selfValue.token, !shouldForceRefresh {
                return Just(token).setFailureType(to: Error.self).eraseToAnyPublisher()
            }
            
            let endpoint = GomaAPIClient.login(username: loggedUser.username,
                                               password: loggedUser.password,
                                               pushToken: pushToken)
            
            guard
                let weakSelf = self,
                let request = endpoint.request()
            else {
                return Fail(error: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
            }
            
            let publisher = weakSelf.session.dataTaskPublisher(for: request)
                .tryMap { result in
                    if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 401 {
                        throw ServiceProviderError.unauthorized
                    }
                    else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 403 {
                        throw ServiceProviderError.forbidden
                    }
                    else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode != 200 {
                        throw ServiceProviderError.unknown
                    }
                    return result.data
                }
                .share()
                .decode(type: GomaSessionAccessToken.self, decoder: JSONDecoder())
                .handleEvents(receiveOutput: { token in
                    self?.token = token
                    print("GGAPI New Session Token [logged] \(token)")
                }, receiveCompletion: { _ in
                    self?.queue.sync {
                        self?.refreshPublisher = nil
                    }
                })
                .eraseToAnyPublisher()
            
            self?.refreshPublisher = publisher
            
            return publisher
        })
    }

    private func anonymousValidToken(deviceId: String,
                                     pushToken: String?,
                                     forceRefresh: Bool = false) -> AnyPublisher<GomaSessionAccessToken, Error> {
        return self.queue.sync(execute: { [weak self] in

            var shouldForceRefresh = forceRefresh

            // We're already loading a new token
            if let publisher = self?.refreshPublisher {
                return publisher
            }

            // We don't have a token so we override the forceRefresh
            if let selfValue = self, selfValue.token == nil {
                shouldForceRefresh = true
            }

            // We already have a valid token and don't want to force a refresh
            if let selfValue = self, let token = selfValue.token, !shouldForceRefresh {
                return Just(token).setFailureType(to: Error.self).eraseToAnyPublisher()
            }

            let endpoint = GomaAPIClient.anonymousAuth(deviceId: deviceId,
                                                       pushToken: pushToken)
            
            guard
                let weakSelf = self,
                let request = endpoint.request()
            else {
                return Fail(error: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
            }
            
            let publisher = weakSelf.session.dataTaskPublisher(for: request)
                .tryMap { result in
                    if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 401 {
                        throw ServiceProviderError.unauthorized
                    }
                    else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 403 {
                        throw ServiceProviderError.forbidden
                    }
                    else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode != 200 {
                        throw ServiceProviderError.unknown
                    }
                    return result.data
                }
            
                .share()
                .decode(type: GomaSessionAccessToken.self, decoder: JSONDecoder())
                .handleEvents(receiveOutput: { token in
                    self?.token = token
                    print("GGAPI New Session Token [anon] \(token)")
                }, receiveCompletion: { _ in
                    self?.queue.sync {
                        self?.refreshPublisher = nil
                    }
                })
                .eraseToAnyPublisher()

            self?.refreshPublisher = publisher
            return publisher

        })
    }

}
````

## File: Sources/ServicesProvider/Providers/Goma/GomaAPIProvider.swift
````swift
//
//  GomaAPIProvider.swift
//
//
//  Created by Ruben Roques on 12/12/2023.
//

import Foundation
import Combine
import SharedModels

class GomaAPIProvider {

    var connector: GomaConnector

    private let userSessionStateSubject: CurrentValueSubject<UserSessionStatus, Error> = .init(.anonymous)
    private let userProfileSubject: CurrentValueSubject<UserProfile?, Error> = .init(nil)

    //Paginators cache
    private var paginatorsCache: [String: GomaEventPaginator<GomaModels.Event>] = [:]

    private var cancellables: Set<AnyCancellable> = []

    var isProviderEnabled: Bool = false

    init(deviceIdentifier: String) {

        self.connector = GomaConnector(deviceIdentifier: deviceIdentifier)

    }

}

extension GomaAPIProvider: PrivilegedAccessManager, PromotionsProvider {
    
    var providerEnabled: Bool {
        return self.isProviderEnabled
    }

    func isPromotionsProviderEnabled(isEnabled: Bool) -> AnyPublisher<Bool, ServiceProviderError> {
        self.isProviderEnabled = isEnabled
        return Just(isEnabled).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
    }

    var userSessionStatePublisher: AnyPublisher<UserSessionStatus, Error> {
        return userSessionStateSubject.eraseToAnyPublisher()
    }
    var userProfilePublisher: AnyPublisher<UserProfile?, Error> {
        return userProfileSubject.eraseToAnyPublisher()
    }

    var accessToken: String? {
        return self.connector.authenticator.getToken()
    }

    var hasSecurityQuestions: Bool {
        return false
    }

    func anonymousLogin() -> AnyPublisher<String, ServiceProviderError> {
        let endpoint = GomaAPIClient.anonymousAuth(deviceId: self.connector.authenticator.deviceIdentifier, pushToken: self.connector.getPushNotificationToken())

        let publisher: AnyPublisher<GomaModels.AnonymousLoginResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher
            .handleEvents(receiveOutput: { [weak self] response in
                self?.connector.updateToken(newToken: response.token)
            })
            .map({ anonymousLoginResponse in
                return anonymousLoginResponse.token
            }).eraseToAnyPublisher()
    }

    func login(username: String, password: String) -> AnyPublisher<UserProfile, ServiceProviderError> {
        let endpoint = GomaAPIClient.login(username: username,
                                           password: password,
                                           pushToken: self.connector.getPushNotificationToken())

        let publisher: AnyPublisher<GomaModels.LoginResponse, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .handleEvents(receiveOutput: { [weak self] response in
                self?.connector.updateToken(newToken: response.token)
            })
            .map({ loginResponse in
            let mappedLoginResponse = GomaModelMapper.loginResponse(fromInternalLoginResponse: loginResponse)
            return mappedLoginResponse.userProfile
        }).eraseToAnyPublisher()
    }

    func logoutUser() -> AnyPublisher<String, ServiceProviderError> {

        let endpoint = GomaAPIClient.logout

        let publisher: AnyPublisher<GomaModels.LogoutResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher
            .handleEvents(receiveOutput: { [weak self] response in
                self?.connector.clearToken()
            })
            .map({ logoutResponse in
            return logoutResponse.message
        }).eraseToAnyPublisher()
    }

    func updateUserProfile(form: UpdateUserProfileForm) -> AnyPublisher<Bool, ServiceProviderError> {

        let endpoint = GomaAPIClient.updatePersonalInfo(fullname: form.firstName ?? "", avatar: form.avatar ?? "")

        let publisher: AnyPublisher<String, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ statusResponse -> AnyPublisher<Bool, ServiceProviderError> in

            return Just(true).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()

//        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func checkEmailRegistered(_ email: String) -> AnyPublisher<Bool, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func validateUsername(_ username: String) -> AnyPublisher<UsernameValidation, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func simpleSignUp(form: SimpleSignUpForm) -> AnyPublisher<Bool, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func basicSignUp(form: SignUpForm) -> AnyPublisher<DetailedSignUpResponse, ServiceProviderError> {
        let endpoint = GomaAPIClient.register(name: form.firstName + " " + form.lastName,
                                            email: form.email,
                                            username: form.username,
                                            password: form.password,
                                              avatarName: form.avatarName ?? "")
        let publisher: AnyPublisher<GomaModels.GomaResponse<GomaModels.BasicRegisterResponse>, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ gomaResponse in
            let basicRegisterResponse = gomaResponse.data

            let basicSignUpResponse = GomaModelMapper.basicRegisterResponse(fromInternalBasicRegisterResponse: basicRegisterResponse)

            return basicSignUpResponse
        }).eraseToAnyPublisher()
    }

    func signUp(form: SignUpForm) -> AnyPublisher<SignUpResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func updateExtraInfo(placeOfBirth: String?, address2: String?) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func updateDeviceIdentifier(deviceIdentifier: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        self.connector.updatePushNotificationToken(newToken: deviceIdentifier)
        return Just(BasicResponse(status: "ok")).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
    }

    func getAllCountries() -> AnyPublisher<[SharedModels.Country], ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func getCountries() -> AnyPublisher<[SharedModels.Country], ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func getCurrentCountry() -> AnyPublisher<SharedModels.Country?, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func signupConfirmation(_ email: String, confirmationCode: String) -> AnyPublisher<Bool, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func forgotPassword(email: String, secretQuestion: String?, secretAnswer: String?) -> AnyPublisher<Bool, ServiceProviderError> {
        let endpoint: GomaAPIClient = GomaAPIClient.requestPasswordResetEmail(email: email)
        let publisher: AnyPublisher<BasicMessageResponse, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ basicMessageResponse -> Bool in
            return basicMessageResponse.message.lowercased().contains("reset link sent")
        }).eraseToAnyPublisher()
    }

    func updatePassword(oldPassword: String, newPassword: String) -> AnyPublisher<Bool, ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.updatePassword(oldPassword: oldPassword, password: newPassword, passwordConfirmation: newPassword)
        let publisher: AnyPublisher<BasicMessageResponse, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ basicMessageResponse -> Bool in
            return basicMessageResponse.message.lowercased().contains("successfully")
        }).eraseToAnyPublisher()

    }

    func getPasswordPolicy() -> AnyPublisher<PasswordPolicy, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func updateWeeklyDepositLimits(newLimit: Double) -> AnyPublisher<Bool, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func updateWeeklyBettingLimits(newLimit: Double) -> AnyPublisher<Bool, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func updateResponsibleGamingLimits(newLimit: Double) -> AnyPublisher<Bool, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func getPersonalDepositLimits() -> AnyPublisher<PersonalDepositLimitResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func getLimits() -> AnyPublisher<LimitsResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func lockPlayer(isPermanent: Bool?, lockPeriodUnit: String?, lockPeriod: String?) -> AnyPublisher<BasicResponse, ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.closeAccount

        let publisher: AnyPublisher<String, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ closeAccountResponse in
            let basicResponse = BasicResponse(status: "success", message: closeAccountResponse)
            return basicResponse
        }).eraseToAnyPublisher()
    }

    func getUserBalance() -> AnyPublisher<UserWallet, ServiceProviderError> {
        let endpoint: GomaAPIClient = GomaAPIClient.getUserWallet
        let publisher: AnyPublisher<GomaModels.UserWallet, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ userWallet in
            let total = userWallet.balance + userWallet.freeBalance
            let wallet = UserWallet(vipStatus: nil,
                                    currency: "EUR",
                                    loyaltyPoint: nil,
                                    totalString: nil,
                                    total: total,
                                    withdrawableString: nil,
                                    withdrawable: userWallet.balance,
                                    bonusString: nil,
                                    bonus: userWallet.freeBalance,
                                    pendingBonusString: nil,
                                    pendingBonus: nil,
                                    casinoPlayableBonusString: nil,
                                    casinoPlayableBonus: nil,
                                    sportsbookPlayableBonusString: nil,
                                    sportsbookPlayableBonus: nil,
                                    withdrawableEscrowString: nil,
                                    withdrawableEscrow: nil,
                                    totalWithdrawableString: nil,
                                    totalWithdrawable: nil,
                                    withdrawRestrictionAmountString: nil,
                                    withdrawRestrictionAmount: nil,
                                    totalEscrowString: nil,
                                    totalEscrow: nil)
            return wallet
        }).eraseToAnyPublisher()
    }

    func getUserCashbackBalance() -> AnyPublisher<CashbackBalance, ServiceProviderError> {
        let endpoint: GomaAPIClient = GomaAPIClient.getUserWallet
        let publisher: AnyPublisher<GomaModels.UserWallet, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ userWallet in
            let wallet = CashbackBalance(status: "", balance: "\(userWallet.cashbackBalance)", message: nil)
            return wallet
        }).eraseToAnyPublisher()
    }

    func depositOnWallet(amount: Double) -> AnyPublisher<Bool, ServiceProviderError> {
        let endpoint: GomaAPIClient = GomaAPIClient.addAmoutToUserWallet(amount: amount)
        let publisher: AnyPublisher<GomaModels.UserWallet, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ wallet in
            return true
        }).eraseToAnyPublisher()
    }

    func signUpCompletion(form: UpdateUserProfileForm) -> AnyPublisher<Bool, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func getDocumentTypes() -> AnyPublisher<DocumentTypesResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func getUserDocuments() -> AnyPublisher<UserDocumentsResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func uploadUserDocument(documentType: String, file: Data, fileName: String) -> AnyPublisher<UploadDocumentResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func uploadMultipleUserDocuments(documentType: String, files: [String: Data]) -> AnyPublisher<UploadDocumentResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func getPayments() -> AnyPublisher<SimplePaymentMethodsResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func processDeposit(paymentMethod: String, amount: Double, option: String) -> AnyPublisher<ProcessDepositResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func cancelDeposit(paymentId: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func checkPaymentStatus(paymentMethod: String, paymentId: String) -> AnyPublisher<PaymentStatusResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func getWithdrawalMethods() -> AnyPublisher<[WithdrawalMethod], ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func getPendingWithdrawals() -> AnyPublisher<[PendingWithdrawal], ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func cancelWithdrawal(paymentId: Int) -> AnyPublisher<CancelWithdrawalResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func getPaymentInformation() -> AnyPublisher<PaymentInformation, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func addPaymentInformation(type: String, fields: String) -> AnyPublisher<AddPaymentInformationResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func getTransactionsHistory(startDate: String, endDate: String, transactionTypes: [TransactionType]?, pageNumber: Int?) -> AnyPublisher<[TransactionDetail], ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func getGrantedBonuses() -> AnyPublisher<[GrantedBonus], ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func redeemBonus(code: String) -> AnyPublisher<RedeemBonusResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func getAvailableBonuses() -> AnyPublisher<[AvailableBonus], ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func redeemAvailableBonus(partyId: String, code: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func cancelBonus(bonusId: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func optOutBonus(partyId: String, code: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func contactUs(firstName: String, lastName: String, email: String, subject: String, message: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
    }

    func contactSupport(userIdentifier: String, firstName: String, lastName: String,
                        email: String, subject: String, subjectType: String,
                        message: String, isLogged: Bool) -> AnyPublisher<SupportResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getAllConsents() -> AnyPublisher<[ConsentInfo], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getUserConsents() -> AnyPublisher<[UserConsent], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func setUserConsents(consentVersionIds: [Int]?, unconsenVersionIds: [Int]?) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getSumsubAccessToken(userId: String, levelName: String) -> AnyPublisher<AccessTokenResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getSumsubApplicantData(userId: String) -> AnyPublisher<ApplicantDataResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func generateDocumentTypeToken(docType: String) -> AnyPublisher<AccessTokenResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func checkDocumentationData() -> AnyPublisher<ApplicantDataResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getMobileVerificationCode(forMobileNumber mobileNumber: String) -> AnyPublisher<MobileVerifyResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func verifyMobileCode(code: String, requestId: String) -> AnyPublisher<MobileVerifyResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    //
    //
    //
    func getUserProfile(withKycExpire: String?) -> AnyPublisher<UserProfile, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func updateDeviceIdentifier(deviceIdentifier: String, appVersion: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func updateResponsibleGamingLimits(newLimit: Double, limitType: String, hasRollingWeeklyLimits: Bool) -> AnyPublisher<Bool, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func getResponsibleGamingLimits(periodTypes: String?, limitTypes: String?) -> AnyPublisher<ResponsibleGamingLimitsResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func updatePayment(amount: Double, paymentId: String, type: String, returnUrl: String?, nameOnCard: String?, encryptedExpiryYear: String?, encryptedExpiryMonth: String?, encryptedSecurityCode: String?, encryptedCardNumber: String?) -> AnyPublisher<UpdatePaymentResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func processWithdrawal(paymentMethod: String, amount: Double, conversionId: String?) -> AnyPublisher<ProcessWithdrawalResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func prepareWithdrawal(paymentMethod: String) -> AnyPublisher<PrepareWithdrawalResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func getReferralLink() -> AnyPublisher<ReferralLink, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func getReferees() -> AnyPublisher<[Referee], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    //
    //
    //
    func getFollowees() -> AnyPublisher<[Follower], ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.getFollowees

        let publisher: AnyPublisher<GomaModels.GomaResponse<GomaModels.FolloweesResponse>, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ followeesResponse in

            let mappedFollowers = followeesResponse.data.followees.map( {

                return GomaModelMapper.follower(fromFollower: $0)
            })

            return mappedFollowers

        }).eraseToAnyPublisher()
    }

    func getTotalFollowees() -> AnyPublisher<Int, ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.getTotalFollowees

        let publisher: AnyPublisher<GomaModels.GomaResponse<GomaModels.TotalFolloweesResponse>, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ totalFolloweesResponse in

            return totalFolloweesResponse.data.count

        }).eraseToAnyPublisher()
    }

    func getFollowers() -> AnyPublisher<[Follower], ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.getFollowers

        let publisher: AnyPublisher<GomaModels.GomaResponse<GomaModels.FollowersResponse>, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ followersResponse in

            let mappedFollowers = followersResponse.data.followers.map( {

                return GomaModelMapper.follower(fromFollower: $0)
            })

            return mappedFollowers

        }).eraseToAnyPublisher()
    }

    func getTotalFollowers() -> AnyPublisher<Int, ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.getTotalFollowers

        let publisher: AnyPublisher<GomaModels.GomaResponse<GomaModels.TotalFollowersResponse>, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ totalFollowersResponse in

            return totalFollowersResponse.data.count

        }).eraseToAnyPublisher()
    }

    func addFollowee(userId: String) -> AnyPublisher<[String], ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.addFollowee(userId: userId)

        let publisher: AnyPublisher<GomaModels.GomaResponse<GomaModels.FolloweeActionResponse>, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ followeeActionResponse in

            let followeeIds = followeeActionResponse.data.followeeIds.map({
                return "\($0)"
            })

            return followeeIds

        }).eraseToAnyPublisher()
    }

    func removeFollowee(userId: String) -> AnyPublisher<[String], ServiceProviderError> {
        let endpoint: GomaAPIClient = GomaAPIClient.removeFollowee(userId: userId)
        let publisher: AnyPublisher<GomaModels.GomaResponse<GomaModels.FolloweeActionResponse>, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ followeeActionResponse in
            let followeeIds = followeeActionResponse.data.followeeIds.map({
                return "\($0)"
            })
            return followeeIds
        }).eraseToAnyPublisher()
    }

    func getTipsRankings(type: String?, followers: Bool?) -> AnyPublisher<[TipRanking], ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.getTipsRankings(type: type, followers: followers)

        let publisher: AnyPublisher<[GomaModels.TipRanking], ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ tipsRankings in

            let mappedTipsRankings = tipsRankings.map( {

                return GomaModelMapper.tipRanking(fromTipRanking: $0)
            })

            return mappedTipsRankings

        }).eraseToAnyPublisher()
    }

    func getUserProfileInfo(userId: String) -> AnyPublisher<UserProfileInfo, ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.getUserProfile(userId: userId)

        let publisher: AnyPublisher<GomaModels.UserProfileInfo, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ userProfileInfo in

            let mappedUserProfileInfo = GomaModelMapper.userProfileInfo(fromUserProfileInfo: userProfileInfo)

            return mappedUserProfileInfo

        }).eraseToAnyPublisher()
    }

    func getUserNotifications() -> AnyPublisher<UserNotificationsSettings, ServiceProviderError> {
        let endpoint: GomaAPIClient = GomaAPIClient.getUserNotificationsSettings
        let publisher: AnyPublisher<GomaModels.UserNotificationsSettings, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map(GomaModelMapper.userNotificationsSettings(fromInternalUserNotificationsSettings:)).eraseToAnyPublisher()
    }

    func updateUserNotifications(settings: UserNotificationsSettings) -> AnyPublisher<Bool, ServiceProviderError> {
        let settings = GomaModelMapper.internalUserNotificationsSettings(fromUserNotificationsSettings: settings)
        let endpoint: GomaAPIClient = GomaAPIClient.updateUserNotificationsSettings(settings: settings)
        let publisher: AnyPublisher<BasicResponse, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ response in
            return response.status.lowercased() == "success"
        }).eraseToAnyPublisher()
    }

    func getFriendRequests() -> AnyPublisher<[FriendRequest], ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.getFriendRequests

        let publisher: AnyPublisher<GomaModels.GomaResponse<[GomaModels.FriendRequest]>, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ response in

            let friendRequests = response.data.map({
                return GomaModelMapper.friendRequest(fromFriendRequest: $0)
            })

            return friendRequests
        }).eraseToAnyPublisher()
    }

    func getFriends() -> AnyPublisher<[GomaFriend], ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.getFriends

        let publisher: AnyPublisher<GomaModels.GomaResponse<[GomaModels.GomaFriend]>, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ response in

            let userFriends = response.data.map({
                return GomaModelMapper.userFriend(fromGomaFriend: $0)
            })

            return userFriends
        }).eraseToAnyPublisher()
    }

    func addFriends(userIds: [String], request: Bool) -> AnyPublisher<AddFriendResponse, ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.addFriends(userIds: userIds, request: request)

        let publisher: AnyPublisher<GomaModels.GomaResponse<GomaModels.AddFriendResponse>, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ response in

            let userFriends = GomaModelMapper.addFriendResponse(fromAddFriendResponse: response.data)

            return userFriends
        }).eraseToAnyPublisher()
    }

    func removeFriend(userId: Int) -> AnyPublisher<String, ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.removeFriend(userId: userId)

        let publisher: AnyPublisher<String, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.eraseToAnyPublisher()
    }

    func getChatrooms() -> AnyPublisher<[ChatroomData], ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.getChatrooms

        let publisher: AnyPublisher<GomaModels.GomaResponse<[GomaModels.ChatroomData]>, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ response in

            let chatroomData = response.data.map({
                return GomaModelMapper.chatroomData(fromChatroomData: $0)
            })

            return chatroomData
        }).eraseToAnyPublisher()
    }

    func addGroup(name: String, userIds: [String]) -> AnyPublisher<ChatroomId, ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.addGroup(name: name, userIds: userIds)

        let publisher: AnyPublisher<GomaModels.GomaResponse<GomaModels.ChatroomId>, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ response in

            let chatroomId = GomaModelMapper.chatroomId(fromChatroomId: response.data)

            return chatroomId
        }).eraseToAnyPublisher()
    }

    func deleteGroup(id: Int) -> AnyPublisher<String, ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.deleteGroup(id: id)

        let publisher: AnyPublisher<GomaModels.DeleteGroupResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ response in

            return response.message ?? ""
        }).eraseToAnyPublisher()
    }

    func editGroup(id: Int, name: String) -> AnyPublisher<String, ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.editGroup(id: id, name: name)

        let publisher: AnyPublisher<String, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.eraseToAnyPublisher()
    }

    func leaveGroup(id: Int) -> AnyPublisher<String, ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.leaveGroup(id: id)

        let publisher: AnyPublisher<String, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.eraseToAnyPublisher()
    }

    func addUsersToGroup(groupId: Int, userIds: [String]) -> AnyPublisher<String, ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.addUsersFromGroup(groupId: groupId, userIds: userIds)

        let publisher: AnyPublisher<String, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.eraseToAnyPublisher()
    }

    func removeUsersToGroup(groupId: Int, userIds: [String]) -> AnyPublisher<String, ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.removeUsersFromGroup(groupId: groupId, userIds: userIds)

        let publisher: AnyPublisher<String, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.eraseToAnyPublisher()
    }

    func searchUserWithCode(code: String) -> AnyPublisher<SearchUser, ServiceProviderError> {

        let endpoint: GomaAPIClient = GomaAPIClient.searchUserWithCode(code: code)

        let publisher: AnyPublisher<GomaModels.SearchUser, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ searchUser in

            let searchUser = GomaModelMapper.searchUser(fromSearchUser: searchUser)

            return searchUser
        }).eraseToAnyPublisher()
    }
}

extension GomaAPIProvider: EventsProvider {

    var connectionStatePublisher: AnyPublisher<ConnectorState, Never> {
        return self.connector.connectionStatePublisher.eraseToAnyPublisher()
    }

    func reconnectIfNeeded() {

    }

    func subscribeLiveMatches(forSportType sportType: SportType) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {
        guard
            let sportId = sportType.numericId
        else {
            return Fail(error: ServiceProviderError.incompletedSportData).eraseToAnyPublisher()
        }

        let paginatorId = "live-\(sportType)"

        if let paginator = self.paginatorsCache[paginatorId] {
            paginator.requestInitialPage()
            return paginator.eventsGroupPublisher.map({ events in
                let mappedEvents = GomaModelMapper.eventsGroup(fromInternalEvents: events)
                return SubscribableContent.contentUpdate(content: [mappedEvents])
            }).eraseToAnyPublisher()
        }
        else {
            let paginator = GomaEventPaginator<GomaModels.Event>(needsRefresh: true) { page in
                let endpoint: GomaAPIClient = GomaAPIClient.getLiveEvents(sportCode: sportId, page: page)
                let publisher: AnyPublisher<[GomaModels.Event], ServiceProviderError> = self.connector.request(endpoint)
                return publisher.eraseToAnyPublisher()
            }

            self.paginatorsCache[paginatorId] = paginator

            paginator.requestInitialPage()

            return paginator.eventsGroupPublisher.map({ events in
                let mappedEvents = GomaModelMapper.eventsGroup(fromInternalEvents: events)
                return SubscribableContent.contentUpdate(content: [mappedEvents])
            }).eraseToAnyPublisher()
        }
    }

    func requestLiveMatchesNextPage(forSportType sportType: SportType) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let sportId = sportType.numericId
        else {
            return Fail(error: ServiceProviderError.incompletedSportData).eraseToAnyPublisher()
        }

        let paginatorId = "live-\(sportType)"

        if let paginator = self.paginatorsCache[paginatorId] {
            paginator.requestNextPage()
            return paginator.hasNextPagePublisher.eraseToAnyPublisher()
        }
        else {
            let paginator = GomaEventPaginator<GomaModels.Event>(needsRefresh: true) { page in
                let endpoint: GomaAPIClient = GomaAPIClient.getLiveEvents(sportCode: sportId, page: page)
                let publisher: AnyPublisher<[GomaModels.Event], ServiceProviderError> = self.connector.request(endpoint)
                return publisher.eraseToAnyPublisher()
            }
            self.paginatorsCache[paginatorId] = paginator
            paginator.requestNextPage()
            return paginator.hasNextPagePublisher.eraseToAnyPublisher()
        }
    }

    func subscribePreLiveMatches(forSportType sportType: SportType, initialDate: Date?, endDate: Date?, eventCount: Int?, sortType: EventListSort) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {

        guard
            let sportId = sportType.numericId
        else {
            return Fail(error: ServiceProviderError.incompletedSportData).eraseToAnyPublisher()
        }

        let paginatorId = "preLive-\(sortType)-\(sportType)"

        if let paginator = self.paginatorsCache[paginatorId] {
            paginator.requestInitialPage()
            return paginator.eventsGroupPublisher.map({ events in
                let mappedEvents = GomaModelMapper.eventsGroup(fromInternalEvents: events)
                return SubscribableContent.contentUpdate(content: [mappedEvents])
            }).eraseToAnyPublisher()
        }
        else {
            let paginator = GomaEventPaginator<GomaModels.Event>(needsRefresh: false) { page in
                var endpoint = GomaAPIClient.getUpcomingEvents(sportCode: sportId, page: page)
                switch sortType {
                case .date:
                    endpoint = GomaAPIClient.getUpcomingEvents(sportCode: sportId, page: page)
                case .popular:
                    endpoint = GomaAPIClient.getTrendingEvents(sportCode: sportId, page: page)
                }

                let publisher: AnyPublisher<GomaModels.GomaPagedResponse<[GomaModels.Event]>, ServiceProviderError> = self.connector.request(endpoint)
                return publisher.map(\.data).eraseToAnyPublisher()
            }

            self.paginatorsCache[paginatorId] = paginator

            paginator.requestInitialPage()

            return paginator.eventsGroupPublisher.map({ events in
                let mappedEvents = GomaModelMapper.eventsGroup(fromInternalEvents: events)
                return SubscribableContent.contentUpdate(content: [mappedEvents])
            }).eraseToAnyPublisher()
        }
    }

    func requestPreLiveMatchesNextPage(forSportType sportType: SportType, initialDate: Date?, endDate: Date?, sortType: EventListSort) -> AnyPublisher<Bool, ServiceProviderError> {

        guard
            let sportId = sportType.numericId
        else {
            return Fail(error: ServiceProviderError.incompletedSportData).eraseToAnyPublisher()
        }

        let paginatorId = "preLive-\(sortType)-\(sportType)"

        if let paginator = self.paginatorsCache[paginatorId] {
            paginator.requestNextPage()
            return paginator.hasNextPagePublisher.eraseToAnyPublisher()
        }
        else {
            let paginator = GomaEventPaginator<GomaModels.Event>(needsRefresh: false) { page in
                var endpoint = GomaAPIClient.getUpcomingEvents(sportCode: sportId, page: page)
                switch sortType {
                case .date:
                    endpoint = GomaAPIClient.getUpcomingEvents(sportCode: sportId, page: page)
                case .popular:
                    endpoint = GomaAPIClient.getTrendingEvents(sportCode: sportId, page: page)
                }

                let publisher: AnyPublisher<GomaModels.GomaPagedResponse<[GomaModels.Event]>, ServiceProviderError> = self.connector.request(endpoint)
                return publisher.map(\.data).eraseToAnyPublisher()
            }
            self.paginatorsCache[paginatorId] = paginator
            paginator.requestNextPage()
            return paginator.hasNextPagePublisher.eraseToAnyPublisher()
        }

    }

    func subscribeEndedMatches(forSportType sportType: SportType) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {
        guard
            let sportId = sportType.numericId
        else {
            return Fail(error: ServiceProviderError.incompletedSportData).eraseToAnyPublisher()
        }

        let paginatorId = "ended-\(sportType)"

        if let paginator = self.paginatorsCache[paginatorId] {
            paginator.requestInitialPage()
            return paginator.eventsGroupPublisher.map({ events in
                let mappedEvents = GomaModelMapper.eventsGroup(fromInternalEvents: events)
                return SubscribableContent.contentUpdate(content: [mappedEvents])
            }).eraseToAnyPublisher()
        }
        else {
            let paginator = GomaEventPaginator<GomaModels.Event>(needsRefresh: false) { page in
                let endpoint: GomaAPIClient = GomaAPIClient.getEndedEvents(sportCode: sportId, page: page)
                let publisher: AnyPublisher<GomaModels.GomaPagedResponse<[GomaModels.Event]>, ServiceProviderError> = self.connector.request(endpoint)
                return publisher.map(\.data).eraseToAnyPublisher()
            }

            self.paginatorsCache[paginatorId] = paginator

            paginator.requestInitialPage()

            return paginator.eventsGroupPublisher.map({ events in
                let mappedEvents = GomaModelMapper.eventsGroup(fromInternalEvents: events)
                return SubscribableContent.contentUpdate(content: [mappedEvents])
            }).eraseToAnyPublisher()
        }
    }

    func requestEndedMatchesNextPage(forSportType sportType: SportType) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let sportId = sportType.numericId
        else {
            return Fail(error: ServiceProviderError.incompletedSportData).eraseToAnyPublisher()
        }

        let paginatorId = "ended-\(sportType)"

        if let paginator = self.paginatorsCache[paginatorId] {
            paginator.requestNextPage()
            return paginator.hasNextPagePublisher.eraseToAnyPublisher()
        }
        else {
            let paginator = GomaEventPaginator<GomaModels.Event>(needsRefresh: false) { page in
                let endpoint: GomaAPIClient = GomaAPIClient.getLiveEvents(sportCode: sportId, page: page)
                let publisher: AnyPublisher<GomaModels.GomaPagedResponse<[GomaModels.Event]>, ServiceProviderError> = self.connector.request(endpoint)
                return publisher.map(\.data).eraseToAnyPublisher()
            }
            self.paginatorsCache[paginatorId] = paginator
            paginator.requestNextPage()
            return paginator.hasNextPagePublisher.eraseToAnyPublisher()
        }
    }
    
    func subscribePreLiveSportTypes(initialDate: Date?, endDate: Date?) -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    // TODO: SP Merge - subscribePreLiveSportTypes , subscribeAllSportTypes and subscribeLiveSportTypes should all be merged into -> subscribeSportTypes
    func subscribeLiveSportTypes() -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func subscribeAllSportTypes() -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func subscribeSportTypes() -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError> {
        let endpoint = GomaAPIClient.getSports
        let publisher: AnyPublisher<GomaModels.Sports, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ sports in
            return SubscribableContent.contentUpdate(content: GomaModelMapper.sportsType(fromSports:sports))
        }).eraseToAnyPublisher()
    }

    func getEventsForEventGroup(withId eventGroupId: String) -> AnyPublisher<EventsGroup, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func getHighlightedLiveEventsPointers(eventCount: Int, userId: String?) -> AnyPublisher<[String], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func getPromotedBetslips(userId: String?) -> AnyPublisher<[PromotedBetslip], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    //
    //
    //
    func subscribeOutrightEvent(forMarketGroupId marketGroupId: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func subscribeToEventOnListsLiveDataUpdates(withId id: String) -> AnyPublisher<Event?, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func subscribeToEventOnListsMarketUpdates(withId id: String) -> AnyPublisher<Market?, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func subscribeToEventOnListsOutcomeUpdates(withId id: String) -> AnyPublisher<Outcome?, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func getHighlightedMarkets() -> AnyPublisher<[HighlightMarket], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func getEventForMarketGroup(withId marketGroupId: String) -> AnyPublisher<Event, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func getEventDetails(eventId: String) -> AnyPublisher<Event, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func getEventSecundaryMarkets(eventId: String) -> AnyPublisher<Event, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func getEventLiveData(eventId: String) -> AnyPublisher<EventLiveData, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func subscribeEventMarkets(eventId: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func subscribeToEventAndSecondaryMarkets(withId id: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func getHighlightedLiveEvents(eventCount: Int, userId: String?) -> AnyPublisher<[Event], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    

    //
    //
    //
    func subscribeCompetitionMatches(forMarketGroupId marketGroupId: String) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {
        let endpoint: GomaAPIClient = GomaAPIClient.getEventsFromCompetition(competitionId: marketGroupId)
        let publisher: AnyPublisher<GomaModels.GomaPagedResponse<[GomaModels.Event]>, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ upcomingEventsResponse in
            let events = upcomingEventsResponse.data
            let liveSports = GomaModelMapper.eventsGroup(fromInternalEvents: events)
            return SubscribableContent.contentUpdate(content: [liveSports] )
        }).eraseToAnyPublisher()
    }

    func subscribeToMarketDetails(withId marketId: String, onEventId eventId: String) -> AnyPublisher<SubscribableContent<Market>, ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func subscribeEventDetails(eventId: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {
        return self.getEventDetails(eventId: eventId, marketLimit: nil)
            .map { event -> SubscribableContent<Event> in
                return SubscribableContent.contentUpdate(content: event )
            }
            .eraseToAnyPublisher()
    }

    func subscribeEventSummary(eventId: String) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func subscribeOutrightMarkets(forMarketGroupId marketGroupId: String) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }


    func subscribeToLiveDataUpdates(forEventWithId id: String) -> AnyPublisher<SubscribableContent<EventLiveData>, ServiceProviderError> {
        let endpointDetails = GomaAPIClient.getEventDetails(identifier: id)
        let publisherDetails: AnyPublisher<GomaModels.Event, ServiceProviderError> = self.connector.request(endpointDetails)

        let subscription = Subscription.init(contentType: ContentType.eventDetails,
                                             contentRoute: ContentRoute.eventDetails(eventId: id),
                                             sessionToken: "",
                                             unsubscriber: GomaDummyUnsubscriber())

        return publisherDetails.map({ eventDetails -> SubscribableContent in
            let mappedEventStatus = GomaModelMapper.eventStatus(fromInternalEvent: eventDetails.status)
            let eventLiveData = EventLiveData(id: eventDetails.identifier,
                                              homeScore: eventDetails.homeScore,
                                              awayScore: eventDetails.awayScore,
                                              matchTime: eventDetails.matchTime,
                                              status: mappedEventStatus, detailedScores: [:], activePlayerServing: nil)
            return SubscribableContent.contentUpdate(content: eventLiveData)
        })
        .prepend(SubscribableContent.connected(subscription: subscription))
        .eraseToAnyPublisher()
    }

    func getAvailableSportTypes(initialDate: Date?, endDate: Date?) -> AnyPublisher<[SportType], ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func getMarketGroups(forEvent event: Event) -> AnyPublisher<[MarketGroup], Never> {
        let defaultMarketGroup = [MarketGroup.init(type: "0",
                                                   id: "0",
                                                   groupKey: "All Markets",
                                                   translatedName: "All Markets",
                                                   position: 0,
                                                   isDefault: true,
                                                   numberOfMarkets: nil,
                                                   loaded: true,
                                                   markets: event.markets)]
        return Just(defaultMarketGroup).eraseToAnyPublisher()
    }

    func getFieldWidgetId(eventId: String) -> AnyPublisher<FieldWidget, ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func getFieldWidget(eventId: String, isDarkTheme: Bool?) -> AnyPublisher<FieldWidgetRenderDataType, ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func getStatsWidget(eventId: String, marketTypeName: String, isDarkTheme: Bool?) -> AnyPublisher<StatsWidgetRenderDataType, ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func getSportRegions(sportId: String) -> AnyPublisher<SportNodeInfo, ServiceProviderError> {
        let endpoint = GomaAPIClient.getRegions(sportCode: sportId)
        let publisher: AnyPublisher<[GomaModels.Region], ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ regions in
            let convertedRegions = GomaModelMapper.sportRegions(fromRegions: regions)
            let sportNodeInfo = SportNodeInfo(id: sportId, regionNodes: convertedRegions)
            return sportNodeInfo
        }).eraseToAnyPublisher()
    }

    func getRegionCompetitions(regionId: String) -> AnyPublisher<SportRegionInfo, ServiceProviderError> {
        let endpoint = GomaAPIClient.getCompetitions(regionId: regionId)
        let publisher: AnyPublisher<[GomaModels.Competition], ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ competitions in
            let convertedCompetitions = GomaModelMapper.sportCompetitions(fromCompetitions: competitions)
            return SportRegionInfo(id: regionId, name: "", competitionNodes: convertedCompetitions)
        }).eraseToAnyPublisher()
    }

    func getCompetitionMarketGroups(competitionId: String) -> AnyPublisher<SportCompetitionInfo, ServiceProviderError> {

        let endpoint = GomaAPIClient.getCompetitionDetails(identifier: competitionId)
        let publisher: AnyPublisher<GomaModels.Competition, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ competition in
            let group = SportCompetitionMarketGroup(id: competitionId, name: "main")
            let sportCompetitionInfo = SportCompetitionInfo(id: competition.identifier,
                                                            name: competition.name,
                                                            marketGroups: [group],
                                                            numberOutrightEvents: "0",
                                                            numberOutrightMarkets: "0")
            return sportCompetitionInfo
        }).eraseToAnyPublisher()

    }

    func getSearchEvents(query: String, resultLimit: String, page: String, isLive: Bool) -> AnyPublisher<EventsGroup, ServiceProviderError> {

        let endpoint = GomaAPIClient.search(query: query)

        let requestPublisher: AnyPublisher<GomaModels.GomaResponse<[GomaModels.Event]>, ServiceProviderError> = self.connector.request(endpoint)

        return requestPublisher.map( { gomaResponse in
            let events = gomaResponse.data

            let mappedEventsGroup = GomaModelMapper.eventsGroup(fromInternalEvents: events)

            return mappedEventsGroup
        })
        .eraseToAnyPublisher()

    }

    func getEventSummary(eventId: String, marketLimit: Int?) -> AnyPublisher<Event, ServiceProviderError> {

        let endpointDetails = GomaAPIClient.getEventDetails(identifier: eventId)
        let publisherDetails: AnyPublisher<GomaModels.Event, ServiceProviderError> = self.connector.request(endpointDetails)

        let endpointMarkets = GomaAPIClient.getEventMarkets(identifier: eventId, limit: marketLimit)
        let publisherMarkets: AnyPublisher<[GomaModels.Market], ServiceProviderError> = self.connector.request(endpointMarkets)

        return Publishers.CombineLatest(publisherDetails, publisherMarkets)
            .map({ eventDetails, markets -> Event in
                var event = eventDetails
                event.markets = markets
                return GomaModelMapper.event(fromInternalEvent: event)
        }).eraseToAnyPublisher()
//        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func getEventSummary(forMarketId marketId: String) -> AnyPublisher<Event, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getMarketInfo(marketId: String) -> AnyPublisher<Market, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getHomeSliders() -> AnyPublisher<BannerResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getAlertBanners() -> AnyPublisher<[AlertBanner], ServiceProviderError> {
        let endpoint = GomaAPIClient.getHomeAlerts
        let publisher: AnyPublisher<GomaModels.AlertBanner, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ banner in
            let alertBanners = [banner]
            let banners = alertBanners.filter({ $0.isActive == 1 })
            let convertedBanners = GomaModelMapper.alertBanners(fromAlertBanners: banners)
            return convertedBanners
        }).eraseToAnyPublisher()
    }

    func getNews() -> AnyPublisher<[News], ServiceProviderError> {
        let endpoint = GomaAPIClient.getNews

        let publisher: AnyPublisher<[GomaModels.News], ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ news in

            let mappedNews = news.map({
                return GomaModelMapper.news(fromNews: $0)
            })

            return mappedNews
        }).eraseToAnyPublisher()
    }

    func getPromotedEventGroupsPointers() -> AnyPublisher<[EventGroupPointer], ServiceProviderError> {
        let endpoint = GomaAPIClient.getPopularEventPointers
        let publisher: AnyPublisher<[GomaModels.EventsPointerGroup], ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ pointers in
            var eventGroupPointers: [EventGroupPointer] = []
            for pointer in pointers {
                let eventGroupPointer = EventGroupPointer(eventsPointers: pointer.events, marketGroupId: nil, title: pointer.title)
                eventGroupPointers.append(eventGroupPointer)
            }
            return eventGroupPointers
        }).eraseToAnyPublisher()

    }

    func getPromotedEventsGroups() -> AnyPublisher<[EventsGroup], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getPromotionalTopBanners() -> AnyPublisher<[PromotionalBanner], ServiceProviderError> {

        let endpoint = GomaAPIClient.getBanners
        let publisher: AnyPublisher<[GomaModels.Banner], ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ banners in
//            let banners = banners.filter({ $0.isActive == 1 })
            let convertedBanners = GomaModelMapper.promotionalBanners(fromBanners: banners)
            return convertedBanners
        }).eraseToAnyPublisher()
    }

    func getPromotionalSlidingTopEventsPointers() -> AnyPublisher<[EventMetadataPointer], ServiceProviderError> {
        let endpoint = GomaAPIClient.getEventsBanners
        let publisher: AnyPublisher<[GomaModels.EventMetadataPointer], ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ metadataPointers in
            return metadataPointers.map(GomaModelMapper.eventMetadataPointer(fromInternalEventMetadataPointer:))
        }).eraseToAnyPublisher()
    }

    func getPromotionalSlidingTopEvents() -> AnyPublisher<[Event], ServiceProviderError> {
        let endpoint = GomaAPIClient.getEventsBanners
        let publisher: AnyPublisher<[GomaModels.SportAssociatedEventBanner], ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ eventBanners in
            let convertedEvents = GomaModelMapper.events(fromSportAssociatedEventBanners: eventBanners)
            return convertedEvents
        }).eraseToAnyPublisher()
    }

    func getPromotionalTopStories() -> AnyPublisher<[PromotionalStory], ServiceProviderError> {

        let endpoint = GomaAPIClient.getStories
        let publisher: AnyPublisher<[GomaModels.Story], ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ stories in
            let convertedStories = GomaModelMapper.promotionalStories(fromStories: stories)
            return convertedStories
        }).eraseToAnyPublisher()

    }

    func getHighlightedBoostedEventsPointers() -> AnyPublisher<[EventMetadataPointer], ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func getHighlightedVisualImageEventsPointers() -> AnyPublisher<[EventMetadataPointer], ServiceProviderError> {
        let endpoint = GomaAPIClient.getHighlights
        let publisher: AnyPublisher<[GomaModels.EventMetadataPointer], ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ metadataPointers in
            return metadataPointers.map(GomaModelMapper.eventMetadataPointer(fromInternalEventMetadataPointer:))
        }).eraseToAnyPublisher()
    }

    func getHighlightedBoostedEvents() -> AnyPublisher<[Event], ServiceProviderError> {
        let endpoint = GomaAPIClient.getBoostedOddEvents
        let publisher: AnyPublisher<[GomaModels.BoostedEvent], ServiceProviderError> = self.connector.request(endpoint)
        return publisher.print("getBoostedEvents").map({ boostedOddEvents in

            let convertedEvents = boostedOddEvents.map({
                return GomaModelMapper.event(fromInternalBoostedEvent: $0)
            })

            return convertedEvents
        }).eraseToAnyPublisher()
//        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func getHighlightedVisualImageEvents() -> AnyPublisher<[Event], ServiceProviderError> {
        let endpoint = GomaAPIClient.getHighlights
        let publisher: AnyPublisher<[GomaModels.Event], ServiceProviderError> = self.connector.request(endpoint)
        return publisher.print("getHighlightedVisualImageEvents").map({ events in
            let convertedEvents = GomaModelMapper.events(fromInternalEvents: events)

            return convertedEvents
        }).eraseToAnyPublisher()
    }

    func getHeroGameEvent() -> AnyPublisher<[Event], ServiceProviderError> {

        let endpoint = GomaAPIClient.getHeroCards
        let publisher: AnyPublisher<[GomaModels.HeroCardEvents], ServiceProviderError> = self.connector.request(endpoint)
        return publisher.print("getHeroCards").map({ heroCardEvents in

            let convertedEvents = heroCardEvents.map({
                return GomaModelMapper.event(fromInternalHeroCardEvent: $0)
            })

            return convertedEvents
        }).eraseToAnyPublisher()

    }

    func getPromotedSports() -> AnyPublisher<[PromotedSport], ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func getPromotedEventsBySport() -> AnyPublisher<[SportType: [Event]], ServiceProviderError> {

        let endpoint = GomaAPIClient.getPopularEvents
        let publisher: AnyPublisher<[GomaModels.PopularEvent], ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ popularEvents in
//            let allEvents = popularEvents.flatMap { $0.events }
//
//            let convertedEvents = GomaModelMapper.events(fromInternalEvents: allEvents)
//
//            let groupedEvents: [SportType: [Event]] = convertedEvents.reduce(into: [:]) { dict, event in
//                dict[event.sport, default: []].append(event)
//            }

            var groupedEvents: [SportType: [Event]] = [:]

            for popularEvent in popularEvents {

                if popularEvent.events.isEmpty {
                    continue
                }

                let eventTitle = popularEvent.title ?? ""

                let convertedEvents = GomaModelMapper.events(fromInternalEvents: popularEvent.events)

                var newSportType = SportType(name: eventTitle, numericId: nil, alphaId: nil, iconId: nil, showEventCategory: false, numberEvents: popularEvent.events.count, numberOutrightEvents: 0, numberOutrightMarkets: 0, numberLiveEvents: 0)
                if let sportType = convertedEvents.first?.sport,
                   eventTitle == sportType.name {
                    newSportType = sportType
                }

                groupedEvents[newSportType] = convertedEvents
            }

            return groupedEvents
        }).eraseToAnyPublisher()

    }

    func getCashbackSuccessBanner() -> AnyPublisher<BannerResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func getTopCompetitionsPointers() -> AnyPublisher<[TopCompetitionPointer], ServiceProviderError> {

        let endpoint = GomaAPIClient.getFeaturedCompetitions
        let publisher: AnyPublisher<[GomaModels.Competition], ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ competitions in
            return GomaModelMapper.topCompetitionsPointers(fromCompetitions: competitions)
        }).eraseToAnyPublisher()

//        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func getTopCompetitions() -> AnyPublisher<[TopCompetition], ServiceProviderError> {
        let endpoint = GomaAPIClient.getFeaturedCompetitions
        let publisher: AnyPublisher<[GomaModels.Competition], ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ competitions in
            return GomaModelMapper.topCompetitions(fromCompetitions: competitions)
        }).eraseToAnyPublisher()
    }

    func getEventDetails(eventId: String, marketLimit: Int?) -> AnyPublisher<Event, ServiceProviderError> {

        let endpointDetails = GomaAPIClient.getEventDetails(identifier: eventId)
        let publisherDetails: AnyPublisher<GomaModels.Event, ServiceProviderError> = self.connector.request(endpointDetails)

        let endpointMarkets = GomaAPIClient.getEventMarkets(identifier: eventId, limit: marketLimit)
        let publisherMarkets: AnyPublisher<[GomaModels.Market], ServiceProviderError> = self.connector.request(endpointMarkets)

        return Publishers.CombineLatest(publisherDetails, publisherMarkets)
            .map({ eventDetails, markets -> Event in
                var event = eventDetails
                event.markets = markets
                return GomaModelMapper.event(fromInternalEvent: event)
        }).eraseToAnyPublisher()
    }

    func getFavoritesList() -> AnyPublisher<FavoritesListResponse, ServiceProviderError> {

        let endpoint = GomaAPIClient.getFavorites

        let publisher: AnyPublisher<GomaModels.GomaResponse<[GomaModels.FavoriteItem]>, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ favoritesResponse in

            let favoriteItems = favoritesResponse.data

            let favoritesList = favoriteItems.map({ favoriteItem in

                let favoriteList = GomaModelMapper.favoriteList(fromInternalFavoriteItem: favoriteItem)

                return favoriteList
            })

            let favoritesListResponse = FavoritesListResponse(favoritesList: favoritesList)

            return favoritesListResponse
        }).eraseToAnyPublisher()

    }

    func addFavoritesList(name: String) -> AnyPublisher<FavoritesListAddResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func deleteFavoritesList(listId: Int) -> AnyPublisher<FavoritesListDeleteResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func addFavoriteToList(listId: Int, eventId: String) -> AnyPublisher<FavoriteAddResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func getFavoritesFromList(listId: Int) -> AnyPublisher<FavoriteEventResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func deleteFavoriteFromList(eventId: Int) -> AnyPublisher<FavoritesListDeleteResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
    }

    func addFavoriteItem(favoriteId: Int, type: String) -> AnyPublisher<BasicMessageResponse, ServiceProviderError> {

        let endpoint = GomaAPIClient.addFavorite(favoriteId: favoriteId, type: type)

        let publisher: AnyPublisher<BasicMessageResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ basicMessageResponse in

            return basicMessageResponse
        }).eraseToAnyPublisher()

    }

    func deleteFavoriteItem(favoriteId: Int, type: String) -> AnyPublisher<BasicMessageResponse, ServiceProviderError> {

        let endpoint = GomaAPIClient.deleteFavorite(favoriteId: favoriteId, type: type)

        let publisher: AnyPublisher<BasicMessageResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.map({ basicMessageResponse in

            return basicMessageResponse
        }).eraseToAnyPublisher()
    }

    func getDatesFilter(timeRange: String) -> [Date] {
        // TODO: Implement this func
        return []
    }

    func getFeaturedTips(page: Int?, limit: Int?, topTips: Bool?, followersTips: Bool?, friendsTips: Bool?, userId: String?, homeTips: Bool?) -> AnyPublisher<FeaturedTips, ServiceProviderError> {
        let endpoint = GomaAPIClient.getFeaturedTips(page: page, limit: limit, topTips: topTips, followersTips: followersTips, friendsTips: friendsTips, userId: userId, homeTips: homeTips)

        let publisher: AnyPublisher<GomaModels.FeaturedTipsPagedResponse, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ featuredTipsResponse in
            return GomaModelMapper.featuredTips(fromInternaFeaturedTips: featuredTipsResponse.featuredTips)
        }).eraseToAnyPublisher()
    }

}

extension GomaAPIProvider: BettingProvider {

    func getBetHistory(pageIndex: Int) -> AnyPublisher<BettingHistory, ServiceProviderError> {

        let endpoint = GomaAPIClient.getMyTickets(states: nil, limit: "20", page: "\(pageIndex)")

        let publisher: AnyPublisher<GomaModels.MyTicketsResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher
            .map(GomaModelMapper.bettingHistory(fromMyTicketsResponse:))
            .eraseToAnyPublisher()
    }

    func getBetDetails(identifier: String) -> AnyPublisher<Bet, ServiceProviderError> {
        let endpoint = GomaAPIClient.getTicketDetails(betId: identifier)
        let publisher: AnyPublisher<GomaModels.MyTicket, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .map(GomaModelMapper.bet(fromMyTicket:))
            .eraseToAnyPublisher()
    }

    func getOpenBetsHistory(pageIndex: Int, startDate: String?, endDate: String?) -> AnyPublisher<BettingHistory, ServiceProviderError> {
        let endpoint = GomaAPIClient.getMyTickets(states: [GomaModels.MyTicketStatus.pending], limit: "20", page: "\(pageIndex)")
        let publisher: AnyPublisher<GomaModels.MyTicketsResponse, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .map(GomaModelMapper.bettingHistory(fromMyTicketsResponse:))
            .eraseToAnyPublisher()
    }

    func getResolvedBetsHistory(pageIndex: Int, startDate: String?, endDate: String?) -> AnyPublisher<BettingHistory, ServiceProviderError> {
        let endpoint = GomaAPIClient.getMyTickets(states: [GomaModels.MyTicketStatus.won, GomaModels.MyTicketStatus.lost, GomaModels.MyTicketStatus.push], limit: "20", page: "\(pageIndex)")
        let publisher: AnyPublisher<GomaModels.MyTicketsResponse, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .map(GomaModelMapper.bettingHistory(fromMyTicketsResponse:))
            .eraseToAnyPublisher()
    }

    func getWonBetsHistory(pageIndex: Int, startDate: String?, endDate: String?) -> AnyPublisher<BettingHistory, ServiceProviderError> {
        let endpoint = GomaAPIClient.getMyTickets(states: [GomaModels.MyTicketStatus.won], limit: "20", page: "\(pageIndex)")
        let publisher: AnyPublisher<GomaModels.MyTicketsResponse, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .map(GomaModelMapper.bettingHistory(fromMyTicketsResponse:))
            .eraseToAnyPublisher()
    }

    func getAllowedBetTypes(withBetTicketSelections betTicketSelections: [BetTicketSelection]) -> AnyPublisher<[BetType], ServiceProviderError> {
        var argumentSelections: [GomaAPIClient.ArgumentModels.BetSelection] = []
        for betTicketSelection in betTicketSelections {
            if let eventId = betTicketSelection.eventId, let outcomeId = betTicketSelection.outcomeId {
                let betSelection = GomaAPIClient.ArgumentModels.BetSelection(eventId: eventId, outcomeId: outcomeId)
                argumentSelections.append(betSelection)
            }
        }
        let endpoint = GomaAPIClient.getAllowedBetTypes(selections: argumentSelections)
        let publisher: AnyPublisher<GomaModels.AllowedBets, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ allowedBetsResponse in
            return GomaModelMapper.betTypes(fromGomaBetTypes: allowedBetsResponse.allowedTypes)
        }).eraseToAnyPublisher()
    }

    func calculatePotentialReturn(forBetTicket betTicket: BetTicket) -> AnyPublisher<BetslipPotentialReturn, ServiceProviderError> {
        var argumentSelections: [GomaAPIClient.ArgumentModels.BetSelection] = []
        for betTicketSelection in betTicket.tickets {
            if let eventId = betTicketSelection.eventId, let outcomeId = betTicketSelection.outcomeId {
                let betSelection = GomaAPIClient.ArgumentModels.BetSelection(eventId: eventId, outcomeId: outcomeId)
                argumentSelections.append(betSelection)
            }
        }
        let betType = GomaModelMapper.gomaBetType(fromBetGroupingType: betTicket.betGroupingType)

        let endpoint = GomaAPIClient.getCalculatePossibleBetResult(stake: betTicket.globalStake ?? 0.0, type: betType, selections: argumentSelections)
        let publisher: AnyPublisher<GomaModels.BetslipPotentialReturn, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.map({ betslipPotentialReturn in
            let betslipPotentialReturn = BetslipPotentialReturn(potentialReturn: betslipPotentialReturn.possibleWinnings,
                                          totalStake: betslipPotentialReturn.stake,
                                          numberOfBets: betslipPotentialReturn.selections.count,
                                          totalOdd: betslipPotentialReturn.odds)
            return betslipPotentialReturn
        }).eraseToAnyPublisher()
    }

    func placeBets(betTickets: [BetTicket], useFreebetBalance: Bool) -> AnyPublisher<PlacedBetsResponse, ServiceProviderError> {

        let publishers = betTickets.map { betTicket in
            let endpoint = GomaAPIClient.placeBetTicket(betTicket: betTicket, useCashback: useFreebetBalance)
            let publisher: AnyPublisher<GomaModels.PlaceBetTicketResponse, ServiceProviderError> = self.connector.request(endpoint)
            return publisher
                .map { Result<GomaModels.PlaceBetTicketResponse, ServiceProviderError>.success($0) }
                .catch { Just<Result<GomaModels.PlaceBetTicketResponse, ServiceProviderError>>(.failure($0)) }
                .setFailureType(to: ServiceProviderError.self)
                .eraseToAnyPublisher()
        }

        return Publishers.MergeMany(publishers)
            .collect()
            .flatMap({ (results: [Result<GomaModels.PlaceBetTicketResponse, ServiceProviderError>])
                -> AnyPublisher<PlacedBetsResponse, ServiceProviderError> in

                var validResults: [GomaModels.PlaceBetTicketResponse] = []
                var errors: [ServiceProviderError] = []

                for result in results {
                    switch result {
                    case .success(let success):
                        validResults.append(success)
                    case .failure(let failure):
                        errors.append(failure)
                    }
                }

                let placeBetResponse = GomaModelMapper.placedBetsResponse(fromPlaceBetTicketsResponses: validResults)

                if validResults.isEmpty {
                    if let firstError = errors.first {
                        return Fail(outputType: PlacedBetsResponse.self, failure: firstError).eraseToAnyPublisher()
                    }
                    else {
                        return Fail(outputType: PlacedBetsResponse.self, failure: ServiceProviderError.unknown).eraseToAnyPublisher()
                    }
                } else {
                    return Just(placeBetResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                }
            })
            .eraseToAnyPublisher()
    }

    func calculateCashout(betId: String, stakeValue: String?) -> AnyPublisher<Cashout, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func cashoutBet(betId: String, cashoutValue: Double, stakeValue: Double?) -> AnyPublisher<CashoutResult, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func calculateCashback(forBetTicket betTicket: BetTicket) -> AnyPublisher<CashbackResult, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getBetslipSettings() -> AnyPublisher<BetslipSettings?, Never> {
        // TODO: Implement this func
        return Just(nil).eraseToAnyPublisher()
    }

    func updateBetslipSettings(_ betslipSettings: BetslipSettings) -> AnyPublisher<Bool, Never> {
        // TODO: Implement this func
        return Just(false).eraseToAnyPublisher()
    }

    func getFreebet() -> AnyPublisher<FreebetBalance, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getSharedTicket(betslipId: String) -> AnyPublisher<SharedTicketResponse, ServiceProviderError> {

        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getTicketSelection(ticketSelectionId: String) -> AnyPublisher<TicketSelection, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func updateTicketOdds(betId: String) -> AnyPublisher<Bet, ServiceProviderError> {
        let endpoint = GomaAPIClient.updateTicketOdds(betId: betId)
        let publisher: AnyPublisher<GomaModels.MyTicket, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .map(GomaModelMapper.bet(fromMyTicket:))
            .eraseToAnyPublisher()
    }

    func getTicketQRCode(betId: String) -> AnyPublisher<BetQRCode, ServiceProviderError> {
        let endpoint = GomaAPIClient.getTicketQRCode(betId: betId)
        let publisher: AnyPublisher<GomaModels.MyTicketQRCode, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .map(GomaModelMapper.betQRCode(fromMyTicketQRCode:))
            .eraseToAnyPublisher()
    }

    func getSocialSharedTicket(shareId: String) -> AnyPublisher<Bet, ServiceProviderError> {

        let endpoint = GomaAPIClient.getSharedTicket(sharedId: shareId)

        let publisher: AnyPublisher<GomaModels.MyTicket, ServiceProviderError> = self.connector.request(endpoint)
        return publisher.print("getSharedTicket").map({ sharedTicket in

            let mappedBet = GomaModelMapper.bet(fromMyTicket: sharedTicket)

            return mappedBet
        }).eraseToAnyPublisher()
    }

    func deleteTicket(betId: String) -> AnyPublisher<Bool, ServiceProviderError> {
        let endpoint = GomaAPIClient.deleteTicket(betId: betId)
        let publisher: AnyPublisher<Bool, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
    }

    func updateTicket(betId: String, betTicket: BetTicket) -> AnyPublisher<PlacedBetsResponse, ServiceProviderError> {
        let endpoint = GomaAPIClient.updateTicket(betId: betId, betTicket: betTicket)
        let publisher: AnyPublisher<GomaModels.MyTicket, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .map(GomaModelMapper.placedBetsResponse(fromMyTicket:))
            .eraseToAnyPublisher()
    }
    
    func calculateBetBuilderPotentialReturn(forBetTicket betTicket: BetTicket) -> AnyPublisher<BetBuilderPotentialReturn, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func placeBetBuilderBet(betTicket: BetTicket, calculatedOdd: Double) -> AnyPublisher<PlacedBetsResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func confirmBoostedBet(identifier: String) -> AnyPublisher<Bool, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func rejectBoostedBet(identifier: String) -> AnyPublisher<Bool, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func allowedCashoutBetIds() -> AnyPublisher<[String], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Goma/GomaConnector.swift
````swift
//
//  File.swift
//
//
//  Created by Ruben Roques on 18/12/2023.
//

import Foundation
import Combine

struct GomaSessionAccessToken: Codable {
    var hash: String
    var type: String
    
    enum CodingKeys: String, CodingKey {
        case hash = "token"
        case type = "type"
    }
    
}

struct GomaUserCredentials: Codable {
    var username: String
    var password: String
}

class GomaConnector: Connector {
    
    var connectionStateSubject: CurrentValueSubject<ConnectorState, Never> = .init(.connected)
    var connectionStatePublisher: AnyPublisher<ConnectorState, Never> {
        return connectionStateSubject.eraseToAnyPublisher()
    }
    
    var authenticator: GomaAPIAuthenticator
    private let session: URLSession
    private let decoder: JSONDecoder
    
    init(session: URLSession = URLSession(configuration: URLSessionConfiguration.default),
         decoder: JSONDecoder = JSONDecoder(),
         deviceIdentifier: String) {
        
        self.session = session
        self.decoder = decoder
        
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss" // 2003-12-31 00:00:00
        self.decoder.dateDecodingStrategy = .formatted(dateFormatter)
        
        self.authenticator = GomaAPIAuthenticator(deviceIdentifier: deviceIdentifier)
    }
    
    func clearToken() {
        self.authenticator.updateToken(newToken: nil)
    }
    
    func updateToken(newToken: String) {
        self.authenticator.updateToken(newToken: newToken)
    }
    
    func updateCredentials(credentials: GomaUserCredentials?) {
        self.authenticator.updateCredentials(credentials: credentials)
    }
    
    func getPushNotificationToken() -> String? {
        return self.authenticator.pushNotificationsToken
    }
    func updatePushNotificationToken(newToken: String?) {
        self.authenticator.updatePushNotificationToken(newToken: newToken)
    }
    
    func request<T: Codable>(_ endpoint: Endpoint) -> AnyPublisher<T, ServiceProviderError> {
        
        guard
            var request = endpoint.request()
        else {
            let error = ServiceProviderError.invalidRequestFormat
            return Fail<T, ServiceProviderError>(error: error).eraseToAnyPublisher()
        }
        
        return self.authenticator.publisherWithValidToken()
            .flatMap { token -> AnyPublisher<Data, Error> in
                request.setValue("Bearer \(token.hash)", forHTTPHeaderField: "Authorization")
                return self.publisher(for: request, token: token).eraseToAnyPublisher()
            }
            .tryCatch { error -> AnyPublisher<Data, Error> in
                // We only catch this error if it's a unauthorized
                guard
                    let serviceError = error as? ServiceProviderError,
                    serviceError == .unauthorized
                else {
                    throw error
                }
                // We only catch this error if it's an unauthorized
                return self.authenticator.publisherWithValidToken(forceRefresh: true)
                    .flatMap { token -> AnyPublisher<Data, Error> in
                        // We can now use this new token to authenticate the second attempt at making this request
                        request.setValue("Bearer \(token.hash)", forHTTPHeaderField: "Authorization")
                        return self.publisher(for: request, token: token).eraseToAnyPublisher()
                    }
                    .eraseToAnyPublisher()
            }
            .tryMap({ data in
                do {
                    return try self.decoder.decode(T.self, from: data)
                } catch let error as DecodingError {
                    // Handle DecodingError by printing the expected and received JSON
                    print("Decoding Error: \(error)")
                    print("Received JSON: \(String(data: data, encoding: .utf8) ?? "Invalid JSON")")
                    throw error
                } catch {
                    // Propagate other errors
                    throw error
                }
            })
            .mapError({ error -> ServiceProviderError in
                if let typedError = error as? ServiceProviderError {
                    return typedError
                }
                else if let decodingError = error as? DecodingError {
                    let errorMessage = "\(decodingError)"
                    return ServiceProviderError.decodingError(message: errorMessage)
                }
                return ServiceProviderError.invalidResponse
            })
            .eraseToAnyPublisher()
    }
    
    private func publisher(for url: URL, token: GomaSessionAccessToken?) -> AnyPublisher<Data, Error> {
        self.publisher(for: URLRequest(url: url), token: token)
    }
    
    private func publisher(for request: URLRequest, token: GomaSessionAccessToken?) -> AnyPublisher<Data, Error> {
        
        var request = request
        if let token = token {
            request.setValue("Bearer \(token.hash)", forHTTPHeaderField: "Authorization")
        }
        else {
            print("Error Authorization token not found.")
        }
        
        print("GomaGaming URL Request: \n", request.cURL(pretty: true), "\n==========================================")
        
        return self.session.dataTaskPublisher(for: request)
            .tryMap { urlSessionOutput in
                guard let httpResponse = urlSessionOutput.response as? HTTPURLResponse else {
                    throw ServiceProviderError.invalidResponse
                }
                switch httpResponse.statusCode {
                case 200...299:
                    return urlSessionOutput.data
                case 401:
                    throw ServiceProviderError.unauthorized
                case 403:
                    throw ServiceProviderError.forbidden
                case 404:
                    if let messageResponse = try? JSONDecoder().decode(BasicMessageResponse.self, from: urlSessionOutput.data) {
                        throw ServiceProviderError.errorMessage(message: messageResponse.message)
                    }
                    throw ServiceProviderError.unknown
                case 422:
                    if let messageResponse = try? JSONDecoder().decode(BasicMessageResponse.self, from: urlSessionOutput.data) {
                        if messageResponse.message.lowercased().contains("does not allow selections") {
                            throw ServiceProviderError.notPlacedBet(message: messageResponse.message)
                        }
                        else {
                            throw ServiceProviderError.errorMessage(message: messageResponse.message)
                        }
                    }
                    throw ServiceProviderError.unknown
                case 500:
                    throw ServiceProviderError.internalServerError
                default:
                    throw ServiceProviderError.unknown
                }
            }
            .eraseToAnyPublisher()
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Goma/GomaDummyUnsubscriber.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 01/03/2024.
//

import Foundation

class GomaDummyUnsubscriber: UnsubscriptionController {
    func unsubscribe(subscription: Subscription) {
        
    }
}
````

## File: Sources/ServicesProvider/Providers/Goma/GomaEventPaginator.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 23/02/2024.
//

import Foundation
import Combine

class GomaEventPaginator<T: Equatable> {
    
    var eventsGroupPublisher: AnyPublisher<[T], ServiceProviderError> {
        self.eventsGroupSubject.eraseToAnyPublisher()
    }
    
    var hasNextPagePublisher: AnyPublisher<Bool, ServiceProviderError> {
        self.hasNextPageSubject.eraseToAnyPublisher()
    }
    
    private var eventsGroupSubject = CurrentValueSubject<[T], ServiceProviderError>([])
    private var hasNextPageSubject = CurrentValueSubject<Bool, ServiceProviderError>(true)
    
    private let paginatorRequest: (Int) -> AnyPublisher<[T], ServiceProviderError>

    private var initialPage: Int
    private var currentPage: Int
    private var eventsPerPage: Int

    private var needsRefresh: Bool
    private var refreshTimer: Timer?

    private var cancellables = Set<AnyCancellable>()

    init(initialPage: Int = 1, 
         eventsPerPage: Int = 10,
         needsRefresh: Bool,
         request: @escaping (Int) -> AnyPublisher<[T], ServiceProviderError>) {
        
        self.paginatorRequest = request
        self.initialPage = initialPage
        self.currentPage = initialPage

        self.eventsPerPage = eventsPerPage
        self.needsRefresh = needsRefresh
        
        if self.needsRefresh {
            self.startRefreshTimer()
        }
        
        print("[GomaEventPaginator] init")
    }
    
    deinit {
        self.refreshTimer?.invalidate()
    }
    
    func requestInitialPage() {
        self.currentPage = 1
        self.eventsGroupSubject.send([])
        self.hasNextPageSubject.send(true)
        self.triggerRequest()
    }
    
    func requestNextPage() {
        self.currentPage = self.currentPage + 1
        self.triggerRequest()
    }
    
    private func triggerRequest() {
        self.paginatorRequest(self.currentPage)
            .sink { [weak self] completion in
                switch completion {
                case .finished:
                    // We should keep eventsGroupSubject alive for the next pages
                    break
                case .failure(let error):
                    self?.eventsGroupSubject.send(completion: .failure(error))
                    self?.hasNextPageSubject.send(completion: .failure(error))
                }
            } receiveValue: { [weak self] events in
                let hasNextPage = events.count >= (self?.eventsPerPage ?? 0)
                self?.hasNextPageSubject.send(hasNextPage)
                self?.eventsGroupSubject.value.append(contentsOf: events)
            }
            .store(in: &self.cancellables)
    }
    
    private func startRefreshTimer() {
        self.refreshTimer = Timer.scheduledTimer(withTimeInterval: 30, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            print("[GomaEventPaginator] Refresh timer triggered")

            self.refreshContents()
        }
    }
    
    func refreshContents() {
        let refreshPublishers = [self.initialPage ... self.currentPage].map({ index in
            self.paginatorRequest(self.currentPage)
                .replaceError(with: [])
        })
        
        Publishers.MergeMany(refreshPublishers)
            .sink { completion in
                print("[GomaEventPaginator] MergeMany completion: \(completion)")
            } receiveValue: { [weak self] events in
                let expectedEvents = (self?.currentPage ?? 0) * (self?.eventsPerPage ?? 0)
                let hasNextPage = events.count >= expectedEvents
                
                print("[GomaEventPaginator] Received \(events.count) events, expected \(expectedEvents) events")

                self?.hasNextPageSubject.send(hasNextPage)
                self?.eventsGroupSubject.send(events)
            }
            .store(in: &self.cancellables)

    }
    
}
````

## File: Sources/ServicesProvider/Providers/Goma/GomaManagedContentProvider.swift
````swift
//
//  GomaManagedContentProvider.swift
//
//
//  Created on: May 15, 2024
//

import Foundation
import Combine

/// Implementation of ManagedContentProvider for the Goma API
class GomaManagedContentProvider: ManagedContentProvider {
    
    // MARK: - Properties
    var connectionStatePublisher: AnyPublisher<ConnectorState, Never> {
        connectionStateSubject.eraseToAnyPublisher()
    }

    private let connectionStateSubject = CurrentValueSubject<ConnectorState, Never>(.disconnected)
    private let gomaAPIAuthenticator: GomaAPIAuthenticator
    private var cancellables = Set<AnyCancellable>()

    // MARK: - Initialization

    init(gomaAPIAuthenticator: GomaAPIAuthenticator) {
        self.gomaAPIAuthenticator = gomaAPIAuthenticator

    }

    // MARK: - API Request Helper

    private func request<T: Decodable>(_ endpoint: GomaPromotionsAPIClient) -> AnyPublisher<T, ServiceProviderError> {
        // This is a simplified placeholder for API requests
        // In a real implementation, you would handle authentication and network requests here
        return Fail(error: ServiceProviderError.notSupportedForProvider)
            .eraseToAnyPublisher()
    }

    // MARK: - ManagedContentProvider Implementation

    func getHomeTemplate() -> AnyPublisher<HomeTemplate, ServiceProviderError> {
        fatalError("")
    }

    func getAlertBanner() -> AnyPublisher<AlertBanner?, ServiceProviderError> {
        fatalError("")
    }

    func getBanners() -> AnyPublisher<[Banner], ServiceProviderError> {
        fatalError("")
    }

    func getSportBanners() -> AnyPublisher<[SportBanner], ServiceProviderError> {
        fatalError("")
    }

    func getBoostedOddsBanners() -> AnyPublisher<[BoostedOddsBanner], ServiceProviderError> {
        fatalError("")
    }

    func getHeroCards() -> AnyPublisher<[HeroCard], ServiceProviderError> {
        fatalError("")
    }

    func getStories() -> AnyPublisher<[Story], ServiceProviderError> {
        fatalError("")
    }

    func getNews(pageIndex: Int, pageSize: Int) -> AnyPublisher<[NewsItem], ServiceProviderError> {
        fatalError("")
    }

    func getProChoices() -> AnyPublisher<[ProChoice], ServiceProviderError> {
        fatalError("")
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Betting-Poseidon/BettingAPIClient.swift
````swift
//
//  BettingAPIClient.swift
//  
//
//  Created by Ruben Roques on 11/11/2022.
//

import Foundation

enum BettingAPIClient {
    case betHistory(page: Int, startDate: String?, endDate: String?, betState: [SportRadarModels.BetState]?, betResult: [SportRadarModels.BetResult]?, pageSize: Int)
    case betDetails(identifier: String)
    case calculateReturns(betTicket: BetTicket)
    case getAllowedBetTypes(betTicketSelections: [BetTicketSelection])
    case placeBets(betTickets: [BetTicket], useFreebetBalance: Bool)
    
    case calculateBetBuilderReturn(betTicket: BetTicket)
    case placeBetBuilderBet(betTicket: BetTicket, calculatedOdd: Double)
    
    case confirmBoostedBet(identifier: String)
    case rejectBoostedBet(identifier: String)
    
    case calculateCashout(betId: String, stakeValue: String?)
    case cashoutBet(betId: String, cashoutValue: Double, stakeValue: Double?)
    
    case getAllowedCashoutBetIds
    
    case getBetslipSettings
    
    case updateBetslipSettings(oddChange: BetslipOddChangeSetting)
    case updateBetslipSettingsPreMatch(oddChange: BetslipOddChangeSetting)
    case updateBetslipSettingsRunning(oddChange: BetslipOddChangeSetting)
    
    case getFreebetBalance
    case getSharedTicket(betslipId: String)
    case getTicketSelection(ticketSelectionId: String)
    case calculateCashback(betTicket: BetTicket)
}

extension BettingAPIClient: Endpoint {
    
    var endpoint: String {
        switch self {
        case .betHistory:
            return "/api/betting/fo/bets"
        case .betDetails(let identifier):
            return "/api/betting/fo/bets/\(identifier)"
        case .calculateReturns:
            return "/api/betting/fo/bet/calculate"
        case .getAllowedBetTypes:
            return "/api/betting/fo/allowedBetTypesWithCalculation"
        case .placeBets:
            return "/api/betting/fo/betslip"
            
        case .calculateBetBuilderReturn:
            return "/api/custom-bet/v1/calculate"
        case .placeBetBuilderBet:
            return "/api/custom-bet/v1/placecustombet"
            
        case .confirmBoostedBet(let identifier):
            return "/api/betting/fo/betslip/\(identifier)/confirm"
        case .rejectBoostedBet(let identifier):
            return "/api/betting/fo/betslip/\(identifier)/reject"
            
        case .calculateCashout(let betId, _):
            return "/api/cashout/fo/cashout/\(betId)/calculate"
        case .cashoutBet(let betId, _, _):
            return "/api/cashout/fo/cashout/\(betId)"
        case .getAllowedCashoutBetIds:
            return "/api/cashout/fo/cashout/allowedBetIds"
            
        case .getBetslipSettings:
            return "/api/betting/fo/attribute/getAll"
        case .updateBetslipSettings:
            return "/api/betting/fo/attribute/update"
        case .updateBetslipSettingsRunning:
            return "/api/betting/fo/attribute/update"
        case .updateBetslipSettingsPreMatch:
            return "/api/betting/fo/attribute/update"
            
        case .getFreebetBalance:
            return "/api/betting/fo/freeBalance"
        case .getSharedTicket(let betslipId):
            return "/api/betting/fo/bookbetslip/\(betslipId)"
        case .getTicketSelection:
            return "/services/content/get"
        case .calculateCashback:
            return "/api/special-offer-calculator/v1/calculateSpecialOffers"
        }
    }
    
    var query: [URLQueryItem]? {
        switch self {
        case .betHistory(let page, let startDate, let endDate, let betStates, let betOutcomes, let pageSize):
            
//            let dateFormatter = DateFormatter()
//            dateFormatter.dateFormat = "yyyy-MM-dd'T'hh:mm:ss.SSS"
//
            var query: [URLQueryItem] = []
//
//            if let startDate = startDate {
//                query.append(URLQueryItem(name: "from", value: dateFormatter.string(from: startDate)))
//            }
//            if let endDate = endDate {
//                query.append(URLQueryItem(name: "to", value: dateFormatter.string(from: endDate)))
//            }

            if let startDate = startDate {
                query.append(URLQueryItem(name: "from", value: startDate))
            }

            if let endDate = endDate {
                query.append(URLQueryItem(name: "to", value: endDate))
            }
            
            if let betStates = betStates?.map(\.rawValue).joined(separator: ",") {
                query.append(URLQueryItem(name: "betStateTypes", value: betStates))
            }

            if let betOutcomes = betOutcomes?.map(\.rawValue).joined(separator: ",") {
                query.append(URLQueryItem(name: "betOutcomes", value: betOutcomes))
            }
            else {
                query.append(URLQueryItem(name: "betOutcomes", value: "NotSpecified"))
            }

            query.append(URLQueryItem(name: "orderBy", value: "0"))
            query.append(URLQueryItem(name: "orderDesc", value: "true"))
            
            query.append(URLQueryItem(name: "pageSize", value: "\(pageSize)"))

            query.append(URLQueryItem(name: "pageNumber", value: "\(page)"))

            return query
        case .betDetails:
            return nil
        case .calculateReturns:
            return nil
        case .getAllowedBetTypes:
            return nil
        case .placeBets:
            return nil
            
        case .calculateBetBuilderReturn:
            return nil
        case .placeBetBuilderBet:
            return nil
            
        case .confirmBoostedBet:
            return nil
        case .rejectBoostedBet:
            return nil
            
        case .calculateCashout:
            return nil
        case .cashoutBet:
            return nil
        case .getAllowedCashoutBetIds:
            return nil
            
        case .getBetslipSettings:
            return nil
        case .updateBetslipSettings:
            return nil
        
        case .updateBetslipSettingsRunning:
            return nil
        case .updateBetslipSettingsPreMatch:
            return nil
            
        case .getFreebetBalance:
            return nil
        case .getSharedTicket:
            return nil
        case .getTicketSelection:
            return nil
        case .calculateCashback:
            return nil
        }
    }
    
    var body: Data? {
        switch self {
        case .betHistory:
            return nil
        case .betDetails:
            return nil
        case .calculateReturns(let betTicket):
            return Self.createBetLegsJSONBody(fromBetTicket: betTicket)

            // ===================================================
        case .getAllowedBetTypes(let betTicketSelections):

            var betLegs: [String] = []

            for betTicketSelection in betTicketSelections {
                let priceDown: String
                let priceUp: String

                switch betTicketSelection.odd {
                case .fraction(let numerator, let denominator):
                    priceUp = "\(numerator)"
                    priceDown = "\(denominator)"
                case .decimal:
                    priceUp = ""
                    priceDown = ""
                }

                let leg  =
                """
                   {
                     "eachWayPlaceTerms": "",
                     "eachWayReduction": "",
                     "handicap": "",
                     "idFOPriceType": "CP",
                     "idFOSelection": "\(betTicketSelection.identifier)",
                     "isTrap": "",
                     "lowerBand": "",
                     "priceDown": "\(priceDown)",
                     "priceUp": "\(priceUp)",
                     "systemTag": "",
                     "upperBand": ""
                   }
                """
                betLegs.append(leg)
            }
            let body = """
                       {
                         "betLegs": [
                            \(betLegs.joined(separator: ","))
                         ],
                         "idFOBetType": "",
                         "winStake": 0,
                         "isPool": false
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data

        case .placeBets(let betTickets, let useFreebetBalance):

            var betsArray: [String] = []
            for ticket in betTickets {
                var legsStringArray: [String] = []
                for selection in ticket.tickets {
                    let priceDown: String
                    let priceUp: String

                    switch selection.odd {
                    case .fraction(let numerator, let denominator):
                        priceUp = "\(numerator)"
                        priceDown = "\(denominator)"
                    case .decimal:
                        priceUp = ""
                        priceDown = ""
                    }

                    legsStringArray.append(
                    """
                    {
                      "eachWayPlaceTerms": "",
                      "eachWayReduction": "",
                      "handicap": "",
                      "idFOPriceType": "CP",
                      "idFOSelection": "\(selection.identifier)",
                      "isTrap": "",
                      "lowerBand": "",
                      "priceDown": "\(priceDown)",
                      "priceUp": "\(priceUp)",
                      "systemTag": "",
                      "upperBand": ""
                    }
                    """)
                }

                let legsString = legsStringArray.joined(separator: ",")
                betsArray.append(
                    """
                    {
                        "betLegs": [ \(legsString) ],
                        "idFOBetType": "\(ticket.betGroupingType.identifier)",
                        "pool": false,
                        "winStake": \(ticket.globalStake ?? 0.0)
                    }
                    """)
            }

            let betsString = betsArray.joined(separator: ",")

            let body = """
                       {
                         "bets": [\(betsString)],
                         "useAutoAcceptance": true,
                         "free": \(useFreebetBalance)
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data

            //
        // BetBuidler
        //
        case .calculateBetBuilderReturn(let betTicket):
            let betAmount = (betTicket.globalStake ?? 0.0)
            let betTicketSelectionsIds = betTicket.tickets.map({ "\"" + $0.identifier + "\"" }).joined(separator: ",")
            let body = """
                       {
                         "idFOSelections": [\(betTicketSelectionsIds)],
                         "stakeAmount": \(betAmount)
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
            
        case .placeBetBuilderBet(let betTicket, let odd):
            let betAmount = (betTicket.globalStake ?? 0.0)
            let betTicketSelectionsIds = betTicket.tickets.map({ "\"" + $0.identifier + "\"" }).joined(separator: ",")
            let body = """
                       {
                         "idFOSelections": [\(betTicketSelectionsIds)],
                         "stakeAmount": \(betAmount),
                         "free" : 0,
                         "useAutoAcceptance" : true,
                         "calculatedOdds" : \(odd)
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
            
            
        case .confirmBoostedBet:
            let body = """
                        {
                            "betStatus": {
                                "state": 1,
                                "detailedState": 66,
                                "statusCode": null,
                                "statusText": null
                            },
                            "securityCode": ""
                        }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
        case .rejectBoostedBet:
            let data = "{}".data(using: String.Encoding.utf8)!
            return data
            
        //
        case .calculateCashout(_, let stakeValue):

            if let stakeValue {
                let body = """
                           {
                             "stakeValue": \(stakeValue)
                           }
                           """
                let data = body.data(using: String.Encoding.utf8)!
                return data
            }
            else {
                return nil
            }
            
        case .getAllowedCashoutBetIds:
            return nil

        case .cashoutBet( _, let cashoutValue, let stakeValue):
            if let stakeValue {
                let body = """
                       {
                         "expectedValue": \(cashoutValue),
                         "stakeValue": \(stakeValue)
                       }
                       """
                let data = body.data(using: String.Encoding.utf8)!
                return data
            }

            let body = """
                   {
                     "expectedValue": \(cashoutValue)
                   }
                   """
            let data = body.data(using: String.Encoding.utf8)!
            return data

        case .getBetslipSettings:
            return nil
        case .updateBetslipSettings(let oddChange):

            var acceptingReofferStringValue = "none"
            switch oddChange {
            case .none:
                acceptingReofferStringValue = "none"
            case .higher:
                acceptingReofferStringValue = "higher"
            }
            
            let body = """
                       {
                       "id": 648,
                       "name": "OddsChange",
                       "value": "\(acceptingReofferStringValue)"}
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data

        case .updateBetslipSettingsRunning(let oddChange):

            var acceptingReofferStringValue = "none"
            switch oddChange {
            case .none:
                acceptingReofferStringValue = "none"
            case .higher:
                acceptingReofferStringValue = "higher"
            }
            
            let body = """
                       {
                       "id": 668,
                       "name": "oddsChangePreMatch",
                       "value": "\(acceptingReofferStringValue)"}
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
        case .updateBetslipSettingsPreMatch(let oddChange):

            var acceptingReofferStringValue = "none"
            switch oddChange {
            case .none:
                acceptingReofferStringValue = "none"
            case .higher:
                acceptingReofferStringValue = "higher"
            }
            
            let body = """
                       {
                       "id": 667,
                       "name": "oddsChangeInRunning",
                       "value": "\(acceptingReofferStringValue)"}
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data
            
        case .getFreebetBalance:
            return nil
        case .getSharedTicket:
            return nil
        case .getTicketSelection(let ticketSelectionId):
            let body = """
                       {
                        "clientContext": {
                            "ipAddress": "127.0.0.1",
                            "language": "\(SportRadarConfiguration.shared.socketLanguageCode)"
                        },
                        "contentId": {
                            "id": "\(ticketSelectionId)",
                            "type": "selection"
                        }
                       }
                       """
            let data = body.data(using: String.Encoding.utf8)!
            return data

        case .calculateCashback(let betTicket):
            return Self.createCashbackBetLegsJSONBody(fromBetTicket: betTicket)
        }
        
    }
    
    var method: HTTP.Method {
        switch self {
        case .betHistory: return .get
        case .betDetails: return .get
        case .calculateReturns: return .post
        case .getAllowedBetTypes: return .post
        case .placeBets: return .post
            
        case .calculateBetBuilderReturn: return .post
        case .placeBetBuilderBet: return .post
            
        case .confirmBoostedBet: return .put
        case .rejectBoostedBet: return .post
            
        case .calculateCashout: return .post
        case .cashoutBet: return .post
        case .getAllowedCashoutBetIds: return .get
            
        case .getBetslipSettings: return .get
        case .updateBetslipSettings: return .post
        case .updateBetslipSettingsRunning: return .post
        case .updateBetslipSettingsPreMatch: return .post
        case .getFreebetBalance: return .get
        case .getSharedTicket: return .get
        case .getTicketSelection: return .post
        case .calculateCashback: return .post
        }
    }
    
    var requireSessionKey: Bool {
        switch self {
        case .betHistory: return true
        case .betDetails: return true
        case .calculateReturns: return false
        case .getAllowedBetTypes: return false
        case .placeBets: return true
         
        case .calculateBetBuilderReturn: return false
        case .placeBetBuilderBet: return true
            
        case .confirmBoostedBet: return true
        case .rejectBoostedBet: return true
            
        case .calculateCashout: return true
        case .cashoutBet: return true
        case .getAllowedCashoutBetIds: return true
            
        case .getBetslipSettings: return true
        case .updateBetslipSettings: return true
        case .updateBetslipSettingsRunning: return true
        case .updateBetslipSettingsPreMatch: return true
            
        case .getFreebetBalance: return true
        case .getSharedTicket: return false
        case .getTicketSelection: return false
        case .calculateCashback: return true
        }
    }
    
    var url: String {
        switch self {
        case .getTicketSelection:
            return SportRadarConfiguration.shared.servicesRestHostname
        default:
            return SportRadarConfiguration.shared.apiRestHostname
        }
    }
    
    var headers: HTTP.Headers? {
        switch self {
        case .confirmBoostedBet, .rejectBoostedBet:
            return [
                "Content-Type": "application/json",
                "X-MGS-BusinessUnit": "3",
                "X-MGS-Location": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                "Accept-Language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
            ]
        default:
            return [
                "Accept-Encoding": "gzip, deflate",
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json",
                "X-MGS-BusinessUnit": "3",
                "app-origin": "ios",
                "Accept-Languag": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                "X-MGS-Location": "\(SportRadarConfiguration.shared.socketLanguageCode)",
            ]
        }
    }
    
    var cachePolicy: URLRequest.CachePolicy {
        return .reloadIgnoringLocalCacheData
    }
    
    var timeout: TimeInterval {
        switch self {
        case .betHistory: return TimeInterval(180)
        case .betDetails: return TimeInterval(180)
        case .calculateReturns: return TimeInterval(180)
        case .getAllowedBetTypes: return TimeInterval(180)
        case .placeBets: return TimeInterval(180)
            
        case .calculateBetBuilderReturn: return TimeInterval(180)
        case .placeBetBuilderBet: return TimeInterval(180)
            
        case .confirmBoostedBet: return TimeInterval(180)
        case .rejectBoostedBet: return TimeInterval(180)
            
        case .calculateCashout: return TimeInterval(180)
        case .cashoutBet: return TimeInterval(180)
        case .getAllowedCashoutBetIds: return TimeInterval(20)
            
        case .getBetslipSettings: return TimeInterval(180)
        case .updateBetslipSettings: return TimeInterval(180)
        case .updateBetslipSettingsRunning: return TimeInterval(180)
        case .updateBetslipSettingsPreMatch: return TimeInterval(180)
            
        case .getFreebetBalance: return TimeInterval(180)
        case .getSharedTicket: return TimeInterval(180)
        case .getTicketSelection: return TimeInterval(180)
        case .calculateCashback: return TimeInterval(180)
        }
    }
    
    var comment: String? {
        switch self {
        case .betHistory: return "betHistory"
        case .betDetails: return "betDetails"
        case .calculateReturns: return "calculateReturns"
        case .getAllowedBetTypes: return "getAllowedBetTypes"
        case .placeBets: return "placeBets"
        case .calculateBetBuilderReturn: return "calculateBetBuilderReturn"
        case .placeBetBuilderBet: return "placeBetBuilderBet"
        case .confirmBoostedBet: return "confirmBoostedBet"
        case .rejectBoostedBet: return "rejectBoostedBet"
        
        case .calculateCashout: return "calculateCashout"
        case .cashoutBet: return "cashoutBet"
        case .getAllowedCashoutBetIds: return "getAllowedCashoutBetIds"
            
        case .getBetslipSettings: return "getBetslipSettings"
        case .updateBetslipSettings: return "updateBetslipSettings"
        case .updateBetslipSettingsRunning: return "updateBetslipSettingsRunning"
        case .updateBetslipSettingsPreMatch: return "updateBetslipSettingsPreMatch"
            
        case .getFreebetBalance: return "getFreebetBalance"
        case .getSharedTicket: return "getSharedTicket"
        case .getTicketSelection: return "getTicketSelection"
        case .calculateCashback: return "calculateCashback"
        }
    }
    
    // TODO: Check if we can use this in every endpoint
    private static func createBetJSONBody(fromBetTickets betTickets: [BetTicket]) -> Data {
        var betsArray: [String] = []
        for ticket in betTickets {
            var legsStringArray: [String] = []
            for selection in ticket.tickets {
                let priceDown: String
                let priceUp: String

                switch selection.odd {
                case .fraction(let numerator, let denominator):
                    priceUp = "\(numerator)"
                    priceDown = "\(denominator)"
                case .decimal:
                    priceUp = ""
                    priceDown = ""
                }

                legsStringArray.append(
                """
                {
                  "eachWayPlaceTerms": "",
                  "eachWayReduction": "",
                  "handicap": "",
                  "idFOPriceType": "CP",
                  "idFOSelection": "\(selection.identifier)",
                  "isTrap": "",
                  "lowerBand": "",
                  "priceDown": "\(priceDown)",
                  "priceUp": "\(priceUp)",
                  "systemTag": "",
                  "upperBand": ""
                }
                """)
            }

            let legsString = legsStringArray.joined(separator: ",")
            betsArray.append(
                """
                {
                    "betLegs": [ \(legsString) ],
                    "idFOBetType": "\(ticket.betGroupingType.identifier)",
                    "pool": false,
                    "winStake": \(ticket.globalStake ?? 0.0)
                }
                """)
        }

        let betsString = betsArray.joined(separator: ",")
        let body = """
                   {
                     "bets": [\(betsString)],
                     "useAutoAcceptance": true
                   }
                   """

        let data = body.data(using: String.Encoding.utf8)!
        return data
    }

    private static func createBetLegsJSONBody(fromBetTicket betTicket: BetTicket) -> Data {

        var legsStringArray: [String] = []
        for selection in betTicket.tickets {
            let priceDown: String
            let priceUp: String

            switch selection.odd {
            case .fraction(let numerator, let denominator):
                priceUp = "\(numerator)"
                priceDown = "\(denominator)"
            case .decimal:
                priceUp = ""
                priceDown = ""
            }

            legsStringArray.append(
                """
                {
                  "eachWayPlaceTerms": "",
                  "eachWayReduction": "",
                  "handicap": "",
                  "idFOPriceType": "CP",
                  "idFOSelection": "\(selection.identifier)",
                  "isTrap": "",
                  "lowerBand": "",
                  "priceDown": "\(priceDown)",
                  "priceUp": "\(priceUp)",
                  "systemTag": "",
                  "upperBand": ""
                }
                """)
        }

        let legsString = legsStringArray.joined(separator: ",")
        let body =
                """
                {
                    "betLegs": [ \(legsString) ],
                    "idFOBetType": "\(betTicket.betGroupingType.identifier)",
                    "pool": false,
                    "winStake": \(betTicket.globalStake ?? 0.0)
                }
                """

        let data = body.data(using: String.Encoding.utf8)!
        return data
    }

    private static func createCashbackBetLegsJSONBody(fromBetTicket betTicket: BetTicket) -> Data {

        var legsStringArray: [String] = []
        for selection in betTicket.tickets {
            let priceDown: String
            let priceUp: String

            switch selection.odd {
            case .fraction(let numerator, let denominator):
                priceUp = "\(numerator)"
                priceDown = "\(denominator)"
            case .decimal:
                priceUp = ""
                priceDown = ""
            }

            legsStringArray.append(
                """
                {
                "idFOPriceType": "CP",
                "idFOSelection": "\(selection.identifier)",
                "priceDown": "\(priceDown)",
                "priceUp": "\(priceUp)",
                "idFOSport": "\(selection.sportIdCode ?? "SPORT")",
                "idFOMarket": "\(selection.marketName)",
                "idFOEvent": "\(selection.eventName)"
                }
                """)
        }

        let legsString = legsStringArray.joined(separator: ",")
        let body =
                """
                {
                    "betLegs": [ \(legsString) ],
                    "idFOBetType": "\(betTicket.betGroupingType.identifier)",
                    "wunitstake": \(betTicket.globalStake ?? 0.0)
                }
                """

        let data = body.data(using: String.Encoding.utf8)!
        return data
    }

}
//
//{
//    "betLegs": [
//        {
//            "priceType": "CP",
//            "idFOSelection": "251663186.1",
//            "priceDown": "100",
//            "priceUp": "79",
//            "idFOSport": "SPORT",
//            "idFOMarket": "50930219.1",
//            "idFOEvent": "3234242.1"
//        },
//        {
//            "priceType": "CP",
//            "idFOSelection": "251663184.1",
//            "priceDown": "100",
//            "priceUp": "61",
//            "idFOSport": "SPORT",
//            "idFOMarket": "50930218.1",
//            "idFOEvent": "3234243.1"
//        },
//        {
//            "priceType": "CP",
//            "idFOSelection": "251260968.1",
//            "priceDown": "100",
//            "priceUp": "187",
//            "idFOSport": "SPORT",
//            "idFOMarket": "50844314.1",
//            "idFOEvent": "3233037.1"
//        }
//    ],
//    "betType": "T",
//    "wunitstake": 10
//}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Betting-Poseidon/BettingConnector.swift
````swift
//
//  BettingConnector.swift
//
//
//  Created by Ruben Roques on 12/11/2022.
//

import Foundation
import Combine

class BettingConnector: Connector {

    var token: BettingSessionAccessToken?
    
    var connectionStateSubject: CurrentValueSubject<ConnectorState, Never> = .init(.connected)
    var connectionStatePublisher: AnyPublisher<ConnectorState, Never> {
        return connectionStateSubject.eraseToAnyPublisher()
    }

    var requestTokenRefresher: () -> AnyPublisher<String?, Never> = { Just(Optional<String>.none).eraseToAnyPublisher() }

    private let session: URLSession
    private let decoder: JSONDecoder
    
    init(session: URLSession = URLSession(configuration: URLSessionConfiguration.default), decoder: JSONDecoder = JSONDecoder()) {
        self.session = session
        self.decoder = decoder
        
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss'.0'" // 2003-12-31 00:00:00
        self.decoder.dateDecodingStrategy = .formatted(dateFormatter)
    }

    func clearSessionKey() {
        return self.token = nil
    }
    
    func saveSessionKey(_ sessionKey: String) {
        return self.token = BettingSessionAccessToken(hash: sessionKey)
    }
    
    func retrieveSessionKey() -> String? {
        return self.token?.hash
    }
    
    func request<T: Codable>(_ endpoint: Endpoint) -> AnyPublisher<T, ServiceProviderError> {
        
        var additionalHeaders: HTTP.Headers?
        if endpoint.requireSessionKey {
            if let sessionKey = self.retrieveSessionKey() {
                additionalHeaders = ["Authorization": sessionKey]
            }
            else {
                return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
            }
        }
        
        guard
            let request = endpoint.request(aditionalHeaders: additionalHeaders)
        else {
            let error = ServiceProviderError.invalidRequestFormat
            return Fail<T, ServiceProviderError>(error: error).eraseToAnyPublisher()
        }

        // print("Betting-NetworkManager: URL Request: \n", request.cURL(pretty: true), "\n==========================================")
        
        return self.session.dataTaskPublisher(for: request)
            .tryMap { result -> Data in

                if (request.url?.absoluteString ?? "").contains("/custom-bet/v1/calculate") || (request.url?.absoluteString ?? "").contains("custom-bet/v1/placecustombet") {
                    var responseBody = String(data: request.httpBody ?? Data(), encoding: .utf8) ?? ""
                    responseBody = responseBody.replacingOccurrences(of: "\n", with: " ")
                    print("MixMatchDebug: | ", request, " body: ", responseBody , " | response: ", String(data: result.data, encoding: .utf8) ?? "!?" )
                }
                
                if (request.url?.absoluteString ?? "").contains("/custom-bet/v1/calculate") {
                    if let httpResponse = result.response as? HTTPURLResponse {
                        if httpResponse.statusCode == 401 || httpResponse.statusCode == 500 || httpResponse.statusCode == 503 {
                            throw ServiceProviderError.badRequest
                        }
                    }
                }

                if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 401 {
                    throw ServiceProviderError.unauthorized
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 404 {
                    throw ServiceProviderError.pageNotFound
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 400 {
                    throw ServiceProviderError.badRequest
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 403 {
                    throw ServiceProviderError.forbidden
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 500 {
                    throw ServiceProviderError.internalServerError
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 503 {
                    throw ServiceProviderError.internalServerError
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode != 200 {
                    throw ServiceProviderError.unknown
                }
                return result.data
            }
            .handleEvents(receiveOutput: { data in
//                    print("Betting-NetworkManager [[ requesting ]] ",
//                          request, " Body: ",
//                          String(data: request.httpBody ?? Data(), encoding: .utf8) ?? "" ,
//                          " [[ response ]] ", String(data: data, encoding: .utf8) ?? "!?" )
            })
        
            .decode(type: T.self, decoder: self.decoder)
            .mapError({ error -> ServiceProviderError in
                if let typedError = error as? ServiceProviderError {
                    return typedError
                }
                else if let decodingError = error as? DecodingError {
                    let errorMessage = "\(decodingError)"
                    return ServiceProviderError.decodingError(message: errorMessage)
                }
                return ServiceProviderError.invalidResponse
            })
            .catch({ [weak self] (error: ServiceProviderError) -> AnyPublisher<T, ServiceProviderError> in
                guard let self = self else { return Fail(error: error).eraseToAnyPublisher()  }
                if case ServiceProviderError.unauthorized = error {
                    return self.requestTokenRefresher()
                        .setFailureType(to: ServiceProviderError.self)
                        .flatMap({ [weak self] (newToken: String?) -> AnyPublisher<T, ServiceProviderError> in
                            guard
                                let weakSelf = self,
                                let newTokenValue = newToken
                            else {
                                return Fail(error: ServiceProviderError.unknown).eraseToAnyPublisher()
                            }
                            weakSelf.saveSessionKey(newTokenValue)
                            return weakSelf.request(endpoint).eraseToAnyPublisher()
                        })
                        .eraseToAnyPublisher()
                }
                else {
                    return Fail(error: error).eraseToAnyPublisher()
                }
            })
            .eraseToAnyPublisher()
    }
        
}

extension URLRequest {
    public func cURL(pretty: Bool = false) -> String {
        let newLine = pretty ? "\\\n" : ""
        let method = (pretty ? "--request " : "-X ") + "\(self.httpMethod ?? "GET") \(newLine)"
        let url: String = (pretty ? "--url " : "") + "\'\(self.url?.absoluteString ?? "")\' \(newLine)"
        
        var cURL = "curl "
        var header = ""
        var data: String = ""
        
        if let httpHeaders = self.allHTTPHeaderFields, httpHeaders.keys.count > 0 {
            for (key,value) in httpHeaders {
                header += (pretty ? "--header " : "-H ") + "\'\(key): \(value)\' \(newLine)"
            }
        }
        if let bodyData = self.httpBody, let bodyString = String(data: bodyData, encoding: .utf8),  !bodyString.isEmpty {
            let escaped = bodyString.replacingOccurrences(of: "'", with: "'\\''")   // important to escape ' so it become '\'' that would work in command line
            data = "--data '\(escaped)'"
        }
        cURL += method + url + header + data
        cURL = cURL.replacingOccurrences(of: "\n", with: "")
        return cURL
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Betting-Poseidon/BettingSession.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 15/11/2022.
//

import Foundation

struct BettingSessionAccessToken {
    var hash: String
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Events-Poseidon/EventsDetails/SportRadarEventDetailsCoordinator.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 01/03/2023.
//

import Foundation
import Combine

class SportRadarEventDetailsCoordinator {

    var storage: SportRadarEventStorage
    var sessionToken: String

    let eventDetailsIdentifier: ContentIdentifier
    let liveDataContentIdentifier: ContentIdentifier
    
    weak var liveDataExtendedSubscription: Subscription?
    
    weak var marketsSubscription: Subscription?
    
    var isActive: Bool {
        if self.waitingSubscription {
            // We haven't tried to subscribe or the
            // subscribe request it's ongoing right now
            return true
        }
        return self.marketsSubscription != nil
    }

    var eventDetailsPublisher: AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {
        return eventDetailsCurrentValueSubject
            .eraseToAnyPublisher()
    }

    private var eventDetailsCurrentValueSubject: CurrentValueSubject<SubscribableContent<Event>, ServiceProviderError> = .init(.disconnected)
    
    private var waitingSubscription = true
    private let decoder = JSONDecoder()
    private let session = URLSession.init(configuration: .default)
    
    private var cancellables = Set<AnyCancellable>()

    init(matchId: String, sessionToken: String, storage: SportRadarEventStorage, liveDataExtendedSubscription: Subscription? = nil, marketsSubscription: Subscription? = nil) {
        self.sessionToken = sessionToken
        self.storage = storage

        self.liveDataExtendedSubscription = liveDataExtendedSubscription
        self.marketsSubscription = marketsSubscription
    
        let eventDetailsType = ContentType.eventDetails
        let eventDetailsRoute = ContentRoute.eventDetails(eventId: matchId)
        let eventDetailsIdentifier = ContentIdentifier(contentType: eventDetailsType, contentRoute: eventDetailsRoute)

        self.eventDetailsIdentifier = eventDetailsIdentifier

        let liveDataContentType = ContentType.eventDetailsLiveData
        let liveDataContentRoute = ContentRoute.eventDetailsLiveData(eventId: matchId)
        let liveDataContentIdentifier = ContentIdentifier(contentType: liveDataContentType, contentRoute: liveDataContentRoute)

        self.liveDataContentIdentifier = liveDataContentIdentifier
        
        // Boot the coordinator
        self.checkEventDetailsAvailable()
            .flatMap { [weak self] _ -> AnyPublisher<Void, ServiceProviderError>  in
                guard let weakSelf = self else {
                    return Fail(error: ServiceProviderError.onSubscribe).eraseToAnyPublisher()
                }
                return weakSelf.subscribeEventDetails()
            }
            .sink { [weak self] completion in
                guard let weakSelf = self else { return }
                
                switch completion {
                case .finished:
                    
                    if let marketsSubscription = weakSelf.marketsSubscription {
                        weakSelf.eventDetailsCurrentValueSubject.send(.connected(subscription: marketsSubscription))
                    }
                    else {
                        let subscription = Subscription(contentIdentifier: weakSelf.eventDetailsIdentifier,
                                                        sessionToken: weakSelf.sessionToken,
                                                        unsubscriber: weakSelf)
                        weakSelf.eventDetailsCurrentValueSubject.send(.connected(subscription: subscription))
                        weakSelf.marketsSubscription = subscription
                    }
                    
                    weakSelf.requestEventLiveData()
                    
                case .failure(let error):
                    weakSelf.eventDetailsCurrentValueSubject.send(completion: .failure(error))
                }
                weakSelf.waitingSubscription = false
            } receiveValue: { _ in
            }
            .store(in: &self.cancellables)

    }

    deinit {
    }
    
    private func checkEventDetailsAvailable() -> AnyPublisher<Void, ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.get(contentIdentifier: self.eventDetailsIdentifier)

        guard
            let request = endpoint.request()
        else {
            return Fail(error: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
        }

        return self.session.dataTaskPublisher(for: request)
            .map({ response in
                return String(data: response.data, encoding: .utf8) ?? ""
            })
            .mapError({ error in
                return ServiceProviderError.resourceUnavailableOrDeleted
            })
            .flatMap { responseString -> AnyPublisher<Void, ServiceProviderError> in
                if responseString.uppercased().contains("CONTENT_NOT_FOUND") {
                    return Fail(outputType: Void.self, failure: ServiceProviderError.resourceUnavailableOrDeleted).eraseToAnyPublisher()
                }
                else {
                    return Just(()).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                }
            }
            .eraseToAnyPublisher()

    }

    func subscribeEventDetails() -> AnyPublisher<Void, ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                         contentIdentifier: self.eventDetailsIdentifier)

        guard
            let request = endpoint.request()
        else {
            return Fail(error: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
        }

        return self.session.dataTaskPublisher(for: request)
            .tryMap { data, response -> Data in
                guard
                    let httpResponse = response as? HTTPURLResponse,
                    (200...299).contains(httpResponse.statusCode)
                else {
                    throw ServiceProviderError.onSubscribe
                }
                return data
            }
            .mapError { _ in ServiceProviderError.onSubscribe }
            .flatMap { data -> AnyPublisher<Void, ServiceProviderError> in
                if let responseString = String(data: data, encoding: .utf8), responseString.lowercased().contains("version") {
                    return Just(()).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                } else {
                    return Fail(error: ServiceProviderError.onSubscribe).eraseToAnyPublisher()
                }
            }
            .eraseToAnyPublisher()
    }
        
    func requestEventLiveData() {
        let publisher = CurrentValueSubject<SubscribableContent<Event>, ServiceProviderError>.init(.disconnected)
        let endpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                         contentIdentifier: self.liveDataContentIdentifier)
        guard
            let request = endpoint.request()
        else {
            return
        }

        let sessionDataTask = self.session.dataTask(with: request) { [weak self] data, response, error in
            guard
                (error == nil),
                let httpResponse = response as? HTTPURLResponse,
                (200...299).contains(httpResponse.statusCode)
            else {
                publisher.send(completion: .failure(ServiceProviderError.onSubscribe))
                return
            }
            if let liveDataExtendedSubscription = self?.liveDataExtendedSubscription {
                print("liveDataSubscription isn't managed by this class \(liveDataExtendedSubscription)")
            }
            else if let weakSelf = self {
                let liveDataExtendedSubscription = Subscription(contentIdentifier: weakSelf.liveDataContentIdentifier,
                                                sessionToken: weakSelf.sessionToken,
                                                unsubscriber: weakSelf)
                weakSelf.liveDataExtendedSubscription = liveDataExtendedSubscription
                weakSelf.marketsSubscription?.associateSubscription(liveDataExtendedSubscription)
            }
        }

        sessionDataTask.resume()
    }

    func updateEventDetails(_ updatedEvent: Event, forContentIdentifier contentIdentifier: ContentIdentifier) {
        print("ServiceProvider SportRadarEventDetailsCoordinator updateEventDetails \(eventDetailsIdentifier) \(liveDataContentIdentifier)")

        if contentIdentifier == self.liveDataContentIdentifier || contentIdentifier == self.eventDetailsIdentifier {
            self.storage.storeEvent(updatedEvent)
            self.eventDetailsCurrentValueSubject.send(.contentUpdate(content: updatedEvent))
        }
    }

    func reconnect(withNewSessionToken newSessionToken: String) {
        self.sessionToken = newSessionToken
        self.storage.reset()

        //
        //
        let marketsEndpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                                contentIdentifier: self.eventDetailsIdentifier)

        guard let marketsRequest = marketsEndpoint.request() else { return }
        let marketsSessionDataTask = self.session.dataTask(with: marketsRequest) { data, response, error in
            if let error {
                print("SportRadarEventDetailsCoordinator: reconnect dataTask contentIdentifier \(self.eventDetailsIdentifier) error \(error)")
            }
            if let data, let dataString = String(data: data, encoding: .utf8) {
                print("SportRadarEventDetailsCoordinator: reconnect dataTask contentIdentifier \(self.eventDetailsIdentifier) data \(dataString)")
            }
        }
        marketsSessionDataTask.resume()

        //
        //
        let liveDataEndpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                                 contentIdentifier: self.liveDataContentIdentifier)

        guard let liveDataRequest = liveDataEndpoint.request() else { return }
        let liveDataSessionDataTask = self.session.dataTask(with: liveDataRequest) { data, response, error in
            if let error {
                print("SportRadarEventDetailsCoordinator: reconnect dataTask contentIdentifier \(self.liveDataContentIdentifier) error \(error)")
            }
            if let data, let dataString = String(data: data, encoding: .utf8) {
                print("SportRadarEventDetailsCoordinator: reconnect dataTask contentIdentifier \(self.liveDataContentIdentifier) data \(dataString)")
            }
        }
        liveDataSessionDataTask.resume()
    }

}


extension SportRadarEventDetailsCoordinator {

    private func updateWithLiveDataExtended(eventLiveDataExtended: SportRadarModels.EventLiveDataExtended) {
        
        if let newStatus = eventLiveDataExtended.status?.stringValue {
            self.storage.updateEventStatus(newStatus: newStatus)
        }
        if let newTime = eventLiveDataExtended.matchTime {
            self.storage.updateEventTime(newTime: newTime)
        }

        self.storage.updateEventScore(newHomeScore: eventLiveDataExtended.homeScore, newAwayScore: eventLiveDataExtended.awayScore)
        
        if !eventLiveDataExtended.scores.isEmpty {
            let mappedDetailedScores = SportRadarModelMapper.scoresDictionary(fromInternalScoresDictionary: eventLiveDataExtended.scores)
            
            self.storage.updateEventFullDetailedScore(mappedDetailedScores)
        }

        if let storedEvent = self.storage.storedEvent() {
            self.eventDetailsCurrentValueSubject.send(.contentUpdate(content: storedEvent))
        }
        
        if let serving = eventLiveDataExtended.activePlayerServing {
            let mappedServing = SportRadarModelMapper.activePlayerServe(fromInternalActivePlayerServe: serving)
            self.storage.updateActivePlayer(mappedServing)
        }
        
    }
    
    func updatedLiveData(eventLiveDataExtended: SportRadarModels.EventLiveDataExtended, forContentIdentifier contentIdentifier: ContentIdentifier) {

        guard
            contentIdentifier == self.liveDataContentIdentifier ||  contentIdentifier == self.eventDetailsIdentifier
        else {
            return
        }

        self.updateWithLiveDataExtended(eventLiveDataExtended: eventLiveDataExtended)
    }

    func handleContentUpdate(_ content: SportRadarModels.ContentContainer) {
        
        guard
            let updatedContentIdentifier = content.contentIdentifier
        else {
            return
        }
        
        if self.eventDetailsIdentifier != updatedContentIdentifier && self.liveDataContentIdentifier != updatedContentIdentifier {
            return
        }
        
        // print("☁️SP debugdetails SportRadarEventDetailsCoordinator handleContentUpdate \(content)")
        
        switch content {
            
            // Odds
        case .updateOutcomeOdd(_, let selectionId, let newOddNumerator, let newOddDenominator):
            self.storage.updateOutcomeOdd(withId: selectionId, newOddNumerator: newOddNumerator, newOddDenominator: newOddDenominator)
        case .updateOutcomeTradability(_, let selectionId, let isTradable):
            self.storage.updateOutcomeTradability(withId: selectionId, isTradable: isTradable)
            
            // Live Data
        case .updateEventLiveDataExtended(_, _, let eventLiveDataExtended):
            self.updateWithLiveDataExtended(eventLiveDataExtended: eventLiveDataExtended)
            
        case .updateEventState(_, _, let newStatus):
            self.storage.updateEventStatus(newStatus: newStatus)
            
        case .updateEventTime(_, _, let newTime):
            self.storage.updateEventTime(newTime: newTime)
        case .updateEventScore(_, _, let homeScore, let awayScore):
            self.storage.updateEventScore(newHomeScore: homeScore, newAwayScore: awayScore)
            
        case .updateActivePlayer(_, _, let serving):
            let mappedServing = SportRadarModelMapper.activePlayerServe(fromInternalActivePlayerServe: serving)
            self.storage.updateActivePlayer(mappedServing)
            
        case .updateEventDetailedScore(_, _, let detailedScore):
            let mappedScore = SportRadarModelMapper.score(fromInternalScore: detailedScore)
            self.storage.updateEventDetailedScore(mappedScore)
            
            // Markets
        case .updateMarketTradability(_, let marketId, let isTradable):
            self.storage.updateMarketTradability(withId: marketId, isTradable: isTradable)
            
        case .addMarket(_, let market):
            for outcome in market.outcomes {
                if let fractionOdd = outcome.odd.fractionOdd {
                    self.storage.updateOutcomeOdd(withId: outcome.id, newOddNumerator: String(fractionOdd.numerator), newOddDenominator: String(fractionOdd.denominator))
                }
            }
            self.storage.updateMarketTradability(withId: market.id, isTradable: market.isTradable)
            
        case .enableMarket(_, let marketId):
            self.storage.updateMarketTradability(withId: marketId, isTradable: true)
        case .removeMarket(_, let marketId):
            self.storage.updateMarketTradability(withId: marketId, isTradable: false)
            
            //        case .removeEvent(_, let eventId):
            //            self.storage.removedEvent(withId: eventId)
            
        default:
            () // Ignore other cases
        }
        
    }
}

extension SportRadarEventDetailsCoordinator {

    func subscribeToEventOnListsLiveDataUpdates(withId id: String) -> AnyPublisher<Event?, Never> {
        return self.storage.subscribeToEventOnListsLiveDataUpdates(withId: id)
    }

    func subscribeToEventOnListsMarketUpdates(withId id: String) -> AnyPublisher<Market, Never>? {
        return self.storage.subscribeToEventOnListsMarketUpdates(withId: id)
    }

    func subscribeToEventOnListsOutcomeUpdates(withId id: String) -> AnyPublisher<Outcome, Never>? {
        return self.storage.subscribeToEventOnListsOutcomeUpdates(withId: id)
    }

    func containsEvent(withid id: String) -> Bool {
        return self.storage.containsEvent(withid: id)
    }
    
    func containsMarket(withid id: String) -> Bool {
        return self.storage.containsMarket(withid: id)
    }

    func containsOutcome(withid id: String) -> Bool {
        return self.storage.containsOutcome(withid: id)
    }

}

extension SportRadarEventDetailsCoordinator: UnsubscriptionController {

    func unsubscribe(subscription: Subscription) {
        let endpoint = SportRadarRestAPIClient.unsubscribe(sessionToken: subscription.sessionToken, contentIdentifier: subscription.contentIdentifier)
        guard let request = endpoint.request() else { return }
        let sessionDataTask = self.session.dataTask(with: request) { data, response, error in
            guard
                error == nil,
                let httpResponse = response as? HTTPURLResponse,
                (200...299).contains(httpResponse.statusCode)
            else {
                print("ServiceProvider.Subscription.Debug unsubscribe failed")
                return
            }
            print("ServiceProvider.Subscription.Debug unsubscribe ok")
        }
        sessionDataTask.resume()
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Events-Poseidon/EventsGroups/SportRadarEventsGroupCoordinator.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 01/03/2023.
//

import Foundation
import Combine

class SportRadarEventsGroupCoordinator {

    var storage: SportRadarEventsGroupStorage
    var sessionToken: String

    let eventsGroupIdentifier: ContentIdentifier

    weak var marketsSubscription: Subscription?
    var isActive: Bool {
        return self.marketsSubscription != nil
    }

    var eventsGroupPublisher: AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {
        return eventsGroupCurrentValueSubject.eraseToAnyPublisher()
    }

    private var eventsGroupCurrentValueSubject: CurrentValueSubject<SubscribableContent<Event>, ServiceProviderError> = .init(.disconnected)

    private let decoder = JSONDecoder()
    private let session = URLSession.init(configuration: .default)
    
    private var cancellables = Set<AnyCancellable>()

    init(eventsGroupId: String, sessionToken: String, storage: SportRadarEventsGroupStorage) {
        self.sessionToken = sessionToken
        self.storage = storage

        let eventsGroupType = ContentType.eventGroup
        let eventsGroupRoute = ContentRoute.eventGroup(marketGroupId: eventsGroupId)
        let eventsGroupIdentifier = ContentIdentifier(contentType: eventsGroupType, contentRoute: eventsGroupRoute)

        self.eventsGroupIdentifier = eventsGroupIdentifier

        // Boot the coordinator
        self.checkEventDetailsAvailable()
            .flatMap { [weak self] _ -> AnyPublisher<Void, ServiceProviderError>  in
                guard let self = self else {
                    return Fail(error: ServiceProviderError.onSubscribe).eraseToAnyPublisher()
                }
                return self.subscribeEventDetails()
            }
            .sink { [weak self] completion in
                guard let self = self else { return }
                switch completion {
                case .finished:
                    let subscription = Subscription(contentIdentifier: self.eventsGroupIdentifier,
                                                    sessionToken: self.sessionToken,
                                                    unsubscriber: self)
                    self.eventsGroupCurrentValueSubject.send(.connected(subscription: subscription))
                    self.marketsSubscription = subscription
                    
                case .failure(let error):
                    self.eventsGroupCurrentValueSubject.send(completion: .failure(error))
                }
            } receiveValue: { _ in }
            .store(in: &self.cancellables)

    }

    private func checkEventDetailsAvailable() -> AnyPublisher<Void, ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.get(contentIdentifier: self.eventsGroupIdentifier)

        guard
            let request = endpoint.request()
        else {
            return Fail(error: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
        }

        return self.session.dataTaskPublisher(for: request)
            .retry(1)
            .map({ return String(data: $0.data, encoding: .utf8) ?? "" })
            .mapError({ _ in return ServiceProviderError.invalidRequestFormat })
            .flatMap { responseString -> AnyPublisher<Void, ServiceProviderError> in
                if responseString.uppercased().contains("CONTENT_NOT_FOUND") {
                    return Fail(outputType: Void.self, failure: ServiceProviderError.resourceUnavailableOrDeleted).eraseToAnyPublisher()
                }
                else {
                    return Just(()).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                }
            }
            .eraseToAnyPublisher()

    }

    func subscribeEventDetails() -> AnyPublisher<Void, ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                         contentIdentifier: self.eventsGroupIdentifier)

        guard
            let request = endpoint.request()
        else {
            return Fail(error: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
        }

        return self.session.dataTaskPublisher(for: request)
            .retry(1) // 
            .tryMap { data, response -> Data in
                guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {
                    throw ServiceProviderError.onSubscribe
                }
                return data
            }
            .mapError { _ in ServiceProviderError.onSubscribe }
            .flatMap { data -> AnyPublisher<Void, ServiceProviderError> in
                if let responseString = String(data: data, encoding: .utf8), responseString.lowercased().contains("version") {
                    return Just(()).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                } else {
                    return Fail(error: ServiceProviderError.onSubscribe).eraseToAnyPublisher()
                }
            }
            .eraseToAnyPublisher()
    }

    func updateEventDetails(_ updatedEvent: Event, forContentIdentifier contentIdentifier: ContentIdentifier) {
        print("ServiceProvider SportRadarEventsGroupCoordinator update \(eventsGroupIdentifier) ")

        if contentIdentifier == self.eventsGroupIdentifier {
            self.storage.storeEvent(updatedEvent)
            self.eventsGroupCurrentValueSubject.send(.contentUpdate(content: updatedEvent))
        }
    }

    func reconnect(withNewSessionToken newSessionToken: String) {
        self.sessionToken = newSessionToken
        self.storage.reset()

        //
        //
        let marketsEndpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                                contentIdentifier: self.eventsGroupIdentifier)

        guard let marketsRequest = marketsEndpoint.request() else { return }
        let marketsSessionDataTask = self.session.dataTask(with: marketsRequest) { data, response, error in
            if let error {
                print("SportRadarEventDetailsCoordinator: reconnect dataTask contentIdentifier \(self.eventsGroupIdentifier) error \(error)")
            }
            if let data, let dataString = String(data: data, encoding: .utf8) {
                print("SportRadarEventDetailsCoordinator: reconnect dataTask contentIdentifier \(self.eventsGroupIdentifier) data \(dataString)")
            }
        }
        marketsSessionDataTask.resume()

    }

}


extension SportRadarEventsGroupCoordinator {

    func updatedLiveData(eventLiveDataExtended: SportRadarModels.EventLiveDataExtended, forContentIdentifier contentIdentifier: ContentIdentifier) {

        guard
            contentIdentifier == self.eventsGroupIdentifier
        else {
            return
        }

        if let newStatus = eventLiveDataExtended.status?.stringValue {
            self.storage.updateEventStatus(newStatus: newStatus)
        }
        if let newTime = eventLiveDataExtended.matchTime {
            self.storage.updateEventTime(newTime: newTime)
        }

        self.storage.updateEventScore(newHomeScore: eventLiveDataExtended.homeScore, newAwayScore: eventLiveDataExtended.awayScore)

        if let storedEvent = self.storage.storedEvent() {
            self.eventsGroupCurrentValueSubject.send(.contentUpdate(content: storedEvent))
        }
        
    }

    func handleContentUpdate(_ content: SportRadarModels.ContentContainer) {

        guard
            let updatedContentIdentifier = content.contentIdentifier
        else {
            // ignoring contentIdentifierLess updates
            // print("☁️SP debugdetails ignoring contentIdentifierLess \(content)")
            return
        }

        if self.eventsGroupIdentifier != updatedContentIdentifier {
            // ignoring this update, not subscribed by this class
            // print("☁️SP debugdetails ignoring \(updatedContentIdentifier) != \(eventsGroupIdentifier) \(liveDataContentIdentifier)")
            return
        }

        // print("☁️SP debugdetails SportRadarEventDetailsCoordinator handleContentUpdate \(content)")

        switch content {

        // Odds
        case .updateOutcomeOdd(_, let selectionId, let newOddNumerator, let newOddDenominator):
            self.storage.updateOutcomeOdd(withId: selectionId, newOddNumerator: newOddNumerator, newOddDenominator: newOddDenominator)
        case .updateOutcomeTradability(_, let selectionId, let isTradable):
            self.storage.updateOutcomeTradability(withId: selectionId, isTradable: isTradable)

        // Live Data
        case .updateEventLiveDataExtended(_, _, let eventLiveDataExtended):
            if let newTime = eventLiveDataExtended.matchTime {
                self.storage.updateEventTime(newTime: newTime)
            }
            if let newStatus = eventLiveDataExtended.status {
                self.storage.updateEventStatus(newStatus: newStatus.stringValue)
            }
            self.storage.updateEventScore(newHomeScore: eventLiveDataExtended.homeScore, newAwayScore: eventLiveDataExtended.awayScore)

        case .updateEventState(_, _, let newStatus):
            self.storage.updateEventStatus(newStatus: newStatus)
            
        case .updateEventTime(_, _, let newTime):
            self.storage.updateEventTime(newTime: newTime)
        case .updateEventScore(_, _, let homeScore, let awayScore):
            self.storage.updateEventScore(newHomeScore: homeScore, newAwayScore: awayScore)
        
        case .updateActivePlayer(_, _, let serving):
            let mappedServing = SportRadarModelMapper.activePlayerServe(fromInternalActivePlayerServe: serving)
            self.storage.updateActivePlayer(mappedServing)
            
        case .updateEventDetailedScore(_, _, let detailedScore):
            let mappedScore = SportRadarModelMapper.score(fromInternalScore: detailedScore)
            self.storage.updateEventDetailedScore(mappedScore)
            
        // Markets
        case .updateMarketTradability(_, let marketId, let isTradable):
            self.storage.updateMarketTradability(withId: marketId, isTradable: isTradable)

        case .addMarket(_, let market):
            for outcome in market.outcomes {
                if let fractionOdd = outcome.odd.fractionOdd {
                    self.storage.updateOutcomeOdd(withId: outcome.id, newOddNumerator: String(fractionOdd.numerator), newOddDenominator: String(fractionOdd.denominator))
                }
            }
            self.storage.updateMarketTradability(withId: market.id, isTradable: market.isTradable)

        case .enableMarket(_, let marketId):
            self.storage.updateMarketTradability(withId: marketId, isTradable: true)
        case .removeMarket(_, let marketId):
            self.storage.updateMarketTradability(withId: marketId, isTradable: false)

        default:
            () // Ignore other cases
        }
    }
}

extension SportRadarEventsGroupCoordinator {

    func subscribeToEventOnListsLiveDataUpdates(withId id: String) -> AnyPublisher<Event?, Never> {
        return self.storage.subscribeToEventOnListsLiveDataUpdates(withId: id)
    }

    func subscribeToEventOnListsMarketUpdates(withId id: String) -> AnyPublisher<Market, Never>? {
        return self.storage.subscribeToEventOnListsMarketUpdates(withId: id)
    }

    func subscribeToEventOnListsOutcomeUpdates(withId id: String) -> AnyPublisher<Outcome, Never>? {
        return self.storage.subscribeToEventOnListsOutcomeUpdates(withId: id)
    }

    func containsEvent(withid id: String) -> Bool {
        return self.storage.containsEvent(withid: id)
    }
    
    func containsMarket(withid id: String) -> Bool {
        return self.storage.containsMarket(withid: id)
    }

    func containsOutcome(withid id: String) -> Bool {
        return self.storage.containsOutcome(withid: id)
    }

}

extension SportRadarEventsGroupCoordinator: UnsubscriptionController {

    func unsubscribe(subscription: Subscription) {
        let endpoint = SportRadarRestAPIClient.unsubscribe(sessionToken: subscription.sessionToken, contentIdentifier: subscription.contentIdentifier)
        guard let request = endpoint.request() else { return }
        let sessionDataTask = self.session.dataTask(with: request) { data, response, error in
            guard
                error == nil,
                let httpResponse = response as? HTTPURLResponse,
                (200...299).contains(httpResponse.statusCode)
            else {
                print("ServiceProvider.Subscription.Debug unsubscribe failed")
                return
            }
            print("ServiceProvider.Subscription.Debug unsubscribe ok")
        }
        sessionDataTask.resume()
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Events-Poseidon/EventsGroups/SportRadarEventsGroupStorage.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 01/03/2023.
//

import Foundation
import OrderedCollections
import Combine

class SportRadarEventsGroupStorage {

    private var eventSubject: CurrentValueSubject<Event?, Never>
    private var marketsDictionary: OrderedDictionary<String, CurrentValueSubject<Market, Never>>
    private var outcomesDictionary: OrderedDictionary<String, CurrentValueSubject<Outcome, Never>>

    init() {
        self.eventSubject = .init(nil)
        self.marketsDictionary = [:]
        self.outcomesDictionary = [:]
    }

    func reset() {
        self.eventSubject.send(nil)
        self.marketsDictionary = [:]
        self.outcomesDictionary = [:]
    }

    func storeEvent(_ event: Event) {
        self.marketsDictionary = [:]
        self.outcomesDictionary = [:]

        for market in event.markets {
            for outcome in market.outcomes {
                outcomesDictionary[outcome.id] = CurrentValueSubject(outcome)
            }
            marketsDictionary[market.id] = CurrentValueSubject(market)
        }
        self.eventSubject.send(event)
    }

    func storedEvent() -> Event? {
        return self.eventSubject.value
    }

}

extension SportRadarEventsGroupStorage {

//    func removedEvent(withId id: String) {
//        guard let event = self.eventSubject.value else { return }
//
//        for market in event.markets {
//            self.updateMarketTradability(withId: market.id, isTradable: false)
//        }
//    }

    // Odds updates
    func updateOutcomeOdd(withId id: String, newOddNumerator: String?, newOddDenominator: String?) {
        guard let outcomeSubject = self.outcomesDictionary[id] else { return }
        let outcome = outcomeSubject.value

        var oldNumerator: Int = 1
        var oldDenominator: Int = 1

        if case let .fraction(numerator, denominator) = outcome.odd {
            oldNumerator = numerator
            oldDenominator = denominator
        }

        let newOddNumeratorValue = Int(newOddNumerator ?? "x") ?? oldNumerator
        let newOddDenominatorValue = Int(newOddDenominator ?? "x") ?? oldDenominator

        if newOddNumeratorValue == oldNumerator && newOddDenominatorValue == oldDenominator {
            return
        }
        
        outcome.odd = OddFormat.fraction(numerator: newOddNumeratorValue, denominator: newOddDenominatorValue)
        outcomeSubject.send(outcome)
    }

    func updateOutcomeTradability(withId id: String, isTradable: Bool) {
        guard let outcomeSubject = self.outcomesDictionary[id] else { return }
        let outcome = outcomeSubject.value
        outcome.isTradable = isTradable
        outcomeSubject.send(outcome)
    }
    

    // Market updates
    func addMarket(_ market: Market) {
        if self.marketsDictionary[market.id] != nil { // We already
            updateMarketTradability(withId: market.id, isTradable: market.isTradable)
            return
        }
        else {

        }


    }

    func updateMarketTradability(withId id: String, isTradable: Bool) {
        guard
            let marketSubject = self.marketsDictionary[id]
        else {
            return
        }
        
        let market = marketSubject.value
        market.isTradable = isTradable
        marketSubject.send(market)
    }

    // Live data updates
    func updateEventStatus(newStatus: String) {
        guard let event = self.eventSubject.value else { return }
        event.status = EventStatus(value: newStatus)
        eventSubject.send(event)
    }

    func updateEventTime(newTime: String) {
        guard let event = self.eventSubject.value else { return }
        event.matchTime = newTime
        eventSubject.send(event)
    }

    func updateEventScore(newHomeScore: Int?, newAwayScore: Int?) {
        guard let event = self.eventSubject.value else { return }
        if let newHomeScoreValue = newHomeScore {
            event.homeTeamScore = newHomeScoreValue
        }
        if let newAwayScoreValue = newAwayScore {
            event.awayTeamScore = newAwayScoreValue
        }
        eventSubject.send(event)
    }
    
    func updateEventDetailedScore(_ detailedScore: Score) {
        guard let event = self.eventSubject.value else { return }
        event.scores[detailedScore.key] = detailedScore
        
        if case .matchFull(let newHomeScore, let newAwayScore) = detailedScore {
            if let newHomeScoreValue = newHomeScore {
                event.homeTeamScore = newHomeScoreValue
            }
            if let newAwayScoreValue = newAwayScore {
                event.awayTeamScore = newAwayScoreValue
            }
        }
        
        eventSubject.send(event)
    }

    func updateActivePlayer(_ activePlayerServing: ActivePlayerServe?) {
        guard let event = self.eventSubject.value else { return }
        event.activePlayerServing = activePlayerServing
        self.eventSubject.send(event)
    }
    
}

extension SportRadarEventsGroupStorage {

    func subscribeToEventOnListsLiveDataUpdates(withId id: String) -> AnyPublisher<Event?, Never> {
        return self.eventSubject.eraseToAnyPublisher()
    }

    func subscribeToEventOnListsMarketUpdates(withId id: String) -> AnyPublisher<Market, Never>? {
        if let publisher = self.marketsDictionary[id] {
            return publisher.eraseToAnyPublisher()
        }
        else {
            return nil
        }
    }

    func subscribeToEventOnListsOutcomeUpdates(withId id: String) -> AnyPublisher<Outcome, Never>? {
        return self.outcomesDictionary[id]?.eraseToAnyPublisher()
    }

    func containsEvent(withid id: String) -> Bool {
        return self.eventSubject.value?.id == id
    }

    func containsMarket(withid id: String) -> Bool {
        return self.marketsDictionary[id] != nil
    }

    func containsOutcome(withid id: String) -> Bool {
        return self.outcomesDictionary[id] != nil
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Events-Poseidon/EventsLists/SportRadarEventsPaginator.swift
````swift
//
//  SportRadarEventsPaginator.swift
//  
//
//  Created by Ruben Roques on 02/12/2022.
//

import Foundation
import Combine

class SportRadarEventsPaginator {

    let contentIdentifier: ContentIdentifier
    
    var eventsGroupPublisher: AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {
        if case let .connected(subscription) = eventsSubject.value {
            return self.eventsSubject
                .prepend(.connected(subscription: subscription))
                .eraseToAnyPublisher()
        }
        else if case .contentUpdate(_) = eventsSubject.value {
            if let subscription = self.subscription {
                return self.eventsSubject
                    .prepend(.connected(subscription: subscription))
                    .eraseToAnyPublisher()
            }
            else {
                return self.eventsSubject.eraseToAnyPublisher()
            }
        }
        else {
            return self.eventsSubject
                .eraseToAnyPublisher()
        }
    }
    
    var isActive: Bool {
        return self.subscription != nil
    }
    
    weak var subscription: Subscription?
    
    private var storage: SportRadarEventsStorage

    private var startPageIndex: Int = 0
    private var currentPage: Int

    private var hasNextPage: Bool = false

    private var sessionToken: String

    private var eventsPerPage: Int

    private var eventsSubject: CurrentValueSubject<SubscribableContent<[EventsGroup]>, ServiceProviderError>

    private var cancellables = Set<AnyCancellable>()

    init(contentIdentifier: ContentIdentifier, sessionToken: String, storage: SportRadarEventsStorage) {

        self.sessionToken = sessionToken
        self.storage = storage
        self.contentIdentifier = contentIdentifier

        self.eventsPerPage = self.contentIdentifier.contentRoute.eventCount ?? Int.max
        self.startPageIndex = 0
        self.currentPage = 0

        self.eventsSubject = .init(.disconnected)

        Publishers.CombineLatest(self.storage.eventsPublisher,
                                 self.eventsGroupPublisher.replaceError(with: .disconnected))
            .filter({ storedEvents, eventsGroupPublisher in
                switch eventsGroupPublisher {
                case .connected, .contentUpdate:
                    return true && (storedEvents != nil)
                case .disconnected:
                    return false
                }
            })
            .compactMap({ (newEvents: [Event]?, _)  in
                if let newEvents {
                    return EventsGroup(events: newEvents, marketGroupId: nil)
                }
                else {
                    return nil
                }
            })
            .sink { [weak self] (newEventsGroup: EventsGroup) in
                self?.eventsSubject.send(.contentUpdate(content: [newEventsGroup]))
            }
            .store(in: &self.cancellables)
        
        self.requestInitialPage()
            .retry(2)
            .sink(receiveCompletion: { [weak self] completion in
                switch completion {
                case .finished:
                    break
                case .failure(let error):
                    self?.eventsSubject.send(.disconnected)
                    self?.eventsSubject.send(completion: .failure(error))
                }
            }, receiveValue: { [weak self] subscribableContent in
                self?.eventsSubject.send(subscribableContent)
                
                if case .connected(let subscription) = subscribableContent {
                    self?.subscription = subscription
                }
            })
            .store(in: &self.cancellables)
    }

    deinit {
        
    }
    
    //
    private func requestInitialPage() -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {
        
        let endpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken, contentIdentifier: self.contentIdentifier)
        
        guard let request = endpoint.request() else {
            return Fail(error: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
        }

        return Future<Subscription, ServiceProviderError> { promise in
            let sessionDataTask = URLSession.shared.dataTask(with: request) { data, response, error in
                guard
                    error == nil,
                    let httpResponse = response as? HTTPURLResponse,
                    (200...299).contains(httpResponse.statusCode)
                else {
                    print("SportRadarEventsPaginator: requestInitialPage - error on subscribe to topic \(String(describing: dump(error))) \(String(describing: dump(response)))")
                    promise(.failure(ServiceProviderError.onSubscribe))
                    return
                }
                
                let subscription = Subscription(contentIdentifier: self.contentIdentifier,
                                                sessionToken: self.sessionToken,
                                                unsubscriber: self)
                promise(.success(subscription))
            }
            sessionDataTask.resume()
        }
        .map { subscription in
            return .connected(subscription: subscription)
        }
        .eraseToAnyPublisher()
    }

    // Return as boolean indicating if there is more pages
    func requestNextPage() -> AnyPublisher<Bool, ServiceProviderError> {

        if !hasNextPage {
            return Just(false).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
        }

        self.currentPage = self.currentPage + 1
        let nextPageIndex = self.currentPage

        let nextPageRoute: ContentRoute
        switch self.contentIdentifier.contentRoute {
        case .preLiveEvents(let sportAlphaId, let startDate, let endDate, _, let eventCount, let sortType):
            nextPageRoute = .preLiveEvents(sportAlphaId: sportAlphaId,
                                           startDate: startDate,
                                           endDate: endDate,
                                           pageIndex: nextPageIndex,
                                           eventCount: eventCount,
                                           sortType: sortType)
        case .liveEvents(let sportAlphaId, _):
            nextPageRoute = .liveEvents(sportAlphaId: sportAlphaId,
                                        pageIndex: nextPageIndex)
        default:
            return Just(false).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
        }

        let nextPageContentIdentifier = ContentIdentifier(contentType: self.contentIdentifier.contentType,
                                                          contentRoute: nextPageRoute)

        let endpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                         contentIdentifier: nextPageContentIdentifier)
        guard
            let request = endpoint.request()
        else {
            return Fail(error: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
        }

        let sessionDataTask = URLSession.shared.dataTask(with: request) { data, response, error in
            guard
                (error == nil),
                let httpResponse = response as? HTTPURLResponse,
                (200...299).contains(httpResponse.statusCode)
            else {
                print("SportRadarEventsPaginator: requestNextPage - error on subscribe to topic")
                return
            }
            let subscription = Subscription(contentIdentifier: nextPageContentIdentifier,
                                            sessionToken: self.sessionToken,
                                               unsubscriber: self)
            self.subscription?.associateSubscription(subscription)
        }
        sessionDataTask.resume()

        return Just(true).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
    }

    func updateEventsList(events: [Event]) {
        // If the number of received events is >= than eventsPerPage it means we can try request more
        self.hasNextPage = events.count >= self.eventsPerPage

        self.storage.storeEvents(events)
    }

    func reconnect(withNewSessionToken newSessionToken: String) {

        // Update the socket session token
        self.sessionToken = newSessionToken

        guard let subscription = self.subscription else { return }

        // Reset the storage, we will recieve every info again
        self.storage.reset()

        // Include the self subscription in the array
        var allSubscriptions = [subscription]
        allSubscriptions.append(contentsOf: subscription.associatedSubscriptions)

        // Send the REST subscribe request again
        for subscription in allSubscriptions {

            let endpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                             contentIdentifier: subscription.contentIdentifier)

            guard let request = endpoint.request() else { continue }
            let sessionDataTask = URLSession.shared.dataTask(with: request) { data, response, error in
                if let error {
                    print("SportRadarEventsPaginator: reconnect dataTask contentIdentifier \(subscription.contentIdentifier) error \(error)")
                }
                if let data, let dataString = String(data: data, encoding: .utf8) {
                    print("SportRadarEventsPaginator: reconnect dataTask contentIdentifier \(subscription.contentIdentifier) data \(dataString)")
                }
            }
            sessionDataTask.resume()
        }

    }

}

extension SportRadarEventsPaginator {

    func handleContentUpdate(_ content: SportRadarModels.ContentContainer) {

        guard
            let updatedContentIdentifier = content.contentIdentifier
        else {
            // print("☁️SP debugdetails SportRadarEventsPaginator ignoring contentIdentifierLess \(content)")
            return
        }

        if self.contentIdentifier.contentType == updatedContentIdentifier.contentType
            && self.contentIdentifier.contentRoute.pageableRoute == updatedContentIdentifier.contentRoute.pageableRoute {
            // It's a valid update for this paginator
        }
        else {
            // ignoring this update, not subscribed by this class
            // print("☁️SP debugdetails SportRadarEventsPaginator ignoring \(updatedContentIdentifier)")
            return
        }

        // print("☁️SP debugdetails SportRadarEventsPaginator handleContentUpdate \(content)")

        switch content {

        case .updateOutcomeOdd(_, let selectionId, let newOddNumerator, let newOddDenominator):
            self.storage.updateOutcomeOdd(withId: selectionId, newOddNumerator: newOddNumerator, newOddDenominator: newOddDenominator)
        case .updateOutcomeTradability(_, let selectionId, let isTradable):
            self.storage.updateOutcomeTradability(withId: selectionId, isTradable: isTradable)

        case .updateMarketTradability(_, let marketId, let isTradable):
            self.storage.updateMarketTradability(withId: marketId, isTradable: isTradable)

        //
        case .updateEventLiveDataExtended(_, let eventId, let eventLiveDataExtended):
            if let newTime = eventLiveDataExtended.matchTime {
                self.storage.updateEventTime(withId: eventId, newTime: newTime)
            }
            if let newStatus = eventLiveDataExtended.status {
                self.storage.updateEventStatus(withId: eventId, newStatus: newStatus.stringValue)
            }
            self.storage.updateEventScore(withId: eventId, newHomeScore: eventLiveDataExtended.homeScore, newAwayScore: eventLiveDataExtended.awayScore)

        case .updateEventState(_, let eventId, let newStatus):
            self.storage.updateEventStatus(withId: eventId, newStatus: newStatus)
        case .updateEventTime(_, let eventId, let newTime):
            self.storage.updateEventTime(withId: eventId, newTime: newTime)
        case .updateEventScore(_, let eventId, let homeScore, let awayScore):
            self.storage.updateEventScore(withId: eventId, newHomeScore: homeScore, newAwayScore: awayScore)

        case .updateActivePlayer(_, let eventId, let serving):
            let mappedServing = SportRadarModelMapper.activePlayerServe(fromInternalActivePlayerServe: serving)
            self.storage.updateActivePlayer(withId: eventId, activePlayerServing: mappedServing)
            
        case .updateEventDetailedScore(_, let eventId, let detailedScore):
            let mappedScore = SportRadarModelMapper.score(fromInternalScore: detailedScore)
            self.storage.updateEventDetailedScore(withId: eventId, detailedScore: mappedScore)
            
        //
        case .addMarket(_ , let market):
            for outcome in market.outcomes {
                if let fractionOdd = outcome.odd.fractionOdd {
                    self.storage.updateOutcomeOdd(withId: outcome.id, newOddNumerator: String(fractionOdd.numerator), newOddDenominator: String(fractionOdd.denominator))
                }
            }
            self.storage.updateMarketTradability(withId: market.id, isTradable: market.isTradable)

        case .enableMarket(_, let marketId):
            self.storage.updateMarketTradability(withId: marketId, isTradable: true)
        case .removeMarket(_, let marketId):
            self.storage.updateMarketTradability(withId: marketId, isTradable: false)
        case .removeEvent(_, let eventId):
            self.storage.removedEvent(withId: eventId)
        case .addEvent(_, let updatedEvent):
            let mappedEvent = SportRadarModelMapper.event(fromInternalEvent: updatedEvent)
            self.storage.addEvent(withEvent: mappedEvent)
            
        default:
            () // Ignore other cases
        }
    }

}

extension SportRadarEventsPaginator {

    func subscribeToEventOnListsLiveDataUpdates(withId id: String) -> AnyPublisher<Event, Never>? {
        return self.storage.subscribeToEventOnListsLiveDataUpdates(withId: id)
    }

    func subscribeToEventOnListsMarketUpdates(withId id: String) -> AnyPublisher<Market, Never>? {
        return self.storage.subscribeToEventOnListsMarketUpdates(withId: id)
    }

    func subscribeToEventOnListsOutcomeUpdates(withId id: String) -> AnyPublisher<Outcome, Never>? {
        return self.storage.subscribeToEventOnListsOutcomeUpdates(withId: id)
    }

    func containsEvent(withid id: String) -> Bool {
        return self.storage.containsEvent(withid: id)
    }

    func containsMarket(withid id: String) -> Bool {
        return self.storage.containsMarket(withid: id)
    }

    func containsOutcome(withid id: String) -> Bool {
        return self.storage.containsOutcome(withid: id)
    }

}

extension SportRadarEventsPaginator: UnsubscriptionController {

    func unsubscribe(subscription: Subscription) {
        let endpoint = SportRadarRestAPIClient.unsubscribe(sessionToken: subscription.sessionToken, contentIdentifier: subscription.contentIdentifier)
        guard let request = endpoint.request() else { return }
        
        let sessionDataTask = URLSession.shared.dataTask(with: request) { data, response, error in
            guard
                error == nil,
                let httpResponse = response as? HTTPURLResponse,
                (200...299).contains(httpResponse.statusCode)
            else {
                return
            }
            // print("SportRadarEventsPaginator unsubscribe ok")
        }
        sessionDataTask.resume()
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Events-Poseidon/EventsLists/SportRadarEventsStorage.swift
````swift
//
//  SportRadarEventsStorage.swift
//  
//
//  Created by Ruben Roques on 23/11/2022.
//

import Foundation
import OrderedCollections
import Combine

class SportRadarEventsStorage {

    var eventsPublisher: AnyPublisher<[Event]?, Never> {
        return self.eventsSubject.eraseToAnyPublisher()
    }

    private var eventsSubject: CurrentValueSubject<[Event]?, Never> = .init(nil)

    private var eventsDictionary: OrderedDictionary<String, CurrentValueSubject<Event, Never>>
    private var marketsDictionary: OrderedDictionary<String, CurrentValueSubject<Market, Never>>
    private var outcomesDictionary: OrderedDictionary<String, CurrentValueSubject<Outcome, Never>>

    init() {
        self.eventsSubject.send(nil)

        self.eventsDictionary = [:]
        self.marketsDictionary = [:]
        self.outcomesDictionary = [:]
    }

    func reset() {
        self.eventsSubject.send(nil)

        self.eventsDictionary = [:]
        self.marketsDictionary = [:]
        self.outcomesDictionary = [:]
    }

    func storeEvents(_ events: [Event]) {

        for event in events {
            for market in event.markets {
                for outcome in market.outcomes {
                    outcomesDictionary[outcome.id] = CurrentValueSubject(outcome)
                }
                marketsDictionary[market.id] = CurrentValueSubject(market)
            }
            eventsDictionary[event.id] = CurrentValueSubject(event)
        }

        // Avoid duplication, we just just a values of the dictionary
        let subjectValues = self.eventsDictionary.values
        let orderedEvents = Array(subjectValues).map(\.value)
        self.eventsSubject.send(orderedEvents)
    }

}

extension SportRadarEventsStorage {

    func addEvent(withEvent updatedEvent: Event) {

        if let storedEvent = self.eventsDictionary[updatedEvent.id]?.value {
            for market in storedEvent.markets {
                self.updateMarketTradability(withId: market.id, isTradable: market.isTradable)
            }
        }
        else {
            self.storeEvents([updatedEvent])
        }

    }

    func removedEvent(withId id: String) {
        guard let eventSubject = self.eventsDictionary[id] else { return }
        let event = eventSubject.value

        for market in event.markets {
            self.updateMarketTradability(withId: market.id, isTradable: false)
        }

        let newEventsList = (self.eventsSubject.value ?? []).filter({ event in
            return event.id != id
        })

        self.eventsSubject.send(newEventsList)
    }

    func updateOutcomeOdd(withId id: String, newOddNumerator: String?, newOddDenominator: String?) {
        guard let outcomeSubject = self.outcomesDictionary[id] else { return }
        let outcome = outcomeSubject.value

        var oldNumerator: Int = 1
        var oldDenominator: Int = 1

        if case let .fraction(numerator, denominator) = outcome.odd {
            oldNumerator = numerator
            oldDenominator = denominator
        }

        let newOddNumeratorValue = Int(newOddNumerator ?? "x") ?? oldNumerator
        let newOddDenominatorValue = Int(newOddDenominator ?? "x") ?? oldDenominator

        if newOddNumeratorValue == oldNumerator && newOddDenominatorValue == oldDenominator {
            return
        }

        outcome.odd = OddFormat.fraction(numerator: newOddNumeratorValue, denominator: newOddDenominatorValue)
        outcomeSubject.send(outcome)
    }

    func updateOutcomeTradability(withId id: String, isTradable: Bool) {
        guard let outcomeSubject = self.outcomesDictionary[id] else { return }
        let outcome = outcomeSubject.value
        outcome.isTradable = isTradable
        outcomeSubject.send(outcome)
    }
    
    func updateMarketTradability(withId id: String, isTradable: Bool) {
        guard
            let marketSubject = self.marketsDictionary[id]
        else {
            // print("PaginatorStorage updateMarketTradability \(id) not found to isTradable:\(isTradable)")
            return
        }
        let market = marketSubject.value

        // print("PaginatorStorage updateMarketTradability \(id) isTradable:\(isTradable)")
        market.isTradable = isTradable
        marketSubject.send(market)
    }

    func updateEventStatus(withId id: String, newStatus: String) {
        guard let eventSubject = self.eventsDictionary[id] else { return }
        let event = eventSubject.value

        event.status = EventStatus(value: newStatus)

        eventSubject.send(event)
    }

    func updateEventTime(withId id: String, newTime: String) {
        guard let eventSubject = self.eventsDictionary[id] else { return }
        let event = eventSubject.value

        event.matchTime = newTime

        eventSubject.send(event)
    }

    func updateEventScore(withId id: String, newHomeScore: Int?, newAwayScore: Int?) {
        guard let eventSubject = self.eventsDictionary[id] else { return }
        let event = eventSubject.value

        event.homeTeamScore = newHomeScore
        event.awayTeamScore = newAwayScore

        eventSubject.send(event)
    }
    
    func updateEventDetailedScore(withId id: String, detailedScore: Score) {
        guard let eventSubject = self.eventsDictionary[id] else { return }
        let event = eventSubject.value
        event.scores[detailedScore.key] = detailedScore
        
        if case .matchFull(let newHomeScore, let newAwayScore) = detailedScore {
            if let newHomeScoreValue = newHomeScore {
                event.homeTeamScore = newHomeScoreValue
            }
            if let newAwayScoreValue = newAwayScore {
                event.awayTeamScore = newAwayScoreValue
            }
        }
        
        eventSubject.send(event)
    }
    
    func updateActivePlayer(withId id: String, activePlayerServing: ActivePlayerServe?) {
        guard let eventSubject = self.eventsDictionary[id] else { return }
        let event = eventSubject.value
        
        event.activePlayerServing = activePlayerServing
        eventSubject.send(event)
    }
    
}

extension SportRadarEventsStorage {

    func subscribeToEventOnListsLiveDataUpdates(withId id: String) -> AnyPublisher<Event, Never>? {
        return self.eventsDictionary[id]?.eraseToAnyPublisher()
    }

    func subscribeToEventOnListsMarketUpdates(withId id: String) -> AnyPublisher<Market, Never>? {
        return self.marketsDictionary[id]?.eraseToAnyPublisher()
    }

    func subscribeToEventOnListsOutcomeUpdates(withId id: String) -> AnyPublisher<Outcome, Never>? {
        return self.outcomesDictionary[id]?.eraseToAnyPublisher()
    }

    func containsEvent(withid id: String) -> Bool {
        return self.eventsDictionary[id] != nil
    }

    func containsMarket(withid id: String) -> Bool {
        return self.marketsDictionary[id] != nil
    }

    func containsOutcome(withid id: String) -> Bool {
        return self.outcomesDictionary[id] != nil
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Events-Poseidon/LiveEventDetails/SportRadarLiveEventDataCoordinator.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 14/10/2023.
//

import Foundation
import Combine

//
// This class subscribes only to the Live details of the event.
class SportRadarLiveEventDataCoordinator {

    var sessionToken: String

    let liveEventContentIdentifier: ContentIdentifier

    // TODO: check why live highlights in home are losing the reference to this subscription
    var liveDataExtendedSubscription: Subscription?
    var isActive: Bool {
        if self.waitingSubscription {
            // We haven't tried to subscribe or the
            // subscribe request it's ongoing right now
            return true
        }
        return self.liveDataExtendedSubscription != nil
    }

    var eventLiveDataPublisher: AnyPublisher<SubscribableContent<EventLiveData>, ServiceProviderError> {
        return liveEventCurrentValueSubject
            .eraseToAnyPublisher()
    }

    private var liveEventCurrentValueSubject: CurrentValueSubject<SubscribableContent<EventLiveData>, ServiceProviderError> = .init(.disconnected)
    
    private var eventLiveData: EventLiveData? {
        set {
            if let eventLiveData = newValue {
                self.liveEventCurrentValueSubject.send(.contentUpdate(content: eventLiveData))
            }
        }
        get {
            switch self.liveEventCurrentValueSubject.value {
            case .disconnected, .connected:
                return nil
            case .contentUpdate(let eventLiveDataValue):
                return eventLiveDataValue
            }
        }
    }
    
    private let eventIdObserved: String
    private var waitingSubscription = true
    private let decoder = JSONDecoder()
    private let session = URLSession.init(configuration: .default)
    
    private var cancellables = Set<AnyCancellable>()

    init(eventId: String, sessionToken: String, storage: SportRadarEventStorage, liveDataExtendedSubscription: Subscription? = nil) {
        self.eventIdObserved = eventId
        
        self.liveDataExtendedSubscription = liveDataExtendedSubscription
        self.sessionToken = sessionToken

        let liveDataContentType = ContentType.eventDetailsLiveData
        let liveDataContentRoute = ContentRoute.eventDetailsLiveData(eventId: eventId)
        let liveDataContentIdentifier = ContentIdentifier(contentType: liveDataContentType, contentRoute: liveDataContentRoute)

        self.liveEventContentIdentifier = liveDataContentIdentifier

        self.waitingSubscription = true
        
        // Boot the coordinator
        self.checkLiveEventDetailsAvailable()
            .flatMap { [weak self] _ -> AnyPublisher<Bool, ServiceProviderError>  in
                guard let self = self else {
                    return Fail(error: ServiceProviderError.onSubscribe).eraseToAnyPublisher()
                }
                
                if let liveDataExtendedSubscription = self.liveDataExtendedSubscription {
                    self.liveEventCurrentValueSubject.send(.connected(subscription: liveDataExtendedSubscription))
                }
                else {
                    let liveDataExtendedSubscription = Subscription(contentIdentifier: self.liveEventContentIdentifier,
                                                    sessionToken: self.sessionToken,
                                                    unsubscriber: self)
                    self.liveEventCurrentValueSubject.send(.connected(subscription: liveDataExtendedSubscription))
                    self.liveDataExtendedSubscription = liveDataExtendedSubscription
                }
                self.waitingSubscription = false
                
                return self.subscribeLiveEventDetails()
            }
            .sink { [weak self] completion in
                guard let self = self else { return }
                switch completion {
                case .finished:
                   break
                case .failure(let error):
                    self.liveEventCurrentValueSubject.send(completion: .failure(error))
                }
                self.waitingSubscription = false
            } receiveValue: { connected in
                // [weak self] Publish the event live details
                print("checkLiveEventDetailsAvailable connected \(connected)")
            }
            .store(in: &self.cancellables)

    }
    
    deinit {
        
    }

    private func checkLiveEventDetailsAvailable() -> AnyPublisher<Void, ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.get(contentIdentifier: self.liveEventContentIdentifier)

        guard
            let request = endpoint.request()
        else {
            return Fail(error: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
        }

        return self.session.dataTaskPublisher(for: request)
            .retry(1)
            .map({ return String(data: $0.data, encoding: .utf8) ?? "" })
            .mapError({ _ in return ServiceProviderError.resourceUnavailableOrDeleted })
            .flatMap { responseString -> AnyPublisher<Void, ServiceProviderError> in
                if responseString.uppercased().contains("CONTENT_NOT_FOUND") {
                    return Fail(outputType: Void.self, failure: ServiceProviderError.resourceUnavailableOrDeleted).eraseToAnyPublisher()
                }
                else {
                    return Just(()).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                }
            }
            .eraseToAnyPublisher()

    }

    func subscribeLiveEventDetails() -> AnyPublisher<Bool, ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                         contentIdentifier: self.liveEventContentIdentifier)

        guard
            let request = endpoint.request()
        else {
            return Fail(error: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
        }    
        
        return self.session.dataTaskPublisher(for: request)
            .tryMap { data, response -> Data in
                guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {
                    throw ServiceProviderError.onSubscribe
                }
                return data
            }
            .tryMap { data in
                do {
                    if let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] {
                        if let version = json["version"] as? Int {
                            return version
                        }
                    }
                    throw ServiceProviderError.invalidResponse
                } catch {
                    throw ServiceProviderError.invalidResponse
                }
            }
            .map { version in
                return version != 0
            }
            .mapError { error in
                if let typedError = error as? ServiceProviderError {
                    return typedError
                }
               return ServiceProviderError.onSubscribe
            }
            .eraseToAnyPublisher()
    }

    func reconnect(withNewSessionToken newSessionToken: String) {
        self.sessionToken = newSessionToken

        //
        //
        let marketsEndpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                                contentIdentifier: self.liveEventContentIdentifier)

        guard let marketsRequest = marketsEndpoint.request() else { return }
        let marketsSessionDataTask = self.session.dataTask(with: marketsRequest) { data, response, error in
            if let error {
                print("SportRadarEventDetailsCoordinator: reconnect dataTask contentIdentifier \(self.liveEventContentIdentifier) error \(error)")
            }
            if let data, let dataString = String(data: data, encoding: .utf8) {
                print("SportRadarEventDetailsCoordinator: reconnect dataTask contentIdentifier \(self.liveEventContentIdentifier) data \(dataString)")
            }
        }
        marketsSessionDataTask.resume()

    }

}


extension SportRadarLiveEventDataCoordinator {

    func updatedLiveData(eventLiveDataExtended: SportRadarModels.EventLiveDataExtended, forContentIdentifier contentIdentifier: ContentIdentifier) {

        guard
            contentIdentifier == self.liveEventContentIdentifier
        else {
            return
        }

        if let newStatus = eventLiveDataExtended.status?.stringValue {
            self.updateEventStatus(newStatus: newStatus)
        }
        if let newTime = eventLiveDataExtended.matchTime {
            self.updateEventTime(newTime: newTime)
        }

        self.updateEventScore(newHomeScore: eventLiveDataExtended.homeScore, newAwayScore: eventLiveDataExtended.awayScore)

        let mappedEventLiveData = SportRadarModelMapper.eventLiveData(fromInternalEventLiveData: eventLiveDataExtended)
        
        self.eventLiveData = mappedEventLiveData
    }

    func handleContentUpdate(_ content: SportRadarModels.ContentContainer) {

        guard
            let updatedContentIdentifier = content.contentIdentifier,
            self.liveEventContentIdentifier == updatedContentIdentifier
        else {
            return
        }

        switch content {
        case .updateEventLiveDataExtended(_, _, let eventLiveDataExtended):
            if let newTime = eventLiveDataExtended.matchTime {
                self.updateEventTime(newTime: newTime)
            }
            if let newStatus = eventLiveDataExtended.status {
                self.updateEventStatus(newStatus: newStatus.stringValue)
            }
            
            for score in eventLiveDataExtended.scores.values {
                let mappedScore = SportRadarModelMapper.score(fromInternalScore: score)
                self.updateEventDetailedScore(mappedScore)
            }
            
            self.updateEventScore(newHomeScore: eventLiveDataExtended.homeScore, newAwayScore: eventLiveDataExtended.awayScore)
            
        case .updateEventDetailedScore(_, _, let detailedScore):
            let mappedScore = SportRadarModelMapper.score(fromInternalScore: detailedScore)
            self.updateEventDetailedScore(mappedScore)
        
        case .updateActivePlayer(_, _, let serving):
            let mappedServing = SportRadarModelMapper.activePlayerServe(fromInternalActivePlayerServe: serving)
            self.updateActivePlayer(mappedServing)
            
        default:
            break // Ignore other cases
        }
    }
    
    func containsEvent(withid id: String) -> Bool {
        return self.eventIdObserved == id
    }
    
}

extension SportRadarLiveEventDataCoordinator {
    
    func updateActivePlayer(_ activePlayerServing: ActivePlayerServe?) {
        guard var event = self.eventLiveData else { return }
        event.activePlayerServing = activePlayerServing
        self.eventLiveData = event
    }
    
    func updateEventStatus(newStatus: String) {
        guard var event = self.eventLiveData else { return }
        event.status = EventStatus(value: newStatus)
        self.eventLiveData = event
    }

    func updateEventTime(newTime: String) {
        guard var event = self.eventLiveData else { return }
        event.matchTime = newTime
        self.eventLiveData = event
    }

    func updateEventScore(newHomeScore: Int?, newAwayScore: Int?) {
        guard var event = self.eventLiveData else { return }
        if let newHomeScoreValue = newHomeScore {
            event.homeScore = newHomeScoreValue
        }
        if let newAwayScoreValue = newAwayScore {
            event.awayScore = newAwayScoreValue
        }
        self.eventLiveData = event
    }
    
    func updateEventDetailedScore(_ detailedScore: Score) {
        guard var event = self.eventLiveData else { return }
        
        if var detailedScores = event.detailedScores {
            detailedScores[detailedScore.key] = detailedScore
            event.detailedScores = detailedScores
        }
        else {
            event.detailedScores = [detailedScore.key: detailedScore]
        }
        
        if case .matchFull(let newHomeScore, let newAwayScore) = detailedScore {
            event.homeScore = newHomeScore
            event.awayScore = newAwayScore
        }
        
        self.eventLiveData = event
    }
    
}

extension SportRadarLiveEventDataCoordinator: UnsubscriptionController {

    func unsubscribe(subscription: Subscription) {
        let endpoint = SportRadarRestAPIClient.unsubscribe(sessionToken: subscription.sessionToken, contentIdentifier: subscription.contentIdentifier)
        guard let request = endpoint.request() else { return }
        let sessionDataTask = self.session.dataTask(with: request) { data, response, error in
            guard
                error == nil,
                let httpResponse = response as? HTTPURLResponse,
                (200...299).contains(httpResponse.statusCode)
            else {
                print("ServiceProvider.Subscription.Debug unsubscribe failed")
                return
            }
        }
        sessionDataTask.resume()
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Events-Poseidon/MarketUpdates/SportRadarEventSecundaryMarketsCoordinator.swift
````swift
//
//  SportRadarEventMarketsCoordinator.swift
//
//
//  Created by Ruben Roques on 15/04/2024.
//

import Foundation
import Combine
import OrderedCollections


class SportRadarEventMarketsCoordinator {

    var storage: SportRadarEventStorage
    var sessionToken: String

    let eventMainMarketIdentifier: ContentIdentifier

    let eventSecundaryMarketsIdentifier: ContentIdentifier
    
    // TODO: check why live highlights in home are losing the reference to this subscription.
    // TODO: IMPORTANT: This vars needs to be weak for the auto unsubscribe to work
    var subscription: Subscription?
    
    var isActive: Bool {
        if self.waitingSubscription {
            // We haven't tried to subscribe or the
            // subscribe request it's ongoing right now
            return true
        }
        
        return self.subscription != nil
    }

    var eventWithSecundaryMarketsPublisher: AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {
        return self.eventWithSecundaryMarketsSubject
            .throttle(for: .milliseconds(800), scheduler: DispatchQueue.main, latest: true)
            .eraseToAnyPublisher()
    }

    private var eventWithSecundaryMarketsSubject: CurrentValueSubject<SubscribableContent<Event>, ServiceProviderError> = .init(.disconnected)
    
    private var waitingSubscription = true
    private let decoder = JSONDecoder()
    private let session = URLSession.init(configuration: .default)
    
    private var cancellables = Set<AnyCancellable>()

    init(matchId: String, sessionToken: String, storage: SportRadarEventStorage) {
        self.sessionToken = sessionToken
        self.storage = storage

        let eventMainMarketType = ContentType.eventMainMarket
        let eventMainMarketRoute = ContentRoute.eventMainMarket(eventId: matchId)
        let eventMainMarketIdentifier = ContentIdentifier(contentType: eventMainMarketType,
                                                                contentRoute: eventMainMarketRoute)

        self.eventMainMarketIdentifier = eventMainMarketIdentifier

        let eventSecundaryMarketsType = ContentType.eventSecundaryMarkets
        let eventSecundaryMarketsRoute = ContentRoute.eventSecundaryMarkets(eventId: matchId)
        let eventSecundaryMarketsIdentifier = ContentIdentifier(contentType: eventSecundaryMarketsType,
                                                                contentRoute: eventSecundaryMarketsRoute)

        self.eventSecundaryMarketsIdentifier = eventSecundaryMarketsIdentifier
        
        self.subscription = nil
        self.waitingSubscription = true
        
        Publishers.CombineLatest(self.storage.eventPublisher,
                                 self.eventWithSecundaryMarketsSubject.replaceError(with: .disconnected))
        .filter({ storedEvent, eventWithSecundaryMarketsSubject in
            switch eventWithSecundaryMarketsSubject {
            case .connected, .contentUpdate:
                return true && (storedEvent != nil)
            case .disconnected:
                return false
            }
        })
        .compactMap({ updatedStoredEvent, _  in
            if let updatedStoredEvent {
                return updatedStoredEvent
            }
            else {
                return nil
            }
        })
        .sink { completion in
            
        } receiveValue: { [weak self] updatedStoredEvent in
            self?.eventWithSecundaryMarketsSubject.send(.contentUpdate(content: updatedStoredEvent))
        }
        .store(in: &self.cancellables)

    }

    deinit {
        let debugPrint = "SportRadarEventMarketsCoordinator deinit \(self.eventSecundaryMarketsIdentifier)"
        print(debugPrint)
    }
    
    func start() {
        // Boot the coordinator
        self.subscribeEventMainMarkets()
        self.subscribeEventSecundaryMarkets()
    }

    func subscribeEventMainMarkets() {
        let endpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                         contentIdentifier: self.eventMainMarketIdentifier)

        guard
            let request = endpoint.request()
        else {
            return
        }

        return self.session.dataTaskPublisher(for: request)
            .tryMap { data, response -> Data in
                guard
                    let httpResponse = response as? HTTPURLResponse,
                    (200...299).contains(httpResponse.statusCode)
                else {
                    throw ServiceProviderError.onSubscribe
                }
                return data
            }
            .mapError { _ in ServiceProviderError.onSubscribe }
            .flatMap { data -> AnyPublisher<Void, ServiceProviderError> in
                if let responseString = String(data: data, encoding: .utf8), responseString.lowercased().contains("version") {
                    return Just(()).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                } else {
                    return Fail(error: ServiceProviderError.onSubscribe).eraseToAnyPublisher()
                }
            }
            .sink(receiveCompletion: { [weak self] completion in
                switch completion {
                case .finished:
                    break
                case .failure(let failure):
                    self?.subscription = nil
                    print("subscribeEventSecundaryMarkets completed with error: \(failure)")
                }
                self?.waitingSubscription = false
            }, receiveValue: { [weak self] in
                if let self = self {
                    let subscription = Subscription(contentIdentifier: self.eventMainMarketIdentifier,
                                                    sessionToken: self.sessionToken,
                                                    unsubscriber: self)
                    self.eventWithSecundaryMarketsSubject.send(.connected(subscription: subscription))

                    if let currentSubscription = self.subscription {
                        currentSubscription.associateSubscription(subscription)
                    }
                    else {
                        self.subscription = subscription
                    }
                }

            })
            .store(in: &self.cancellables)
    }

    func subscribeEventSecundaryMarkets() {
        let endpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                         contentIdentifier: self.eventSecundaryMarketsIdentifier)

        guard
            let request = endpoint.request()
        else {
            return
        }

        return self.session.dataTaskPublisher(for: request)
            .tryMap { data, response -> Data in
                guard
                    let httpResponse = response as? HTTPURLResponse,
                    (200...299).contains(httpResponse.statusCode)
                else {
                    throw ServiceProviderError.onSubscribe
                }
                return data
            }
            .mapError { _ in ServiceProviderError.onSubscribe }
            .flatMap { data -> AnyPublisher<Void, ServiceProviderError> in
                if let responseString = String(data: data, encoding: .utf8), responseString.lowercased().contains("version") {
                    return Just(()).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                } else {
                    return Fail(error: ServiceProviderError.onSubscribe).eraseToAnyPublisher()
                }
            }
            .sink(receiveCompletion: { [weak self] completion in
                switch completion {
                case .finished:
                    break
                case .failure(let failure):
                    self?.subscription = nil
                    print("subscribeEventSecundaryMarkets completed with error: \(failure)")
                }
                self?.waitingSubscription = false
            }, receiveValue: { [weak self] in
                if let self = self {
                    let subscription = Subscription(contentIdentifier: self.eventSecundaryMarketsIdentifier,
                                                    sessionToken: self.sessionToken,
                                                    unsubscriber: self)
                    self.eventWithSecundaryMarketsSubject.send(.connected(subscription: subscription))

                    if let currentSubscription = self.subscription {
                        currentSubscription.associateSubscription(subscription)
                    }
                    else {
                        self.subscription = subscription
                    }
                }
            })
            .store(in: &self.cancellables)
    }

    func reconnect(withNewSessionToken newSessionToken: String) {
        self.sessionToken = newSessionToken
        self.storage.reset()

        //
        //
        let secundaryMarketsEndpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                                contentIdentifier: self.eventSecundaryMarketsIdentifier)

        guard let secundarMarketsRequest = secundaryMarketsEndpoint.request() else { return }
        let secundaryMarketsSessionDataTask = self.session.dataTask(with: secundarMarketsRequest) { data, response, error in
            if let error {
                print("SportRadarEventMarketsCoordinator: reconnect dataTask contentIdentifier \(self.eventSecundaryMarketsIdentifier) error \(error)")
            }
            if let data, let dataString = String(data: data, encoding: .utf8) {
                print("SportRadarEventMarketsCoordinator: reconnect dataTask contentIdentifier \(self.eventSecundaryMarketsIdentifier) data \(dataString)")
            }
        }
        secundaryMarketsSessionDataTask.resume()

    }

}


extension SportRadarEventMarketsCoordinator {

    func updatedMainMarket(forContentIdentifier identifier: ContentIdentifier, onEvent event: Event) {

        if self.eventMainMarketIdentifier != identifier {
            return
        }

        self.storage.storeEvent(event, withMainMarket: true)
    }

    func updatedSecundaryMarkets(forContentIdentifier identifier: ContentIdentifier, onEvent event: Event) {

        if self.eventSecundaryMarketsIdentifier != identifier {
            return
        }

        self.storage.storeSecundaryMarkets(event.markets)
    }
    
    func handleContentUpdate(_ content: SportRadarModels.ContentContainer) {

        if content.contentIdentifier?.contentType == .eventSecundaryMarkets {
            return
        }

        guard
            let updatedContentIdentifier = content.contentIdentifier
        else {
            return
        }

        guard
            self.eventSecundaryMarketsIdentifier == updatedContentIdentifier || self.eventMainMarketIdentifier == updatedContentIdentifier
        else {
            return
        }

        switch content {

        case .updateOutcomeOdd(_, let selectionId, let newOddNumerator, let newOddDenominator):
            self.storage.updateOutcomeOdd(withId: selectionId, newOddNumerator: newOddNumerator, newOddDenominator: newOddDenominator)
        case .updateOutcomeTradability(_, let selectionId, let isTradable):
            self.storage.updateOutcomeTradability(withId: selectionId, isTradable: isTradable)

        case .updateMarketTradability(_, let marketId, let isTradable):
            self.storage.updateMarketTradability(withId: marketId, isTradable: isTradable)

        //
        case .addMarket(let contentIdentifier, let market):
            let mappedMarket = SportRadarModelMapper.market(fromInternalMarket: market)
            if contentIdentifier.contentType == .eventMainMarket {
                self.storage.addMainMarket(mappedMarket)
            }
            else {
                self.storage.addMarket(mappedMarket)
            }

        case .enableMarket(_, let marketId):
            self.storage.updateMarketTradability(withId: marketId, isTradable: true)
            
        case .removeMarket(let contentIdentifier, let marketId):
            if contentIdentifier.contentType == .eventMainMarket {
                self.storage.removeMainMarket(withId: marketId)
            }
            else {
                self.storage.removeMarket(withId: marketId)
            }

        default:
            () // Ignore other cases
        }
    }

}

extension SportRadarEventMarketsCoordinator {

    func subscribeToEventOnListsLiveDataUpdates(withId id: String) -> AnyPublisher<Event?, Never> {
        return self.storage.subscribeToEventOnListsLiveDataUpdates(withId: id)
    }

    func subscribeToEventOnListsMarketUpdates(withId id: String) -> AnyPublisher<Market, Never>? {
        return self.storage.subscribeToEventOnListsMarketUpdates(withId: id)
    }

    func subscribeToEventOnListsOutcomeUpdates(withId id: String) -> AnyPublisher<Outcome, Never>? {
        return self.storage.subscribeToEventOnListsOutcomeUpdates(withId: id)
    }

    func containsEvent(withid id: String) -> Bool {
        return self.storage.containsEvent(withid: id)
    }
    
    func containsMarket(withid id: String) -> Bool {
        return self.storage.containsMarket(withid: id)
    }

    func containsOutcome(withid id: String) -> Bool {
        return self.storage.containsOutcome(withid: id)
    }

}

extension SportRadarEventMarketsCoordinator: UnsubscriptionController {

    func unsubscribe(subscription: Subscription) {
        let endpoint = SportRadarRestAPIClient.unsubscribe(sessionToken: subscription.sessionToken, contentIdentifier: subscription.contentIdentifier)
        guard let request = endpoint.request() else { return }
        let sessionDataTask = self.session.dataTask(with: request) { data, response, error in
            guard
                error == nil,
                let httpResponse = response as? HTTPURLResponse,
                (200...299).contains(httpResponse.statusCode)
            else {
                print("ServiceProvider.Subscription.Debug unsubscribe failed")
                return
            }
            print("ServiceProvider.Subscription.Debug unsubscribe ok")
        }
        sessionDataTask.resume()
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Events-Poseidon/MarketUpdates/SportRadarMarketDetailsCoordinator.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 07/03/2023.
//

import Foundation
import Combine
import OrderedCollections

class SportRadarMarketDetailsCoordinator {

    var sessionToken: String
    let contentIdentifier: ContentIdentifier

    weak var subscription: Subscription?
    var isActive: Bool {
        return self.subscription != nil
    }

    var marketPublisher: AnyPublisher<SubscribableContent<Market>, ServiceProviderError> {
        return marketCurrentValueSubject.eraseToAnyPublisher()
    }

    private var marketCurrentValueSubject: CurrentValueSubject<SubscribableContent<Market>, ServiceProviderError>
    private var market: Market? {
        switch self.marketCurrentValueSubject.value {
        case .disconnected:
            return nil
        case .connected:
            return nil
        case .contentUpdate(let content):
            return content
        }
    }

    private var outcomesDictionary: OrderedDictionary<String, CurrentValueSubject<Outcome, Never>>

    private let marketId: String
    private let eventId: String

    private let decoder = JSONDecoder()
    private let session = URLSession.init(configuration: .default)

    private var marketCancellable: AnyCancellable?

    init(marketId: String, eventId: String, sessionToken: String, contentIdentifier: ContentIdentifier) {

        print("SportRadarMarketDetailsCoordinator new \(contentIdentifier)")
        
        self.marketId = marketId
        self.eventId = eventId

        self.sessionToken = sessionToken
        self.contentIdentifier = contentIdentifier
        self.subscription = nil

        self.outcomesDictionary = [:]
        
        self.marketCurrentValueSubject = .init(.disconnected)

        self.connectListenner()
    }

    private func connectListenner() {
        
        self.marketCancellable?.cancel()
        self.marketCancellable = nil
        
        // Boot the coordinator
        self.marketCancellable = self.checkMarketUpdatesAvailable()
            .flatMap { [weak self] market -> AnyPublisher<Void, ServiceProviderError>  in
                guard let self = self else {
                    return Fail(error: ServiceProviderError.onSubscribe).eraseToAnyPublisher()
                }
                
                // Create the subscription
                let subscription = Subscription(contentIdentifier: self.contentIdentifier, sessionToken: self.sessionToken, unsubscriber: self)
                self.marketCurrentValueSubject.send(.connected(subscription: subscription))
                self.subscription = subscription
                
                // update with the market from the get request
                self.updateMarket(market)
                
                return self.requestMarketUpdates()
            }
            .sink(receiveCompletion: { [weak self] completion in
                switch completion {
                case .finished:
                    break
                case .failure(let error):
                    self?.subscription = nil
                    self?.marketCurrentValueSubject.send(completion: .failure(error))
                }
                
            }, receiveValue: { _ in
                
            })

    }
    
    private func checkMarketUpdatesAvailable() -> AnyPublisher<Market, ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.get(contentIdentifier: self.contentIdentifier)

        guard
            let request = endpoint.request()
        else {
            return Fail(error: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
        }

        return self.session.dataTaskPublisher(for: request)
            .retry(1)
            .map({ return $0.data  })
            .mapError({ _ in return ServiceProviderError.invalidRequestFormat })
            .flatMap { (data: Data) -> AnyPublisher<Data, ServiceProviderError> in
                if let responseString = String(data: data, encoding: .utf8), responseString.uppercased().contains("CONTENT_NOT_FOUND") {
                    return Fail(outputType: Data.self, failure: ServiceProviderError.resourceUnavailableOrDeleted).eraseToAnyPublisher()
                }
                else {
                    return Just(data).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                }
            }
            .decode(type: SportRadarModels.SportRadarResponse<SportRadarModels.Market>.self, decoder: JSONDecoder() )
            .map({ SportRadarModelMapper.market(fromInternalMarket: $0.data) })
            .mapError({ error in
                if let serviceProviderError = error as? ServiceProviderError {
                    return serviceProviderError
                }
                else {
                    return ServiceProviderError.invalidResponse
                }
            })
            .eraseToAnyPublisher()

    }

    func requestMarketUpdates() -> AnyPublisher<Void, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                         contentIdentifier: self.contentIdentifier)

        guard
            let request = endpoint.request()
        else {
            return Fail(error: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
        }

        return self.session.dataTaskPublisher(for: request)
            .retry(1)
            .tryMap { data, response -> Data in
                guard let httpResponse = response as? HTTPURLResponse, (200...299).contains(httpResponse.statusCode) else {
                    throw ServiceProviderError.onSubscribe
                }
                return data
            }
            .mapError { _ in ServiceProviderError.onSubscribe }
            .flatMap { data -> AnyPublisher<Void, ServiceProviderError> in
                if let responseString = String(data: data, encoding: .utf8), responseString.lowercased().contains("version") {
                    return Just(()).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                } else {
                    return Fail(error: ServiceProviderError.onSubscribe).eraseToAnyPublisher()
                }
            }
            .eraseToAnyPublisher()
    }


    func updateMarket(_ market: Market) {
        // print("☁️SP debugbetslip updated SportRadarMarketDetailsCoordinator \(self.contentIdentifier) \(market.id)")

        self.marketCurrentValueSubject.send(.contentUpdate(content: market))

        self.outcomesDictionary = [:]
        for outcome in market.outcomes {
            self.outcomesDictionary[outcome.id] = CurrentValueSubject(outcome)
        }
    }

    func reset() {
        self.marketCurrentValueSubject.send(.disconnected)

        self.outcomesDictionary = [:]
        self.subscription = nil
        
        self.connectListenner()
    }

    func reconnect(withNewSessionToken newSessionToken: String) {

        // Update the socket session token
        self.sessionToken = newSessionToken
        print("SportRadarMarketDetailsCoordinator: reconnect withNewSessionToken \(newSessionToken)")

        guard self.subscription != nil else { return }

        // Reset the storage, avoid duplicates, we will recieve every info again
        self.reset()

        //
        let endpoint = SportRadarRestAPIClient.subscribe(sessionToken: self.sessionToken,
                                                         contentIdentifier: self.contentIdentifier)

        guard let request = endpoint.request() else { return }
        let sessionDataTask = URLSession.shared.dataTask(with: request) { data, response, error in
            if let error {
                print("SportRadarMarketDetailsCoordinator: reconnect dataTask contentIdentifier \(self.contentIdentifier) error \(error)")
            }
            if let data, let dataString = String(data: data, encoding: .utf8) {
                print("SportRadarMarketDetailsCoordinator: reconnect dataTask contentIdentifier \(self.contentIdentifier) data \(dataString)")
            }
        }
        sessionDataTask.resume()
    }

}


extension SportRadarMarketDetailsCoordinator {

    func handleContentUpdate(_ content: SportRadarModels.ContentContainer) {

//        guard
//            let updatedContentIdentifier = content.contentIdentifier
//        else {
//            print("SportRadarMarketDetailsCoordinator ignoring contentIdentifierLess \(content)")
//            return
//        }
//
//        if self.contentIdentifier != updatedContentIdentifier {
//            // ignoring this update, not subscribed by this class
//            // print("☁️SP \"type\":\"market\" SportRadarMarketDetailsCoordinator ignoring \(updatedContentIdentifier) != \(self.contentIdentifier)")
//            return
//        }
//        else {
//            print("☁️SP \"type\":\"market\" SportRadarMarketDetailsCoordinator handling \(updatedContentIdentifier) ==  self \(self.contentIdentifier)")
//        }

        // print("☁️SP debugdetails  \"type\":\"market\" SportRadarMarketDetailsCoordinator handleContentUpdate \(content)")

        let trackedMarketId = self.marketId
        
        switch content {
        case .updateMarketTradability(_, let marketId, let isTradable):
            if trackedMarketId == marketId {
                // print("☁️SP debugbetslip updateMarketTradability \(marketId) \(isTradable)")
                self.updateMarketTradability(withId: marketId, isTradable: isTradable)
            }
        case .updateOutcomeOdd(_, let selectionId, let newOddNumerator, let newOddDenominator):
            self.updateOutcomeOdd(withId: selectionId, newOddNumerator: newOddNumerator, newOddDenominator: newOddDenominator)

        case .updateOutcomeTradability(_, let selectionId, let isTradable):
            self.updateMarketTradability(withId: selectionId, isTradable: isTradable)

        case .addMarket(_ , let market):
            if trackedMarketId == market.id {
                for outcome in market.outcomes {
                    if let fractionOdd = outcome.odd.fractionOdd {
                        self.updateOutcomeOdd(withId: outcome.id, newOddNumerator: String(fractionOdd.numerator), newOddDenominator: String(fractionOdd.denominator))
                    }
                }
                // print("☁️SP MarketDetailer debugbetslip \(market.id) add market ")
                self.updateMarketTradability(withId: market.id, isTradable: market.isTradable)
            }
        case .enableMarket(_, let marketId):
            if trackedMarketId == marketId {
                // print("☁️SP MarketDetailer debugbetslip \(marketId) enabled market")
                self.updateMarketTradability(withId: marketId, isTradable: true)
            }
        case .removeMarket(_, let marketId):
            if trackedMarketId == marketId {
                // print("☁️SP MarketDetailer debugbetslip \(marketId) removed market")
                self.updateMarketTradability(withId: marketId, isTradable: false)
            }
        case .removeEvent(_, let updatedEventId):
            if self.eventId == updatedEventId {
                self.updateMarketTradability(withId: trackedMarketId, isTradable: false)
            }
        case .addEvent(_, let updatedEvent):
            if self.eventId == updatedEvent.id {
                self.updateMarketTradability(withId: trackedMarketId, isTradable: true)
            }
        default:
            () // Ignore other cases
        }
    }

    func updateMarketTradability(withId id: String, isTradable: Bool) {
        guard let updatedMarket = self.market else { return }
        let currentTradable = updatedMarket.isTradable
        if isTradable != currentTradable {
            updatedMarket.isTradable = isTradable
            self.marketCurrentValueSubject.send(.contentUpdate(content: updatedMarket))
        }
    }

    func updateOutcomeOdd(withId id: String, newOddNumerator: String?, newOddDenominator: String?) {
        guard 
            let newMarket = self.market
        else {
            return
        }
        guard let outcomeSubject = self.outcomesDictionary[id] else { return }

        let outcome = outcomeSubject.value

        var oldNumerator: Int = 1
        var oldDenominator: Int = 1

        if case let .fraction(numerator, denominator) = outcome.odd {
            oldNumerator = numerator
            oldDenominator = denominator
        }

        let newOddNumeratorValue = Int(newOddNumerator ?? "x") ?? oldNumerator
        let newOddDenominatorValue = Int(newOddDenominator ?? "x") ?? oldDenominator

        if newOddNumeratorValue == oldNumerator && newOddDenominatorValue == oldDenominator {
            return
        }

        outcome.odd = OddFormat.fraction(numerator: newOddNumeratorValue, denominator: newOddDenominatorValue)
        outcomeSubject.send(outcome)

        // Update the market with the new outcome list
        let updatedOutcomes = Array(self.outcomesDictionary.values.map(\.value))
        newMarket.outcomes = updatedOutcomes

        self.marketCurrentValueSubject.send(.contentUpdate(content: newMarket))
    }

    func updateOutcomeTradability(withId id: String, isTradable: Bool) {
        guard let outcomeSubject = self.outcomesDictionary[id] else { return }
        let outcome = outcomeSubject.value
        outcome.isTradable = isTradable
        outcomeSubject.send(outcome)
    }

}

extension SportRadarMarketDetailsCoordinator {


}

extension SportRadarMarketDetailsCoordinator: UnsubscriptionController {

    func unsubscribe(subscription: Subscription) {
        let endpoint = SportRadarRestAPIClient.unsubscribe(sessionToken: subscription.sessionToken, contentIdentifier: subscription.contentIdentifier)
        guard let request = endpoint.request() else { return }
        let sessionDataTask = URLSession.shared.dataTask(with: request) { data, response, error in
            guard
                error == nil,
                let httpResponse = response as? HTTPURLResponse,
                (200...299).contains(httpResponse.statusCode)
            else {
                print("SportRadarMarketDetailsCoordinator unsubscribe failed")
                return
            }
            print("SportRadarMarketDetailsCoordinator unsubscribe ok")
        }
        sessionDataTask.resume()
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Events-Poseidon/Storage/SportRadarEventStorage.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 01/03/2023.
//

import Foundation
import OrderedCollections
import Combine

class SportRadarEventStorage {

    var eventPublisher: AnyPublisher<Event?, Never> {
        self.eventSubject
            .eraseToAnyPublisher()
    }

    private var removedMainMarketId: String? = nil

    private var eventSubject: CurrentValueSubject<Event?, Never>
    private var marketsDictionary: OrderedDictionary<String, CurrentValueSubject<Market, Never>>
    private var outcomesDictionary: OrderedDictionary<String, CurrentValueSubject<Outcome, Never>>

    private var cancellables = Set<AnyCancellable>()

    init() {
        self.eventSubject = .init(nil)
        self.marketsDictionary = [:]
        self.outcomesDictionary = [:]
    }

    func reset() {
        self.eventSubject.send(nil)
        self.marketsDictionary = [:]
        self.outcomesDictionary = [:]
    }

    func storeEvent(_ event: Event, withMainMarket: Bool = false) {
        self.marketsDictionary = [:]
        self.outcomesDictionary = [:]

        if withMainMarket {
            event.markets.first?.isMainMarket = withMainMarket
        }

        for market in event.markets {
            for outcome in market.outcomes {
                self.outcomesDictionary[outcome.id] = CurrentValueSubject(outcome)
            }
            self.marketsDictionary[market.id] = CurrentValueSubject(market)
        }

        self.eventSubject.send(event)
    }

    func storeSecundaryMarkets(_ secundaryMarkets: [Market]) {
        guard let event = self.eventSubject.value else { return }

        for market in secundaryMarkets {

            // Check if there's an existing market with this ID and if it's marked as main
            if let existingMarket = self.marketsDictionary[market.id]?.value,
               existingMarket.isMainMarket {
                continue // Skip this secondary market
            }

            //
            for outcome in market.outcomes {
                self.outcomesDictionary[outcome.id] = CurrentValueSubject(outcome)
            }
            self.marketsDictionary[market.id] = CurrentValueSubject(market)
        }

        event.markets = self.marketsDictionary.values.map(\.value)
        self.eventSubject.send(event)
    }

    func storedEvent() -> Event? {
        return self.eventSubject.value
    }

}

extension SportRadarEventStorage {

    // Odds updates
    func updateOutcomeOdd(withId id: String, newOddNumerator: String?, newOddDenominator: String?) {
        guard let outcomeSubject = self.outcomesDictionary[id] else { return }
        let outcome = outcomeSubject.value

        var oldNumerator: Int = 1
        var oldDenominator: Int = 1

        if case let .fraction(numerator, denominator) = outcome.odd {
            oldNumerator = numerator
            oldDenominator = denominator
        }

        let newOddNumeratorValue = Int(newOddNumerator ?? "x") ?? oldNumerator
        let newOddDenominatorValue = Int(newOddDenominator ?? "x") ?? oldDenominator

        if newOddNumeratorValue == oldNumerator && newOddDenominatorValue == oldDenominator {
            return
        }
        
        outcome.odd = OddFormat.fraction(numerator: newOddNumeratorValue, denominator: newOddDenominatorValue)
        outcomeSubject.send(outcome)
    }

    func updateOutcomeTradability(withId id: String, isTradable: Bool) {
        guard let outcomeSubject = self.outcomesDictionary[id] else { return }
        let outcome = outcomeSubject.value
        outcome.isTradable = isTradable
        outcomeSubject.send(outcome)
    }
    
    //
    // Main Market updates
    func addMainMarket(_ market: Market) {
        guard let removedMainMarketId = self.removedMainMarketId else { return }

        market.isMainMarket = true

        // remove old main market
        self.marketsDictionary.removeValue(forKey: removedMainMarketId)

        self.removedMainMarketId = nil
        self.addMarket(market)
    }

    func removeMainMarket(withId id: String) {
        guard
            self.marketsDictionary[id] != nil
        else {
            return
        }

        self.updateMarketTradability(withId: id, isTradable: false)

        self.removedMainMarketId = id
    }

    //
    // Market updates
    func addMarket(_ market: Market) {
        
        if self.marketsDictionary[market.id] != nil { // We already
            self.updateMarketTradability(withId: market.id, isTradable: market.isTradable)
            return
        }
        else {
            for outcome in market.outcomes {
                self.outcomesDictionary[outcome.id] = CurrentValueSubject(outcome)
            }
            
            self.marketsDictionary[market.id] = CurrentValueSubject(market)
            let updatedMarkets: [Market] = self.marketsDictionary.values.map(\.value)
            
            guard let event = self.eventSubject.value else { return }
            event.markets = updatedMarkets
            eventSubject.send(event)
        }
        
    }


    func removeMarket(withId id: String) {
        self.marketsDictionary.removeValue(forKey: id)
        
        let updatedMarkets: [Market] = self.marketsDictionary.values.map(\.value)
        
        guard let event = self.eventSubject.value else { return }
        event.markets = updatedMarkets
        eventSubject.send(event)
    }

    func updateMarketTradability(withId id: String, isTradable: Bool) {
        guard
            let marketSubject = self.marketsDictionary[id]
        else {
            return
        }
        
        let market = marketSubject.value
        market.isTradable = isTradable
        marketSubject.send(market)
    }

    // Live data updates
    func updateEventStatus(newStatus: String) {
        guard let event = self.eventSubject.value else { return }
        event.status = EventStatus(value: newStatus)
        eventSubject.send(event)
    }

    func updateEventTime(newTime: String) {
        guard let event = self.eventSubject.value else { return }
        event.matchTime = newTime
        eventSubject.send(event)
    }

    func updateEventScore(newHomeScore: Int?, newAwayScore: Int?) {
        guard let event = self.eventSubject.value else { return }
        if let newHomeScoreValue = newHomeScore {
            event.homeTeamScore = newHomeScoreValue
        }
        if let newAwayScoreValue = newAwayScore {
            event.awayTeamScore = newAwayScoreValue
        }
        eventSubject.send(event)
    }
    
    func updateEventDetailedScore(_ detailedScore: Score) {
        guard let event = self.eventSubject.value else { return }
        event.scores[detailedScore.key] = detailedScore
        
        if case .matchFull(let newHomeScore, let newAwayScore) = detailedScore {
            if let newHomeScoreValue = newHomeScore {
                event.homeTeamScore = newHomeScoreValue
            }
            if let newAwayScoreValue = newAwayScore {
                event.awayTeamScore = newAwayScoreValue
            }
        }
        
        eventSubject.send(event)
    }
    
    func updateEventFullDetailedScore(_ detailedScore: [String: Score]) {
        for value in detailedScore.values {
            self.updateEventDetailedScore(value)
        }
    }
    
    func updateActivePlayer(_ activePlayerServing: ActivePlayerServe?) {
        guard let event = self.eventSubject.value else { return }
        event.activePlayerServing = activePlayerServing
        self.eventSubject.send(event)
    }

}

extension SportRadarEventStorage {

    func subscribeToEventOnListsLiveDataUpdates(withId id: String) -> AnyPublisher<Event?, Never> {
        return self.eventSubject.eraseToAnyPublisher()
    }

    func subscribeToEventOnListsMarketUpdates(withId id: String) -> AnyPublisher<Market, Never>? {
        return self.marketsDictionary[id]?.eraseToAnyPublisher()
    }

    func subscribeToEventOnListsOutcomeUpdates(withId id: String) -> AnyPublisher<Outcome, Never>? {
        return self.outcomesDictionary[id]?.eraseToAnyPublisher()
    }

    func containsEvent(withid id: String) -> Bool {
        return self.eventSubject.value?.id == id
    }

    func containsMarket(withid id: String) -> Bool {
        return self.marketsDictionary[id] != nil
    }

    func containsOutcome(withid id: String) -> Bool {
        return self.outcomesDictionary[id] != nil
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Events-Poseidon/SportRadarRestAPIClient.swift
````swift
//
//  SportRadarRestAPIClient.swift
//  
//
//  Created by André Lascas on 02/11/2022.
//

import Foundation

/* https://cdn1.optimahq.com/sportradar/sportsbook/config/marketsFilter_v2.json
 */

enum SportRadarRestAPIClient {
    case get(contentIdentifier: ContentIdentifier)
    case subscribe(sessionToken: String, contentIdentifier: ContentIdentifier)
    case unsubscribe(sessionToken: String, contentIdentifier: ContentIdentifier)
    case marketsFilter
    case fieldWidgetId(eventId: String)
    case sportsBoNavigationList
    case sportsScheduledList(dateRange: String)
    case sportRegionsNavigationList(sportId: String)
    case regionCompetitions(regionId: String)
    case competitionMarketGroups(competitionId: String)
    case search(query: String, resultLimit: String, page: String, isLive: Bool)
    //case banners
    case getEventSummary(eventId: String)
    case getMarketInfo(marketId: String)

    case getEventDetails(eventId: String)
    case getEventSecundaryMarkets(eventId: String)

    case getEventForMarketGroup(marketGroupId: String)
    case getEventsForEventGroup(eventGroupId: String)
    case getEventForMarket(marketId: String)

    case homeSliders
    
    case promotionalTopBanners
    case promotionalTopEvents
    case promotionalTopStories
    case highlightsBoostedOddsEvents
    case highlightsImageVisualEvents

    case highlightsMarkets

    case getHeroGameCard

    case promotedSports

    case favoritesList
    case addFavoriteList(name: String)
    case addFavoriteToList(listId: Int, eventId: String)
    case getFavoritesFromList(listId: Int)
    case deleteFavoriteList(listId: Int)
    case deleteFavoriteFromList(eventId: Int)

    case getCashbackSuccessBanner
    case getTopCompetitions
    case getTopCompetitionCountry(competitionId: String)
}

extension SportRadarRestAPIClient: Endpoint {

    var endpoint: String {
        switch self {
        //
        case .get:
            return "/services/content/get"
        case .subscribe:
            return "/services/content/subscribe" 
        case .unsubscribe:
            return "/services/content/unsubscribe"
        //
        case .marketsFilter:
            // return "/sportradar/sportsbook/config/marketsFilter_v2.json"
            // new: "/sportsbook/config/marketsFilter_v2.json"
            return "/sportsbook/config/marketsFilter_v2.json"
        //
        case .fieldWidgetId:
            return "/services/content/get"
        case .sportsBoNavigationList:
            return "/services/content/get"
        case .sportsScheduledList:
            return "/services/content/get"
        case .sportRegionsNavigationList:
            return "/services/content/get"
        case .regionCompetitions:
            return "/services/content/get"
        case .competitionMarketGroups:
            return "/services/content/get"
        case .search:
            return "/services/content/get"
        case .getEventSummary:
            return "/services/content/get"
        case .getMarketInfo:
            return "/services/content/get"
        
        case .getEventDetails:
            return "/services/content/get"
        case .getEventSecundaryMarkets:
            return "/services/content/get"
        
        case .getEventForMarketGroup:
            return "/services/content/get"
        case .getEventsForEventGroup:
            return "/services/content/get"
        case .getEventForMarket:
            return "/services/content/get"

        //
        case .homeSliders:
            return "/services/content/get"
        case .promotionalTopBanners:
            return "/services/content/get"

        case .promotionalTopEvents:
            return "/services/content/get"
        case .promotionalTopStories:
            return "/services/content/get"

        case .highlightsBoostedOddsEvents:
            return "/services/content/get"
        case .highlightsImageVisualEvents:
            return "/services/content/get"

        case .highlightsMarkets:
            return "/services/content/get"

        case .getHeroGameCard:
            return "/services/content/get"

        case .promotedSports:
            return "/services/content/get"

        //
        case .favoritesList:
            return "/api/favourites/fw/getAccountFavouriteCoupon"
        case .addFavoriteList:
            return "/api/favourites/fw/addAccountFavouriteCoupon"
        case .addFavoriteToList:
            return "/api/favourites/fw/addAccountFavourite"
        case .getFavoritesFromList:
            return "/api/favourites/fw/getFavouritesForCustomer"
        case .deleteFavoriteList:
            return "/api/favourites/fw/deleteAccountFavouriteCoupon"
        case .deleteFavoriteFromList:
            return "/api/favourites/fw/deleteAccountFavourites"

        case .getCashbackSuccessBanner:
            return "/services/content/get"

        case .getTopCompetitions:
            return "/services/content/get"

        case .getTopCompetitionCountry:
            return "/services/content/get"
        }
    }

    var query: [URLQueryItem]? {
        switch self {
        case .get: return nil
        case .subscribe: return nil
        case .unsubscribe: return nil
        case .marketsFilter: return nil
        case .fieldWidgetId: return nil
        case .sportsBoNavigationList: return nil
        case .sportsScheduledList: return nil
        case .sportRegionsNavigationList: return nil 
        case .regionCompetitions: return nil
        case .competitionMarketGroups: return nil
        case .search: return nil
        case .getEventSummary: return nil
        case .getMarketInfo: return nil
        
        case .getEventDetails:  return nil
        case .getEventSecundaryMarkets: return nil
            
        case .getEventForMarketGroup: return nil
        case .getEventsForEventGroup: return nil
        case .getEventForMarket: return nil

        case .homeSliders: return nil
        case .promotionalTopBanners: return nil
        case .promotionalTopEvents: return nil
        case .promotionalTopStories: return nil

        case .highlightsBoostedOddsEvents: return nil
        case .highlightsImageVisualEvents: return nil
        case .highlightsMarkets: return nil

        case .getHeroGameCard: return nil
            
        case .promotedSports: return nil

        case .favoritesList: return nil
        case .addFavoriteList: return nil
        case .addFavoriteToList: return nil
        case .getFavoritesFromList: return nil
        case .deleteFavoriteList: return nil
        case .deleteFavoriteFromList: return nil

        case .getCashbackSuccessBanner: return nil
        case .getTopCompetitions: return nil
        case .getTopCompetitionCountry: return nil
        }
    }

    var method: HTTP.Method {
        switch self {
        case .get: return .post
        case .subscribe: return .post
        case .unsubscribe: return .post
        case .marketsFilter: return .get
        case .fieldWidgetId: return .post
        case .sportsBoNavigationList: return .post
        case .sportsScheduledList: return .post
        case .sportRegionsNavigationList: return .post 
        case .regionCompetitions: return .post
        case .competitionMarketGroups: return .post
        case .search: return .post

        case .getEventSummary: return .post
        case .getMarketInfo: return .post
        case .getEventDetails: return .post
        case .getEventSecundaryMarkets: return .post

        case .getEventForMarketGroup: return .post
        case .getEventsForEventGroup: return .post
        case .getEventForMarket: return .post

        case .homeSliders: return .post
        case .promotionalTopBanners: return .post
        case .promotionalTopEvents: return .post
        case .promotionalTopStories: return .post

        case .highlightsBoostedOddsEvents: return .post
        case .highlightsImageVisualEvents: return .post
        case .highlightsMarkets: return .post

        case .getHeroGameCard: return .post
            
        case .promotedSports: return .post

        case .favoritesList: return .get
        case .addFavoriteList: return .post
        case .addFavoriteToList: return .post
        case .getFavoritesFromList: return .post
        case .deleteFavoriteList: return .delete
        case .deleteFavoriteFromList: return .delete

        case .getCashbackSuccessBanner: return .post
        case .getTopCompetitions: return .post
        case .getTopCompetitionCountry: return .post
        }
    }

    var body: Data? {
        switch self {
        case .get(let contentIdentifier):
            return Self.createPayloadData(with: nil, contentIdentifier: contentIdentifier)
        case .subscribe(let sessionToken, let contentIdentifier):
            return Self.createPayloadData(with: sessionToken, contentIdentifier: contentIdentifier)
        case .unsubscribe(let sessionToken, let contentIdentifier):
            return Self.createPayloadData(with: sessionToken, contentIdentifier: contentIdentifier)
        case .fieldWidgetId(let eventId):
            let bodyString =
            """
            {
                "contentId": {
                    "type": "eventExternalId",
                    "id": "\(eventId)/SportRadarWidget"
                },
                "clientContext": {
                    "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                    "ipAddress": "127.0.0.1"
                }
            }
            """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
        case .sportsBoNavigationList:
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "boNavigationList",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/top"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
        case .sportsScheduledList(let dateRange):
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "sportTypeByDate",
                                "id": "\(dateRange)"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
        case .sportRegionsNavigationList(let sportId):
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "boNavigationList",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/\(sportId)"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
        case .regionCompetitions(let regionId):
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "boNavigationList",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/\(regionId)"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .competitionMarketGroups(let competitionId):
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "boNavigationList",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/\(competitionId)"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
        case .search(let query, let resultLimit, let page, _):
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "eventSearch",
                                "id": "\(query)/\(resultLimit)/\(page)"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .getEventSummary(let eventId):
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "eventSummary",
                                "id": "\(eventId)"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .getEventDetails(let eventId):
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "event",
                                "id": "\(eventId)"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
            
        case .getEventSecundaryMarkets(let eventId):
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "eventWithBalancedMarkets",
                                "id": "\(eventId)"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
            
        case .homeSliders:
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "headline",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/20/HomepageSliders"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .promotionalTopBanners: // TODO: use correct language
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "bannerCategoryList",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/Homepage"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .promotionalTopEvents:
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "headline",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/20/slidingEvent"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .promotionalTopStories:
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "headline",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/20/InstaCard"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .highlightsBoostedOddsEvents:
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "headline",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/20/boostedOddCard"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .highlightsImageVisualEvents:
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "headline",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/20/eventCard"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .highlightsMarkets:
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "headline",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/20/altMarkets"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .getHeroGameCard:
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "headline",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/20/HeroGameCard"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
        case .addFavoriteList(let name):
            let bodyString =
                        """
                        {
                            "name": "\(name)"
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
        case .addFavoriteToList(let listId, let eventId):
            let bodyString =
                        """
                        {
                            "idfwAccountFavouriteCoupon": \(listId),
                            "niddcUserReq": null,
                            "nidmmCustomer":  null,
                            "sfavouriteContent": ["\(eventId)"],
                            "sfavouriteID": "\(eventId)",
                            "sidfwFavouriteType": "N"
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
        case .getFavoritesFromList(let listId):
            let bodyString =
                        """
                        {
                            "idfwAccountFavouriteCoupon": \(listId)
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
        case .deleteFavoriteList(let listId):
            let bodyString =
                        """
                        {
                            "idfwAccountFavouriteCoupon": "\(listId)"
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
        case .deleteFavoriteFromList(let eventId):
            let bodyString =
                        """
                        {
                            "nidfwAccountFavourites": \(eventId)
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
        case .getMarketInfo(let marketId):
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "market",
                                "id": "\(marketId)"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .getEventsForEventGroup(let eventGroupId):
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "eventGroup",
                                "id": "\(eventGroupId)"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .getEventForMarketGroup(let marketGroupId):
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "marketGroup",
                                "id": "\(marketGroupId)"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
            
        case .getEventForMarket(let marketId):
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "market",
                                "id": "\(marketId)"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .promotedSports:
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "boNavigationList",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/top"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .getCashbackSuccessBanner:
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "bannerCategoryList",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/cashbackSuccessBanner"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
        case .getTopCompetitions:
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "bannerCategoryList",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/QuickLinks"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .getTopCompetitionCountry(let competitionId):
            let bodyString =
                        """
                        {
                            "contentId": {
                                "type": "boNavigationList",
                                "id": "\(SportRadarConfiguration.shared.frontEndCode)/\(competitionId)"
                            },
                            "clientContext": {
                                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                                "ipAddress": "127.0.0.1"
                            }
                        }
                        """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
            
        default:
            return nil
        }
    }

    var url: String {
        switch self {
        case .get:
            // https://www-bson-ssb-ua.betsson.fr/services/content/get
            return SportRadarConfiguration.shared.servicesRestHostname
        case .subscribe:
            // https://velsv-bson-ssb-ua.betsson.fr/services/content/subscribe
            return SportRadarConfiguration.shared.servicesSubscribeRestHostname
        case .unsubscribe:
            // https://velsv-bson-ssb-ua.betsson.fr/services/content/unsubscribe
            return SportRadarConfiguration.shared.servicesSubscribeRestHostname

        case .marketsFilter:
            return SportRadarConfiguration.shared.sportRadarFrontEndURL
            
        case .fieldWidgetId:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .sportsBoNavigationList:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .sportsScheduledList:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .sportRegionsNavigationList:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .regionCompetitions:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .competitionMarketGroups:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .search:
            return SportRadarConfiguration.shared.servicesRestHostname

        case .getEventSummary:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .getMarketInfo:
            return SportRadarConfiguration.shared.servicesRestHostname
        
        case .getEventDetails:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .getEventSecundaryMarkets:
            return SportRadarConfiguration.shared.servicesRestHostname
            
        case .getEventForMarketGroup:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .getEventsForEventGroup:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .getEventForMarket:
            return SportRadarConfiguration.shared.servicesRestHostname

        case .homeSliders:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .promotionalTopBanners:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .promotionalTopEvents:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .promotionalTopStories:
            return SportRadarConfiguration.shared.servicesRestHostname

        case .highlightsBoostedOddsEvents:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .highlightsImageVisualEvents:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .highlightsMarkets:
            return SportRadarConfiguration.shared.servicesRestHostname

        case .getHeroGameCard:
            return SportRadarConfiguration.shared.servicesRestHostname
        
        case .promotedSports:
            return SportRadarConfiguration.shared.servicesRestHostname

        case .favoritesList:
            return SportRadarConfiguration.shared.apiRestHostname
        case .addFavoriteList:
            return SportRadarConfiguration.shared.apiRestHostname
        case .addFavoriteToList:
            return SportRadarConfiguration.shared.apiRestHostname
        case .getFavoritesFromList:
            return SportRadarConfiguration.shared.apiRestHostname
        case .deleteFavoriteList:
            return SportRadarConfiguration.shared.apiRestHostname
        case .deleteFavoriteFromList:
            return SportRadarConfiguration.shared.apiRestHostname

        case .getCashbackSuccessBanner:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .getTopCompetitions:
            return SportRadarConfiguration.shared.servicesRestHostname
        case .getTopCompetitionCountry:
            return SportRadarConfiguration.shared.servicesRestHostname
        }
    }

    var headers: HTTP.Headers? {
        let defaultHeaders = [
            "Accept-Encoding": "gzip, deflate",
            "Content-Type": "application/json; charset=UTF-8",
            "Media-Type": "application/json",
            "app-origin": "ios",
            "Accept": "application/json"
        ]

        switch self {
        case .get:
            return defaultHeaders
        case .subscribe:
            return ["Content-Type": "application/json",
                    "app-origin": "ios",
                    "Media-Type": "application/json"]
        case .unsubscribe:
            return ["Content-Type": "application/json",
                    "app-origin": "ios",
                    "Media-Type": "application/json"]
        case .marketsFilter:
            return defaultHeaders
        case .fieldWidgetId(_):
            return defaultHeaders
        case .sportsBoNavigationList:
            return defaultHeaders
        case .sportsScheduledList(_):
            return defaultHeaders
        case .sportRegionsNavigationList:
            return defaultHeaders
        case .regionCompetitions:
            return defaultHeaders
        case .competitionMarketGroups:
            return defaultHeaders
        case .search:
            return defaultHeaders

        case .getEventSummary:
            return defaultHeaders
        case .getMarketInfo:
            return defaultHeaders
        case .getEventDetails:
            return defaultHeaders
        case .getEventSecundaryMarkets:
            return defaultHeaders
            
        case .getEventForMarketGroup:
            return defaultHeaders
        case .getEventsForEventGroup:
            return defaultHeaders
        case .getEventForMarket:
            return defaultHeaders
            
        case .highlightsBoostedOddsEvents:
            return defaultHeaders
        case .highlightsImageVisualEvents:
            return defaultHeaders
        case .highlightsMarkets:
            return defaultHeaders

        case .promotedSports:
            return defaultHeaders
            
        case .homeSliders:
            return defaultHeaders
        case .promotionalTopBanners:
            return defaultHeaders
        case .promotionalTopEvents:
            return defaultHeaders
        case .promotionalTopStories:
            return defaultHeaders
        case .getCashbackSuccessBanner:
            return defaultHeaders
        case .getTopCompetitions:
            return defaultHeaders
        case .getTopCompetitionCountry:
            return defaultHeaders
        case .getHeroGameCard:
            return defaultHeaders
            
        case .favoritesList, .addFavoriteList, .addFavoriteToList, .getFavoritesFromList, .deleteFavoriteList, .deleteFavoriteFromList:
            return [
                "Accept-Encoding": "gzip, deflate, br",
                "Content-Type": "application/json; charset=UTF-8",
                "Media-Type": "application/json",
                "Accept": "application/json",
                "X-MGS-BusinessUnit": "3",
                "app-origin": "ios",
                "Accept-Languag": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                "X-MGS-Location": "\(SportRadarConfiguration.shared.socketLanguageCode)",
            ]

        }
    }

    var cachePolicy: URLRequest.CachePolicy {
        return .reloadIgnoringLocalCacheData
    }

    var timeout: TimeInterval {
        switch self {
        case .subscribe: return TimeInterval(60)
        case .unsubscribe: return TimeInterval(20)
        default: return TimeInterval(120)
        }
    }

    var requireSessionKey: Bool {
        switch self {
        case .favoritesList:
            return true
        case .addFavoriteList:
            return true
        case .addFavoriteToList:
            return true
        case .deleteFavoriteList:
            return true
        case .getFavoritesFromList:
            return true
        case .deleteFavoriteFromList:
            return true
        default:
            return false
        }
    }

    var comment: String? {
        switch self {
        case .get(let contentIdentifier):
            return "get-\(contentIdentifier.contentType)"
        case .subscribe(_, let contentIdentifier):
            return "subscribe-\(contentIdentifier.contentType)"
        case .unsubscribe(_, let contentIdentifier):
            return "unsubscribe-\(contentIdentifier.contentType)"
        case .marketsFilter: return "marketsFilter"
        case .fieldWidgetId: return "fieldWidgetId"
        case .sportsBoNavigationList: return "sportsBoNavigationList"
        case .sportsScheduledList: return "sportsScheduledList"
        case .sportRegionsNavigationList: return "sportRegionsNavigationList"
        case .regionCompetitions: return "regionCompetitions"
        case .competitionMarketGroups(let competitionId): return "competitionMarketGroups \(competitionId)"
        case .search: return "search"
        case .getEventSummary(let eventId): return "getEventSummary \(eventId)"
        case .getMarketInfo: return "getMarketInfo"
        
        case .getEventDetails(let eventId): return "getEventDetails \(eventId)"
        case .getEventSecundaryMarkets(let eventId): return "getEventSecundaryMarkets \(eventId)"
            
        case .getEventForMarketGroup(let marektGroupid): return "getEventForMarketGroup \(marektGroupid)"
        case .getEventsForEventGroup(let eventGroupId): return "getEventsForEventGroup \(eventGroupId)"
        case .getEventForMarket(let marketId): return "getEventForMarket \(marketId)"
        case .homeSliders: return "homeSliders"
        case .promotionalTopBanners: return "promotionalTopBanners"
        case .promotionalTopEvents: return "promotionalTopEvents"
        case .promotionalTopStories: return "promotionalTopStories"
        case .highlightsBoostedOddsEvents: return "highlightsBoostedOddsEvents"
        case .highlightsImageVisualEvents: return "highlightsImageVisualEvents"
        case .highlightsMarkets: return "highlightsMarkets"
        case .getHeroGameCard: return "getHeroGameCard"
        case .promotedSports: return "promotedSports"
        case .favoritesList: return "favoritesList"
        case .addFavoriteList: return "addFavoriteList"
        case .addFavoriteToList: return "addFavoriteToList"
        case .getFavoritesFromList: return "getFavoritesFromList"
        case .deleteFavoriteList: return "deleteFavoriteList"
        case .deleteFavoriteFromList: return "deleteFavoriteFromList"
        case .getCashbackSuccessBanner: return "getCashbackSuccessBanner"
        case .getTopCompetitions: return "getTopCompetitions PointersOnly"
        case .getTopCompetitionCountry(let competitionId): return "getTopCompetitionCountry \(competitionId)"
        }
    }
    
}

extension SportRadarRestAPIClient {

    private static func createPayloadData(with sessionToken: String?,
                                          contentIdentifier: ContentIdentifier) -> Data {
        if let sessionToken = sessionToken {
            let bodyString =
                """
                {
                    "subscriberId": "\(sessionToken)",
                    "contentId": {
                        "type": "\(contentIdentifier.contentType.rawValue)",
                        "id": "\(contentIdentifier.contentRoute.fullRoute)"
                    },
                    "clientContext": {
                        "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                        "ipAddress": "127.0.0.1"
                    }
                }
                """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
        }
        else {
            let bodyString =
                """
                {
                    "contentId": {
                        "type": "\(contentIdentifier.contentType.rawValue)",
                        "id": "\(contentIdentifier.contentRoute.fullRoute)"
                    },
                    "clientContext": {
                        "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                        "ipAddress": "127.0.0.1"
                    }
                }
                """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Events-Poseidon/SportRadarRestConnector.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 25/10/2022.
//

import Foundation
import Combine

class SportRadarRestConnector {
    
    private let session: URLSession
    private let decoder: JSONDecoder

    var token: SportRadarSessionAccessToken?
    
    init(session: URLSession = URLSession(configuration: URLSessionConfiguration.default), decoder: JSONDecoder = JSONDecoder()) {
        self.session = session
        self.decoder = decoder
        
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd HH:mm:ss" // 2003-12-31 00:00:00
        self.decoder.dateDecodingStrategy = .formatted(dateFormatter)
    }

    func request<T: Codable>(_ endpoint: Endpoint) -> AnyPublisher<T, ServiceProviderError> {

        var additionalHeaders: HTTP.Headers?
        if endpoint.requireSessionKey {
            if let sessionKey = self.retrieveSessionKey() {
                additionalHeaders = ["Authorization": sessionKey]
            }
            else {
                return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
            }
        }

        guard
            //let request = endpoint.request()
            let request = endpoint.request(aditionalHeaders: additionalHeaders)
        else {
            let error = ServiceProviderError.invalidRequestFormat
            return AnyPublisher(Fail<T, ServiceProviderError>(error: error))
        }

        // print("SportRadarRestConnector Request:", request.cURL(pretty: true))
        
        return self.session.dataTaskPublisher(for: request)
            .tryMap { result in

                if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 401 {
                    throw ServiceProviderError.unauthorized
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 403 {
                    throw ServiceProviderError.forbidden
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 204 {
                    // SUCCESS EMPTY DATA
                    throw ServiceProviderError.emptyData
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode != 200 {
                    throw ServiceProviderError.unknown
                }
                // is a 200OK but has an errorType with CONTENT_NOT_FOUND
                // we only check this in small responses due to performance
                else if result.data.count < 256,
                   let dataString = String(data: result.data, encoding: .utf8),
                   dataString.contains("errorType") && dataString.contains("CONTENT_NOT_FOUND") {
                    throw ServiceProviderError.resourceUnavailableOrDeleted
                }

                //
                // print("SportRadarRestConnector.Data: \(String(data: result.data, encoding: .utf8)!) ")
                
                return result.data
            }
            .decode(type: T.self, decoder: self.decoder)
            .mapError { error in
                // Debug helper
                // print("ServiceProvider-NetworkManager Error \(error)")
                
                if "\(error)" == "emptyData" {
                    return ServiceProviderError.emptyData
                }
                if let typedError = error as? ServiceProviderError,
                    case .resourceUnavailableOrDeleted = typedError {
                    return typedError
                }
                return ServiceProviderError.invalidResponse
            }
            .eraseToAnyPublisher()
    }

    func clearSessionKey() {
        return self.token = nil
    }

    func saveSessionKey(_ sessionKey: String) {
        return self.token = SportRadarSessionAccessToken(hash: sessionKey)
    }

    func retrieveSessionKey() -> String? {
        return self.token?.hash
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Events-Poseidon/SportRadarSessionAccessToken.swift
````swift
//
//  SportRadarSessionAccessToken.swift
//  
//
//  Created by Ruben Roques on 07/10/2022.
//

import Foundation

struct SportRadarSessionAccessToken: Equatable {
    var hash: String
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Events-Poseidon/SportRadarSocketConnector.swift
````swift
//
//  SportRadarConnector.swift
//
//
//  Created by Ruben Roques on 07/10/2022.
//

import Foundation
import Starscream
import Combine

protocol SportRadarConnectorSubscriber: AnyObject {
    func liveEventsUpdated(forContentIdentifier identifier: ContentIdentifier, withEvents: [EventsGroup])
    func preLiveEventsUpdated(forContentIdentifier identifier: ContentIdentifier, withEvents: [EventsGroup])

    func liveSportsUpdated(withSportTypes: [SportRadarModels.SportType])
    func preLiveSportsUpdated(withSportTypes: [SportRadarModels.SportType])
    func allSportsUpdated(withSportTypes: [SportRadarModels.SportType])

    func updateSportLiveCount(nodeId: String, liveCount: Int)
    func updateSportEventCount(nodeId: String, eventCount: Int)

    func eventDetailsUpdated(forContentIdentifier identifier: ContentIdentifier, event: Event)
    func eventDetailsLiveData(contentIdentifier: ContentIdentifier, eventLiveDataExtended: SportRadarModels.EventLiveDataExtended)

    func eventGroups(forContentIdentifier identifier: ContentIdentifier, withEvents: [EventsGroup])
    func outrightEventGroups(events: [EventsGroup])

    func marketDetails(forContentIdentifier identifier: ContentIdentifier, market: Market)

    func updateEventSecundaryMarkets(forContentIdentifier identifier: ContentIdentifier, event: Event)
    func updateEventMainMarket(forContentIdentifier identifier: ContentIdentifier, event: Event)

    func didReceiveGenericUpdate(content: SportRadarModels.ContentContainer)
}

class SportRadarSocketConnector: NSObject, Connector {
    
    var token: SportRadarSessionAccessToken? {
        return self.tokenSubject.value
    }

    private var tokenSubject: CurrentValueSubject<SportRadarSessionAccessToken?, Never> = .init(nil)
    var tokenPublisher: AnyPublisher<SportRadarSessionAccessToken?, Never> {
        return tokenSubject.eraseToAnyPublisher()
    }

    weak var messageSubscriber: SportRadarConnectorSubscriber?
    
    var connectionStatePublisher: AnyPublisher<ConnectorState, Never> {
        connectionStateSubject.eraseToAnyPublisher()
    }
    private let connectionStateSubject: CurrentValueSubject<ConnectorState, Never>
    
    private var webSocket : URLSessionWebSocketTask?
    private var socket: WebSocket
    private var isConnected: Bool {
        didSet {
            if self.isConnected {
                self.connectionStateSubject.send(.connected)
            }
            else {
                self.connectionStateSubject.send(.disconnected)
            }
        }
    }
    
    override init() {
        self.connectionStateSubject = .init(.disconnected)
        self.isConnected = false
        
        self.socket = WebSocket.init(request: Self.socketRequest(), useCustomEngine: false)
        super.init()
    }
    
    private func connectSocket() {

        self.socket.delegate = self
        self.socket.connect()

    }
    
    private static func socketRequest() -> URLRequest {
        let wssURLString = SportRadarConfiguration.shared.socketURL
        return URLRequest(url: URL(string: wssURLString)!)
    }
    
    private func sendListeningStarted() {
        
        var body: String = ""
        
        if let previousSessionId = self.token {
            print("ServiceProvider - ↔️ SportRadarSocketConnector using previous subscriberId \(previousSessionId)")
            body = """
                   {
                     "subscriberId": "\(previousSessionId.hash)",
                     "versionList": [],
                     "clientContext": {
                       "language":"\(SportRadarConfiguration.shared.socketLanguageCode)",
                       "ipAddress":""
                     }
                   }
                   """
        }
        else {
            print("ServiceProvider - ↔️ SportRadarSocketConnector empty subscriberId")

            body = """
                   {
                     "subscriberId": null,
                     "versionList": [],
                     "clientContext": {
                       "language":"\(SportRadarConfiguration.shared.socketLanguageCode)",
                       "ipAddress":""
                     }
                   }
                   """
        }
        
        self.socket.write(string: body) {
            print("ServiceProvider - ↔️ SportRadarSocketConnector: sendListeningStarted sent")
        }
        
    }
    
    func connect() {
        self.connectSocket()
    }
    
    func refreshConnection() {
        self.isConnected = false
        self.socket.forceDisconnect()
        self.socket = WebSocket.init(request: Self.socketRequest(), useCustomEngine: false)
        self.connectSocket()
    }
    
    func disconnect() {
        self.socket.forceDisconnect()
    }

}


extension SportRadarSocketConnector: Starscream.WebSocketDelegate {
    func didReceive(event: Starscream.WebSocketEvent, client: Starscream.WebSocketClient) {
        
        // yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ
        // 2022-07-05T09:51:00.000+02:00
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSSZZZZZ"

        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(dateFormatter)
        
        switch event {
        case .connected(let headers):
            self.sendListeningStarted()
            print("ServiceProvider - ↔️ SportRadarSocketConnector websocket 🟢 is connected: \(headers)")

        case .disconnected(let reason, let code):
            self.isConnected = false
            self.refreshConnection()
            print("ServiceProvider - ↔️ SportRadarSocketConnector websocket is disconnected: \(reason) with code: \(code)")

        case .text(let string):
            print("\n▶️ServiceProvider - ↔️ Ⓜ️ SportRadarSocketConnector received text: \(string)◀️\n")
            if let data = string.data(using: .utf8),
               let sportRadarSocketResponse = try? decoder.decode(SportRadarModels.NotificationType.self, from: data) {
                self.handleContentMessage(sportRadarSocketResponse, messageData: data)
            }

        case .binary(let data):
            if let sportRadarSocketResponse = try? decoder.decode(SportRadarModels.NotificationType.self, from: data) {
                self.handleContentMessage(sportRadarSocketResponse, messageData: data)
            }

        case .ping(_):
            print("ServiceProvider - ↔️ SportRadarSocketConnector ping")
            break
        case .pong(_):
            print("ServiceProvider - ↔️ SportRadarSocketConnector pong")
            break
        case .viabilityChanged(_):
            print("ServiceProvider - ↔️ SportRadarSocketConnector viabilityChanged")
            break
        case .reconnectSuggested(_):
            self.refreshConnection()
            print("ServiceProvider - ↔️ SportRadarSocketConnector reconnectSuggested")
        case .cancelled:
            self.isConnected = false
            print("ServiceProvider - ↔️ SportRadarSocketConnector cancelled")
        case .error(let error):
            self.isConnected = false
            print("ServiceProvider - ↔️ SportRadarSocketConnector websocket ❌ Error \(error.debugDescription)")
            self.refreshConnection()
        case .peerClosed:
            self.isConnected = false
            print("ServiceProvider - ↔️ SportRadarSocketConnector peerClosed")
        }
        
    }
    
    func handleContentMessage(_ messageType: SportRadarModels.NotificationType, messageData: Data) {
        
        switch messageType {
        case .listeningStarted(let sessionTokenId):
            self.tokenSubject.send(SportRadarSessionAccessToken(hash: sessionTokenId))
            self.isConnected = true
            
        case .contentChanges(let contents):
            for content in contents {
                switch content {
                case .liveEvents(let contentIdentifier, let events):
                    if let subscriber = self.messageSubscriber {
                        let eventsGroup = SportRadarModelMapper.eventsGroup(fromInternalEvents: events)
                        subscriber.liveEventsUpdated(forContentIdentifier: contentIdentifier, withEvents: [eventsGroup])
                    }
                case .preLiveEvents(let contentIdentifier, let events):
                    if let subscriber = self.messageSubscriber {
                        let eventsGroup = SportRadarModelMapper.eventsGroup(fromInternalEvents: events)
                        subscriber.preLiveEventsUpdated(forContentIdentifier: contentIdentifier, withEvents: [eventsGroup])
                    }

                case .liveSports(let sportsTypes):
                    if let subscriber = self.messageSubscriber {
                        subscriber.liveSportsUpdated(withSportTypes: sportsTypes)
                    }
                case .preLiveSports(let sportsTypes):
                    if let subscriber = self.messageSubscriber {
                        subscriber.preLiveSportsUpdated(withSportTypes: sportsTypes)
                    }
                case .allSports(let sportTypes):
                    if let subscriber = self.messageSubscriber {
                        subscriber.allSportsUpdated(withSportTypes: sportTypes)
                    }
                case .updateAllSportsLiveCount(_, let nodeId, let eventCount):
                    if let subscriber = self.messageSubscriber {
                        subscriber.updateSportLiveCount(nodeId: nodeId, liveCount: eventCount)
                    }
                case .updateAllSportsEventCount(_, let nodeId, let eventCount):
                    if let subscriber = self.messageSubscriber {
                        subscriber.updateSportEventCount(nodeId: nodeId, eventCount: eventCount)
                    }
                case .eventDetails(let contentIdentifier, let event):
                    if let subscriber = self.messageSubscriber, let eventValue = event {
                        let mappedEvent = SportRadarModelMapper.event(fromInternalEvent: eventValue)
                        subscriber.eventDetailsUpdated(forContentIdentifier: contentIdentifier, event: mappedEvent)
                    }
                case .eventGroup(let contentIdentifier, let events):
                    if let subscriber = self.messageSubscriber {
                        let eventsGroup = SportRadarModelMapper.eventsGroup(fromInternalEvents: events)
                        subscriber.eventGroups(forContentIdentifier: contentIdentifier, withEvents: [eventsGroup])
                    }
                case .outrightEventGroup(let events):
                    if let subscriber = self.messageSubscriber {
                        let eventsGroup = SportRadarModelMapper.eventsGroup(fromInternalEvents: events)
                        subscriber.outrightEventGroups(events: [eventsGroup])
                    }
                case .marketDetails(let contentIdentifier, let market):
                    if let subscriber = self.messageSubscriber, let marketValue = market {
                        let mappedMarket = SportRadarModelMapper.market(fromInternalMarket: marketValue)
                        subscriber.marketDetails(forContentIdentifier: contentIdentifier, market: mappedMarket)
                    }
                case .eventDetailsLiveData(let contentIdentifier, let eventLiveDataExtended):
                    if let subscriber = self.messageSubscriber, let eventLiveDataExtendedValue = eventLiveDataExtended {
                        subscriber.eventDetailsLiveData(contentIdentifier: contentIdentifier, eventLiveDataExtended: eventLiveDataExtendedValue)
                    }
                    
                case .updateEventSecundaryMarkets(let contentIdentifier, let event):
                    if let subscriber = self.messageSubscriber, let eventValue = event  {
                        let mappedEvent = SportRadarModelMapper.event(fromInternalEvent: eventValue)
                        subscriber.updateEventSecundaryMarkets(forContentIdentifier: contentIdentifier, event: mappedEvent)
                    }
                case .updateEventMainMarket(let contentIdentifier, let event):
                    if let subscriber = self.messageSubscriber, let eventValue = event  {
                        let mappedEvent = SportRadarModelMapper.event(fromInternalEvent: eventValue)
                        subscriber.updateEventMainMarket(forContentIdentifier: contentIdentifier, event: mappedEvent)
                    }

                case .unknown:
                    break
                    // print("❓SportRadarSocketConnector handleContentMessage unknown: \( String(data: messageData, encoding: .utf8) ?? "" )")

                default:
                    if let subscriber = self.messageSubscriber {
                        subscriber.didReceiveGenericUpdate(content: content)
                    }
                }
            }
            
        case .subscriberIdNotFoundError(let oldId):
            print("SportRadarSocketConnector subscriberIdNotFoundError error: \(oldId ?? "no id returned")")
            self.tokenSubject.send(nil) // Clear old token
            self.refreshConnection()
            
        case .genericError:
            print("SportRadarSocketConnector Uknown error")
            
        case .unknown:
            print("SportRadarSocketConnector Uknown Response \( String(data: messageData, encoding: .utf8) ?? "" )")
        }
        
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/Events-Poseidon/SportsMerger.swift
````swift
//
//  SportsMerger.swift
//  ServicesProvider
//
//  Created by Ruben Roques on 20/02/2025.
//

import Foundation
import Combine

// Responsible for merging sports data from different sources while maintaining proper counting and IDs
final class SportsMerger {
    // MARK: - Properties
    private var cancellables = Set<AnyCancellable>()
    private let session: URLSession

    private var sportsCurrentValueSubject: CurrentValueSubject<SubscribableContent<[SportType]>, ServiceProviderError> = .init(.disconnected)

    // Content identifiers
    private let liveSportsIdentifier: ContentIdentifier
    private let allSportsIdentifier: ContentIdentifier

    // Subscriptions
    private var liveSportsSubscription: Subscription? // TODO: SP should be weak to avoid retain c
    private var allSportsSubscription: Subscription? // TODO: SP should be weak to avoid retain c

    private let sessionToken: String
    private var waitingSubscription = true

    // Only keep live counts state
    private var liveSportsCounts: [String: Int] = [:]

    var isActive: Bool {
        return true
    }

    // MARK: - Public Interface
    var sportsPublisher: AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError> {
        return sportsCurrentValueSubject.eraseToAnyPublisher()
    }

    init(sessionToken: String, urlSession: URLSession = .init(configuration: .default)) {
        print("[SERVICEPROVIDER][MERGER] Initializing SportsMerger with session token")
        self.sessionToken = sessionToken
        self.session = urlSession

        // Setup content identifiers
        self.liveSportsIdentifier = ContentIdentifier(
            contentType: .liveSports,
            contentRoute: .liveSports
        )

        self.allSportsIdentifier = ContentIdentifier(
            contentType: .allSports,
            contentRoute: .allSports
        )

        // Subscribe to state changes
        self.sportsCurrentValueSubject
            .sink { completion in
                print("[SERVICEPROVIDER][MERGER.value] Subject completed with: \(completion)")
            } receiveValue: { state in
                switch state {
                case .disconnected:
                    print("[SERVICEPROVIDER][MERGER.value] Subject is in disconnected state")
                case .connected:
                    print("[SERVICEPROVIDER][MERGER.value] Subject is in connected state")
                case .contentUpdate(let sports):
                    print("[SERVICEPROVIDER][MERGER.value] Subject is in contentUpdate state with \(sports.count) sports")
                }
            }
            .store(in: &cancellables)

        // Start subscriptions
        self.setupSubscriptions()
    }

    private func setupSubscriptions() {
        print("[SERVICEPROVIDER][MERGER] Setting up subscriptions")

        if let allSportsSubscription = self.allSportsSubscription {
            self.sportsCurrentValueSubject.send(.connected(subscription: allSportsSubscription))
        } else {
            let subscription = Subscription(
                contentIdentifier: self.allSportsIdentifier,
                sessionToken: self.sessionToken,
                unsubscriber: self
            )
            self.sportsCurrentValueSubject.send(.connected(subscription: subscription))
            self.allSportsSubscription = subscription
        }

        // Subscribe to all sports first
        self.subscribeAllSports()
            .flatMap { [weak self] _ -> AnyPublisher<Void, ServiceProviderError> in
                print("[SERVICEPROVIDER][MERGER] All sports subscription successful, subscribing to live sports")
                guard let self = self else {
                    return Fail(error: ServiceProviderError.onSubscribe).eraseToAnyPublisher()
                }
                // Subscribe to live sports
                return self.subscribeLiveSports()
            }
            .sink { [weak self] completion in
                guard let self = self else { return }

                switch completion {
                case .finished:
                    print("[SERVICEPROVIDER][MERGER] All subscriptions completed successfully")

                case .failure(let error):
                    print("[SERVICEPROVIDER][MERGER] Subscription setup failed with error: \(error)")
                    self.sportsCurrentValueSubject.send(completion: .failure(error))
                }
                self.waitingSubscription = false

            } receiveValue: { _ in }
            .store(in: &cancellables)
    }

    private func subscribeAllSports() -> AnyPublisher<Void, ServiceProviderError> {
        print("[SERVICEPROVIDER][MERGER] Subscribing to all sports")
        let endpoint = SportRadarRestAPIClient.subscribe(
            sessionToken: self.sessionToken,
            contentIdentifier: self.allSportsIdentifier
        )

        guard let request = endpoint.request() else {
            print("[SERVICEPROVIDER][MERGER] Failed to create request for all sports subscription")
            return Fail(error: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
        }

        return session.dataTaskPublisher(for: request)
            .tryMap { data, response -> Data in
                guard
                    let httpResponse = response as? HTTPURLResponse,
                    (200...299).contains(httpResponse.statusCode)
                else {
                    print("[SERVICEPROVIDER][MERGER] All sports subscription request failed")
                    throw ServiceProviderError.onSubscribe
                }
                print("[SERVICEPROVIDER][MERGER] All sports subscription request successful")
                return data
            }
            .mapError { error in
                print("[SERVICEPROVIDER][MERGER] Error mapping all sports subscription response \(error)")
                return ServiceProviderError.onSubscribe
            }
            .flatMap { data -> AnyPublisher<Void, ServiceProviderError> in
                if let responseString = String(data: data, encoding: .utf8),
                   responseString.lowercased().contains("version") {
                    print("[SERVICEPROVIDER][MERGER] All sports subscription response validated")
                    return Just(()).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                } else {
                    print("[SERVICEPROVIDER][MERGER] Invalid all sports subscription response format")
                    return Fail(error: ServiceProviderError.onSubscribe).eraseToAnyPublisher()
                }
            }
            .eraseToAnyPublisher()
    }

    private func subscribeLiveSports() -> AnyPublisher<Void, ServiceProviderError> {
        print("[SERVICEPROVIDER][MERGER] Subscribing to live sports")
        let endpoint = SportRadarRestAPIClient.subscribe(
            sessionToken: self.sessionToken,
            contentIdentifier: self.liveSportsIdentifier
        )

        guard let request = endpoint.request() else {
            print("[SERVICEPROVIDER][MERGER] Failed to create request for live sports subscription")
            return Fail(error: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
        }

        return Future<Void, ServiceProviderError> { [weak self] promise in
            let task = URLSession.shared.dataTask(with: request) { [weak self] data, response, error in
                guard
                    error == nil,
                    let httpResponse = response as? HTTPURLResponse,
                    (200...299).contains(httpResponse.statusCode)
                else {
                    print("[SERVICEPROVIDER][MERGER] Live sports subscription request failed")
                    promise(.failure(.onSubscribe))
                    return
                }

                if let self = self {
                    print("[SERVICEPROVIDER][MERGER] Creating live sports subscription")
                    let subscription = Subscription(
                        contentIdentifier: self.liveSportsIdentifier,
                        sessionToken: self.sessionToken,
                        unsubscriber: self
                    )
                    self.liveSportsSubscription = subscription
                    self.allSportsSubscription?.associateSubscription(subscription)
                    print("[SERVICEPROVIDER][MERGER] Live sports subscription created and associated")
                }

                print("[SERVICEPROVIDER][MERGER] Live sports subscription successful")
                promise(.success(()))
            }
            task.resume()
        }.eraseToAnyPublisher()
    }

    func updateSports(_ sports: [SportType], forContentIdentifier identifier: ContentIdentifier) {
        guard identifier == self.allSportsIdentifier || identifier == self.liveSportsIdentifier else {
            //
            return
        }

        print("[SERVICEPROVIDER][MERGER] Updating sports for identifier: \(identifier.contentType.rawValue)")
        print("[SERVICEPROVIDER][MERGER.value] Current sportsCurrentValueSubject state: \(String(describing: self.sportsCurrentValueSubject.value))")

        if identifier == self.allSportsIdentifier {
            print("[SERVICEPROVIDER][MERGER] Updating base sports list with \(sports.count) sports")

            // Merge with existing live counts
            var updatedSports = sports
            for (index, sport) in updatedSports.enumerated() {
                if let alphaId = sport.alphaId {
                    updatedSports[index].numberLiveEvents = self.liveSportsCounts[alphaId] ?? 0
                }
            }

            print("[SERVICEPROVIDER][MERGER] Sending contentUpdate with \(updatedSports.count) sports")
            self.sportsCurrentValueSubject.send(.contentUpdate(content: updatedSports))
            print("[SERVICEPROVIDER][MERGER] New sportsCurrentValueSubject state after all sports update: \(String(describing: self.sportsCurrentValueSubject.value))")

        } else if identifier == self.liveSportsIdentifier {
            print("[SERVICEPROVIDER][MERGER] Updating live counts")
            // Update live counts dictionary
            for sport in sports {
                if let alphaId = sport.alphaId {
                    self.liveSportsCounts[alphaId] = sport.numberLiveEvents
                }
            }

            // Get current sports from subject and merge with live counts
            switch self.sportsCurrentValueSubject.value {
            case .disconnected:
                print("[SERVICEPROVIDER][MERGER] WARNING: Subject is in disconnected state")
            case .connected:
                print("[SERVICEPROVIDER][MERGER] WARNING: Subject is in connected state but no sports data")
            case .contentUpdate(let currentSports):
                print("[SERVICEPROVIDER][MERGER] Found \(currentSports.count) current sports to update")
                var updatedSports = currentSports
                for (index, sport) in updatedSports.enumerated() {
                    if let alphaId = sport.alphaId {
                        updatedSports[index].numberLiveEvents = self.liveSportsCounts[alphaId] ?? 0
                    }
                }

                print("[SERVICEPROVIDER][MERGER] Sending contentUpdate with \(updatedSports.count) sports")
                self.sportsCurrentValueSubject.send(.contentUpdate(content: updatedSports))
                print("[SERVICEPROVIDER][MERGER] New sportsCurrentValueSubject state after live update: \(String(describing: self.sportsCurrentValueSubject.value))")
            }
        }
    }

    func reconnect(withNewSessionToken newSessionToken: String) {
        print("[SERVICEPROVIDER][MERGER] Reconnecting with new session token")
        // Resubscribe with new token
        let allSportsEndpoint = SportRadarRestAPIClient.subscribe(
            sessionToken: newSessionToken,
            contentIdentifier: self.allSportsIdentifier
        )

        if let request = allSportsEndpoint.request() {
            print("[SERVICEPROVIDER][MERGER] Resubscribing to all sports")
            let task = session.dataTask(with: request)
            task.resume()
        } else {
            print("[SERVICEPROVIDER][MERGER] Failed to create request for all sports resubscription")
        }

        let liveSportsEndpoint = SportRadarRestAPIClient.subscribe(
            sessionToken: newSessionToken,
            contentIdentifier: self.liveSportsIdentifier
        )

        if let request = liveSportsEndpoint.request() {
            print("[SERVICEPROVIDER][MERGER] Resubscribing to live sports")
            let task = session.dataTask(with: request)
            task.resume()
        } else {
            print("[SERVICEPROVIDER][MERGER] Failed to create request for live sports resubscription")
        }
    }
}

// MARK: - UnsubscriptionController
extension SportsMerger: UnsubscriptionController {
    func unsubscribe(subscription: Subscription) {
        print("[SERVICEPROVIDER][MERGER] Unsubscribing from content: \(subscription.contentIdentifier.contentType.rawValue)")
        let endpoint = SportRadarRestAPIClient.unsubscribe(
            sessionToken: subscription.sessionToken,
            contentIdentifier: subscription.contentIdentifier
        )

        guard let request = endpoint.request() else {
            print("[SERVICEPROVIDER][MERGER] Failed to create unsubscribe request")
            return
        }

        let task = session.dataTask(with: request) { data, response, error in
            guard
                error == nil,
                let httpResponse = response as? HTTPURLResponse,
                (200...299).contains(httpResponse.statusCode)
            else {
                print("[SERVICEPROVIDER][MERGER] Unsubscribe request failed with error: \(error?.localizedDescription ?? "unknown error")")
                return
            }
            print("[SERVICEPROVIDER][MERGER] Successfully unsubscribed from \(subscription.contentIdentifier.contentType.rawValue)")
        }
        task.resume()
    }
}

// MARK: - Live Data Handling
extension SportsMerger {
    /// Updates live event counts for sports
    /// - Parameters:
    ///   - sports: Current list of sports
    ///   - liveCounts: Dictionary of sport IDs to live event counts
    /// - Returns: Updated sports array with new live counts
    func updateLiveEventCounts(sports: [SportType], liveCounts: [String: Int]) -> [SportType] {
        print("[SERVICEPROVIDER][MERGER] Updating live event counts for \(sports.count) sports")
        let updatedSports = sports.map { sport in
            var updatedSport = sport
            if let alphaId = sport.alphaId {
                let newCount = liveCounts[alphaId] ?? 0
                print("[SERVICEPROVIDER][MERGER] Setting live count for sport \(alphaId): \(newCount)")
                updatedSport.numberLiveEvents = newCount
            }
            return updatedSport
        }
        print("[SERVICEPROVIDER][MERGER] Finished updating live event counts")
        return updatedSports
    }
}

// MARK: - Event Counting
extension SportsMerger {
    /// Updates total event counts for sports
    /// - Parameters:
    ///   - sports: Current list of sports
    ///   - eventCounts: Dictionary of sport IDs to total event counts
    /// - Returns: Updated sports array with new event counts
    func updateEventCounts(sports: [SportType], eventCounts: [String: Int]) -> [SportType] {
        print("[SERVICEPROVIDER][MERGER] Updating event counts for \(sports.count) sports")
        let updatedSports = sports.map { sport in
            var updatedSport = sport
            if let numericId = sport.numericId {
                let newCount = eventCounts[numericId] ?? 0
                print("[SERVICEPROVIDER][MERGER] Setting event count for sport \(numericId): \(newCount)")
                updatedSport.numberEvents = newCount
            }
            return updatedSport
        }
        print("[SERVICEPROVIDER][MERGER] Finished updating event counts")
        return updatedSports
    }

    /// Updates the event count for a specific sport
    /// - Parameters:
    ///   - nodeId: The numeric ID of the sport to update
    ///   - eventCount: The new event count
    func updateSportEventCount(nodeId: String, eventCount: Int) {
        print("[SERVICEPROVIDER][MERGER] Updating event count for sport \(nodeId): \(eventCount)")
        if case .contentUpdate(let currentSports) = sportsCurrentValueSubject.value {
            var updatedSports = currentSports
            if let sportIndex = updatedSports.firstIndex(where: { $0.numericId == nodeId }) {
                updatedSports[sportIndex].numberEvents = eventCount
                print("[SERVICEPROVIDER][MERGER] Found sport at index \(sportIndex), updating event count")
                updateSports(updatedSports, forContentIdentifier: allSportsIdentifier)
            } else {
                print("[SERVICEPROVIDER][MERGER] Sport not found for nodeId: \(nodeId)")
            }
        } else {
            print("[SERVICEPROVIDER][MERGER] No current sports available to update event count")
        }
    }

    /// Updates the live event count for a specific sport
    /// - Parameters:
    ///   - nodeId: The numeric ID of the sport to update
    ///   - liveCount: The new live event count
    func updateSportLiveCount(nodeId: String, liveCount: Int) {
        print("[SERVICEPROVIDER][MERGER] Updating live count for sport \(nodeId): \(liveCount)")
        if case .contentUpdate(let currentSports) = sportsCurrentValueSubject.value {
            var updatedSports = currentSports
            if let sportIndex = updatedSports.firstIndex(where: { $0.numericId == nodeId }) {
                updatedSports[sportIndex].numberLiveEvents = liveCount
                print("[SERVICEPROVIDER][MERGER] Found sport at index \(sportIndex), updating live count")
                updateSports(updatedSports, forContentIdentifier: liveSportsIdentifier)
            } else {
                print("[SERVICEPROVIDER][MERGER] Sport not found for nodeId: \(nodeId)")
            }
        } else {
            print("[SERVICEPROVIDER][MERGER] No current sports available to update live count")
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/PAM-Omega/OmegaAPIClient.swift
````swift
//
//  OmegaAPIClient.swift
//  
//
//  Created by Ruben Roques on 24/10/2022.
//

import Foundation

/*
 username - gomafrontend
 pass - Omega123
 https://ps.omegasys.eu/ps/ips/login
 https://ps.omegasys.eu/ps/ips/openGameSession
 https://ps.omegasys.eu/ps/ips/logout
 https://ps.omegasys.eu/ps/ips/getPlayerInfo
 https://ps.omegasys.eu/ps/ips/getBalanceSimple
 https://ps.omegasys.eu/ps/ips/updatePlayerInfo
 https://ps.omegasys.eu/ps/ips/quickSignup [ get ] [ver se o email é válido]
 https://ps.omegasys.eu/ps/ips/quickSignup [ post ]
 https://ps.omegasys.eu/ps/ips/resendVerificationCode
 https://ps.omegasys.eu/ps/ips/signupConfirmation
 https://ps.omegasys.eu/ps/ips/forgotPasswordStep1And2
 https://ps.omegasys.eu/ps/ips/updatePassword
 */

enum OmegaAPIClient {
    case login(username: String, password: String)
    case openSession
    case logout
    case playerInfo
    case updatePlayerInfo(username: String?,
                          email: String?,
                          firstName: String?,
                          lastName: String?,
                          birthDate: Date?,
                          gender: String?,
                          address: String?,
                          province: String?,
                          city: String?,
                          postalCode: String?,
                          country: String?,
                          cardId: String?)
    case checkCredentialEmail(email: String)
    case checkUsername(username: String)
    case quickSignup(email: String,
                     username: String,
                     password: String,
                     birthDate: Date,
                     mobilePrefix: String,
                     mobileNumber: String,
                     countryIsoCode: String,
                     currencyCode: String)
    case signUp(email: String,
                username: String,
                password: String,
                birthDate: Date,
                mobilePrefix: String,
                mobileNumber: String,
                nationalityIso2Code: String,
                currencyCode: String,
                firstName: String,
                lastName: String,
                middleName: String?,
                gender: String,
                address: String,
                city: String,
                postalCode: String,
                countryIso2Code: String,

                bonusCode: String?,
                receiveMarketingEmails: Bool?,
                avatarName: String?,
                godfatherCode: String?,

                birthDepartment: String,
                birthCity: String,
                birthCountry: String,

                streetNumber: String,
                consentedIds: [String],
                unconsentedIds: [String],
                mobileVerificationRequestId: String?)
    
    case updateExtraInfo(placeOfBirth: String?, address2: String?)

    case updateDeviceIdentifier(deviceIdentifier: String, appVersion: String)
    
    case resendVerificationCode(username: String)
    case signupConfirmation(email: String,
                            confirmationCode: String)
    case getCountries
    case getCurrentCountry
    case forgotPassword(email: String,
                        secretQuestion: String? = nil,
                        secretAnswer: String? = nil)
    case updatePassword(oldPassword: String,
                        newPassword: String)


    case updateWeeklyDepositLimits(newLimit: Double)
    case updateWeeklyBettingLimits(newLimit: Double)
    case updateResponsibleGamingLimits(newLimit: Double, limitType: String, limitPeriod: String)
    case getPersonalDepositLimits
    case getLimits
    case getResponsibleGamingLimits(limitType: String, periodType: String)
    case lockPlayer(isPermanent: Bool? = nil, lockPeriodUnit: String? = nil, lockPeriod: String? = nil)

    case getBalance
    case getCashbackBalance

    case quickSignupCompletion(firstName: String?,
                               lastName: String?,
                               birthDate: Date?,
                               gender: String?,
                               mobileNumber: String?,
                               address: String?,
                               province: String?,
                               city: String?,
                               postalCode: String?,
                               country: String?,
                               cardId: String?,
                               securityQuestion: String?,
                               securityAnswer: String?)

    case getDocumentTypes
    case getUserDocuments
    case uploadUserDocument(documentType: String, file: Data, body: Data, header: String)
    case uploadMultipleUserDocuments(documentType: String,
                                     files: [String: Data], body: Data, header: String)
    
    case getPayments
    case processDeposit(paymentMethod: String, amount: Double, option: String)
    case updatePayment(amount: Double, paymentId: String, type: String, returnUrl: String?, nameOnCard: String?, encryptedExpiryYear: String?, encryptedExpiryMonth: String?, encryptedSecurityCode: String?, encryptedCardNumber: String?)
    case cancelDeposit(paymentId: String)
    case checkPaymentStatus(paymentMethod: String, paymentId: String)

    case getWithdrawalsMethods
    case processWithdrawal(withdrawalMethod: String, amount: Double, conversionId: String?)
    case prepareWithdrawal(withdrawalMethod: String)
    case getPendingWithdrawals
    case cancelWithdrawal(paymentId: Int)
    case getPaymentInformation
    case addPaymentInformation(type: String, fields: String)

    case getTransactionsHistory(startDate: String, endDate: String, transactionType: [String]? = nil, pageNumber: Int? = nil, pageSize: Int? = nil)

    case getGrantedBonuses
    case redeemBonus(code: String)
    case getAvailableBonuses
    case redeemAvailableBonuses(partyId: String, bonusId: String)
    case cancelBonus(bonusId: String)
    case optOutBonus(partyId: String, bonusId: String)

    case contactUs(firstName: String, lastName: String, email: String, subject: String, message: String)

    case contactSupport(userIdentifier: String, firstName: String, lastName: String, email: String, subject: String, subjectType: String, message: String, isLogged: Bool)

    case getAllConsents
    case getUserConsents
    case setUserConsents(consentVersionIds: [Int]? = nil, unconsentVersionIds: [Int]? = nil)

    case getSumsubAccessToken(userId: String, levelName: String, body: Data? = nil, header: [String: String])
    case getSumsubApplicantData(userId: String, body: Data? = nil, header: [String: String])

    case generateDocumentTypeToken(docType: String)
    case checkDocumentationData

    case getMobileVerificationCode(mobileNumber: String)
    case verifyMobileCode(code: String, requestId: String)
    
    case getReferralLink
    case getReferees
}

extension OmegaAPIClient: Endpoint {
    
    var endpoint: String {
        switch self {
        case .login:
            return "/ps/ips/login"
        case .openSession:
            return "/ps/ips/openGameSession"
        case .logout:
            return "/ps/ips/logout"
        case .playerInfo:
            return "/ps/ips/getPlayerInfo"
        case .updatePlayerInfo:
            return "/ps/ips/updatePlayerInfo"
        case .checkCredentialEmail:
            return "/ps/ips/checkCredential"
        case .checkUsername:
            return "/ps/ips/getUserIdSuggestion"
        case .quickSignup:
            return "/ps/ips/quickSignup"
        case .signUp:
            return "/ps/ips/signup"
        case .resendVerificationCode:
            return "/ps/ips/resendVerificationCode"
        case .signupConfirmation:
            return "/ps/ips/signupConfirmation"
        case .getCountries:
            return "/ps/ips/getCountries"
        case .getCurrentCountry:
            return "/ps/ips/getCountryInfo"
        case .forgotPassword:
            return "/ps/ips/forgotPasswordStep1And2"
        case .updatePassword:
            return "/ps/ips/updatePassword"
        case .updateExtraInfo:
            return "/ps/ips/updateExtraInfo"
        case .updateDeviceIdentifier:
            return "/ps/ips/updateExtraInfo"

        case .updateWeeklyDepositLimits:
            return "/ps/ips/setPersonalDepositLimits"
        case .updateWeeklyBettingLimits:
            return "/ps/ips/updateWagerLimit"
        case .updateResponsibleGamingLimits:
            return "/ps/ips/updateResponsibleGamingLimit"
        case .getPersonalDepositLimits:
            return "/ps/ips/getPersonalDepositLimits"
        case .getLimits:
            return "/ps/ips/getLimits"
        case .getResponsibleGamingLimits:
            return "/ps/ips/getResponsibleGamingLimit"
        case .lockPlayer:
            return "/ps/ips/lockPlayer"

        case .getBalance:
            return "/ps/ips/getBalance"
        case .getCashbackBalance:
            return "/ps/ips/getSportRadarReportedCashbackBalance"
        case .quickSignupCompletion:
            return "/ps/ips/quickSignupCompletion"
        case .getDocumentTypes:
            return "/ps/ips/getDocumentTypes"
        case .getUserDocuments:
            return "/ps/ips/getUserDocuments"
        case .uploadUserDocument:
            return "/ps/ips/uploadUserDocument"
        case .uploadMultipleUserDocuments:
            return "/ps/ips/uploadMultiUserDocument"

        case .getPayments:
            return "/ps/ips/getDepositMethods"
        case .processDeposit:
            return "/ps/ips/processDeposit"
        case .updatePayment:
            return "/ps/ips/updatePayment"
        case .cancelDeposit:
            return "/ps/ips/cancelDeposit"
        case .checkPaymentStatus:
            return "/ps/ips/checkPaymentStatus"

        case .getWithdrawalsMethods:
            return "/ps/ips/getWithdrawalMethods"
        case .processWithdrawal:
            return "/ps/ips/processWithdrawal"
        case .prepareWithdrawal:
            return "/ps/ips/prepareWithdrawal"
        case .getPendingWithdrawals:
            return "/ps/ips/getPendingWithdrawals"
        case .cancelWithdrawal:
            return "/ps/ips/cancelWithdrawal"
        case .getPaymentInformation:
            return "/ps/ips/getPaymentInformation"
        case .addPaymentInformation:
            return "/ps/ips/addPaymentInformation"

        case .getTransactionsHistory:
            return "/ps/ips/getTransactionHistoryByCurrency"

        case .getGrantedBonuses:
            return "/ps/ips/getBonuses"
        case .redeemBonus:
            return "/ps/ips/redeemBonus"
        case .getAvailableBonuses:
            return "/ps/ips/getEligibleOptInBonusPlans"
        case .redeemAvailableBonuses:
            return "/ps/ips/optInBonus"
        case .cancelBonus:
            return "/ps/ips/cancelBonus"
        case .optOutBonus:
            return "/ps/ips/optOutBonus"

        case .contactUs:
            return "/ps/ips/contactus"

        case .contactSupport:
            return "/api/v2/requests"

        case .getAllConsents:
            return "/ps/ips/consents"
        case .getUserConsents:
            return "/ps/ips/user/consents"
        case .setUserConsents:
            return "/ps/ips/user/consents/save"

        case .getSumsubAccessToken:
            return "/resources/accessTokens"
        case .getSumsubApplicantData(let userId, _, _):
            return "/resources/applicants/-;externalUserId=\(userId)/one"

        case .generateDocumentTypeToken:
            return "/ps/ips/generateToken"

        case .checkDocumentationData:
            return "/ps/ips/checkDocumentation"
            
        case .getMobileVerificationCode:
            return "/ps/ips/verify"
        case .verifyMobileCode:
            return "/ps/ips/verify"
            
        case .getReferralLink:
            return "/ps/ips/getReferralLinks"
        case .getReferees:
            return "/ps/ips/getReferees"
        }
    }
    
    var query: [URLQueryItem]? {
        switch self {
        case .login:
//            return [URLQueryItem(name: "username", value: username),
//                    URLQueryItem(name: "password", value: password)]
            return nil
        case .openSession:
            return [URLQueryItem(name: "productCode", value: "SPORT_RADAR"),
                    URLQueryItem(name: "gameId", value: "SPORTSBOOK")]
        case .logout:
            return nil
        case .playerInfo:
            return nil

        case .checkCredentialEmail(let email):
            return [URLQueryItem(name: "field", value: "email"),
                    URLQueryItem(name: "value", value: email)]
        case .checkUsername(let username):
            return [URLQueryItem(name: "userId", value: username)]

        case .quickSignup(let email, let username, let password, let birthDate,
                          let mobilePrefix, let mobileNumber, let countryIsoCode, let currencyCode):
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "yyyy-MM-dd"
            let birthDateString = dateFormatter.string(from: birthDate)
            
            let phoneNumber = "\(mobilePrefix)\(mobileNumber)".replacingOccurrences(of: "+", with: "")
            
            return [
                URLQueryItem(name: "username", value: username),
                URLQueryItem(name: "password", value: password),
                URLQueryItem(name: "email", value: email),
                URLQueryItem(name: "currency", value: currencyCode),
                URLQueryItem(name: "receiveEmail", value: "true"),
                URLQueryItem(name: "country", value: countryIsoCode),
                URLQueryItem(name: "birthDate", value: birthDateString),
                URLQueryItem(name: "mobile", value: phoneNumber)
            ]

        case .signUp(let email,
                     let username,
                     let password,
                     let birthDate,
                     let mobilePrefix,
                     let mobileNumber,
                     _,
                     let currencyCode,
                     let firstName,
                     let lastName,
                     let middleName,
                     let gender,
                     let address,
                     let city,
                     let postalCode,
                     let countryIso2Code,
                     let bonusCode,
                     let receiveMarketingEmails,
                     let avatarName,
                     let godfatherCode,
                     let birthDepartment,
                     let birthCity,
                     let birthCountry,
                     let streetNumber,
                     let consentedIds,
                     let unconsentedIds,
                     let mobileVerificationRequestId):

            let phoneNumber = "\(mobilePrefix)\(mobileNumber)".replacingOccurrences(of: "+", with: "")

            var query: [URLQueryItem] = []

            query.append(URLQueryItem(name: "username", value: username))
            query.append(URLQueryItem(name: "password", value: password))
            query.append(URLQueryItem(name: "email", value: email))
            query.append(URLQueryItem(name: "currency", value: currencyCode))
            // query.append(URLQueryItem(name: "nationality", value: nationalityIso2Code))
            query.append(URLQueryItem(name: "mobile", value: phoneNumber))
            query.append(URLQueryItem(name: "city", value: city))
            query.append(URLQueryItem(name: "country", value: countryIso2Code))

            query.append(URLQueryItem(name: "firstName", value: firstName))
            query.append(URLQueryItem(name: "lastName", value: lastName))
            
            if let middleName = middleName {
                query.append(URLQueryItem(name: "middleName", value: middleName))
            }
            
            query.append(URLQueryItem(name: "gender", value: gender))
            query.append(URLQueryItem(name: "address", value: address))

            query.append(URLQueryItem(name: "postalCode", value: postalCode))
            query.append(URLQueryItem(name: "streetNumber", value: streetNumber))
            query.append(URLQueryItem(name: "birthDepartment", value: birthDepartment))
            query.append(URLQueryItem(name: "birthCity", value: birthCity))
            query.append(URLQueryItem(name: "birthCountry", value: birthCountry))

            let dateFromatter = DateFormatter()
            dateFromatter.dateFormat = "yyyy-MM-dd"
            let birthDateString = dateFromatter.string(from: birthDate)
            query.append(URLQueryItem(name: "birthDate", value: birthDateString))


            if let bonusCode = bonusCode { query.append(URLQueryItem(name: "bonusCode", value: bonusCode)) }
            if let receiveMarketingEmails = receiveMarketingEmails {
                query.append(URLQueryItem(name: "receiveEmail", value: receiveMarketingEmails ? "true" : "false"))
            }

            if let mobileVerificationRequestIdValue = mobileVerificationRequestId {
                query.append(URLQueryItem(name: "verificationRequestId", value: mobileVerificationRequestIdValue))
            }
            
            let extraInfo = """
                            {
                            "avatar":"\(avatarName ?? "")",
                            "device_os": "iOS",
                            "godfatherCode":"\(godfatherCode ?? "")"
                            }
                            """
            
            query.append(URLQueryItem(name: "extraInfo", value: extraInfo))
            
            if let godfatherCode {
                query.append(URLQueryItem(name: "referralCode", value: "\(godfatherCode)"))
            }

            for consentedId in consentedIds {
                query.append(URLQueryItem(name: "consentedVersions[]", value: consentedId))
            }
            
            for unconsentedId in unconsentedIds {
                query.append(URLQueryItem(name: "unConsentedversions[]", value: unconsentedId))
            }
            
            
            return query

        case .updateExtraInfo(let placeOfBirth, let address2):
            var query: [URLQueryItem] = []
            let extraInfo = """
                            {
                                "placeOfBirth":"\(placeOfBirth ?? "")",
                                "streetLine2":"\(address2 ?? "")"
                            }
                            """
            query.append(URLQueryItem(name: "extraInfo", value: extraInfo))
            return query
            
        case .updateDeviceIdentifier(let deviceIdentifier, let appVersion):
            
            var query: [URLQueryItem] = []
            let extraInfo = """
                            {
                                "device_app_version": "\(appVersion)",
                                "device_os": "iOS",
                                "device_token_ios": "\(deviceIdentifier)",
                                "device_token_last" : "\(deviceIdentifier)"
                            }
                            """
            query.append(URLQueryItem(name: "extraInfo", value: extraInfo))
            return query
            
        case .resendVerificationCode(let username):
            return [
                URLQueryItem(name: "username", value: username),
                URLQueryItem(name: "verificationTarget", value: "email"),
            ]
        case .signupConfirmation(let email, let confirmationCode):
            return [
                URLQueryItem(name: "confirmationCode", value: confirmationCode),
                URLQueryItem(name: "email", value: email),
            ]
        case .updatePlayerInfo(let username, let email, let firstName, let lastName,
                               let birthDate, let gender, let address, let province, let city,
                               let postalCode, let country, let cardId):
            
            var query: [URLQueryItem] = []
            
            if let username = username { query.append(URLQueryItem(name: "userid", value: username)) }
            if let email = email { query.append(URLQueryItem(name: "email", value: email)) }
            
            if let firstName = firstName { query.append(URLQueryItem(name: "firstName", value: firstName)) }
            if let lastName = lastName { query.append(URLQueryItem(name: "lastName", value: lastName)) }
            if let address = address { query.append(URLQueryItem(name: "address", value: address)) }
            if let province = province { query.append(URLQueryItem(name: "province", value: province)) }
            
            if let gender = gender { query.append(URLQueryItem(name: "gender", value: gender)) }
            if let country = country { query.append(URLQueryItem(name: "country", value: country)) }
            if let birthDate = birthDate {
                let dateFromatter = DateFormatter()
                dateFromatter.dateFormat = "yyyy-MM-dd"
                let birthDateString = dateFromatter.string(from: birthDate)
                query.append(URLQueryItem(name: "birthDate", value: birthDateString))
            }
            
            if let city = city { query.append(URLQueryItem(name: "city", value: city)) }
            if let postalCode = postalCode { query.append(URLQueryItem(name: "postalCode", value: postalCode)) }
            if let cardId = cardId { query.append(URLQueryItem(name: "idCardNumber", value: cardId)) }
            
            return query
        case .getCountries:
            return nil
        case .getCurrentCountry:
            return nil
        case .forgotPassword(let email, let secretQuestion, let secretAnswer):
            var queryItemsURL: [URLQueryItem] = []

            let queryItem = URLQueryItem(name: "email", value: email)
            queryItemsURL.append(queryItem)

            if secretQuestion != nil {
                let queryItem = URLQueryItem(name: "secretQuestion", value: secretQuestion)
                queryItemsURL.append(queryItem)
            }

            if secretAnswer != nil {
                let queryItem = URLQueryItem(name: "secretAnswer", value: secretAnswer)
                queryItemsURL.append(queryItem)
            }

            return queryItemsURL
        case .updatePassword(let oldPassword, let newPassword):
            return [URLQueryItem(name: "oldPassword", value: oldPassword),
                    URLQueryItem(name: "newPassword", value: newPassword)
            ]

        case .updateWeeklyDepositLimits(let newLimit):
            let limitFormated = String(format: "%.2f", newLimit)
            return [URLQueryItem(name: "weeklyLimit", value: limitFormated)]
        case .updateWeeklyBettingLimits(let newLimit):
            let limitFormated = String(format: "%.2f", newLimit)
            return [URLQueryItem(name: "limit", value: limitFormated)]
        case .updateResponsibleGamingLimits(let newLimit, let limitType, let limitPeriod):
            let limitFormated = String(format: "%.2f", newLimit)
            return [URLQueryItem(name: "limitType", value: limitType),
                    URLQueryItem(name: "periodType", value: limitPeriod),
                    URLQueryItem(name: "limit", value: limitFormated)
            ]
        case .lockPlayer(let isPermanent, let lockPeriodUnit, let lockPeriod):
            var queryItemsURL: [URLQueryItem] = []

            if isPermanent != nil {
                let queryItem = URLQueryItem(name: "isPermanent", value: "true")
                queryItemsURL.append(queryItem)
            }

            if lockPeriodUnit != nil {
                let queryItem = URLQueryItem(name: "lockPeriodUnit", value: lockPeriodUnit)
                queryItemsURL.append(queryItem)
            }

            if lockPeriod != nil {
                let queryItem = URLQueryItem(name: "lockPeriod", value: lockPeriod)
                queryItemsURL.append(queryItem)
            }

            let queryItem = URLQueryItem(name: "lockType", value: "TIMEOUT")
            queryItemsURL.append(queryItem)

            return queryItemsURL

        case .getPersonalDepositLimits:
            return nil
        case .getLimits:
            return nil
        case .getResponsibleGamingLimits(let limitType, let periodType):
            return [URLQueryItem(name: "limitTypes", value: limitType),
                    URLQueryItem(name: "periodTypes", value: periodType)
            ]

        case .getBalance:
            return nil
        case .getCashbackBalance:
            return nil

        case .quickSignupCompletion(let firstName, let lastName, let birthDate, let gender, let mobileNumber,
                                    let address, let province, let city, let postalCode, let country, let cardId, let securityQuestion, let securityAnswer):
            var query: [URLQueryItem] = []
            
            if let firstName = firstName { query.append(URLQueryItem(name: "firstName", value: firstName)) }
            if let lastName = lastName { query.append(URLQueryItem(name: "lastName", value: lastName)) }
            if let gender = gender { query.append(URLQueryItem(name: "gender", value: gender)) }
            if let mobileNumber = mobileNumber { query.append(URLQueryItem(name: "mobile", value: mobileNumber)) }
            
            if let birthDate = birthDate {
                let dateFromatter = DateFormatter()
                dateFromatter.dateFormat = "yyyy-MM-dd"
                let birthDateString = dateFromatter.string(from: birthDate)
                query.append(URLQueryItem(name: "birthDate", value: birthDateString))
            }
            
            if let address = address { query.append(URLQueryItem(name: "address", value: address)) }
            if let province = province { query.append(URLQueryItem(name: "province", value: province)) }
            if let country = country { query.append(URLQueryItem(name: "country", value: country)) }
            if let city = city { query.append(URLQueryItem(name: "city", value: city)) }
            if let postalCode = postalCode { query.append(URLQueryItem(name: "postalCode", value: postalCode)) }
            if let cardId = cardId { query.append(URLQueryItem(name: "idCardNumber", value: cardId)) }
            
            if let securityQuestion = securityQuestion { query.append(URLQueryItem(name: "securityQuestion", value: securityQuestion)) }
            if let securityAnswer = securityAnswer { query.append(URLQueryItem(name: "securityAnswer", value: securityAnswer)) }
            
            return query
        case .getDocumentTypes:
            return nil
        case .getUserDocuments:
            return nil
        case .uploadUserDocument:
            return nil
        case .uploadMultipleUserDocuments:
            return nil

        case .getPayments:

            return nil
        case .processDeposit(let paymentMethod, let amount, let option):
            let localeCode = Locale.current.languageCode
            let localeRegion = Locale.current.regionCode
            let locale = "\(localeCode ?? "fr")-\(localeRegion ?? "FR")"

            return [

                URLQueryItem(name: "paymentMethod", value: paymentMethod),
                URLQueryItem(name: "amount", value: "\(amount)"),
                URLQueryItem(name: "option", value: option),
                URLQueryItem(name: "locale", value: locale),
                URLQueryItem(name: "requestedBonusPlanId", value: "NONE"),
                URLQueryItem(name: "channel", value: "iOS"),
                URLQueryItem(name: "threeDSNative", value: "true")
            ]

        case .processWithdrawal(let withdrawalMethod, let amount, let conversionId):
            var query = [
                
                URLQueryItem(name: "paymentMethod", value: withdrawalMethod),
                URLQueryItem(name: "amount", value: "\(amount)")
            ]
            
            if let conversionId {
                query.append(URLQueryItem(name: "conversionId", value: conversionId))
            }
            
            return query
        case .prepareWithdrawal(let withdrawalMethod):
            return [

                URLQueryItem(name: "paymentMethod", value: withdrawalMethod),
                URLQueryItem(name: "action", value: "GET_EXCHANGE_INFO")
            ]
        case .getPendingWithdrawals:
            return nil
        case .cancelWithdrawal(let paymentId):
            return [
                URLQueryItem(name: "paymentId", value: "\(paymentId)")
            ]
        case .updatePayment(let amount, let paymentId, let type, let returnUrl, let nameOnCard, let encryptedExpiryYear, let encryptedExpiryMonth, let encryptedSecurityCode, let encryptedCardNumber):
            var query = [
                URLQueryItem(name: "amount", value: "\(amount)"),
                URLQueryItem(name: "paymentId", value: paymentId),
                URLQueryItem(name: "type", value: type),
            ]
            
            if let returnUrlValue = returnUrl {
                query.append(URLQueryItem(name: "returnUrl", value: returnUrlValue))
            }
            if let nameOnCardValue = nameOnCard {
                query.append(URLQueryItem(name: "nameOnCard", value: nameOnCardValue))
            }
            if let encryptedExpiryYearValue = encryptedExpiryYear {
                query.append(URLQueryItem(name: "encryptedExpiryYear", value: encryptedExpiryYearValue))
            }
            if let encryptedExpiryMonthValue = encryptedExpiryMonth {
                query.append(URLQueryItem(name: "encryptedExpiryMonth", value: encryptedExpiryMonthValue))
            }
            if let encryptedSecurityCodeValue = encryptedSecurityCode {
                query.append(URLQueryItem(name: "encryptedSecurityCode", value: encryptedSecurityCodeValue))
            }
            if let encryptedCardNumberValue = encryptedCardNumber {
                query.append(URLQueryItem(name: "encryptedCardNumber", value: encryptedCardNumberValue))
            }
            return query

        case .cancelDeposit(let paymentId):
            return [
                URLQueryItem(name: "paymentId", value: paymentId)
            ]
        case .checkPaymentStatus(let paymentMethod, let paymentId):
            return [
                URLQueryItem(name: "paymentMethod", value: "\(paymentMethod)"),
                URLQueryItem(name: "paymentId", value: "\(paymentId)")
            ]
            
        case .getWithdrawalsMethods:
            return nil

        case .getPaymentInformation:
            return nil

        case .addPaymentInformation(let type, let fields):
            return [

                URLQueryItem(name: "type", value: type),
                URLQueryItem(name: "fields", value: fields)
            ]

        case .getTransactionsHistory(let startDate, let endDate, let transactionType, let pageNumber, let pageSize):
            var queryItemsURL: [URLQueryItem] = []

            let startDateQueryItem = URLQueryItem(name: "startDateTime", value: startDate)
            queryItemsURL.append(startDateQueryItem)

            let endDateQueryItem = URLQueryItem(name: "endDateTime", value: endDate)
            queryItemsURL.append(endDateQueryItem)

            if let transactionType {
                for tranType in transactionType {
                    let queryItem = URLQueryItem(name: "tranType", value: tranType)
                    queryItemsURL.append(queryItem)
                }
            }

            if let pageNumber {
                let queryItem = URLQueryItem(name: "pageNum", value: "\(pageNumber)")
                queryItemsURL.append(queryItem)
            }

            if let pageSize {
                let queryItem = URLQueryItem(name: "pageSize", value: "\(pageSize)")
                queryItemsURL.append(queryItem)
            }

            return queryItemsURL

        case .getGrantedBonuses:
            return nil

        case .redeemBonus(let code):
            return [
                URLQueryItem(name: "bonusCode", value: code)
            ]

        case .getAvailableBonuses:
            return nil

        case .redeemAvailableBonuses(let partyId, let bonusId):
            return [
                URLQueryItem(name: "partyId", value: partyId),
                URLQueryItem(name: "optInId", value: bonusId),
            ]

        case .cancelBonus(let bonusId):
            return [
                URLQueryItem(name: "bonusId", value: bonusId)
            ]

        case .optOutBonus(let partyId, let bonusId):
            return [
                URLQueryItem(name: "partyId", value: partyId),
                URLQueryItem(name: "bonusId", value: bonusId),
            ]

        case .contactUs(let firstName, let lastName, let email, let subject, let message):
            return [
                URLQueryItem(name: "firstName", value: firstName),
                URLQueryItem(name: "lastName", value: lastName),
                URLQueryItem(name: "email", value: email),
                URLQueryItem(name: "subject", value: subject),
                URLQueryItem(name: "message", value: message)
            ]

        case .contactSupport:
            return nil

        case .getAllConsents:
            return nil
        case .getUserConsents:
            return nil

        case .setUserConsents(let consentVersionIds, let unconsentVersionIds):

            var queryItemsURL: [URLQueryItem] = []


            if let consentVersionIds {
                for consentId in consentVersionIds {
                    let queryItem = URLQueryItem(name: "consentedVersions", value: "\(consentId)")
                    queryItemsURL.append(queryItem)
                }
            }

            if let unconsentVersionIds {
                for unconsentId in unconsentVersionIds {
                    let queryItem = URLQueryItem(name: "unConsentedVersions", value: "\(unconsentId)")
                    queryItemsURL.append(queryItem)
                }
            }

            return queryItemsURL

        case .getSumsubAccessToken(let userId, let levelName, _, _):
            return [

                URLQueryItem(name: "userId", value: userId),
                URLQueryItem(name: "levelName", value: levelName)
//                URLQueryItem(name: "ttlInSecs", value: "600")

            ]

        case .getSumsubApplicantData:
            return nil

        case .generateDocumentTypeToken(let docType):
            return [

                URLQueryItem(name: "target", value: "SUMSUB"),
                URLQueryItem(name: "docType", value: docType)

            ]

        case .checkDocumentationData:
            return [
                URLQueryItem(name: "target", value: "SUMSUB"),
                URLQueryItem(name: "resultType", value: "OVERALL")
            ]
            
        case .getMobileVerificationCode(let mobileNumber):
            return [
                URLQueryItem(name: "verificationType", value: "MOBILE"),
                URLQueryItem(name: "verificationValue", value: mobileNumber)
            ]
        
        case .verifyMobileCode(let code, let requestId):
            return [
                URLQueryItem(name: "verificationRequestId", value: requestId),
                URLQueryItem(name: "verificationCode", value: code)
            ]

        case .getReferralLink:
            return nil
        case .getReferees:
            return nil
        }
    }
    
    
    var method: HTTP.Method {
        switch self {
        case .login: return .post
        case .openSession: return .get
        case .logout: return .get
        case .playerInfo: return .get
        case .updatePlayerInfo: return .get
        case .checkCredentialEmail: return .get
        case .checkUsername: return .get
        case .quickSignup: return .get
        case .signUp: return .get
        case .resendVerificationCode: return .get
        case .signupConfirmation: return .get
        case .getCountries: return .get
        case .getCurrentCountry: return .get
        case .forgotPassword: return .get
        case .updatePassword: return .get
        case .updateExtraInfo: return .post
        case .updateDeviceIdentifier: return .post

        case .updateWeeklyDepositLimits: return .get
        case .updateWeeklyBettingLimits: return .get
        case .updateResponsibleGamingLimits: return .get
        case .getPersonalDepositLimits: return .get
        case .getLimits: return .get
        case .getResponsibleGamingLimits: return .get
        case .lockPlayer: return .post

        case .getBalance: return .get
        case .getCashbackBalance: return .get

        case .quickSignupCompletion: return .get
        case .getDocumentTypes: return .get
        case .getUserDocuments: return .get
        case .uploadUserDocument: return .post
        case .uploadMultipleUserDocuments: return .post

        case .getPayments: return .get
        case .processDeposit: return .post
        case .updatePayment: return .post
        case .cancelDeposit: return .post
        case .checkPaymentStatus: return .post
            
        case .getWithdrawalsMethods: return .get
        case .processWithdrawal: return .post
        case .prepareWithdrawal: return .post
        case .getPendingWithdrawals: return .get
        case .cancelWithdrawal: return .post
        case .getPaymentInformation: return .get
        case .addPaymentInformation: return .post

        case .getTransactionsHistory: return .get

        case .getGrantedBonuses: return .get
        case .redeemBonus: return .post
        case .getAvailableBonuses: return .get
        case .redeemAvailableBonuses: return .post
        case .cancelBonus: return .post
        case .optOutBonus: return .post
        case .contactUs: return .get
        case .contactSupport: return .post

        case .getAllConsents: return .get
        case .getUserConsents: return .get
        case .setUserConsents: return .post

        case .getSumsubAccessToken: return .post
        case .getSumsubApplicantData: return .get

        case .generateDocumentTypeToken: return .get
        case .checkDocumentationData: return .get
            
        case .getMobileVerificationCode: return .get
        case .verifyMobileCode: return .get
            
        case .getReferralLink: return .get
        case .getReferees: return .get
        }
    }
    
    var body: Data? {
        switch self {
        case .login(let username, let password):

            let parameters = [
                "username": username,
                "password": password
            ]

            let allowedCharacterSet = CharacterSet(charactersIn: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-_")

            let formBodyString = parameters.map { key, value in
                let encodedKey = key.addingPercentEncoding(withAllowedCharacters: allowedCharacterSet) ?? key
                let encodedValue = value.addingPercentEncoding(withAllowedCharacters: allowedCharacterSet) ?? value
                return "\(encodedKey)=\(encodedValue)"
            }.joined(separator: "&")
            return formBodyString.data(using: String.Encoding.utf8)

        case .uploadUserDocument( _, _, let body, _):
            return body
        case .uploadMultipleUserDocuments( _, _, let body, _):
            return body
        case .contactSupport(let userIdentifier, let firstName, let lastName, let email, let subject, let subjectType, let message, _):
            let bodyString =
            """
            {
            "request": {
                "requester": {
                    "name": "\(userIdentifier)",
                    "email": "\(email)"
                    },
                "custom_fields": [
                    {
                    "11249444074770": "\(firstName)"
                    },
                    {
                    "11249427898002": "\(lastName)"
                    },
                    {
                    "11096886022546": "\(subjectType)"
                    }
                ],
                "subject": "\(subject)",
                "comment": {
                    "body": "\(message)"
                }
            }
            }
            """
            return bodyString.data(using: String.Encoding.utf8) ?? Data()

        case .getSumsubAccessToken( _, _, let body, _):
            return body

        default:
            return nil
        }
    }
    
    var requireSessionKey: Bool {
        switch self {
        case .login: return false
        case .openSession: return true
        case .logout: return true
        case .playerInfo: return true
        case .updatePlayerInfo: return true
        case .checkCredentialEmail: return false
        case .checkUsername: return false
        case .quickSignup: return false
        case .signUp: return false
        case .resendVerificationCode: return false
        case .signupConfirmation: return false
        case .getCountries: return false
        case .getCurrentCountry: return false
        case .forgotPassword: return false
        case .updatePassword: return true
        case .updateExtraInfo: return true
        case .updateDeviceIdentifier: return true
            
        case .updateWeeklyDepositLimits: return true
        case .updateWeeklyBettingLimits: return true
        case .updateResponsibleGamingLimits: return true
        case .getPersonalDepositLimits: return true
        case .getLimits: return true
        case .getResponsibleGamingLimits: return true
        case .lockPlayer: return true

        case .getBalance: return true
        case .getCashbackBalance: return true
        case .quickSignupCompletion: return true
        case .getDocumentTypes: return false
        case .getUserDocuments: return true
        case .uploadUserDocument: return true
        case .uploadMultipleUserDocuments: return true

        case .getPayments: return true
        case .processDeposit: return true
        case .updatePayment: return true
        case .cancelDeposit: return true
        case .checkPaymentStatus: return true
            
        case .getWithdrawalsMethods: return true
        case .processWithdrawal: return true
        case .prepareWithdrawal: return true
        case .getPendingWithdrawals: return true
        case .cancelWithdrawal: return true
        case .getPaymentInformation: return true
        case .addPaymentInformation: return true

        case .getTransactionsHistory: return true

        case .getGrantedBonuses: return true
        case .redeemBonus: return true
        case .getAvailableBonuses: return true
        case .redeemAvailableBonuses: return true
        case .cancelBonus: return true
        case .optOutBonus: return true
            
        case .contactUs: return false
        case .contactSupport: return false

        case .getAllConsents: return false
        case .getUserConsents: return true
        case .setUserConsents: return true

        case .getSumsubAccessToken: return false
        case .getSumsubApplicantData: return false

        case .generateDocumentTypeToken: return true
        case .checkDocumentationData: return true
            
        case .getMobileVerificationCode: return false
        case .verifyMobileCode: return false
            
        case .getReferralLink: return true
        case .getReferees: return true
        }
    }
    
    var url: String {

        switch self {
        case .contactSupport:
            return SportRadarConfiguration.shared.supportHostname
        case .getSumsubAccessToken:
            return SportRadarConfiguration.shared.sumsubHostname
        case .getSumsubApplicantData:
            return SportRadarConfiguration.shared.sumsubHostname
        default:
            return SportRadarConfiguration.shared.pamHostname
        }


    }
    
    var headers: HTTP.Headers? {
        switch self {
        case .login:
            let headers = [
                "Accept-Encoding": "gzip, deflate",
                "Content-Type": "application/x-www-form-urlencoded",
                "Accept": "*/*",
                "app-origin": "ios",
            ]
            return headers
        case .uploadUserDocument( _, _, _, let header):
            let customHeaders = [
                "Content-Type": header,
                "app-origin": "ios",
            ]
            return customHeaders
        case .uploadMultipleUserDocuments( _, _, _, let header):
            let customHeaders = [
                "Content-Type": header,
                "app-origin": "ios",
            ]
            return customHeaders
        case .getSumsubAccessToken(_ , _, _, let header):
            return header
        case .getSumsubApplicantData( _, _,  let header):
            return header
        case .contactSupport(_, _, _, let email, _, _, _, let isLogged):

            if isLogged {
                let authPassword = "GIpqQMrDwD2JnNUEUF7vOm2ilGMEyZ5wnIOSuURP"

                if let authData = (email + "/token" + ":" + authPassword).data(using: .utf8)?.base64EncodedString() {

                    let headers = [
                        "Accept-Encoding": "gzip, deflate",
                        "Content-Type": "application/json; charset=UTF-8",
                        "Accept": "application/json",
                        "app-origin": "ios",
                        "Authorization": "Basic \(authData)"
                    ]
                    return headers
                }
            }

            let headers = [
                "Accept-Encoding": "gzip, deflate",
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json",
                "app-origin": "ios",
            ]
            return headers

        default:
            let defaultHeaders = [
                "Accept-Encoding": "gzip, deflate",
                "Content-Type": "application/json; charset=UTF-8",
                "Accept": "application/json",
                "app-origin": "ios",
            ]
            return defaultHeaders
        }

    }
    
    var cachePolicy: URLRequest.CachePolicy {
        return .reloadIgnoringLocalCacheData
    }
    
    var timeout: TimeInterval {
        return TimeInterval(20)
    }
    
    var comment: String? {
        switch self {
        case .login: return "login"
        case .openSession: return "openSession"
        case .logout: return "logout"
        case .playerInfo: return "playerInfo"
        case .updatePlayerInfo: return "updatePlayerInfo"
        case .checkCredentialEmail: return "checkCredentialEmail"
        case .checkUsername: return "checkUsername"
        case .quickSignup: return "quickSignup"
        case .signUp: return "signUp"
        case .resendVerificationCode: return "resendVerificationCode"
        case .signupConfirmation: return "signupConfirmation"
        case .getCountries: return "getCountries"
        case .getCurrentCountry: return "getCurrentCountry"
        case .forgotPassword: return "forgotPassword"
        case .updatePassword: return "updatePassword"
        case .updateExtraInfo: return "updateExtraInfo"
        case .updateDeviceIdentifier: return "updateDeviceIdentifier"
        case .updateWeeklyDepositLimits: return "updateWeeklyDepositLimits"
        case .updateWeeklyBettingLimits: return "updateWeeklyBettingLimits"
        case .updateResponsibleGamingLimits: return "updateResponsibleGamingLimits"
        case .getPersonalDepositLimits: return "getPersonalDepositLimits"
        case .getLimits: return "getLimits"
        case .getResponsibleGamingLimits: return "getResponsibleGamingLimits"
        case .lockPlayer: return "lockPlayer"
        case .getBalance: return "getBalance"
        case .getCashbackBalance: return "getCashbackBalance"
        case .quickSignupCompletion: return "quickSignupCompletion"
        case .getDocumentTypes: return "getDocumentTypes"
        case .getUserDocuments: return "getUserDocuments"
        case .uploadUserDocument: return "uploadUserDocument"
        case .uploadMultipleUserDocuments: return "uploadMultipleUserDocuments"
        case .getPayments: return "getPayments"
        case .processDeposit: return "processDeposit"
        case .updatePayment: return "updatePayment"
        case .cancelDeposit: return "cancelDeposit"
        case .checkPaymentStatus: return "checkPaymentStatus"
        case .getWithdrawalsMethods: return "getWithdrawalsMethods"
        case .processWithdrawal: return "processWithdrawal"
        case .prepareWithdrawal: return "prepareWithdrawal"
        case .getPendingWithdrawals: return "getPendingWithdrawals"
        case .cancelWithdrawal: return "cancelWithdrawal"
        case .getPaymentInformation: return "getPaymentInformation"
        case .addPaymentInformation: return "addPaymentInformation"
        case .getTransactionsHistory: return "getTransactionsHistory"
        case .getGrantedBonuses: return "getGrantedBonuses"
        case .redeemBonus: return "redeemBonus"
        case .getAvailableBonuses: return "getAvailableBonuses"
        case .redeemAvailableBonuses: return "redeemAvailableBonuses"
        case .cancelBonus: return "cancelBonus"
        case .optOutBonus: return "optOutBonus"
        case .contactUs: return "contactUs"
        case .contactSupport: return "contactSupport"
        case .getAllConsents: return "getAllConsents"
        case .getUserConsents: return "getUserConsents"
        case .setUserConsents: return "setUserConsents"
        case .getSumsubAccessToken: return "getSumsubAccessToken"
        case .getSumsubApplicantData: return "getSumsubApplicantData"
        case .generateDocumentTypeToken: return "generateDocumentTypeToken"
        case .checkDocumentationData: return "checkDocumentationData"
        case .getMobileVerificationCode: return "getMobileVerificationCode"
        case .verifyMobileCode: return "verifyMobileCode"
        case .getReferralLink: return "getReferralLink"
        case .getReferees: return "getReferees"
        }
    }
}

extension OmegaAPIClient {
    static func parseOmegaDateString(_ dateString: String) -> Date? {
        
        let dateFormatter = DateFormatter()
        
        dateFormatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss.SSS"
        
        if let date = dateFormatter.date(from: dateString) {
            return date
        }
        
        dateFormatter.dateFormat = "dd-MM-yyyy HH:mm:ss"
        dateFormatter.timeZone = TimeZone(secondsFromGMT: 0) // UTC+00
        
        return dateFormatter.date(from: dateString)
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/PAM-Omega/OmegaConnector.swift
````swift
//
//  OmegaConnector.swift
//  
//
//  Created by Ruben Roques on 25/10/2022.
//

import Foundation
import Combine
import Extensions

class OmegaConnector: Connector {
    
    var token: CurrentValueSubject<OmegaSessionAccessToken?, Never> = .init(nil)
    var tokenPublisher: AnyPublisher<OmegaSessionAccessToken?, Never> {
        return self.token.eraseToAnyPublisher()
    }
    
    var connectionStateSubject: CurrentValueSubject<ConnectorState, Never> = .init(.connected)
    var connectionStatePublisher: AnyPublisher<ConnectorState, Never> {
        return self.connectionStateSubject.eraseToAnyPublisher()
    }
    
    private var cancellables: Set<AnyCancellable> = []
    
    private let session: URLSession
    private let decoder: JSONDecoder
    
    private var sessionCredentials: OmegaSessionCredentials?
    private let notLoggedError = "NOT_LOGGED_IN_ERROR"
    
    init(session: URLSession = URLSession(configuration: URLSessionConfiguration.default), decoder: JSONDecoder = JSONDecoder()) {
        self.session = session
        self.decoder = decoder
        
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "dd-MM-yyyy HH:mm:ss" // old format: 2003-12-31 00:00:00 // new format: 31-12-2003 00:00:00
        self.decoder.dateDecodingStrategy = .formatted(dateFormatter)
    }

    private func clearCacheSessionKey() {
        return self.token.send(nil)
    }
    
    private func cacheSessionKey(_ sessionKey: String) {
        return self.token.send(OmegaSessionAccessToken(sessionKey: sessionKey))
    }
    
    private func cacheLaunchKey(_ launchKey: String) {
        if let token = self.token.value {
            let accessToken = OmegaSessionAccessToken(sessionKey: token.sessionKey, launchKey: launchKey)
            return self.token.send(accessToken)
        }
    }
    
    private func retrieveSessionKey() -> String? {
        return self.token.value?.sessionKey
    }

    func forceRefreshSession() -> AnyPublisher<OmegaSessionAccessToken, ServiceProviderError> {
        self.clearCacheSessionKey()

        guard
            let sessionCredentials = self.sessionCredentials
        else {
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }

        return self.login(username: sessionCredentials.username, password: sessionCredentials.password)
            .flatMap { [weak self] (loginResponse: SportRadarModels.LoginResponse) -> AnyPublisher<OmegaSessionAccessToken, ServiceProviderError> in
                if loginResponse.status == "SUCCESS", let token = self?.token.value {
                    return Just(token).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                }
                else {
                    return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
                }
            }
            .eraseToAnyPublisher()

    }

    func request<T: Codable>(_ endpoint: Endpoint) -> AnyPublisher<T, ServiceProviderError> {
        
        var additionalQueryItems: [URLQueryItem] = []
        if endpoint.requireSessionKey {
            if let sessionKey = self.retrieveSessionKey() {
                additionalQueryItems.append(URLQueryItem(name: "sessionKey", value: sessionKey))
            }
            else if let sessionCredentials = self.sessionCredentials {
                return self.login(username: sessionCredentials.username, password: sessionCredentials.password)
                    .flatMap { [weak self] sessionKey -> AnyPublisher<T, ServiceProviderError> in
                        guard
                            let self = self
                        else {
                            return Fail(error: ServiceProviderError.unknown).eraseToAnyPublisher()
                        }
                        return self.request(endpoint)
                    }
                    .eraseToAnyPublisher()
            }
            else {
                return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
            }
        }
        
        guard
            let request = endpoint.request(aditionalQueryItems: additionalQueryItems)
        else {
            let error = ServiceProviderError.invalidRequestFormat
            return Fail<T, ServiceProviderError>(error: error).eraseToAnyPublisher()
        }

        return self.session.dataTaskPublisher(for: request)
//            .handleEvents(receiveOutput: { result in
//                print("ServiceProvider-OmegaConnector [[ requesting ]] ", dump(request),
//                      " [[ response ]] ", String(data: result.data, encoding: .utf8) ?? "!?" )
//            })
            .tryMap { result -> Data in
                if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 401 {
                    throw ServiceProviderError.unauthorized
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 403 {
                    throw ServiceProviderError.forbidden
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 201 {
                    return result.data
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode != 200 {
                    throw ServiceProviderError.unknown
                }
                return result.data
            }
            .mapError({ error in
                if let typedError = error as? ServiceProviderError {
                    return typedError
                }
                return ServiceProviderError.invalidResponse
            })
            .flatMap({ [weak self] (data: Data) -> AnyPublisher<T, ServiceProviderError> in
                guard
                    let self = self
                else {
                    return Fail(error: ServiceProviderError.unknown).eraseToAnyPublisher()
                }
                
                if let responseStatus = try? JSONDecoder().decode(SportRadarModels.StatusResponse.self, from: data) {
                    if responseStatus.status == self.notLoggedError {
                        self.clearCacheSessionKey()
                        return self.request(endpoint)
                    }
                    else {
                        do {
                            let mappedObject = try self.decoder.decode(T.self, from: data)
                            return Just(mappedObject).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                        }
                        catch {
                            if error is DecodingError {
                                return Fail(error: ServiceProviderError.decodingError(message: error.localizedDescription))
                                    .eraseToAnyPublisher()
                            }
                            let localizedErrorKey = "omega_error_" + responseStatus.status.lowercased()
                            var localizedMessage = Localization.localized(localizedErrorKey)
                            if localizedMessage.isEmpty {
                                localizedMessage = Localization.localized("server_error_message")
                            }
                            return Fail(error: ServiceProviderError.errorDetailedMessage(key: responseStatus.status, message: localizedMessage))
                                .eraseToAnyPublisher()
                        }
                    }
                }
                else if let requestStatus = try? JSONDecoder().decode(SportRadarModels.SupportResponse.self, from: data) {
                    do {
                        print("OmegaConnector requestStatus \(requestStatus)")
                        let mappedObject = try self.decoder.decode(T.self, from: data)
                        return Just(mappedObject).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                    }
                    catch {
                        return Fail(error: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
                    }
                }
                else {
                    return Fail(error: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
                }
            })
            .eraseToAnyPublisher()
    }
    
    func login(username: String, password: String) -> AnyPublisher<SportRadarModels.LoginResponse, ServiceProviderError> {
        
        guard
            let request = OmegaAPIClient.login(username: username, password: password).request()
        else {
            return Fail(error: .invalidRequestFormat).eraseToAnyPublisher()
        }

        // print("NetworkLogs: ", request.cURL(pretty: true), "\nNetworkLogs: ==========================================")

        return self.session.dataTaskPublisher(for: request)
//            .handleEvents(receiveOutput: { result in
//                print("ServiceProvider-OmegaConnector login [[ requesting ]] ", request,
//                      " [[ response ]] ", String(data: result.data, encoding: .utf8) ?? "!?" )
//            })
            .tryMap { result in
                if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 401 {
                    throw ServiceProviderError.unauthorized
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 403 {
                    throw ServiceProviderError.forbidden
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode != 200 {
                    throw ServiceProviderError.unknown
                }
                return result.data
            }
            .decode(type: SportRadarModels.LoginResponse.self, decoder: self.decoder)
            .mapError { error in
                return ServiceProviderError.invalidResponse
            }
            .flatMap({ [weak self] loginResponse -> AnyPublisher<SportRadarModels.LoginResponse, ServiceProviderError> in

                guard
                    let self = self
                else {
                    return Fail(error: ServiceProviderError.unknown).eraseToAnyPublisher()
                }

                if loginResponse.status == "FAIL_UN_PW" {
                    self.logout()
                    return Fail(error: ServiceProviderError.invalidEmailPassword).eraseToAnyPublisher()
                }
                else if loginResponse.status == "FAIL_QUICK_OPEN_STATUS" {
                    return Fail(error: ServiceProviderError.quickSignUpIncomplete).eraseToAnyPublisher()
                }
                else if loginResponse.status == "FAIL_TEMP_LOCK" {
                    let date = loginResponse.lockUntilDateFormatted ?? ""

                    return Fail(error: ServiceProviderError.failedTempLock(date: date)).eraseToAnyPublisher()
                }
                else if loginResponse.status == "SUCCESS", let sessionKey = loginResponse.sessionKey {

                    self.cacheSessionKey(sessionKey)
                    self.sessionCredentials = OmegaSessionCredentials(username: username, password: password)

                    // IGNORE GAME SESSION
//                    self.cacheLaunchKey("")
//
//                    return Just(loginResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

                    return self.openSession(withSessionKey: sessionKey)
                        .handleEvents(receiveOutput: { [weak self] (newLaunchToken: String?) in
                            if let newLaunchTokenValue = newLaunchToken {
                                self?.cacheLaunchKey(newLaunchTokenValue)
                            }
                        })
                        .map({ _ -> SportRadarModels.LoginResponse in
                            return loginResponse
                        })
                        .eraseToAnyPublisher()
                }
                else {
                    let localizedErrorKey = "omega_error_" + loginResponse.status.lowercased()
                    var localizedMessage = Localization.localized(localizedErrorKey)
                    if localizedMessage.isEmpty {
                        localizedMessage = Localization.localized("server_error_message")
                    }
                    return Fail(error: ServiceProviderError.errorDetailedMessage(key: loginResponse.status, message: localizedMessage)).eraseToAnyPublisher()
                }
            })
            .eraseToAnyPublisher()
    }
    

    func logout() {
        self.token.send(nil)
        self.sessionCredentials = nil
    }


    func openSession(withSessionKey sessionKey: String) -> AnyPublisher<String?, ServiceProviderError> {
        guard
            let request = OmegaAPIClient.openSession.request(aditionalQueryItems: [URLQueryItem(name: "sessionKey", value: sessionKey)])
        else {
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }

        return self.session.dataTaskPublisher(for: request)
//            .handleEvents(receiveOutput: { result in
//                print("ServiceProvider-OmegaConnector openSession [[ requesting ]] ", request,
//                      " [[ response ]] ", String(data: result.data, encoding: .utf8) ?? "!?" )
//            })
            .tryMap { result in
                if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 401 {
                    throw ServiceProviderError.unauthorized
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 403 {
                    throw ServiceProviderError.forbidden
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode != 200 {
                    throw ServiceProviderError.unknown
                }
                return result.data
            }
            .decode(type: SportRadarModels.OpenSessionResponse.self, decoder: self.decoder)
            .mapError({ error -> ServiceProviderError in
                if let typedError = error as? ServiceProviderError {
                    return typedError
                }
                else if let decodingError = error as? DecodingError {
                    let errorMessage = "\(decodingError)"
                    return ServiceProviderError.decodingError(message: errorMessage)
                }
                return ServiceProviderError.invalidResponse
            })
            .map({ $0.launchToken })
            .eraseToAnyPublisher()

    }
    
    
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/PAM-Omega/OmegaSession.swift
````swift
//
//  OmegaSessionCredentials.swift
//  
//
//  Created by Ruben Roques on 26/10/2022.
//

import Foundation
import Combine

struct OmegaSessionAccessToken {
    var sessionKey: String
    var launchKey: String?
}

struct OmegaSessionCredentials {
    var username: String
    var password: String
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/VaixAPI/VaixAnalytics/VaixAnalyticsEvent.swift
````swift
//
//  VaixAnalyticsEvent.swift
//  
//
//  Created by Ruben Roques on 14/05/2024.
//

import Foundation

public enum VaixAnalyticsEvent: AnalyticsEvent {
    
    case impressionsEvents(eventsIds: [String])
    case clickEvent(id: String)
    case clickOutcome(eventId: String, outcomeId: String)
    
    public var type: String {
        switch self {
        case .impressionsEvents:
            return "impressions:events"
        case .clickEvent:
            return "clicks:event"
        case .clickOutcome:
            return "clicks:outcome"
        }
    }

    public var data: [String : Any]? {
        switch self {
            
        case .impressionsEvents(let eventsIds):
            return [
                "position": 0,
                "location": "liveevent-popular",
                "channel": "ios",
                "events": eventsIds.map { ["id": $0] }
            ]
        case .clickEvent(let id):
           return [
                "position": 0,
                "location": "liveevent-popular",
                "channel": "ios",
                "event_id": id
            ]
        case .clickOutcome(let eventId, let outcomeId):
            return [
                 "position": 0,
                 "location": "liveevent-popular",
                 "channel": "ios",
                 "event_id": eventId,
                 "outcome_id": outcomeId
             ]
        }
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/APIs/VaixAPI/VaixAPIClient.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 07/05/2024.
//

import Foundation

enum VaixAPIClient {
    case popularEvents(eventsCount: Int, userId: String?)
    case analyticsTrackEvent(event: VaixAnalyticsEvent, userId: String)
    case promotedBetslips(userId: String?)
}

extension VaixAPIClient: Endpoint {
    var url: String {
        return SportRadarConfiguration.shared.vaixHostname
    }
    
    var endpoint: String {
        switch self {
        case .popularEvents:
            return "/api/sports/events/popular"
        case .analyticsTrackEvent:
            return "/api/tracker/events"
        case .promotedBetslips:
            return "/api/sports/betslips/popular"
        }
    }
    
    var query: [URLQueryItem]? {
        var query: [URLQueryItem] = []
        switch self {
        case .popularEvents(let eventsCount, let userId):
            if let userId {
                let userIdFormat = "om\(userId)-eur"
                query.append(URLQueryItem(name:"user", value:userIdFormat))
            }
            else {
                query.append(URLQueryItem(name:"user", value:"0"))
            }
            
            query.append(URLQueryItem(name:"from_offset", value:"-5h"))
            query.append(URLQueryItem(name:"filters", value:"status:eq:live"))
            query.append(URLQueryItem(name:"count", value:"\(eventsCount)"))
            query.append(URLQueryItem(name:"order_by", value:"-event_confidence,+begin"))
            query.append(URLQueryItem(name:"format", value:"orako"))
            query.append(URLQueryItem(name:"location", value:"liveevent-popular"))
        case .analyticsTrackEvent:
            break
        case .promotedBetslips:
            query.append(URLQueryItem(name:"format", value:"orako"))
            query.append(URLQueryItem(name:"count", value:"5"))
            query.append(URLQueryItem(name:"location", value:"multigame_acca"))
        }
        return query
    }
    
    var headers: HTTP.Headers? {
        switch self {
        case .popularEvents:
            return [ "Authorization": "Bearer \(SportRadarConfiguration.shared.vaixAuthTokenValue)",
                     "origin": "null",
                     "x-vaix-client-id": "betsson_france"]
        case .analyticsTrackEvent:
            return ["Authorization": "Bearer \(SportRadarConfiguration.shared.vaixAuthTokenValue)",
                    "origin": "null",
                    "x-vaix-client-id": "betsson_france",
                    "Content-Type": "application/json"]
        case .promotedBetslips:
            return ["Authorization": "Bearer \(SportRadarConfiguration.shared.vaixAuthTokenValue)",
                    "origin": "null",
                    "x-vaix-client-id": "betsson_france"]
        }
    }
    
    var method: HTTP.Method {
        switch self {
        case .popularEvents: return .get
        case .analyticsTrackEvent: return .post
        case .promotedBetslips: return .get
        }
    }
    
    var body: Data? {
        switch self {
        case .popularEvents:
            return nil
        case .analyticsTrackEvent(let event, let userId):
            
            
            if let data = event.data,
               let jsonData = try? JSONSerialization.data(withJSONObject: data, options: .prettyPrinted),
               let dataString = String(data: jsonData, encoding: .utf8) {
                
                let body = """
                            {
                                "event_type": "\(event.type)",
                                "user_id": \(userId),
                                "data": \(dataString)
                            }
                            """
                
                let data = body.data(using: String.Encoding.utf8)!
                return data
            }
            else {
                return nil
            }
        case .promotedBetslips:
            return nil
        }
    }
    
    var cachePolicy: URLRequest.CachePolicy {
        return .reloadIgnoringLocalCacheData
    }

    var timeout: TimeInterval {
        switch self {
        case .popularEvents: return TimeInterval(20)
        case .analyticsTrackEvent: return TimeInterval(5)
        case .promotedBetslips: return TimeInterval(60)
        }
    }
    
    var requireSessionKey: Bool {
        return false
    }
    
    var comment: String? {
        switch self {
        case .popularEvents: return "Vaix popularEvents"
        case .analyticsTrackEvent: return "Vaix Track Event analytics"
        case .promotedBetslips: return "Vaix Track Popular Bets (aka Suggested Bets)"
        }
    }
    
    
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Bonus/SportRadarModels+AvailableBonus.swift
````swift
//
//  SportRadarModels+AvailableBonus.swift
//  
//
//  Created by André Lascas on 24/03/2023.
//

import Foundation

extension SportRadarModels {

    struct AvailableBonus: Codable {
        var id: String
        var bonusPlanId: Int
        var name: String
        var description: String?
        var type: String
        var amount: Double
        var triggerDate: String
        var expiryDate: String
        var wagerRequirement: Double?
        var imageUrl: String?

        enum CodingKeys: String, CodingKey {
            case id = "optInId"
            case bonusPlanId = "bonusPlanId"
            case name = "bonusPlanName"
            case description = "description"
            case type = "bonusPlanType"
            case amount = "bonusAmount"
            case triggerDate = "startDate"
            case expiryDate = "endDate"
            case wagerRequirement = "wagerReq"
            case imageUrl = "imageUrl"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Bonus/SportRadarModels+AvailableBonusResponse.swift
````swift
//
//  SportRadarModels+AvailableBonusResponse.swift
//  
//
//  Created by André Lascas on 24/03/2023.
//

import Foundation

extension SportRadarModels {

    struct AvailableBonusResponse: Codable {

        var status: String
        var bonuses: [AvailableBonus]

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case bonuses = "optInBonusPlans"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Bonus/SportRadarModels+GrantedBonus.swift
````swift
//
//  SportRadarModels+GrantedBonus.swift
//  
//
//  Created by André Lascas on 16/03/2023.
//

import Foundation

extension SportRadarModels {

    struct GrantedBonus: Codable {
        var id: Int
        var name: String
        var status: String
        var amount: String
        var triggerDate: String
        var expiryDate: String
        var wagerRequirement: String?
        var amountWagered: String?

        enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "bonusPlanName"
            case status = "status"
            case amount = "amount"
            case triggerDate = "triggerDate"
            case expiryDate = "expiryDate"
            case wagerRequirement = "wagerRequirement"
            case amountWagered = "amountWagered"
        }
        
        init(from decoder: any Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.GrantedBonus.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.GrantedBonus.CodingKeys.self)
            self.id = try container.decode(Int.self, forKey: SportRadarModels.GrantedBonus.CodingKeys.id)
            self.name = try container.decode(String.self, forKey: SportRadarModels.GrantedBonus.CodingKeys.name)
            self.status = try container.decode(String.self, forKey: SportRadarModels.GrantedBonus.CodingKeys.status)
            self.amount = try container.decode(String.self, forKey: SportRadarModels.GrantedBonus.CodingKeys.amount)
            self.triggerDate = try container.decode(String.self, forKey: SportRadarModels.GrantedBonus.CodingKeys.triggerDate)
            self.expiryDate = try container.decode(String.self, forKey: SportRadarModels.GrantedBonus.CodingKeys.expiryDate)
            self.wagerRequirement = try container.decodeIfPresent(String.self, forKey: SportRadarModels.GrantedBonus.CodingKeys.wagerRequirement)
            self.amountWagered = try container.decodeIfPresent(String.self, forKey: SportRadarModels.GrantedBonus.CodingKeys.amountWagered)
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Bonus/SportRadarModels+GrantedBonusResponse.swift
````swift
//
//  SportRadarModels+GrantedBonusResponse.swift
//  
//
//  Created by André Lascas on 16/03/2023.
//

import Foundation

extension SportRadarModels {

    struct GrantedBonusResponse: Codable {
        var status: String
        var bonuses: [GrantedBonus]

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case bonuses = "bonuses"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Bonus/SportRadarModels+RedeemBonus.swift
````swift
//
//  SportRadarModels+RedeemBonus.swift
//  
//
//  Created by André Lascas on 17/03/2023.
//

import Foundation

extension SportRadarModels {
    struct RedeemBonus: Codable {
        var id: Int
        var name: String
        var status: String
        var triggerDate: String
        var expiryDate: String
        var amount: String
        var wagerRequired: String
        var amountWagered: String

        enum CodingKeys: String, CodingKey {
            case id = "id"
            case name = "bonusPlanName"
            case status = "status"
            case triggerDate = "triggerDate"
            case expiryDate = "expiryDate"
            case amount = "amount"
            case wagerRequired = "wagerRequirement"
            case amountWagered = "amountWagered"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Bonus/SportRadarModels+RedeemBonusResponse.swift
````swift
//
//  SportRadarModels+RedeemBonusResponse.swift
//  
//
//  Created by André Lascas on 17/03/2023.
//

import Foundation

extension SportRadarModels {
    struct RedeemBonusResponse: Codable {
        var status: String
        var message: String?
        var bonus: RedeemBonus?


        enum CodingKeys: String, CodingKey {
            case status = "status"
            case message = "message"
            case bonus = "bonus"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Cashback/SportRadarModels+CashbackBalance.swift
````swift
//
//  SportRadarModels+CashbackBalance.swift
//  
//
//  Created by André Lascas on 17/07/2023.
//

import Foundation

extension SportRadarModels {

    struct CashbackBalance: Codable {
        var status: String
        var balance: String?
        var message: String?

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case balance = "balance"
            case message = "message"
        }
        
        init(status: String, balance: String? = nil, message: String? = nil) {
            self.status = status
            self.balance = balance
            self.message = message
        }

        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.status = try container.decode(String.self, forKey: .status)
            self.message = try container.decodeIfPresent(String.self, forKey: .message)
            
            if let balanceString = try? container.decodeIfPresent(String.self, forKey: .balance) {
                self.balance = balanceString
            }
            else if let balanceDouble = try? container.decodeIfPresent(Double.self, forKey: .balance) {
                self.balance = String(balanceDouble)
            }
            else {
                self.balance = nil
            }
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Cashback/SportRadarModels+CashbackResult.swift
````swift
//
//  SportRadarModels+CashbackResult.swift
//  
//
//  Created by André Lascas on 18/07/2023.
//

import Foundation

extension SportRadarModels {

    struct CashbackResult: Codable {
        var id: Double
        var amount: Double?
        var amountFree: Double?

        enum CodingKeys: String, CodingKey {
            case id = "idFoSOOffer"
            case amount = "soReturn"
            case amountFree = "soFreeReturn"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Cashout/SportRadarModels+Cashout.swift
````swift
//
//  SportRadarModels+Cashout.swift
//  
//
//  Created by André Lascas on 14/03/2023.
//

import Foundation

extension SportRadarModels {

    struct Cashout: Codable {

        var cashoutValue: Double
        var partialCashoutAvailable: Bool?

        enum CodingKeys: String, CodingKey {
            case cashoutValue = "cashoutValue"
            case partialCashoutAvailable = "partialCashoutAvailable"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Cashout/SportRadarModels+CashoutResult.swift
````swift
//
//  SportRadarModels+CashoutResult.swift
//  
//
//  Created by André Lascas on 14/03/2023.
//

import Foundation

extension SportRadarModels {

    struct CashoutResult: Codable {
        var cashoutResult: Int?
        var cashoutReoffer: Double?
        var message: String?

        enum CodingKeys: String, CodingKey {
            case cashoutResult = "cashoutResult"
            case cashoutReoffer = "cashoutReoffer"
            case message = "message"
        }
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Competitions/SportRadarModels+TopCompetitionsResponse.swift
````swift
//
//  SportRadarModels+TopCompetitionsResponse.swift
//  
//
//  Created by André Lascas on 05/07/2023.
//

import Foundation

extension SportRadarModels {

    struct TopCompetitionsResponse: Codable {

        var data: [TopCompetitionData]

        enum CodingKeys: String, CodingKey {
            case data = "data"
        }
    }

    struct TopCompetitionData: Codable {
        var title: String
        var competitions: [TopCompetitionPointer]

        enum CodingKeys: String, CodingKey {
            case title = "title"
            case competitions = "banneritems"
        }
    }

    struct TopCompetitionPointer: Codable {
        var id: String
        var name: String
        var competitionId: String

        enum CodingKeys: String, CodingKey {
            case id = "idfwbanneritem"
            case name = "name"
            case competitionId = "location"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Documents/SportRadarModels+AcessTokenResponse.swift
````swift
//
//  SportRadarModels+AcessTokenResponse.swift
//  
//
//  Created by André Lascas on 12/06/2023.
//

import Foundation

extension SportRadarModels {

    struct AccessTokenResponse: Codable {
        var token: String?
        var userId: String?
        var description: String?
        var code: Int?

        enum CodingKeys: String, CodingKey {
            case token = "token"
            case userId = "userId"
            case description = "description"
            case code = "code"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Documents/SportRadarModels+ApplicantDataResponse.swift
````swift
//
//  SportRadarModels+ApplicantDataResponse.swift
//  
//
//  Created by André Lascas on 12/06/2023.
//

import Foundation

extension SportRadarModels {

    struct ApplicantRootResponse: Codable {
        var status: String
        var message: String?
        var data: ApplicantDataResponse

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case message = "message"
            case data = "data"
        }
    }

    struct ApplicantDataResponse: Codable {
        var externalUserId: String?
        var info: ApplicantDataInfo?
        var reviewData: ApplicantReviewData?
        var description: String?

        enum CodingKeys: String, CodingKey {
            case externalUserId = "externalUserId"
            case info = "info"
            case reviewData = "review"
            case description = "description"
        }
    }

    struct ApplicantDataInfo: Codable {
        var applicantDocs: [ApplicantDoc]?

        enum CodingKeys: String, CodingKey {
            case applicantDocs = "idDocs"
        }
    }

    struct ApplicantDoc: Codable {
        var docType: String

        enum CodingKeys: String, CodingKey {
            case docType = "idDocType"
        }

    }

    struct ApplicantReviewData: Codable {
        var attemptCount: Int
        var createDate: String
        var reviewDate: String?
        var reviewResult: ApplicantReviewResult?
        var reviewStatus: String
        var levelName: String

        enum CodingKeys: String, CodingKey {
            case attemptCount = "attemptCnt"
            case createDate = "createDate"
            case reviewDate = "reviewDate"
            case reviewResult = "reviewResult"
            case reviewStatus = "reviewStatus"
            case levelName = "levelName"
        }
    }

    struct ApplicantReviewResult: Codable {
        var reviewAnswer: String
        var reviewRejectType: String?
        var moderationComment: String?

        enum CodingKeys: String, CodingKey {
            case reviewAnswer = "reviewAnswer"
            case reviewRejectType = "reviewRejectType"
            case moderationComment = "moderationComment"
        }
    }


}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Freebets/SportRadarModels+Freebet.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 04/04/2023.
//

import Foundation

extension SportRadarModels {

    struct FreebetResponse: Codable {

        var balance: Double

        enum CodingKeys: String, CodingKey {
            case balance = "freeBalance"
        }

    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Helpers/SocketMessageParseHelper.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 28/02/2023.
//

import Foundation

enum SocketMessageParseHelper {

    static func extractEventId(_ inputString: String) -> String? {
        let regex = try! NSRegularExpression(pattern: "\\[idfoevent=(\\d+(\\.\\d+)?)\\]")
        let range = NSRange(location: 0, length: inputString.utf16.count)
        if let match = regex.firstMatch(in: inputString, options: [], range: range) {
            let id = (inputString as NSString).substring(with: match.range(at: 1))
            return id
        }
        return nil
    }

    static func extractMarketId(_ inputString: String) -> String? {
        let regex = try! NSRegularExpression(pattern: "\\[idfomarket=(\\d+(\\.\\d+)?)\\]")
        let range = NSRange(location: 0, length: inputString.utf16.count)
        if let match = regex.firstMatch(in: inputString, options: [], range: range) {
            let id = (inputString as NSString).substring(with: match.range(at: 1))
            return id
        }
        return nil
    }
    
    static func extractSportCode(_ inputString: String) -> String? {
        let regex = try! NSRegularExpression(pattern: "\\[idfosporttype=(\\w+)\\]")
        let range = NSRange(location: 0, length: inputString.utf16.count)
        if let match = regex.firstMatch(in: inputString, options: [], range: range) {
            let code = (inputString as NSString).substring(with: match.range(at: 1))
            return code
        }
        return nil
    }

    static func extractSelectionId(_ inputString: String) -> String? {
        let regex = try! NSRegularExpression(pattern: "\\[idfoselection=(\\d+(\\.\\d+)?)\\]")
        let range = NSRange(location: 0, length: inputString.utf16.count)
        if let match = regex.firstMatch(in: inputString, options: [], range: range) {
            let id = (inputString as NSString).substring(with: match.range(at: 1))
            return id
        }
        return nil
    }

    static func extractMatchMinutes(from matchTime: String) -> String? {
        let pattern = #"(?<=^|\s)(\d{1,2}):(\d{2})(?:\s\+(\d{1,2}:\d{2}))?(?=$|\s)"#
        guard let range = matchTime.range(of: pattern, options: .regularExpression) else {
            return nil
        }

        let minuteString = String(matchTime[range])
        let components = minuteString.components(separatedBy: ":")
        let minutes = Int(components[0]) ?? 0

        if let extraTimeRange = minuteString.range(of: #"\s\+([\d:]+)"#, options: .regularExpression),
            let extraTime = Int(String(minuteString[extraTimeRange].dropFirst(2)).components(separatedBy: ":").first ?? "") {
            return "\(minutes)'+\(extraTime)"
        }

        return "\(minutes)'"
    }

    static func extractNodeId(_ inputString: String) -> String? {
        let regex = try! NSRegularExpression(pattern: "\\[idfwbonavigation=(\\d+(\\.\\d+)?)\\]")
        let range = NSRange(location: 0, length: inputString.utf16.count)
        if let match = regex.firstMatch(in: inputString, options: [], range: range) {
            let id = (inputString as NSString).substring(with: match.range(at: 1))
            return id
        }
        return nil
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/HomeWidgets/HeadlineResponse.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 08/06/2023.
//

import Foundation

extension SportRadarModels {

    struct HeadlineResponse: Codable {
        var headlineItems: [HeadlineItem]?

        enum CodingKeys: String, CodingKey {
            case headlineItems = "headlineItems"
        }

        init(headlineItems: [HeadlineItem]?) {
            self.headlineItems = headlineItems
        }
    }

    struct HeadlineItem: Codable {
        var idfwheadline: String?
        var marketGroupId: String?
        var marketId: String?
        var name: String?
        var title: String?
        var tsactivefrom: String?
        var tsactiveto: String?
        var idfwheadlinetype: String?
        var headlinemediatype: String?
        var categoryName: String?
        var numofselections: String?
        var imageURL: String?
        var linkURL: String?
        var oldMarketId: String?
        var tournamentCountryName: String?

        enum CodingKeys: String, CodingKey {
            case idfwheadline = "idfwheadline"
            case marketGroupId = "idfwmarketgroup"
            case marketId = "idfomarket"
            case name = "name"
            case title = "title"
            case tsactivefrom = "tsactivefrom"
            case tsactiveto = "tsactiveto"
            case idfwheadlinetype = "idfwheadlinetype"
            case headlinemediatype = "headlinemediatype"
            case categoryName = "categoryName"
            case numofselections = "numofselections"
            case imageURL = "imageurl"
            case linkURL = "linkurl"
            case oldMarketId = "bodytext"
            case tournamentCountryName = "tournamentcountryname"
        }

        init(idfwheadline: String?, marketGroupId: String?,
             marketId: String?, name: String?, title: String?,
             tsactivefrom: String?, tsactiveto: String?, idfwheadlinetype: String?,
             headlinemediatype: String?, categoryName: String?, numofselections: String?,
             imageURL: String?, linkURL: String?, oldMarketId: String?, tournamentCountryName: String?
        ) {
            self.idfwheadline = idfwheadline
            self.marketGroupId = marketGroupId
            self.marketId = marketId
            self.name = name
            self.title = title
            self.tsactivefrom = tsactivefrom
            self.tsactiveto = tsactiveto
            self.idfwheadlinetype = idfwheadlinetype
            self.headlinemediatype = headlinemediatype
            self.categoryName = categoryName
            self.numofselections = numofselections
            self.imageURL = imageURL
            self.linkURL = linkURL
            self.oldMarketId = oldMarketId
            self.tournamentCountryName = tournamentCountryName
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/HomeWidgets/PromotedSports.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 09/06/2023.
//

import Foundation


extension SportRadarModels {

    struct PromotedSportsResponse: Codable {

        var promotedSports: [PromotedSport]

        enum CodingKeys: String, CodingKey {
            case node = "bonavigationnodes"
            case promotedSports = "promotedSports"
        }

        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)

            // root nodes
            let rawNodes = try container.decode([FailableDecodable<PromotedSportsNodeResponse>].self, forKey: .node)
            let validNodes = rawNodes.compactMap({ $0.content })

            var promotedSportsAccumulator: [PromotedSport] = []
            for validNode in validNodes {
                promotedSportsAccumulator.append(contentsOf: validNode.promotedSports)
            }

            self.promotedSports = promotedSportsAccumulator.filter({ !$0.marketGroups.isEmpty })
        }

        init(promotedSports: [PromotedSport]) {
            self.promotedSports = promotedSports
        }

        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.promotedSports, forKey: .promotedSports)
        }

    }

    struct PromotedSportsNodeResponse: Codable {

        var promotedSports: [PromotedSport]

        enum CodingKeys: String, CodingKey {
            case node = "bonavigationnodes"
            case name = "name"
            case promotedSports = "promotedSports"
        }

        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)
            let name = try container.decode(String.self, forKey: .name)

            if name.lowercased() == "popular" {
                let rawPromotedSports = try container.decode([FailableDecodable<SportRadarModels.PromotedSport>].self, forKey: .node)
                self.promotedSports = rawPromotedSports.compactMap({ $0.content })
            }
            else {
                let context = DecodingError.Context(codingPath: [CodingKeys.node], debugDescription: "PromotedSportsResponse popular node not found")
                throw DecodingError.valueNotFound(ContentRoute.self, context)
            }
        }

        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.promotedSports, forKey: .promotedSports)
        }

    }

     struct PromotedSport: Codable {

         let id: String
         let name: String
         let marketGroups: [MarketGroupPromotedSport]

        enum CodingKeys: String, CodingKey {
            case id = "idfwbonavigation"
            case name = "name"
            case marketGroups = "marketgroups"
        }

         init(from decoder: Decoder) throws {
             let container: KeyedDecodingContainer<SportRadarModels.PromotedSport.CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)
             self.id = try container.decode(String.self, forKey: CodingKeys.id)
             self.name = try container.decode(String.self, forKey: CodingKeys.name)
             self.marketGroups = try container.decode([SportRadarModels.MarketGroupPromotedSport].self, forKey: CodingKeys.marketGroups)
         }
    }

    struct MarketGroupPromotedSport: Codable {

        let id: String
        let typeId: String?
        let name: String?

       enum CodingKeys: String, CodingKey {
           case id = "idfwmarketgroup"
           case typeId = "idfwmarketgrouptype"
           case name = "name"
       }

   }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/HomeWidgets/PromotionalBanners.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 30/05/2023.
//

import Foundation

extension SportRadarModels {

    struct PromotionalBannersResponse: Codable {
        var promotionalBannerItems: [PromotionalBanner]

        enum CodingKeys: String, CodingKey {
            case promotionalBannerItems = "banneritems"
        }

        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)
            let rawPromotionalBannerItems: [FailableDecodable<SportRadarModels.PromotionalBanner>] = try container.decode([FailableDecodable<SportRadarModels.PromotionalBanner>].self, forKey: .promotionalBannerItems)
            self.promotionalBannerItems = rawPromotionalBannerItems.compactMap({ $0.content })
        }

        init(promotionalBannerItems: [PromotionalBanner]) {
            self.promotionalBannerItems = promotionalBannerItems
        }
    }

     struct PromotionalBanner: Codable {
         let id: String
         let name: String?
         let bannerType: String?
         let imageURL: String?
         let bannerDisplay: String?
         let linkType: String?
         let location: String?
         let bannerContents: [String]?

        enum CodingKeys: String, CodingKey {
            case id = "idfwbanneritem"
            case name = "name"
            case bannerType = "bannertype"
            case imageURL = "imageurl"
            case bannerDisplay = "bannerdisplay"
            case linkType = "linktype"
            case location = "location"
            case bannerContents = "bannerstaticcontents"
        }

    }

    enum BannerSpecialAction {
        case register
        case none
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/HomeWidgets/SportRadarModelMapper+HeadlineResponse.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 08/06/2023.
//

import Foundation
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/HomeWidgets/SportRadarModelMapper+PromotedSports.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 09/06/2023.
//

import Foundation


extension SportRadarModelMapper {

    static func promotedSport(fromInternalPromotedSport internalPromotedSport: SportRadarModels.PromotedSport) -> PromotedSport {
        return PromotedSport(id: internalPromotedSport.id,
                             name: internalPromotedSport.name,
                             marketGroups: internalPromotedSport.marketGroups.map(Self.marketGroupPromotedSport(fromInternalMarketGroupPromotedSport:)))
    }

    static func marketGroupPromotedSport(fromInternalMarketGroupPromotedSport marketGroupPromotedSport: SportRadarModels.MarketGroupPromotedSport) -> MarketGroupPromotedSport {
        return MarketGroupPromotedSport(id: marketGroupPromotedSport.id, typeId: marketGroupPromotedSport.typeId, name: marketGroupPromotedSport.name)
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/HomeWidgets/SportRadarModelMapper+PromotionalBanner.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 30/05/2023.
//

import Foundation

extension SportRadarModelMapper {

    static func promotionalBannersResponse(fromInternalPromotionalBannersResponse internalBannerResponse: SportRadarModels.PromotionalBannersResponse)
    -> PromotionalBannersResponse {
        let promotionalBanners = internalBannerResponse.promotionalBannerItems.map({
             Self.promotionalBanner(fromInternalPromotionalBanner: $0)
        })
        return PromotionalBannersResponse(promotionalBannerItems: promotionalBanners)
    }

    static func promotionalBanner(fromInternalPromotionalBanner internalPromotionalBanner: SportRadarModels.PromotionalBanner) -> PromotionalBanner {

        var bannerSpecialAction = BannerSpecialAction.none

        if let location = internalPromotionalBanner.location {
            if location.contains("#register") {
                bannerSpecialAction = .register
            }
        }

        return PromotionalBanner(id: internalPromotionalBanner.id,
                                 name: internalPromotionalBanner.name,
                                 bannerType: internalPromotionalBanner.bannerType,
                                 imageURL: internalPromotionalBanner.imageURL,
                                 bannerDisplay: internalPromotionalBanner.bannerDisplay,
                                 linkType: internalPromotionalBanner.linkType,
                                 location: internalPromotionalBanner.location,
                                 bannerContents: internalPromotionalBanner.bannerContents,
                                 specialAction: bannerSpecialAction)
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Limits/SportRadarModels+ResponsibleGamingLimitsResponse.swift
````swift
//
//  SportRadarModels+ResponsibleGamingLimitsResponse.swift
//  
//
//  Created by André Lascas on 17/03/2023.
//

import Foundation

extension SportRadarModels {

    struct ResponsibleGamingLimitsResponse: Codable {
        var status: String
        var limits: [ResponsibleGamingLimit]

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case limits = "limits"
        }
    }

    struct ResponsibleGamingLimit: Codable {
        var id: Int
        var partyId: Int
        var limitType: String
        var periodType: String
        var effectiveDate: String
        var expiryDate: String
        var limit: Double

        enum CodingKeys: String, CodingKey {
            case id = "responsibleGamingLimitID"
            case partyId = "partyID"
            case limitType = "limitType"
            case periodType = "periodType"
            case effectiveDate = "effectiveDate"
            case expiryDate = "expiryDate"
            case limit = "limit"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/PromotionStories/SportRadarModels+PromotionalStoriesResponse.swift
````swift
//
//  SportRadarModels+PromotionalStoriesResponse.swift
//  
//
//  Created by André Lascas on 25/07/2023.
//

import Foundation

extension SportRadarModels {

    struct PromotionalStoriesResponse: Codable {

        var promotionalStories: [PromotionalStory]

        enum CodingKeys: String, CodingKey {
            case promotionalStories = "headlineItems"
        }
    }

    struct PromotionalStory: Codable {
        var id: String
        var title: String
        var imageUrl: String
        var linkUrl: String
        var bodyText: String

        enum CodingKeys: String, CodingKey {
            case id = "idfwheadline"
            case title = "title"
            case imageUrl = "imageurl"
            case linkUrl = "linkurl"
            case bodyText = "bodytext"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.PromotionalStory.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.PromotionalStory.CodingKeys.self)
            self.id = try container.decode(String.self, forKey: SportRadarModels.PromotionalStory.CodingKeys.id)
            self.title = try container.decode(String.self, forKey: SportRadarModels.PromotionalStory.CodingKeys.title)
            self.imageUrl = try container.decode(String.self, forKey: SportRadarModels.PromotionalStory.CodingKeys.imageUrl)
            self.linkUrl = try container.decode(String.self, forKey: SportRadarModels.PromotionalStory.CodingKeys.linkUrl)
            self.bodyText = (try? container.decode(String.self, forKey: SportRadarModels.PromotionalStory.CodingKeys.bodyText)) ?? ""
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Referrals/SportRadarModels+Referee.swift
````swift
//
//  SportRadarModels+Referee.swift
//
//
//  Created by André Lascas on 11/03/2024.
//

import Foundation

extension SportRadarModels {
    
    struct Referee: Codable {
        
        var id: Int
        var username: String
        var registeredAt: String
        var kycStatus: String
        var depositPassed: Bool
        
        enum CodingKeys: String, CodingKey {
            case id = "partyId"
            case username = "userId"
            case registeredAt = "regDate"
            case kycStatus = "kycStatus"
            case depositPassed = "depositAmountPassed"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Referrals/SportRadarModels+RefereesResponse.swift
````swift
//
//  SportRadarModels+RefereesResponse.swift
//
//
//  Created by André Lascas on 11/03/2024.
//

import Foundation

extension SportRadarModels {
    
    struct RefereesResponse: Codable {
        var status: String
        var referees: [Referee]
        
        enum CodingKeys: String, CodingKey {
            case status = "status"
            case referees = "referees"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Referrals/SportRadarModels+ReferralLink.swift
````swift
//
//  SportRadarModels+ReferralLink.swift
//
//
//  Created by André Lascas on 11/03/2024.
//

import Foundation

extension SportRadarModels {
    
    struct ReferralLink: Codable {
        
        var code: String
        var link: String
        
        enum CodingKeys: String, CodingKey {
            case code = "referralCode"
            case link = "referralLink"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Referrals/SportRadarModels+ReferralResponse.swift
````swift
//
//  SportRadarModels+ReferralResponse.swift
//
//
//  Created by André Lascas on 11/03/2024.
//

import Foundation

extension SportRadarModels {
    
    struct ReferralResponse: Codable {
        var status: String
        var referralLinks: [ReferralLink]
        
        enum CodingKeys: String, CodingKey {
            case status = "status"
            case referralLinks = "referralLinks"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SharedTicket/SportRadarModels+SharedBets.swift
````swift
//
//  SportRadarModels+SharedBets.swift
//  
//
//  Created by André Lascas on 21/04/2023.
//

import Foundation

extension SportRadarModels {

    struct SharedBet: Codable {

        var betSelections: [SharedBetSelection]
        var winStake: Double
        var potentialReturn: Double
        var totalStake: Double

        enum CodingKeys: String, CodingKey {
            case betSelections = "betLegs"
            case winStake = "winStake"
            case potentialReturn = "potentialReturn"
            case totalStake = "totalStake"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SharedTicket/SportRadarModels+SharedBetSelection.swift
````swift
//
//  SportRadarModels+SharedBetSelection.swift
//  
//
//  Created by André Lascas on 21/04/2023.
//

import Foundation

extension SportRadarModels {

    struct SharedBetSelection: Codable {

        var id: Double
        var priceDenominator: Int
        var priceNumerator: Int
        var priceType: String

        enum CodingKeys: String, CodingKey {
            case id = "idFOSelection"
            case priceDenominator = "priceDown"
            case priceNumerator = "priceUp"
            case priceType = "idFOPriceType"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SharedTicket/SportRadarModels+SharedTicketResponse.swift
````swift
//
//  SportRadarModels+SharedTicketResponse.swift
//  
//
//  Created by André Lascas on 21/04/2023.
//

import Foundation

extension SportRadarModels {

    struct SharedTicketResponse: Codable {

        var bets: [SharedBet]
        var totalStake: Double
        var betId: Double

        enum CodingKeys: String, CodingKey {
            case bets = "bets"
            case totalStake = "totalStake"
            case betId = "idFOBetSlip"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SharedTicket/SportRadarModels+TicketSelection.swift
````swift
//
//  SportRadarModels+TicketSelection.swift
//  
//
//  Created by André Lascas on 24/04/2023.
//

import Foundation

extension SportRadarModels {

    struct TicketSelection: Codable {

        var id: String
        var marketId: String
        var name: String
        var priceDenominator: String
        var priceNumerator: String

        var odd: Double {
            let priceNumerator = Double(self.priceNumerator) ?? 0.0
            let priceDenominator = Double(self.priceDenominator) ?? 0.0
            return (priceNumerator/priceDenominator) + 1.0
        }

        enum CodingKeys: String, CodingKey {
            case id = "idfoselection"
            case marketId = "idfomarket"
            case name = "name"
            case priceDenominator = "currentpricedown"
            case priceNumerator = "currentpriceup"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SharedTicket/SportRadarModels+TicketSelectionResponse.swift
````swift
//
//  SportRadarModels+TicketSelectionResponse.swift
//  
//
//  Created by André Lascas on 24/04/2023.
//

import Foundation

extension SportRadarModels {

    struct TicketSelectionResponse: Codable {

        var data: TicketSelection?
        var errorType: String?

        enum CodingKeys: String, CodingKey {
            case data = "data"
            case errorType = "errorType"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/UserConsents/SportRadarModels+UserConsent.swift
````swift
//
//  SportRadarModels+UserConsent.swift
//  
//
//  Created by André Lascas on 09/05/2023.
//

import Foundation

extension SportRadarModels {

    struct UserConsent: Codable {
        var consentInfo: UserConsentInfo
        var consentStatus: String
        
        enum CodingKeys: String, CodingKey {
            case consentInfo = "consent"
            case consentStatus = "consentStatus"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/UserConsents/SportRadarModels+UserConsentInfo.swift
````swift
//
//  SportRadarModels+UserConsentInfo.swift
//  
//
//  Created by André Lascas on 09/05/2023.
//

import Foundation

extension SportRadarModels {

    struct UserConsentInfo: Codable {

        var id: Int
        var key: String
        var name: String
        var consentVersionId: Int
        
        var isMandatory: Bool?
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case key = "key"
            case name = "name"
            case consentVersionId = "consentVersionId"
            
            case isMandatory = "isMandatory"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/UserConsents/SportRadarModels+UserConsentsResponse.swift
````swift
//
//  SportRadarModels+UserConsentsResponse.swift
//  
//
//  Created by André Lascas on 09/05/2023.
//

import Foundation

extension SportRadarModels {

    // MARK: - ConsentsResponse
    struct ConsentsResponse: Codable {
        let status: String
        let consents: [Consent]
    }

    // MARK: - Consent
    struct Consent: Codable {
        let id: Int
        let key: String
        let name: String
        let consentVersionId: Int
        
        let status: String?
        let isMandatory: Bool?
        
        enum CodingKeys: String, CodingKey {
            case id = "id"
            case key = "key"
            case name = "name"
            case consentVersionId = "consentVersionId"
            case status = "consentStatus"
            case isMandatory = "isMandatory"
        }
    }

    struct UserConsentsResponse: Codable {
        var status: String
        var message: String?
        var userConsents: [UserConsent]

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case message = "message"
            case userConsents = "userConsents"
        }

    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Withdrawals/SportRadarModels+AddPaymentInformationResponse.swift
````swift
//
//  SportRadarModels+AddPaymentInformationResponse.swift
//  
//
//  Created by André Lascas on 16/03/2023.
//

import Foundation

extension SportRadarModels {

    struct AddPaymentInformationResponse: Codable {
        var status: String
        var message: String?

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case message = "message"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Withdrawals/SportRadarModels+BankPaymentDetail.swift
````swift
//
//  SportRadarModels+BankPaymentDetail.swift
//  
//
//  Created by André Lascas on 15/03/2023.
//

import Foundation

extension SportRadarModels {
    struct BankPaymentDetail: Codable {

        var id: Int
        var paymentInfoId: Int
        var key: String
        var value: String

        enum CodingKeys: String, CodingKey {
            case id = "id"
            case paymentInfoId = "paymentInformationId"
            case key = "key"
            case value = "value"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Withdrawals/SportRadarModels+BankPaymentInfo.swift
````swift
//
//  SportRadarModels+BankPaymentInfo.swift
//  
//
//  Created by André Lascas on 15/03/2023.
//

import Foundation

extension SportRadarModels {
    struct BankPaymentInfo: Codable {

        var id: Int
        var partyId: Int
        var type: String
        var description: String?
        var priority: Int?
        var details: [BankPaymentDetail]

        enum CodingKeys: String, CodingKey {
            case id = "id"
            case partyId = "partyId"
            case type = "type"
            case description = "description"
            case priority = "priority"
            case details = "details"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Withdrawals/SportRadarModels+CancelWithdrawalResponse.swift
````swift
//
//  SportRadarModels+CancelWithdrawalResponse.swift
//  
//
//  Created by André Lascas on 28/02/2023.
//

import Foundation

extension SportRadarModels {

    struct CancelWithdrawalResponse: Codable {
        var status: String
        var amount: String
        var currency: String

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case amount = "amount"
            case currency = "currency"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Withdrawals/SportRadarModels+PaymentInformation.swift
````swift
//
//  SportRadarModels+PaymentInformation.swift
//  
//
//  Created by André Lascas on 15/03/2023.
//

import Foundation

extension SportRadarModels {
    struct PaymentInformation: Codable {

        var status: String
        var data: [BankPaymentInfo]

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case data = "data"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Withdrawals/SportRadarModels+PendingWithdrawal.swift
````swift
//
//  SportRadarModels+PendingWithdrawal.swift
//  
//
//  Created by André Lascas on 28/02/2023.
//

import Foundation

extension SportRadarModels {

    struct PendingWithdrawal: Codable {

        var status: String
        var paymentId: Int
        var amount: String

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case paymentId = "paymentId"
            case amount = "amount"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Withdrawals/SportRadarModels+PendingWithdrawalResponse.swift
````swift
//
//  SportRadarModels+PendingWithdrawalResponse.swift
//  
//
//  Created by André Lascas on 28/02/2023.
//

import Foundation

extension SportRadarModels {

    struct PendingWithdrawalResponse: Codable {

        var status: String
        var pendingWithdrawals: [PendingWithdrawal]

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case pendingWithdrawals = "withdrawals"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Withdrawals/SportRadarModels+ProcessWithdrawalResponse.swift
````swift
//
//  SportRadarModels+ProcessWithdrawalResponse.swift
//  
//
//  Created by André Lascas on 27/02/2023.
//

import Foundation

extension SportRadarModels {

    struct ProcessWithdrawalResponse: Codable {

        var status: String
        var paymentId: String?
        var message: String?

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case paymentId = "paymentId"
            case message = "message"
        }
    }
    
    struct PrepareWithdrawalResponse: Codable {

        var status: String
        var conversionId: String?
        var message: String?

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case conversionId = "conversionId"
            case message = "message"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Withdrawals/SportRadarModels+WithdrawalMethod.swift
````swift
//
//  SportRadarModels+WithdrawalMethod.swift
//  
//
//  Created by André Lascas on 27/02/2023.
//

import Foundation

extension SportRadarModels {

    struct WithdrawalMethod: Codable {
        var code: String
        var paymentMethod: String
        var minimumWithdrawal: String
        var maximumWithdrawal: String
        var conversionRequired: Bool

        enum CodingKeys: String, CodingKey {
            case code = "code"
            case paymentMethod = "paymentMethod"
            case minimumWithdrawal = "minimumWithdrawal"
            case maximumWithdrawal = "maximumWithdrawal"
            case conversionRequired = "conversionRequired"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/Withdrawals/SportRadarModels+WithdrawalMethodsResponse+Withdrawals.swift
````swift
//
//  SportRadarModels+WithdrawalMethodsResponse.swift
//  
//
//  Created by André Lascas on 24/02/2023.
//

import Foundation

extension SportRadarModels {

    struct WithdrawalMethodsResponse: Codable {

        var status: String
        var withdrawalMethods: [WithdrawalMethod]

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case withdrawalMethods = "withdrawalMethods"
        }
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SportRadarModels+Betting.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 14/11/2022.
//

import Foundation

extension SportRadarModels {
    
    enum BetResult: String, CaseIterable, Codable {
        case won = "Won"
        case lost = "Lost"
        case drawn = "Drawn"
        case open = "Open"
        case void = "Void"
        case pending = "Pending"
        case notSpecified = "NotSpecified"
    }
    
    enum BetState: String, CaseIterable, Codable {
        case attempted = "Attempted"
        case opened = "Opened"
        case closed = "Closed"
        case settled = "Settled"
        case cancelled = "Cancelled"
        case allStates = "AllStates"
        case won = "Won"
        case lost = "Lost"
        case cashedOut = "Cashed Out"
        case void = "Void"
        case undefined = "Undefined"

        init?(rawValue: String) {
            switch rawValue.lowercased() {
            case "attempted", "attempt":
                self = .attempted
            case "opened", "open":
                self = .opened
            case "closed":
                self = .closed
            case "settled":
                self = .settled
            case "cancelled":
                self = .cancelled
            case "won":
                self = .won
            case "lost":
                self = .lost
            case "cashed out":
                self = .cashedOut
            case "void":
                self = .void
            default:
                self = .undefined
            }
        }
    }
    
    struct BettingHistory: Codable {
        var bets: [Bet]
    }

    struct Bet: Codable {
        
        var identifier: String
        var eventName: String

        var homeTeamName: String?
        var awayTeamName: String?

        var sportTypeName: String
        var type: String
        var state: BetState
        var result: BetResult
        var globalState: BetState
        var marketName: String
        var outcomeName: String
        var eventResult: String?
        var potentialReturn: Double?
        var totalReturn: Double?
        var totalOdd: Double
        var totalStake: Double
        var attemptedDate: Date

        var oddNumerator: Double
        var oddDenominator: Double

        var order: Int

        var eventId: Double
        var eventDate: Date?

        var tournamentCountryName: String?
        var tournamentName: String?

        var freeBet: Bool

        var partialCashoutReturn: Double?
        var partialCashoutStake: Double?

        var betslipId: Int?

        var cashbackReturn: Double?
        var freebetReturn: Double?

        var potentialCashbackReturn: Double?
        var potentialFreebetReturn: Double?

        enum CodingKeys: String, CodingKey {
            case identifier = "idFOBet"
            case eventName
            case homeTeamName = "participantHome"
            case awayTeamName = "participantAway"
            case sportTypeName = "idFOSportType"
            case type = "betTypeName"
            case state = "betLegStatus"
            case result = "betResult"
            case globalState = "betState"
            case marketName
            case outcomeName = "selectionName"
            case potentialReturn
            case totalReturn = "totalReturn"
            case totalOdd = "totalMultiBetOdds"
            case totalStake = "totalStake"
            case attemptedDate = "tsAttempted"

            case oddDenominator = "ownPriceDown"
            case oddNumerator = "ownPriceUp"

            case order = "legOrder"
            case eventResult = "eventResult"

            case eventId = "idFOEvent"
            case eventDate = "tsEventTime"

            case tournamentCountryName = "tournamentCountryName"
            case tournamentName = "tournamentName"

            case freeBet = "free"

            case partialCashoutReturn = "partialCashoutReturn"
            case partialCashoutStake = "partialCashoutStake"

            case betslipId = "idFOBetslip"

            case cashbackReturn = "soReturn"
            case freebetReturn = "soFreeReturn"

            case potentialCashbackReturn = "soPotentialReturn"
            case potentialFreebetReturn = "soPotentialFreeReturn"
        }

        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            let identifierDouble = try container.decode(Double.self, forKey: .identifier)
            self.identifier = String(format: "%.2f", identifierDouble)

            self.eventName = try container.decode(String.self, forKey: .eventName)

            self.homeTeamName = try container.decodeIfPresent(String.self, forKey: .homeTeamName)
            self.awayTeamName = try container.decodeIfPresent(String.self, forKey: .awayTeamName)

            self.sportTypeName = try container.decode(String.self, forKey: .sportTypeName)
            self.marketName = try container.decode(String.self, forKey: .marketName)
            self.outcomeName = try container.decode(String.self, forKey: .outcomeName)
            self.eventResult = try container.decodeIfPresent(String.self, forKey: .eventResult)
            self.potentialReturn = (try? container.decode(Double.self, forKey: .potentialReturn)) ?? 0.0
            self.totalReturn = (try? container.decode(Double.self, forKey: .totalReturn)) ?? 0.0

            self.type = try container.decode(String.self, forKey: .type)

            let stateString = try container.decode(String.self, forKey: .state)
            self.state = BetState(rawValue: stateString) ?? .undefined

            let resultString = try container.decode(String.self, forKey: .result)
            self.result = BetResult(rawValue: resultString) ?? .notSpecified

            let globalStateString = try container.decode(String.self, forKey: .globalState)
            self.globalState = BetState(rawValue: globalStateString) ?? .undefined

            self.totalOdd = try container.decode(Double.self, forKey: .totalOdd)
            self.totalStake = try container.decode(Double.self, forKey: .totalStake)

            self.oddNumerator = (try? container.decode(Double.self, forKey: .oddNumerator)) ?? 0.0
            self.oddDenominator = (try? container.decode(Double.self, forKey: .oddDenominator)) ?? 0.0

            self.order = (try? container.decode(Int.self, forKey: .order)) ?? 999

            self.eventId = try container.decode(Double.self, forKey: .eventId)

            if let date = try? container.decode(Date.self, forKey: .attemptedDate) {
                self.attemptedDate = date
            }
            else if let startDateString = try container.decodeIfPresent(String.self, forKey: .attemptedDate) {
                if let date = Self.dateFormatter.date(from: startDateString) {
                    self.attemptedDate = date
                }
                else if let date = Self.fallbackDateFormatter.date(from: startDateString) {
                    self.attemptedDate = date
                }
                else {
                    let context = DecodingError.Context(codingPath: [CodingKeys.attemptedDate], debugDescription: "Start date with wrong format.")
                    throw DecodingError.typeMismatch(Self.self, context)
                }
            }
            else {
                let context = DecodingError.Context(codingPath: [CodingKeys.attemptedDate], debugDescription: "Not start date found.")
                throw DecodingError.valueNotFound(Self.self, context)
            }
            
            if let date = try? container.decode(Date.self, forKey: .eventDate) {
                self.eventDate = date
            }
            else if let startDateString = try container.decodeIfPresent(String.self, forKey: .eventDate) {
                if let date = Self.dateFormatter.date(from: startDateString) {
                    self.eventDate = date
                }
                else if let date = Self.fallbackDateFormatter.date(from: startDateString) {
                    self.eventDate = date
                }
            }
            
            self.tournamentCountryName = try container.decodeIfPresent(String.self, forKey: .tournamentCountryName)

            self.tournamentName = try container.decodeIfPresent(String.self, forKey: .tournamentName)

            if let freeBetIntValue = try container.decodeIfPresent(Int.self, forKey: .freeBet) {
                if freeBetIntValue == -1 {
                    self.freeBet = true
                }
                else {
                    self.freeBet = false
                }
            }
            else if let freeBetStringValue = try container.decodeIfPresent(String.self, forKey: .freeBet) {
                if freeBetStringValue == "-1" {
                    self.freeBet = true
                }
                else {
                    self.freeBet = false
                }
            }
            else if let freeBetBoolValue = try container.decodeIfPresent(Bool.self, forKey: .freeBet) {
                self.freeBet = freeBetBoolValue
            }
            else {
                self.freeBet = false
            }

            self.partialCashoutReturn = try container.decodeIfPresent(Double.self, forKey: .partialCashoutReturn)
            self.partialCashoutStake = try container.decodeIfPresent(Double.self, forKey: .partialCashoutStake)

            self.betslipId = try container.decodeIfPresent(Int.self, forKey: .betslipId)

            self.cashbackReturn = try container.decodeIfPresent(Double.self, forKey: .cashbackReturn)
            self.freebetReturn = try container.decodeIfPresent(Double.self, forKey: .freebetReturn)

            self.potentialCashbackReturn = try container.decodeIfPresent(Double.self, forKey: .potentialCashbackReturn)
            self.potentialFreebetReturn = try container.decodeIfPresent(Double.self, forKey: .potentialFreebetReturn)

        }

        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.identifier, forKey: CodingKeys.identifier)
            try container.encode(self.eventName, forKey: CodingKeys.eventName)
            try container.encodeIfPresent(self.homeTeamName, forKey: CodingKeys.homeTeamName)
            try container.encodeIfPresent(self.awayTeamName, forKey: CodingKeys.awayTeamName)
            try container.encode(self.sportTypeName, forKey: CodingKeys.sportTypeName)
            try container.encode(self.type, forKey: CodingKeys.type)
            try container.encode(self.state, forKey: CodingKeys.state)
            try container.encode(self.result, forKey: CodingKeys.result)
            try container.encode(self.globalState, forKey: CodingKeys.globalState)
            try container.encode(self.marketName, forKey: CodingKeys.marketName)
            try container.encode(self.outcomeName, forKey: CodingKeys.outcomeName)
            try container.encodeIfPresent(self.potentialReturn, forKey: CodingKeys.potentialReturn)
            try container.encodeIfPresent(self.totalReturn, forKey: CodingKeys.totalReturn)
            try container.encode(self.totalOdd, forKey: CodingKeys.totalOdd)
            try container.encode(self.totalStake, forKey: CodingKeys.totalStake)
            try container.encode(self.attemptedDate, forKey: CodingKeys.attemptedDate)
            try container.encode(self.oddDenominator, forKey: CodingKeys.oddDenominator)
            try container.encode(self.oddNumerator, forKey: CodingKeys.oddNumerator)
            try container.encode(self.order, forKey: CodingKeys.order)
            try container.encodeIfPresent(self.eventResult, forKey: CodingKeys.eventResult)
            try container.encode(self.eventId, forKey: CodingKeys.eventId)
            try container.encodeIfPresent(self.tournamentCountryName, forKey: CodingKeys.tournamentCountryName)
            try container.encodeIfPresent(self.tournamentName, forKey: CodingKeys.tournamentName)
            try container.encodeIfPresent(self.freeBet, forKey: CodingKeys.freeBet)

            try container.encodeIfPresent(self.partialCashoutReturn, forKey: CodingKeys.partialCashoutReturn)

            try container.encodeIfPresent(self.partialCashoutStake, forKey: CodingKeys.partialCashoutStake)

            try container.encodeIfPresent(self.betslipId, forKey: CodingKeys.betslipId)
        }
        
        private static var dateFormatter: DateFormatter {
            let formatter = DateFormatter()
            formatter.dateFormat =  "yyyy-MM-dd'T'HH:mm:ss.SSSZ"
            return formatter
        }
        
        private static var fallbackDateFormatter: DateFormatter {
            let formatter = DateFormatter()
            formatter.dateFormat =  "yyyy-MM-dd'T'HH:mm:ssZ"
            return formatter
        }

    }

    struct BetSlip: Codable {
        var tickets: [BetTicket]
    }
    
    struct BetTicket: Codable {
        var selections: [BetTicketSelection]
        var betTypeCode: String
        var winStake: String
        var potentialReturn: Double?
        var pool: Bool
        
        enum CodingKeys: String, CodingKey {
            case selections = "betLegs"
            case betTypeCode = "idFOBetType"
            case winStake = "winStake"
            case potentialReturn = "potentialReturn"
            case pool = "pool"
        }
    }
    
    struct BetTicketSelection: Codable {
        var identifier: String
        var eachWayReduction: String
        var eachWayPlaceTerms: String
        var idFOPriceType: String
        var isTrap: String
        var priceUp: String
        var priceDown: String
        
        enum CodingKeys: String, CodingKey {
            case identifier = "idFOSelection"
            case eachWayReduction = "eachWayReduction"
            case eachWayPlaceTerms = "eachWayPlaceTerms"
            case idFOPriceType = "idFOPriceType"
            case isTrap = "isTrap"
            case priceUp = "priceUp"
            case priceDown = "priceDown"
        }
    }

    struct BetslipPotentialReturnResponse: Codable {

        var potentialReturn: Double
        var totalStake: Double
        var numberOfBets: Int
        var totalOdd: Double?

        enum CodingKeys: String, CodingKey {
            case numberOfBets = "unitCount"
            case potentialReturn = "potentialReturn"
            case totalStake = "totalStake"
            case totalOdd = "totalOdd"
        }
        
    }
    
    struct BetBuilderPotentialReturn: Codable {

        var potentialReturn: Double
        var calculatedOdds: Double

        enum CodingKeys: String, CodingKey {
            case potentialReturn = "potentialReturn"
            case calculatedOdds = "calculatedOdds"
        }
        
    }
    

    struct BetType: Codable {

        var typeCode: String
        var typeName: String
        var potencialReturn: Double
        var totalStake: Double
        var numberOfIndividualBets: Int

        enum CodingKeys: String, CodingKey {
            case numberOfIndividualBets = "unitCount"
            case typeCode = "idFOBetType"
            case typeName = "name"
            case potencialReturn = "potentialReturn"
            case totalStake = "totalStake"
        }
        
    }

    struct BetSlipStateResponse: Codable {
        var tickets: [BetTicket]
    }

    struct ConfirmBetPlaceResponse: Codable {
        var state: Int
        var detailedState: Int
        var statusCode: String?
        var statusText: String?

        enum CodingKeys: String, CodingKey {
            case state = "state"
            case detailedState = "detailedState"
            case statusCode = "statusCode"
            case statusText = "statusText"
        }
    }

    
    struct PlacedBetsResponse: Codable {
        var identifier: String
        var responseCode: String
        var detailedResponseCode: String?
        var errorMessage: String?
        var totalStake: Double
        var bets: [PlacedBetEntry]

        enum CodingKeys: String, CodingKey {
            case identifier = "idFOBetSlip"
            case bets = "bets"
            
            case status = "status"
            case betStatus = "betStatus"
            
            case responseCode = "state"
            case detailedResponseCode = "detailedState"
            
            case totalStake = "totalStake"
            
            case errorMessage = "statusText"
        }

        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.PlacedBetsResponse.CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)

                let identifierInt = try container.decode(Int.self, forKey: .identifier)
                self.identifier = "\(identifierInt)"
                self.bets = try container.decode([SportRadarModels.PlacedBetEntry].self, forKey: .bets)

                let statusContainer = try? container.nestedContainer(keyedBy: CodingKeys.self, forKey: .status)
                let statusCodeInt = (try? statusContainer?.decodeIfPresent(Int.self, forKey: .responseCode)) ?? 0
                self.responseCode = "\(statusCodeInt)"
                
                let detailedResponseCodeInt = (try? statusContainer?.decodeIfPresent(Int.self, forKey: .detailedResponseCode)) ?? 0
                self.detailedResponseCode = "\(detailedResponseCodeInt)"
                
                self.errorMessage = try statusContainer?.decodeIfPresent(String.self, forKey: .errorMessage)
            
                self.totalStake = try container.decodeIfPresent(Double.self, forKey: .totalStake) ?? 0.0
        }

        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.identifier, forKey: CodingKeys.identifier)
            try container.encode(self.bets, forKey: CodingKeys.bets)
            try container.encode(self.responseCode, forKey: CodingKeys.responseCode)
        }
        
    }

    struct PlacedBetEntry: Codable {
        var identifier: String
        var potentialReturn: Double
        var totalAvailableStake: Double
        var betLegs: [PlacedBetLeg]
        var type: String?

        enum CodingKeys: String, CodingKey {
            case identifier = "idFoBet"
            case betLegs = "betLegs"
            case potentialReturn = "potentialReturn"
            case totalAvailableStake = "totalStake"
            case type = "idfoBetType"
        }

        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.PlacedBetEntry.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.PlacedBetEntry.CodingKeys.self)
            let identifierDouble = try container.decode(Double.self, forKey: SportRadarModels.PlacedBetEntry.CodingKeys.identifier)
            self.identifier = String(format: "%.2f", identifierDouble)

            self.betLegs = try container.decode([SportRadarModels.PlacedBetLeg].self, forKey: SportRadarModels.PlacedBetEntry.CodingKeys.betLegs)
            self.potentialReturn = try container.decode(Double.self, forKey: SportRadarModels.PlacedBetEntry.CodingKeys.potentialReturn)
            self.totalAvailableStake = try container.decodeIfPresent(Double.self, forKey: SportRadarModels.PlacedBetEntry.CodingKeys.totalAvailableStake) ?? 0.0

            
            self.type = try container.decodeIfPresent(String.self, forKey: .type)
        }
    }

    struct PlacedBetLeg: Codable {
        var identifier: String
        var priceType: String

        var odd: Double {
            let priceNumerator = Double(self.priceNumerator)
            let priceDenominator = Double(self.priceDenominator)
            return (priceNumerator/priceDenominator) + 1.0
        }

        var priceNumerator: Int
        var priceDenominator: Int

        enum CodingKeys: String, CodingKey {
            case identifier = "idFOSelection"
            case priceNumerator = "priceUp"
            case priceDenominator = "priceDown"
            case priceType = "idFOPriceType"
        }

        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.PlacedBetLeg.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.PlacedBetLeg.CodingKeys.self)

            let identifierDouble = try container.decode(Double.self, forKey: SportRadarModels.PlacedBetLeg.CodingKeys.identifier)
            self.identifier = String(format: "%.1f", identifierDouble)

            self.priceNumerator = (try? container.decode(Int.self, forKey: SportRadarModels.PlacedBetLeg.CodingKeys.priceNumerator)) ?? 0
            self.priceDenominator = (try? container.decode(Int.self, forKey: SportRadarModels.PlacedBetLeg.CodingKeys.priceDenominator)) ?? 0
            self.priceType = try container.decode(String.self, forKey: SportRadarModels.PlacedBetLeg.CodingKeys.priceType)
        }

    }


    struct BetslipSettings: Codable {
        
        var oddChangeLegacy: BetslipOddChangeSetting?
        var oddChangeRunningOrPreMatch: BetslipOddChangeSetting?
        
        enum CodingKeys: String, CodingKey {
            case name = "name"
            case value = "value"
            case acceptingReofferLegacy = "acceptingReofferLegacy"
            case acceptingReofferBoth = "acceptingReofferBoth"
        }

        init(from decoder: Decoder) throws {
            let container = try decoder.singleValueContainer()
            let settings = try container.decode([Settings].self)
            
            if let acceptingReofferRunSetting = settings.first(where: { $0.id ?? 0 == 667 }),
               let acceptingReofferPreSetting = settings.first(where: { $0.id ?? 0 == 668 }),
               let runningValue = acceptingReofferRunSetting.value,
               acceptingReofferPreSetting.value != nil {
                
                switch runningValue {
                case "none":
                    self.oddChangeRunningOrPreMatch = BetslipOddChangeSetting.none
                case "higher":
                    self.oddChangeRunningOrPreMatch = BetslipOddChangeSetting.higher
                default:
                    self.oddChangeRunningOrPreMatch = BetslipOddChangeSetting.none
                }
                
                //
                self.oddChangeLegacy = nil
            }
            else if 
                let acceptingReofferSetting = settings.first(where: { $0.name == "OddsChange" }),
                let value = acceptingReofferSetting.value
            {
                switch value {
                case "none":
                    self.oddChangeLegacy = BetslipOddChangeSetting.none
                case "higher":
                    self.oddChangeLegacy = BetslipOddChangeSetting.higher
                default:
                    self.oddChangeLegacy = BetslipOddChangeSetting.none
                }
                
                //
                self.oddChangeRunningOrPreMatch = nil
            }
            else {
                self.oddChangeRunningOrPreMatch = BetslipOddChangeSetting.none
                self.oddChangeLegacy = nil
            }
        }

        private struct Settings: Codable {
            var name: String?
            var value: String?
            var id: Int?
        }

        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: SportRadarModels.BetslipSettings.CodingKeys.self)
            try container.encode(self.oddChangeLegacy, forKey: .acceptingReofferLegacy)
            try container.encode(self.oddChangeRunningOrPreMatch, forKey: .acceptingReofferBoth)
        }

    }


}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SportRadarModels+ContentContainer.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 26/04/2023.
//

import Foundation

extension SportRadarModels {

    enum ContentContainer: Codable {

        case liveEvents(contentIdentifier: ContentIdentifier, events: [SportRadarModels.Event])
        case preLiveEvents(contentIdentifier: ContentIdentifier, events: [SportRadarModels.Event])

        case liveSports(sportsTypes: [SportType])
        case preLiveSports(sportsTypes: [SportType])
        case allSports(sportTypes: [SportType])

        case eventDetails(contentIdentifier: ContentIdentifier, event: SportRadarModels.Event?)
        case eventDetailsLiveData(contentIdentifier: ContentIdentifier, eventLiveDataExtended: SportRadarModels.EventLiveDataExtended?)

        case eventGroup(contentIdentifier: ContentIdentifier, events: [SportRadarModels.Event])
        case outrightEventGroup(events: [SportRadarModels.Event])
        case eventSummary(contentIdentifier: ContentIdentifier, eventDetails: [SportRadarModels.Event])

        case marketDetails(contentIdentifier: ContentIdentifier, market: SportRadarModels.Market?)
        case updateEventSecundaryMarkets(contentIdentifier: ContentIdentifier, event: SportRadarModels.Event?)
        case updateEventMainMarket(contentIdentifier: ContentIdentifier, event: SportRadarModels.Event?)

        //
        case addEvent(contentIdentifier: ContentIdentifier, event: SportRadarModels.Event)
        case addMarket(contentIdentifier: ContentIdentifier, market: SportRadarModels.Market)
        case addSelection(contentIdentifier: ContentIdentifier, selection: SportRadarModels.Outcome)
        case addSport(contentIdentifier: ContentIdentifier, sportType: SportType)

        case removeEvent(contentIdentifier: ContentIdentifier, eventId: String)
        case removeMarket(contentIdentifier: ContentIdentifier, marketId: String)
        case removeSelection(contentIdentifier: ContentIdentifier, selectionId: String)
        case removeSport(ContentIdentifier: ContentIdentifier, sportCode: String)

        case enableMarket(contentIdentifier: ContentIdentifier, marketId: String)

        case updateEventLiveDataExtended(contentIdentifier: ContentIdentifier, eventId: String, eventLiveDataExtended: SportRadarModels.EventLiveDataExtended)

        case updateAllSportsLiveCount(ContentIdentifier: ContentIdentifier, nodeId: String, eventCount: Int)
        case updateAllSportsEventCount(ContentIdentifier: ContentIdentifier, nodeId: String, eventCount: Int)

        case updateEventState(contentIdentifier: ContentIdentifier, eventId: String, state: String)
        case updateEventTime(contentIdentifier: ContentIdentifier, eventId: String, newTime: String)
        case updateEventScore(contentIdentifier: ContentIdentifier, eventId: String, homeScore: Int?, awayScore: Int?)

        case updateActivePlayer(contentIdentifier: ContentIdentifier, eventId: String, serving: SportRadarModels.ActivePlayerServe)
        
        case updateEventDetailedScore(contentIdentifier: ContentIdentifier, eventId: String, detailedScore: SportRadarModels.Score)
        
        case updateMarketTradability(contentIdentifier: ContentIdentifier, marketId: String, isTradable: Bool)
        case updateEventMarketCount(contentIdentifier: ContentIdentifier, eventId: String, newMarketCount: Int)

        case updateOutcomeOdd(contentIdentifier: ContentIdentifier, selectionId: String, newOddNumerator: String?, newOddDenominator: String?)

        case updateOutcomeTradability(contentIdentifier: ContentIdentifier, selectionId: String, isTradable: Bool)

        case unknown

        var contentIdentifier: ContentIdentifier? {
            switch self {
            case .liveEvents(let contentIdentifier, _):
                return contentIdentifier
            case .preLiveEvents(let contentIdentifier, _):
                return contentIdentifier
            case .liveSports(_):
                return nil
            case .preLiveSports(_):
                return nil
            case .allSports(_):
                return nil
            case .eventDetails(let contentIdentifier, _):
                return contentIdentifier

            case .eventDetailsLiveData(let contentIdentifier, _):
                return contentIdentifier

            case .eventGroup(let contentIdentifier, _):
                return contentIdentifier
            case .outrightEventGroup(_):
                return nil
            case .eventSummary(let contentIdentifier, _):
                return contentIdentifier
            case .marketDetails(let contentIdentifier, _):
                return contentIdentifier
                
            case .updateEventSecundaryMarkets(let contentIdentifier, _):
                return contentIdentifier
            case .updateEventMainMarket(let contentIdentifier, _):
                return contentIdentifier
                
            case .addEvent(let contentIdentifier, _):
                return contentIdentifier
            case .removeEvent(let contentIdentifier, _):
                return contentIdentifier

            case .addMarket(let contentIdentifier, _):
                return contentIdentifier
            case .enableMarket(let contentIdentifier, _):
                return contentIdentifier
            case .removeMarket(let contentIdentifier, _):
                return contentIdentifier

            case .addSelection(let contentIdentifier, _):
                return contentIdentifier
            case .removeSelection(let contentIdentifier, _):
                return contentIdentifier

            case .addSport(let contentIdentifier, _):
                return contentIdentifier
            case .removeSport(let contentIdentifier, _):
                return contentIdentifier

            case .updateOutcomeOdd(let contentIdentifier, _, _, _):
                return contentIdentifier
            case .updateOutcomeTradability(let contentIdentifier, _, _):
                return contentIdentifier

            case .updateEventLiveDataExtended(let contentIdentifier, _, _):
                return contentIdentifier

            case .updateAllSportsLiveCount(let contentIdentifier, _, _):
                return contentIdentifier
            case .updateAllSportsEventCount(let contentIdentifier, _, _):
                return contentIdentifier

            case .updateEventState(let contentIdentifier, _, _):
                return contentIdentifier
            case .updateEventTime(let contentIdentifier, _, _):
                return contentIdentifier
            case .updateEventScore(let contentIdentifier, _, _, _):
                return contentIdentifier
            case .updateActivePlayer(let contentIdentifier, _, _):
                return contentIdentifier
            case .updateEventMarketCount(let contentIdentifier, _, _):
                return contentIdentifier
            case .updateMarketTradability(let contentIdentifier, _, _):
                return contentIdentifier

            case .updateEventDetailedScore(let contentIdentifier, _, _):
                return contentIdentifier
                
            case .unknown:
                return nil

            }
        }

        private enum CodingKeys: String, CodingKey {
            case data = "data"

            case content = "contentId"
            case contentType = "type"
            case contentId = "id"

            case path = "path"

            case changeType = "changeType"
            case change = "change"
        }

        private enum SelectionUpdateCodingKeys: String, CodingKey {
            case oddNumerator = "currentpriceup"
            case oddDenominator = "currentpricedown"
            case selectionId = "idfoselection"
            case marketId = "idfomarket"
            case suspensionType = "idfoselectionsuspensiontype"
        }

        private enum ScoreUpdateCodingKeys: String, CodingKey {
            case home = "home"
            case away = "away"
            case competitor = "COMPETITOR"
        }

        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

            let changeType: String = (try? container.decode(String.self, forKey: .changeType)) ?? ""
            
            switch changeType.lowercased() {
            case "refreshed":
                self = try Self.parseRefreshed(container: container)
            case "updated":
                self = try Self.parseUpdated(container: container)
            case "added":
                self = try Self.parseAdded(container: container)
            case "removed":
                self = try Self.parseRemoved(container: container)
            default:
                self = try Self.parseRefreshed(container: container)
            }

        }

        func encode(to encoder: Encoder) throws {

        }

        private static func parseRefreshed(container: KeyedDecodingContainer<CodingKeys>) throws -> ContentContainer {
            
            let contentTypeContainer = try container.nestedContainer(keyedBy: CodingKeys.self, forKey: .content)
            let contentType = try contentTypeContainer.decode(ContentType.self, forKey: .contentType)
            let contentIdentifier = try container.decode(ContentIdentifier.self, forKey: .content)
            
            switch contentType {
            case .liveEvents:
                let events: [FailableDecodable<SportRadarModels.Event>] = try container.decode([FailableDecodable<SportRadarModels.Event>].self, forKey: .change)
                let validEvents = events.compactMap({ $0.content })
                return .liveEvents(contentIdentifier: contentIdentifier, events: validEvents)

            case .liveSports:
                let sportsTypeDetails: [FailableDecodable<SportRadarModels.LiveSportTypeDetails>] = try container.decode([FailableDecodable<SportRadarModels.LiveSportTypeDetails>].self, forKey: .change)
                let sportsTypes = sportsTypeDetails.compactMap({ $0.content }).map(\.sportType)
                return .liveSports(sportsTypes: sportsTypes)

            case .preLiveSports:
                // change key is optional
                if container.contains(.change) {
                    let sportsTypes: [FailableDecodable<SportRadarModels.SportType>] = try container.decode([FailableDecodable<SportRadarModels.SportType>].self, forKey: .change)
                    return .preLiveSports(sportsTypes: sportsTypes.compactMap({ $0.content }))
                }
                else {
                    let sportsTypes: [SportType] = []
                    return .preLiveSports(sportsTypes: sportsTypes)
                }

            case .allSports:
                let sportsTypeDetails: FailableDecodable<SportRadarModels.SportsList> = try container.decode(FailableDecodable<SportRadarModels.SportsList>.self, forKey: .change)

                if let sportNodes = sportsTypeDetails.content?.sportNodes {
                    let sportTypes = sportNodes.map(SportRadarModelMapper.sportType(fromSportNode:))
                    let filteredSportTypes = sportTypes.filter({
                        $0.alphaId != "0"
                    })
                    return .allSports(sportTypes: filteredSportTypes)
                }

                return .allSports(sportTypes: [])

            case .preLiveEvents:
                // change key is optional
                if container.contains(.change) {
                    let events: [FailableDecodable<SportRadarModels.Event>] = try container.decode([FailableDecodable<SportRadarModels.Event>].self, forKey: .change)
                    let validEvents = events.compactMap({ $0.content })
                    return .preLiveEvents(contentIdentifier: contentIdentifier, events: validEvents)
                }
                else {
                    return .preLiveEvents(contentIdentifier: contentIdentifier, events: [])
                }

            case .eventDetails:
                // change key is optional
                if container.contains(.change) {
                    let event: SportRadarModels.Event = try container.decode(SportRadarModels.Event.self, forKey: .change)
                    return .eventDetails(contentIdentifier: contentIdentifier, event: event)
                }
                else {
                    return .eventDetails(contentIdentifier: contentIdentifier, event: nil)
                }
            case .eventGroup:
                if container.contains(.change) {
                    let marketGroup: SportRadarModels.CompetitionMarketGroup = try container.decode(SportRadarModels.CompetitionMarketGroup.self, forKey: .change)
                    let events = marketGroup.events
                    return .eventGroup(contentIdentifier: contentIdentifier, events: events)
                }
                else {
                    return .eventGroup(contentIdentifier: contentIdentifier, events: [])
                }

            case .eventSummary:
                // change key is optional
                if container.contains(.change) {
                    let event: SportRadarModels.Event = try container.decode(SportRadarModels.Event.self, forKey: .change)
                    return .eventSummary(contentIdentifier: contentIdentifier, eventDetails: [event])
                }
                else {
                    return .eventSummary(contentIdentifier: contentIdentifier, eventDetails: [])
                }
            case .market:
                if container.contains(.change) {
                    let market: SportRadarModels.Market? = try container.decodeIfPresent(SportRadarModels.Market.self, forKey: .change)
                    return .marketDetails(contentIdentifier: contentIdentifier, market: market)
                }
                else {
                    return .marketDetails(contentIdentifier: contentIdentifier, market: nil)
                }
            case .eventSecundaryMarkets:
                if container.contains(.change) {
                    let event: SportRadarModels.Event = try container.decode(SportRadarModels.Event.self, forKey: .change)
                    return .updateEventSecundaryMarkets(contentIdentifier: contentIdentifier, event: event)
                }
                else {
                    return .updateEventSecundaryMarkets(contentIdentifier: contentIdentifier, event: nil)
                }
                
            case .eventDetailsLiveData:
                if container.contains(.change) {
                    let eventLiveData = try container.decodeIfPresent(SportRadarModels.EventLiveDataExtended.self, forKey: .change)
                    return ContentContainer.eventDetailsLiveData(contentIdentifier: contentIdentifier, eventLiveDataExtended: eventLiveData)
                }
                else {
                    return ContentContainer.eventDetailsLiveData(contentIdentifier: contentIdentifier, eventLiveDataExtended: nil)
                }
            case .eventMainMarket:
                if container.contains(.change) {
                    let event: SportRadarModels.Event = try container.decode(SportRadarModels.Event.self, forKey: .change)
                    return .updateEventMainMarket(contentIdentifier: contentIdentifier, event: event)
                }
                else {
                    return .updateEventMainMarket(contentIdentifier: contentIdentifier, event: nil)
                }
            }
        }

        private static func parseUpdated(container: KeyedDecodingContainer<CodingKeys>) throws -> ContentContainer {
            
            // let contentTypeContainer = try container.nestedContainer(keyedBy: CodingKeys.self, forKey: .content)
            // let contentType = try contentTypeContainer.decode(ContentType.self, forKey: .contentType)
            
            let contentIdentifier = try container.decode(ContentIdentifier.self, forKey: .content)
            let path: String = try container.decodeIfPresent(String.self, forKey: .path) ?? ""
            
            if case ContentRoute.eventMainMarket = contentIdentifier.contentRoute {
                if let event = try? container.decode(SportRadarModels.Event.self, forKey: .change) {
                    return .updateEventMainMarket(contentIdentifier: contentIdentifier, event: event)
                }
            }

            if case let ContentRoute.eventDetailsLiveData(eventId) = contentIdentifier.contentRoute {
                
                if let eventLiveData = try? container.decode(SportRadarModels.EventLiveDataExtended.self, forKey: .change) {
                    return .updateEventLiveDataExtended(contentIdentifier: contentIdentifier, eventId: eventId , eventLiveDataExtended: eventLiveData)
                }
                else if path.contains("matchTime"),
                        let matchTime = try container.decodeIfPresent(String.self, forKey: .change),
                        let minutesPart = SocketMessageParseHelper.extractMatchMinutes(from: matchTime) {
                    
                    let eventLiveDataExtended = SportRadarModels.EventLiveDataExtended.init(id: eventId,
                                                                                            homeScore: nil,
                                                                                            awayScore: nil,
                                                                                            matchTime: minutesPart,
                                                                                            status: nil,
                                                                                            scores: [:],
                                                                                            activePlayerServing: nil)
                    
                    
                    return .updateEventLiveDataExtended(contentIdentifier: contentIdentifier,
                                                        eventId: eventId,
                                                        eventLiveDataExtended: eventLiveDataExtended)
                    
                }
                else if path.contains("COMPLETE"),
                        path.contains("STATUS"),
                        let changeDictionary = try container.decodeIfPresent([String: [String: String]].self, forKey: .change),
                        let eventDictionary = changeDictionary["EVENT"],
                        let newStatusString = eventDictionary[""] {
                    
                    let newStatus = EventStatus.init(value: newStatusString)
                    let eventLiveDataExtended = SportRadarModels.EventLiveDataExtended.init(id: eventId,
                                                                                            homeScore: nil,
                                                                                            awayScore: nil,
                                                                                            matchTime: nil,
                                                                                            status: newStatus,
                                                                                            scores: [:],
                                                                                            activePlayerServing: nil)
                    return .updateEventLiveDataExtended(contentIdentifier: contentIdentifier,
                                                        eventId: eventId,
                                                        eventLiveDataExtended: eventLiveDataExtended)
                    
                }
                else if path.contains("COMPLETE"),
                        path.contains("MATCH_SCORE"),
                        let changeDictionary = try container.decodeIfPresent([String: [String: Int]].self, forKey: .change),
                        let scoreDictionary = changeDictionary["COMPETITOR"]{
                    
                    let homeScore = scoreDictionary["home"]
                    let awayScore = scoreDictionary["away"]
                    
                    var scoresDict: [String: Score] = [:]
                    if let score = Score(stringValue: "MATCH_SCORE", homeScore: homeScore, awayScore: awayScore) {
                        scoresDict[score.key] = score
                    }
                    
                    let eventLiveDataExtended = SportRadarModels.EventLiveDataExtended.init(id: eventId,
                                                                                            homeScore: scoreDictionary["home"],
                                                                                            awayScore: scoreDictionary["away"],
                                                                                            matchTime: nil,
                                                                                            status: nil,
                                                                                            scores: scoresDict,
                                                                                            activePlayerServing: nil)
                    return .updateEventLiveDataExtended(contentIdentifier: contentIdentifier,
                                                        eventId: eventId,
                                                        eventLiveDataExtended: eventLiveDataExtended)
                    
                }
                else if path.contains("COMPLETE"),
                        path.contains("CURRENT_SCORE"),
                        let changeDictionary = try container.decodeIfPresent([String: [String: Int]].self, forKey: .change),
                        let scoreDictionary = changeDictionary["COMPETITOR"]{
                    
                    let homeScore = scoreDictionary["home"]
                    let awayScore = scoreDictionary["away"]
                    
                    var scoresDict: [String: Score] = [:]
                    if let score = Score(stringValue: "CURRENT_SCORE", homeScore: homeScore, awayScore: awayScore) {
                        scoresDict[score.key] = score
                    }
                    
                    let eventLiveDataExtended = SportRadarModels.EventLiveDataExtended.init(id: eventId,
                                                                                            homeScore: scoreDictionary["home"],
                                                                                            awayScore: scoreDictionary["away"],
                                                                                            matchTime: nil,
                                                                                            status: nil,
                                                                                            scores: scoresDict,
                                                                                            activePlayerServing: nil)
                    return .updateEventLiveDataExtended(contentIdentifier: contentIdentifier,
                                                        eventId: eventId,
                                                        eventLiveDataExtended: eventLiveDataExtended)
                    
                }
                else if path.contains("COMPLETE"),
                        path.contains("GAME_SCORE"),
                        let changeDictionary = try container.decodeIfPresent([String: [String: Int]].self, forKey: .change),
                        let scoreDictionary = changeDictionary["COMPETITOR"]{
                    
                    let homeScore = scoreDictionary["home"]
                    let awayScore = scoreDictionary["away"]
                    
                    var scoresDict: [String: Score] = [:]
                    if let score = Score(stringValue: "GAME_SCORE", homeScore: homeScore, awayScore: awayScore) {
                        scoresDict[score.key] = score
                    }
                    
                    let eventLiveDataExtended = SportRadarModels.EventLiveDataExtended.init(id: eventId,
                                                                                            homeScore: scoreDictionary["home"],
                                                                                            awayScore: scoreDictionary["away"],
                                                                                            matchTime: nil,
                                                                                            status: nil,
                                                                                            scores: scoresDict,
                                                                                            activePlayerServing: nil)
                    return .updateEventLiveDataExtended(contentIdentifier: contentIdentifier,
                                                        eventId: eventId,
                                                        eventLiveDataExtended: eventLiveDataExtended)
                    
                }
                else if path.contains("COMPLETE"),
                        let changeDictionary = try container.decodeIfPresent([String: [String: Int]].self, forKey: .change),
                        let scoreDictionary = changeDictionary["COMPETITOR"]{
                    
                    let pathParts = path.split(separator: "|")
                    
                    let homeScore = scoreDictionary["home"]
                    let awayScore = scoreDictionary["away"]
                    
                    var scoresDict: [String: Score] = [:]
                    if let setScore = pathParts.last {
                        let setScoreString = String(setScore)
                        if let score = Score(stringValue: setScoreString, homeScore: homeScore, awayScore: awayScore) {
                            scoresDict[score.key] = score
                        }
                    }
                    
                    let eventLiveDataExtended = SportRadarModels.EventLiveDataExtended.init(id: eventId,
                                                                                            homeScore: scoreDictionary["home"],
                                                                                            awayScore: scoreDictionary["away"],
                                                                                            matchTime: nil,
                                                                                            status: nil,
                                                                                            scores: scoresDict,
                                                                                            activePlayerServing: nil)
                    return .updateEventLiveDataExtended(contentIdentifier: contentIdentifier,
                                                        eventId: eventId,
                                                        eventLiveDataExtended: eventLiveDataExtended)
                    
                }
                // SERVE TEAM / PLAYER
                else if path.split(separator: "|").last?.lowercased() == "serve" {
                    var serveCodeString: String = ""
                    
                    // Simple as Int
                    if let serveInt = try? container.decode(Int.self, forKey: .change) {
                        serveCodeString = "\(serveInt)"
                    }
                    // Simple as String
                    else if let serveString = try? container.decode(String.self, forKey: .change) {
                        serveCodeString = serveString
                    }
                    // Inside an ["Event": "": 1] struct
                    else if let serveDictionary = try container.decodeIfPresent([String: [String: Int]].self, forKey: .change),
                            let emptyDict = serveDictionary["EVENT"], let serveInt = emptyDict[""] {
                        serveCodeString = "\(serveInt)"
                    }
                                
                    if serveCodeString == "1" {
                        return .updateActivePlayer(contentIdentifier: contentIdentifier,
                                                   eventId: eventId,
                                                   serving: .home)
                    }
                    else if serveCodeString == "2" {
                        return .updateActivePlayer(contentIdentifier: contentIdentifier,
                                                   eventId: eventId,
                                                   serving: .away)
                    }
                }
                               
                return .unknown
            }

            // ===========================
            if path.contains("idfosporttype") {
                if let sportCode = SocketMessageParseHelper.extractSportCode(path) {
                    if path.contains("numEvents") {
                        let liveEventsCount = try container.decode(Int.self, forKey: .change)
                        let sportType = SportType(name: sportCode,
                                                  alphaId: sportCode,
                                                  numberEvents: liveEventsCount,
                                                  numberOutrightEvents: 0,
                                                  numberOutrightMarkets: 0,
                                                  numberLiveEvents: liveEventsCount)
                        
                        return .liveSports(sportsTypes: [sportType])
                    }
                }
            }
            
            if path.contains("bonavigationnodes") {
                if let sportId = SocketMessageParseHelper.extractNodeId(path) {
                    if path.contains("numinplayevents") {
                        let liveEventsCount = try container.decode(String.self, forKey: .change)
                        return .updateAllSportsLiveCount(ContentIdentifier: contentIdentifier,
                                                         nodeId: sportId,
                                                         eventCount: Int(liveEventsCount) ?? 0)
                    }
                    if path.contains("numevents") {
                        let eventsCount = try container.decode(String.self, forKey: .change)
                        return .updateAllSportsEventCount(ContentIdentifier: contentIdentifier,
                                                          nodeId: sportId,
                                                          eventCount: Int(eventsCount) ?? 0)
                    }
                }
            }



            if path.contains("idfomarket") && path.contains("istradable"), let marketId = SocketMessageParseHelper.extractMarketId(path) {
                // removed a Market
                let newIsTradable = try container.decode(Bool.self, forKey: .change)
                // print("ContentContainer isTradable \(newIsTradable) market with id :: \(path) and associated change \(changeType)")
                return .updateMarketTradability(contentIdentifier: contentIdentifier, marketId: marketId, isTradable: newIsTradable)
            }
            
            // Updates on Events
            else if path.contains("idfoselection") {
                // Updated a selection
                let changeContainer = try container.nestedContainer(keyedBy: SelectionUpdateCodingKeys.self, forKey: .change)
                
                let oddNumerator = try changeContainer.decodeIfPresent(String.self, forKey: .oddNumerator)
                let oddDenominator = try changeContainer.decodeIfPresent(String.self, forKey: .oddDenominator)
                
                let selectionId = try changeContainer.decode(String.self, forKey: .selectionId)
                
                if oddNumerator == nil && oddDenominator == nil {
                    if changeContainer.contains(.suspensionType) {
                        if let selectionSuspentionType = try changeContainer.decodeIfPresent(String.self, forKey: .suspensionType),
                           selectionSuspentionType == "N/O" {
                            return .updateOutcomeTradability(contentIdentifier: contentIdentifier,
                                                             selectionId: selectionId,
                                                             isTradable: false)
                        }
                        else {
                            return .updateOutcomeTradability(contentIdentifier: contentIdentifier,
                                                             selectionId: selectionId,
                                                             isTradable: true)
                        }
                    }
                    else {
                        return .unknown
                    }
                }
                else {
                    return .updateOutcomeOdd(contentIdentifier: contentIdentifier, selectionId: selectionId, newOddNumerator: oddNumerator, newOddDenominator: oddDenominator)
                }
            }
            else if path.contains("numMarkets"), let eventId = SocketMessageParseHelper.extractEventId(path) {
                // Changed the number of markets for an event
                let newMarketCount = try container.decode(Int.self, forKey: .change)
                return .updateEventMarketCount(contentIdentifier: contentIdentifier, eventId: eventId, newMarketCount: newMarketCount)
            }
            else if path.contains("attributes") && path.contains("COMPLETE") && path.contains("CURRENT_SCORE") {
                let changeContainer = try container.nestedContainer(keyedBy: ScoreUpdateCodingKeys.self, forKey: .change)
                let competitorContainer = try changeContainer.nestedContainer(keyedBy: ScoreUpdateCodingKeys.self, forKey: .competitor)
                
                let homeScore = try competitorContainer.decodeIfPresent(Int.self, forKey: .home)
                let awayScore = try competitorContainer.decodeIfPresent(Int.self, forKey: .away)
                
                let eventIdContainer = try container.nestedContainer(keyedBy: CodingKeys.self, forKey: .content)
                
                let eventId = try eventIdContainer.decode(String.self, forKey: .contentId)
                
                return .updateEventScore(contentIdentifier: contentIdentifier, eventId: eventId, homeScore: homeScore, awayScore: awayScore)
            }
            else if path.contains("scores"), let eventId = SocketMessageParseHelper.extractEventId(path) {
                
                let components = path.components(separatedBy: "|")
                guard
                    let lastComponent = components.last,
                    let changeContainer = try? container.nestedContainer(keyedBy: ScoreUpdateCodingKeys.self, forKey: .change),
                    let homeScore = try? changeContainer.decodeIfPresent(Int.self, forKey: .home),
                    let awayScore = try? changeContainer.decodeIfPresent(Int.self, forKey: .away),
                    let score = Score(stringValue: lastComponent, homeScore: homeScore, awayScore: awayScore)
                else {
                    return .unknown
                }
                
                return .updateEventDetailedScore(contentIdentifier: contentIdentifier, eventId: eventId, detailedScore: score)
            }
            else if path.contains("scores") && (path.contains("MATCH_SCORE") || path.contains("CURRENT_SCORE")), let eventId = SocketMessageParseHelper.extractEventId(path) {
                // Updated score information
                let changeContainer = try container.nestedContainer(keyedBy: ScoreUpdateCodingKeys.self, forKey: .change)
                let homeScore = try changeContainer.decodeIfPresent(Int.self, forKey: .home)
                let awayScore = try changeContainer.decodeIfPresent(Int.self, forKey: .away)
                return .updateEventScore(contentIdentifier: contentIdentifier, eventId: eventId, homeScore: homeScore, awayScore: awayScore)
            }
            else if path.contains("serve"), let eventId = SocketMessageParseHelper.extractEventId(path) {
                if let newIsTradableString = try? container.decode(String.self, forKey: .change) {
                    // Updated tennis serve player information
                    if newIsTradableString == "1" {
                        return .updateActivePlayer(contentIdentifier: contentIdentifier,
                                                   eventId: eventId,
                                                   serving: .home)
                    }
                    else if newIsTradableString == "2" {
                        return .updateActivePlayer(contentIdentifier: contentIdentifier,
                                                   eventId: eventId,
                                                   serving: .away)
                    }
                }
                else if let newIsTradable = try? container.decode(Int.self, forKey: .change) {
                    // Updated tennis serve player information
                    if newIsTradable == 1 {
                        return .updateActivePlayer(contentIdentifier: contentIdentifier,
                                                   eventId: eventId,
                                                   serving: .home)
                    }
                    else if newIsTradable == 2 {
                        return .updateActivePlayer(contentIdentifier: contentIdentifier,
                                                   eventId: eventId,
                                                   serving: .away)
                    }
                }
            }
            else if path.contains("matchTime"), let eventId = SocketMessageParseHelper.extractEventId(path) {
                // Match time
                let matchTime = try container.decode(String.self, forKey: .change)
                if let minutesPart = SocketMessageParseHelper.extractMatchMinutes(from: matchTime) {
                    return .updateEventTime(contentIdentifier: contentIdentifier, eventId: eventId, newTime: minutesPart)
                }
            }
            else if path.contains("status"), let eventId = SocketMessageParseHelper.extractEventId(path) {
                let newStatus = try container.decode(String.self, forKey: .change)
                return .updateEventState(contentIdentifier: contentIdentifier, eventId: eventId, state: newStatus)
            }
            else if path.contains("selections") && path.contains("idfoselection") {
                if let changeContainer = try? container.nestedContainer(keyedBy: SelectionUpdateCodingKeys.self, forKey: .change),
                   let oddNumerator = try changeContainer.decodeIfPresent(String.self, forKey: .oddNumerator),
                   let oddDenominator = try changeContainer.decodeIfPresent(String.self, forKey: .oddDenominator),
                   let selectionId = try? changeContainer.decode(String.self, forKey: .selectionId) {
                    
                    return .updateOutcomeOdd(contentIdentifier: contentIdentifier,
                                             selectionId: selectionId,
                                             newOddNumerator: oddNumerator,
                                             newOddDenominator: oddDenominator)
                }
            }
            else if path.contains("istradable"), let newIsTradable = try? container.decode(Bool.self, forKey: .change), let marketId = SocketMessageParseHelper.extractMarketId(path) {
                if newIsTradable {
                    return .enableMarket(contentIdentifier: contentIdentifier, marketId: marketId)
                }
                else {
                    return .removeMarket(contentIdentifier: contentIdentifier, marketId: marketId)
                }
            }
            else if path.contains("istradable"), let newIsTradable = try? container.decode(Bool.self, forKey: .change) {
                if contentIdentifier.contentType == .market, case .market(let marketId) = contentIdentifier.contentRoute {
                    if newIsTradable {
                        return .enableMarket(contentIdentifier: contentIdentifier, marketId: marketId)
                    }
                    else {
                        return .removeMarket(contentIdentifier: contentIdentifier, marketId: marketId)
                    }
                }
            }
            else if path.contains("markets") && path.contains("istradable"), let marketId = SocketMessageParseHelper.extractMarketId(path) {
                let newIsTradable = (try? container.decode(Bool.self, forKey: .change)) ?? true
                return .updateMarketTradability(contentIdentifier: contentIdentifier, marketId: marketId, isTradable: newIsTradable)
            }
            else if path.contains("selections"), let selectionId = SocketMessageParseHelper.extractSelectionId(path) {
                print("Updated Selection \(selectionId)")
            }
            else if contentIdentifier.contentType == .market, // Is a contentRout of market updates
                    path == "istradable", // the path is istradable
                    case .market(let marketId) = contentIdentifier.contentRoute, // extract the marketId
                    let newIsTradable = try? container.decode(Bool.self, forKey: .change) {
                
                return .updateMarketTradability(contentIdentifier: contentIdentifier, marketId: marketId, isTradable: newIsTradable)
            }
            
            // print("ContentContainer ignored update for \(path) and associated change: Updated")
            return .unknown
        }

        private static func parseAdded(container: KeyedDecodingContainer<CodingKeys>) throws -> ContentContainer {
            // let contentTypeContainer = try container.nestedContainer(keyedBy: CodingKeys.self, forKey: .content)
            // let contentType = try contentTypeContainer.decode(ContentType.self, forKey: .contentType)
            
            let contentIdentifier = try container.decode(ContentIdentifier.self, forKey: .content)
            let path: String = try container.decodeIfPresent(String.self, forKey: .path) ?? ""

            if case ContentRoute.liveSports = contentIdentifier.contentRoute {
                if path.contains("idfosporttype"),
                   let newSport = try? container.decodeIfPresent(SportRadarModels.LiveSportTypeDetails.self, forKey: .change) {
                    let newSportType = SportType(name: newSport.sportName,
                                                 alphaId: newSport.sportType.alphaId,
                                                 numberEvents: newSport.eventsCount, numberOutrightEvents: 0, numberOutrightMarkets: 0, numberLiveEvents: newSport.eventsCount)
                    
                    return .liveSports(sportsTypes: [newSportType])
                }
            }

            if path.contains("idfomarket"), let newMarket = try? container.decode(SportRadarModels.Market.self, forKey: .change) {
                return .addMarket(contentIdentifier: contentIdentifier, market: newMarket)
            }
            else if path.contains("idfoevent"), let newEvent = try? container.decode(SportRadarModels.Event.self, forKey: .change) {
                return .addEvent(contentIdentifier: contentIdentifier, event: newEvent)
            }
            else if path.contains("idfosporttype"), let newSport = try? container.decodeIfPresent(SportRadarModels.LiveSportTypeDetails.self, forKey: .change) {
                return .addSport(contentIdentifier: contentIdentifier, sportType: newSport.sportType)
            }
            else if path.contains("status"), let eventId = SocketMessageParseHelper.extractEventId(path) {
                let newStatus = try container.decode(String.self, forKey: .change)
                return .updateEventState(contentIdentifier: contentIdentifier, eventId: eventId, state: newStatus)
            }
            else if path.contains("scores"), let eventId = SocketMessageParseHelper.extractEventId(path) {                
                let components = path.components(separatedBy: "|")
                guard
                    let lastComponent = components.last,
                    let changeContainer = try? container.nestedContainer(keyedBy: ScoreUpdateCodingKeys.self, forKey: .change),
                    let homeScore = try? changeContainer.decodeIfPresent(Int.self, forKey: .home),
                    let awayScore = try? changeContainer.decodeIfPresent(Int.self, forKey: .away),
                    let score = Score(stringValue: lastComponent, homeScore: homeScore, awayScore: awayScore)
                else {
                    return .unknown
                }
                
                return .updateEventDetailedScore(contentIdentifier: contentIdentifier, eventId: eventId, detailedScore: score)
            }
            
            // print("ContentContainer ignored update for \(path) and associated change: Added")
            return .unknown
        }

        private static func parseRemoved(container: KeyedDecodingContainer<CodingKeys>) throws -> ContentContainer {
            // let contentTypeContainer = try container.nestedContainer(keyedBy: CodingKeys.self, forKey: .content)
            // let contentType = try contentTypeContainer.decode(ContentType.self, forKey: .contentType)
            
            let contentIdentifier = try container.decode(ContentIdentifier.self, forKey: .content)
            let path: String = try container.decodeIfPresent(String.self, forKey: .path) ?? ""


            if case ContentRoute.liveSports = contentIdentifier.contentRoute {
                if path.contains("idfosporttype"),
                   let sportCode = SocketMessageParseHelper.extractSportCode(path) {
                                        
                    let sportName = SportRadarModelMapper.sportTypeName(fromAlphaCode: sportCode)
                                        
                    let removedSport = SportType(name: sportName,
                                                 alphaId: sportCode,
                                                 numberEvents: 0, numberOutrightEvents: 0, numberOutrightMarkets: 0, numberLiveEvents: 0)
                    
                    return .liveSports(sportsTypes: [removedSport])
                }
                    
            }

            if contentIdentifier.contentType == .market, case .market(let marketId) = contentIdentifier.contentRoute {
                return .removeMarket(contentIdentifier: contentIdentifier, marketId: marketId)
            }
            else if path.contains("idfoselection"), let selectionId = SocketMessageParseHelper.extractSelectionId(path) {
                return .removeSelection(contentIdentifier: contentIdentifier, selectionId: selectionId)
            }
            else if path.contains("idfomarket"), let marketId = SocketMessageParseHelper.extractMarketId(path) {
                return .removeMarket(contentIdentifier: contentIdentifier, marketId: marketId)
            }
            else if path.contains("idfoevent"), let eventId = SocketMessageParseHelper.extractSportCode(path)  {
                return .removeEvent(contentIdentifier: contentIdentifier, eventId: eventId)
            }
            else if path.contains("idfosporttype"), let sportCode = SocketMessageParseHelper.extractSportCode(path) {
                return .removeSport(ContentIdentifier: contentIdentifier, sportCode: sportCode)
            }

            // print("ContentContainer ignored update for \(path) and associated change: Removed")
            return .unknown
        }

    }

}



extension SportRadarModels.ContentContainer: CustomDebugStringConvertible {
    var debugDescription: String {
        switch self {
        case .liveEvents(let contentIdentifier, let events):
            return "Live Events (Content ID: \(contentIdentifier)) - Event count: \(events.count)"
        case .preLiveEvents(let contentIdentifier, let events):
            return "Pre-live Events (Content ID: \(contentIdentifier)) - Event count: \(events.count)"
        case .liveSports(let sportsTypes):
            return "Live Sports - Sport Types count: \(sportsTypes.count)"
        case .preLiveSports(let sportsTypes):
            return "Pre-live Sports - Sport Types count: \(sportsTypes.count)"
        case .allSports(let sportsTypes):
            return "All Sports - Sport Types count: \(sportsTypes.count)"
        case .eventDetails(let contentIdentifier, let event):
            return "Event Details (Content ID: \(contentIdentifier)) - Event: \(String(describing: event))"
        case .eventDetailsLiveData(let contentIdentifier, let eventLiveDataExtended):
            return "Event Details Live Data (Content ID: \(contentIdentifier)) - Event Live Data Extended: \(String(describing: eventLiveDataExtended))"
        case .eventGroup(let contentIdentifier, let events):
            return "Event Group (Content ID: \(contentIdentifier)) - Event count: \(events.count)"
        case .outrightEventGroup(let events):
            return "Outright Event Group - Event count: \(events.count)"
        case .eventSummary(let contentIdentifier, let eventDetails):
            return "Event Summary (Content ID: \(contentIdentifier)) - Event Details count: \(eventDetails.count)"
        case .marketDetails(let contentIdentifier, let market):
            return "Market Details (Content ID: \(contentIdentifier)) - Market: \(String(describing: market))"

        case .updateEventMainMarket(let contentIdentifier, let event):
            return "Update Event Main Market (Content ID: \(contentIdentifier)) - Event: \(String(describing: event))"
        case .updateEventSecundaryMarkets(let contentIdentifier, let event):
            return "Update Event Secundary Markets (Content ID: \(contentIdentifier)) - Event: \(String(describing: event))"
            
        case .addEvent(let contentIdentifier, let event):
            return "Add Event (Content ID: \(contentIdentifier)) - Event: \(event)"
        case .removeEvent(let contentIdentifier, let eventId):
            return "Remove Event (Content ID: \(contentIdentifier)) - Event ID: \(eventId)"

        case .addMarket(let contentIdentifier, let market):
            return "Add Market (Content ID: \(contentIdentifier)) - Market: \(market)"
        case .enableMarket(let contentIdentifier, let marketId):
            return "Enable Market (Content ID: \(contentIdentifier)) - Market ID: \(marketId)"
        case .removeMarket(let contentIdentifier, let marketId):
            return "Remove Market (Content ID: \(contentIdentifier)) - Market ID: \(marketId)"

        case .addSelection(let contentIdentifier, let selection):
            return "Add Selection (Content ID: \(contentIdentifier)) - Selection: \(selection)"
        case .removeSelection(let contentIdentifier, let selectionId):
            return "Remove Selection (Content ID: \(contentIdentifier)) - Selection ID: \(selectionId)"

        case .addSport(let contentIdentifier, let sportType):
            return "Add Sport (Content ID: \(contentIdentifier)) - Sport ID: \(sportType)"
        case .removeSport(let contentIdentifier, let sportCode):
            return "Remove Sport (Content ID: \(contentIdentifier)) - Sport Code: \(sportCode)"

        case .updateEventLiveDataExtended(let contentIdentifier, let eventId, let eventLiveDataExtended):
            return "Update Event LiveDataExtended (Content ID: \(contentIdentifier)) - Event ID: \(eventId) - LiveDataExtended: \(eventLiveDataExtended)"

        case .updateAllSportsLiveCount(let contentIdentifier, let nodeId, let eventCount):
            return "Update All Sports Live Count (Content ID: \(contentIdentifier)) - Node ID: \(nodeId) - Event Count: \(eventCount)"
        case .updateAllSportsEventCount(let contentIdentifier, let nodeId, let eventCount):
            return "Update All Sports Event Count (Content ID: \(contentIdentifier)) - Node ID: \(nodeId) - Event Count: \(eventCount)"
        case .updateEventState(let contentIdentifier, let eventId, let state):
            return "Update Event State (Content ID: \(contentIdentifier)) - Event ID: \(eventId) - State: \(state)"
        case .updateEventTime(let contentIdentifier, let eventId, let newTime):
            return "Update Event Time (Content ID: \(contentIdentifier)) - Event ID: \(eventId) - New Time: \(newTime)"
        case .updateEventScore(let contentIdentifier, let eventId, let homeScore, let awayScore):
            return "Update Event Score (Content ID: \(contentIdentifier)) - Event ID: \(eventId) - Home Score: \(String(describing: homeScore)) - Away Score: \(String(describing: awayScore))"
        case .updateActivePlayer(let contentIdentifier, let eventId, let serving):
            return "Update ActivePlayer serve (Content ID: \(contentIdentifier)) - Event ID: \(eventId) - Serve: \(serving)"
            
        case .updateEventMarketCount(let contentIdentifier, let eventId, let newMarketCount):
            return "Update Event Market Count (Content ID: \(contentIdentifier)) - Event ID: \(eventId) - New Market Count: \(newMarketCount)"

        case .updateMarketTradability(let contentIdentifier, let marketId, let isTradable):
            return "Update Market Tradability (Content ID: \(contentIdentifier)) - Market ID: \(marketId) - Tradable: \(isTradable)"

        case .updateOutcomeOdd(let contentIdentifier, let selectionId, let newOddNumerator, let newOddDenominator):
            return "Update Outcome Odd (Content ID: \(contentIdentifier)) - Selection ID: \(selectionId) - New Odd Numerator: \(String(describing: newOddNumerator)) - New Odd Denominator: \(String(describing: newOddDenominator))"
        case .updateOutcomeTradability(let contentIdentifier, let selectionId, let isTradable):
            return "Update Outcome Tradability (Content ID: \(contentIdentifier)) - Market ID: \(selectionId) - Tradable: \(isTradable)"

        case .updateEventDetailedScore(let contentIdentifier, let eventId, let detailedScore):
            return "Update Event Detailed Score (Content ID: \(contentIdentifier)) - Event ID: \(eventId) - Detailed Score: \(detailedScore)"
            
        case .unknown:
            return "Unknown ContentContainer"
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SportRadarModels+EventLiveData.swift
````swift
//
//  EventLiveDataExtended.swift
//
//
//  Created by Ruben Roques on 03/04/2024.
//

import Foundation

extension SportRadarModels {
    
    struct EventLiveDataExtended: Codable {
        var id: String
        
        var homeScore: Int?
        var awayScore: Int?
        
        var matchTime: String?
        var status: EventStatus?
        
        var scores: [String: Score]
        
        var activePlayerServing: ActivePlayerServe?
        
        enum CodingKeys: String, CodingKey {
            case targetEventId = "targetEventId"
            case attributedContainer = "attributes"
            case completeContainer = "COMPLETE"
            case currentScoreContainer = "CURRENT_SCORE"
            case competitorContainer = "COMPETITOR"
            case servingContainer = "SERVE"
            case statusContainer = "STATUS"
            case eventContainer = "EVENT"
            case emptyContainer = ""
            case matchScoreContainer = "MATCH_SCORE"
            case homeScore = "home"
            case awayScore = "away"
            case eventStatus = "status"
            case matchTime = "matchTime"
        }
        
        init(id: String,
             homeScore: Int?,
             awayScore: Int?,
             matchTime: String?,
             status: EventStatus?,
             scores: [String: Score],
             activePlayerServing: ActivePlayerServe?
        ) {
            self.id = id
            self.homeScore = homeScore
            self.awayScore = awayScore
            self.matchTime = matchTime
            self.status = status
            self.scores = scores
            self.activePlayerServing = activePlayerServing
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)
            
            self.id = (try? container.decode(String.self, forKey: .targetEventId)) ?? "NO_ID_FOUND"
            
            self.matchTime = nil
            if let fullMatchTime = try container.decodeIfPresent(String.self, forKey: .matchTime),
               let minutesPart = SocketMessageParseHelper.extractMatchMinutes(from: fullMatchTime) {
                self.matchTime = minutesPart
            }
            
            //
            // Status
            self.status = nil
            if let attributesContainer = try? container.nestedContainer(keyedBy: CodingKeys.self, forKey: .attributedContainer),
               let completeContainer = try? attributesContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .completeContainer),
               let statusContainer = try? completeContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .statusContainer),
               let eventContainer = try? statusContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .eventContainer) {
                let statusValue =  try eventContainer.decode(String.self, forKey: .emptyContainer)
                self.status = EventStatus.init(value: statusValue)
            }
            
            //
            // Scores
            self.homeScore = nil
            self.awayScore = nil
            
            self.scores = [:]
            
            //
            // Serving Player
            self.activePlayerServing = nil
            if let attributesContainer = try? container.nestedContainer(keyedBy: CodingKeys.self, forKey: .attributedContainer),
               let completeContainer = try? attributesContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .completeContainer),
               let servingContainer = try? completeContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .servingContainer),
               let eventContainer = try? servingContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .eventContainer)
            {
                if let activePlayerServingInt =  try? eventContainer.decode(Int.self, forKey: .emptyContainer) {
                    if activePlayerServingInt == 1 {
                        self.activePlayerServing = .home
                    }
                    else if activePlayerServingInt == 2 {
                        self.activePlayerServing = .away
                    }
                }
                else if let activePlayerServingString =  try? eventContainer.decode(String.self, forKey: .emptyContainer) {
                    if activePlayerServingString == "1" {
                        self.activePlayerServing = .home
                    }
                    else if activePlayerServingString == "2" {
                        self.activePlayerServing = .away
                    }
                }
                else {
                    self.activePlayerServing = nil
                }
            }
            
            
            // ----------------------------------------------------------------------------------------------------------------
            // Legacy scores
            if let attributesContainer = try? container.nestedContainer(keyedBy: CodingKeys.self, forKey: .attributedContainer),
               let completeContainer = try? attributesContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .completeContainer),
               let currentScoreContainer = try? completeContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .currentScoreContainer),
               let competitorContainer = try? currentScoreContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .competitorContainer) {
                
                if let homeScore = try? competitorContainer.decode(Int.self, forKey: .homeScore) {
                    self.homeScore = homeScore
                }
                if let awayScore = try? competitorContainer.decode(Int.self, forKey: .awayScore) {
                    self.awayScore = awayScore
                }
            }
            else if let attributesContainer = try? container.nestedContainer(keyedBy: CodingKeys.self, forKey: .attributedContainer),
                    let completeContainer = try? attributesContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .completeContainer),
                    let matchScoreContainer = try? completeContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .matchScoreContainer),
                    let competitorContainer = try? matchScoreContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .competitorContainer) {
                
                if let homeScore = try? competitorContainer.decode(Int.self, forKey: .homeScore) {
                    self.homeScore = homeScore
                }
                if let awayScore = try? competitorContainer.decode(Int.self, forKey: .awayScore) {
                    self.awayScore = awayScore
                }
            }
            // ----------------------------------------------------------------------------------------------------------------
            
            //
            // New scores logic
            let attributesContainer = try container.nestedContainer(keyedBy: CodingKeys.self, forKey: .attributedContainer)
            let completeContainer = try attributesContainer.nestedContainer(keyedBy: ScoreCodingKeys.self, forKey: .completeContainer)
            
            let scoresArray = try completeContainer.allKeys.compactMap { key -> Score? in
                let container = try completeContainer.nestedContainer(keyedBy: Score.CompetitorCodingKeys.self, forKey: key)
                return try Score(from: container, key: key)
            }
            
            self.scores = Dictionary(uniqueKeysWithValues: scoresArray.map { ($0.key, $0) })
            
            //
            if self.matchTime == nil, self.status == nil, self.homeScore == nil,
               self.awayScore == nil, self.scores.isEmpty, self.activePlayerServing == nil
            {
                let context = DecodingError.Context(codingPath: [CodingKeys.attributedContainer], debugDescription: "No parsed content found on EventLiveDataExtended")
                throw DecodingError.valueNotFound(ContentRoute.self, context)
            }
            
        }
        
        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            
            try container.encode(id, forKey: .targetEventId)
            
            var attributesContainer = container.nestedContainer(keyedBy: CodingKeys.self, forKey: .attributedContainer)
            var completeContainer = attributesContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .completeContainer)
            // var statusContainer = completeContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .statusContainer)
            // var eventContainer = statusContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .eventContainer)
            
            var currentScoreContainer = completeContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .currentScoreContainer)
            var competitorContainer = currentScoreContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .competitorContainer)
            
            try competitorContainer.encode(homeScore, forKey: .homeScore)
            try competitorContainer.encode(awayScore, forKey: .awayScore)
            
            try container.encode(matchTime, forKey: .matchTime)
        }
        
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SportRadarModels+Events.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 26/10/2022.
//

import Foundation

extension SportRadarModels {

    struct SportRadarResponse<T: Codable>: Codable {
        var data: T
        var version: Int?

        enum CodingKeys: String, CodingKey {
            case data = "data"
            case version = "value"
        }
    }


    struct EventsGroup: Codable {
        var events: [Event]
        var marketGroupId: String?

        enum CodingKeys: String, CodingKey {
            case events = "events"
            case marketGroupId = "idfwmarketgroup"
        }

        init(events: [Event], marketGroupId: String?) {
            self.events = events
            self.marketGroupId = marketGroupId
        }
    }

    struct MarketGroup: Codable {
        var markets: [Market]
        var marketGroupId: String?

        enum CodingKeys: String, CodingKey {
            case markets = "markets"
            case marketGroupId = "idfwmarketgroup"
        }

        init(events: [Market], marketGroupId: String?) {
            self.markets = events
            self.marketGroupId = marketGroupId
        }
    }
    
    enum EventStatus {
        case unknown
        case notStarted
        case inProgress(String)
        case ended

        init(value: String) {
            switch value {
            case "not_started": self = .notStarted
            case "ended": self = .ended
            default: self = .inProgress(value)
            }
        }

        var stringValue: String {
            switch self {
            case .notStarted: return "not_started"
            case .ended: return "ended"
            case .inProgress(let value): return value
            case .unknown: return ""
            }
        }
    }
    
    struct Event: Codable {
        
        var id: String
        var homeName: String?
        var awayName: String?
        var sportTypeName: String?
        var sportTypeCode: String?
        var sportIdCode: String?

        var competitionId: String?
        var competitionName: String?
        var startDate: Date?
        
        var markets: [Market]

        var tournamentCountryName: String?
        
        var numberMarkets: Int?
        var name: String?

        var homeScore: Int
        var awayScore: Int

        var matchTime: String?
        var status: EventStatus

        var scores: [String: Score]
        var activePlayerServing: ActivePlayerServe?

        var trackableReference: String?
        
        enum CodingKeys: String, CodingKey {
            case id = "idfoevent"
            case homeName = "participantname_home"
            case awayName = "participantname_away"
            case competitionId = "idfotournament"
            case competitionName = "tournamentname"
            case sportTypeName = "sporttypename"
            case startDate = "tsstart"
            case markets = "markets"
            case tournamentCountryName = "tournamentcountryname"
            case numberMarkets = "numMarkets"
            case name = "name"
            case sportTypeCode = "idfosporttype"
            case sportIdCode = "idfosport"
            case liveDataSummary = "liveDataSummary"

            case scoresContainer = "scores"
            case currentScores = "CURRENT_SCORE"
            case matchScores = "MATCH_SCORE"
            case homeScore = "home"
            case awayScore = "away"
            case eventStatus = "status"
            case matchTime = "matchTime"
            case activePlayerServing = "serve"
            
            case trackableReference = "externalreference"
        }

        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.Event.CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)
            self.id = try container.decode(String.self, forKey: .id)

            if self.id == "_TOKEN_" {
                throw DecodingError.dataCorruptedError(forKey: .id, in: container, debugDescription: "_TOKEN_ event found - Invalid Event on list ")
            }

            self.homeName = try container.decodeIfPresent(String.self, forKey: .homeName)
            self.awayName = try container.decodeIfPresent(String.self, forKey: .awayName)
            self.competitionId = try container.decodeIfPresent(String.self, forKey: .competitionId)
            self.competitionName = try container.decodeIfPresent(String.self, forKey: .competitionName)
            self.tournamentCountryName = try container.decodeIfPresent(String.self, forKey: .tournamentCountryName)

            if let markets = try container.decodeIfPresent([SportRadarModels.Market].self, forKey: .markets) {
                self.markets = markets
            }
            else if let market = try? Market(from: decoder) {
                // Check if we can parse a flatten event + market
                self.markets = [market]
            }
            else {
                self.markets = []
            }

            self.numberMarkets = container.contains(.numberMarkets) ? try container.decode(Int.self, forKey: .numberMarkets) : self.markets.first?.eventMarketCount

            self.name = try container.decodeIfPresent(String.self, forKey: .name)

            self.sportTypeName = try container.decodeIfPresent(String.self, forKey: .sportTypeName)
            self.sportTypeCode = try container.decodeIfPresent(String.self, forKey: .sportTypeCode)

            self.sportIdCode = try container.decodeIfPresent(String.self, forKey: .sportIdCode)

            self.trackableReference = try container.decodeIfPresent(String.self, forKey: .trackableReference)

            if let startDateString = try container.decodeIfPresent(String.self, forKey: .startDate) {
                if let date = Self.dateFormatter.date(from: startDateString) {
                    self.startDate = date
                }
                else if let date = Self.fallbackDateFormatter.date(from: startDateString) {
                    self.startDate = date
                }
                else {
                    let context = DecodingError.Context(codingPath: [CodingKeys.startDate], debugDescription: "Start date with wrong format.")
                    throw DecodingError.typeMismatch(Self.self, context)
                }
            }
            else {
                let context = DecodingError.Context(codingPath: [CodingKeys.startDate], debugDescription: "Not start date found.")
                throw DecodingError.valueNotFound(Self.self, context)
            }

            //
            //  ---  Live Data  ---
            //
            if let liveDataInfoContainer = try? container.nestedContainer(keyedBy: CodingKeys.self, forKey: .liveDataSummary) {

                let fullMatchTime = try liveDataInfoContainer.decodeIfPresent(String.self, forKey: .matchTime) ?? ""
                let minutesPart = SocketMessageParseHelper.extractMatchMinutes(from: fullMatchTime)
                self.matchTime = minutesPart

                // Status
                self.status = .unknown
                if let statusString = try? liveDataInfoContainer.decode(String.self, forKey: .eventStatus) {
                    self.status = EventStatus.init(value: statusString)
                }

                // ----------------------------------------------------------------------------------------------------------------
                // Legacy Scores
                self.homeScore = 0
                self.awayScore = 0

                if let scoresContainer = try? liveDataInfoContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .scoresContainer),
                    let currentScoresContainer = try? scoresContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .currentScores) {

                    if let homeScore = try? currentScoresContainer.decode(Int.self, forKey: .homeScore) {
                        self.homeScore = homeScore
                    }
                    if let awayScore = try? currentScoresContainer.decode(Int.self, forKey: .awayScore) {
                        self.awayScore = awayScore
                    }
                }
                else if let scoresContainer = try? liveDataInfoContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .scoresContainer),
                    let matchScoresContainer = try? scoresContainer.nestedContainer(keyedBy: CodingKeys.self, forKey: .matchScores) {

                    if let homeScore = try? matchScoresContainer.decode(Int.self, forKey: .homeScore) {
                        self.homeScore = homeScore
                    }
                    if let awayScore = try? matchScoresContainer.decode(Int.self, forKey: .awayScore) {
                        self.awayScore = awayScore
                    }
                }
                // ----------------------------------------------------------------------------------------------------------------
                
                
                //
                // New scores business logic
                self.scores = [:]
                
                let completeContainer = try liveDataInfoContainer.nestedContainer(keyedBy: ScoreCodingKeys.self, forKey: .scoresContainer)
                
                let scoresArray = try completeContainer.allKeys.compactMap { key -> Score? in
                    let container = try completeContainer.nestedContainer(keyedBy: Score.CompetitorCodingKeys.self, forKey: key)
                    return try Score(from: container, key: key)
                }
                self.scores = Dictionary(uniqueKeysWithValues: scoresArray.map { ($0.key, $0) })
                //
                
                //
                // Serving player
                if let activePlayerServingString = try? liveDataInfoContainer.decodeIfPresent(String.self, forKey: .activePlayerServing) {
                   if activePlayerServingString == "1" {
                       self.activePlayerServing = .home
                   }
                   else if activePlayerServingString == "2" {
                       self.activePlayerServing = .away
                   }
               }
                else if let activePlayerServingInt = try? liveDataInfoContainer.decodeIfPresent(Int.self, forKey: .activePlayerServing) {
                    if activePlayerServingInt == 1 {
                        self.activePlayerServing = .home
                    }
                    else if activePlayerServingInt == 2 {
                        self.activePlayerServing = .away
                    }
                }
                
            }
            else {
                // No live information
                self.status = .unknown
                self.homeScore = 0
                self.awayScore = 0
                
                self.scores = [:]
                self.activePlayerServing = nil
            }
        }

        func encode(to encoder: Encoder) throws {

        }

        static var dateFormatter: DateFormatter {
            let formatter = DateFormatter()
            formatter.dateFormat =  "yyyy-MM-dd'T'HH:mm:ss.SSSZ"
            return formatter
        }
        
        static var fallbackDateFormatter: DateFormatter {
            let formatter = DateFormatter()
            formatter.dateFormat =  "yyyy-MM-dd'T'HH:mm:ssZ"
            return formatter
        }
    }
    
    struct Market: Codable {
        
        enum OutcomesOrder: Codable {
            case none
            case odds // by odd
            case name // by name
            case setup // The original order that the server sends us
        }
        
        var id: String
        var name: String
        var outcomes: [Outcome]
        var marketTypeId: String?
        var eventMarketTypeId: String?
        var marketTypeCategoryId: String?
        var marketFilterId: String?
        
        var eventName: String?
        var isMainOutright: Bool?
        var eventMarketCount: Int?
        var isTradable: Bool
        var startDate: Date?
        var homeParticipant: String?
        var awayParticipant: String?
        var eventId: String?

        var isOverUnder: Bool
        var marketDigitLine: String?
        var outcomesOrder: OutcomesOrder
    
        var competitionId: String?
        var competitionName: String?
        var sportTypeName: String?
        var sportTypeCode: String?
        var sportIdCode: String?
        var tournamentCountryName: String?
        
        var customBetAvailable: Bool?
        var isMainMarket: Bool

        enum CodingKeys: String, CodingKey {
            case id = "idfomarket"
            case name = "name"
            case outcomes = "selections"
            case marketTypeId = "idefmarkettype"
            case eventMarketTypeId = "idfomarkettype"
            case marketTypeCategoryId = "idfomarkettypecategory"
            case marketFilterId = "marketFilterId"
            
            case isMainOutright = "ismainoutright"
            case eventMarketCount = "eventMarketCount"
            case isTradable = "istradable"
            case startDate = "tsstart"
            case homeParticipant = "participantname_home"
            case awayParticipant = "participantname_away"
            
            case isOverUnder = "isunderover"
            case marketDigitLine = "line"
            case outcomesOrder = "idfoselectionorder"
            case customBetAvailable = "custombetavailable"
       
            case eventId = "idfoevent"
            case eventName = "eventname"
            case competitionId = "idfotournament"
            case competitionName = "tournamentname"
            case tournamentCountryName = "tournamentcountryname"
            case sportTypeName = "sportname"
            case sportTypeCode = "idfosporttype"
            case sportIdCode = "idfosport"

            case isMainMarket = "isMainMarket"
        }

        init(id: String,
             name: String,
             outcomes: [Outcome],
             marketTypeId: String? = nil,
             eventMarketTypeId: String? = nil,
             marketTypeCategoryId: String? = nil,
             marketFilterId: String? = nil,
             
             eventName: String? = nil,
             isMainOutright: Bool? = nil,
             eventMarketCount: Int? = nil,
             isTradable: Bool,
             startDate: Date? = nil,
             homeParticipant: String? = nil,
             awayParticipant: String? = nil,
             eventId: String? = nil,
             isOverUnder: Bool = false,
             marketDigitLine: String?,
             outcomesOrder: OutcomesOrder,
             //
             competitionId: String? = nil,
             competitionName: String? = nil,
             sportTypeName: String? = nil,
             sportTypeCode: String? = nil,
             sportIdCode: String? = nil,
             tournamentCountryName: String? = nil,

             customBetAvailable: Bool?,
             isMainMarket: Bool
        ) {
            self.id = id
            self.name = name
            self.outcomes = outcomes
            self.marketTypeId = marketTypeId
            self.eventMarketTypeId = eventMarketTypeId
            self.marketTypeCategoryId = marketTypeCategoryId
            self.marketFilterId = marketFilterId
            
            self.eventName = eventName
            self.isMainOutright = isMainOutright
            self.eventMarketCount = eventMarketCount
            self.isTradable = isTradable
            self.startDate = startDate
            self.homeParticipant = homeParticipant
            self.awayParticipant = awayParticipant
            self.eventId = eventId
            self.isOverUnder = isOverUnder
            self.marketDigitLine = marketDigitLine
            self.outcomesOrder = outcomesOrder
            //
            self.competitionId = competitionId
            self.competitionName = competitionName
            self.sportTypeName = sportTypeName
            self.sportTypeCode = sportTypeCode
            self.sportIdCode = sportIdCode
            self.tournamentCountryName = tournamentCountryName
            
            self.customBetAvailable = customBetAvailable
            self.isMainMarket = isMainMarket
        }

        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: SportRadarModels.Market.CodingKeys.self)
            self.id = try container.decode(String.self, forKey: .id)
           
            var nameValue = try container.decode(String.self, forKey: .name)
            nameValue = nameValue.replacingOccurrences(of: "\n", with: "")
            nameValue = nameValue.replacingOccurrences(of: "\r", with: "")
            self.name = nameValue
            
            self.marketTypeId = try container.decodeIfPresent(String.self, forKey: .marketTypeId)
            
            // a marketTypeId with fallback if empty / used to group markets in filters/tabs
            self.marketFilterId = try container.decodeIfPresent(String.self, forKey: .marketTypeId)
            
            self.eventMarketTypeId = try container.decodeIfPresent(String.self, forKey: .eventMarketTypeId)
            self.marketTypeCategoryId = try container.decodeIfPresent(String.self, forKey: .marketTypeCategoryId)

            
            // Fallback to marketTypeCategoryId if marketTypeId is empty
            if self.marketFilterId == nil && self.marketTypeCategoryId != nil {
                self.marketFilterId = self.marketTypeCategoryId
            }

            self.eventName = try container.decodeIfPresent(String.self, forKey: .eventName)
            self.isMainOutright = try container.decodeIfPresent(Bool.self, forKey: .isMainOutright)
            self.eventMarketCount = try container.decodeIfPresent(Int.self, forKey: .eventMarketCount)
            self.isTradable = try container.decodeIfPresent(Bool.self, forKey: .isTradable) ?? true
            self.outcomes = try container.decode([SportRadarModels.Outcome].self, forKey: .outcomes)
            
            self.homeParticipant = try container.decodeIfPresent(String.self, forKey: .homeParticipant)
            self.awayParticipant = try container.decodeIfPresent(String.self, forKey: .awayParticipant)
            self.eventId = try container.decodeIfPresent(String.self, forKey: .eventId)
            
            self.isMainMarket = false

            if let startDateString = try container.decodeIfPresent(String.self, forKey: .startDate) {
                if let date = Event.dateFormatter.date(from: startDateString) {
                    self.startDate = date
                }
                else if let date = Event.fallbackDateFormatter.date(from: startDateString) {
                    self.startDate = date
                }
                else {
                    self.startDate = nil
                }
            }
            else {
                self.startDate = nil
            }
            
            self.marketDigitLine = nil
            if let marketDigitLineString = try? container.decodeIfPresent(String.self, forKey: .marketDigitLine) {
                self.marketDigitLine = marketDigitLineString
            }
            else if let marketDigitLineDouble = try? container.decodeIfPresent(Double.self, forKey: .marketDigitLine) {
                self.marketDigitLine = String(marketDigitLineDouble)
            }
            
            self.outcomesOrder = .none
            if let outcomesOrderString = (try container.decodeIfPresent(String.self, forKey: .outcomesOrder)) {
                self.isOverUnder = false
                
                switch outcomesOrderString.lowercased() {
                case "odds":
                    self.outcomesOrder = .odds
                case "name":
                    self.outcomesOrder = .name
                case "setup":
                    self.outcomesOrder = .setup
                default:
                    self.outcomesOrder = .none
                }
            }
            
            self.isOverUnder = (try container.decodeIfPresent(Bool.self, forKey: .isOverUnder)) ?? false
            if self.isOverUnder {
                for index in self.outcomes.indices {
                    if (self.outcomes[index].orderValue ?? "").lowercased() == "h" {
                        self.outcomes[index].orderValue = "a"
                    }
                    else if (self.outcomes[index].orderValue ?? "").lowercased() == "a" {
                        self.outcomes[index].orderValue = "h"
                    }
                }
                self.outcomes = self.outcomes.reversed()
            }
            
            self.customBetAvailable = try container.decodeIfPresent(Bool.self, forKey: .customBetAvailable)

            self.competitionId = try container.decodeIfPresent(String.self, forKey: .competitionId)
            self.competitionName = try container.decodeIfPresent(String.self, forKey: .competitionName)
            
            self.sportTypeName = try container.decodeIfPresent(String.self, forKey: .sportTypeName)
            self.sportTypeCode = try container.decodeIfPresent(String.self, forKey: .sportTypeCode)
            self.sportIdCode = try container.decodeIfPresent(String.self, forKey: .sportIdCode)
            self.tournamentCountryName = try container.decodeIfPresent(String.self, forKey: .tournamentCountryName)

            //Apply custom bet available from market to outcome
            if let customBetAvailable {
                for index in self.outcomes.indices {
                    self.outcomes[index].customBetAvailableMarket = customBetAvailable
                }
            }
        }
        
        func encode(to encoder: Encoder) throws {
            //
        }
        
    }
    
    struct Outcome: Codable {
        
        var id: String
        var name: String
        var hashCode: String
        var marketId: String?
        var orderValue: String?
        var externalReference: String?

        var odd: OddFormat
        
        private var priceNumerator: String?
        private var priceDenominator: String?

        var isTradable: Bool?
        var isTerminated: Bool?
        
        var isOverUnder: Bool

        var customBetAvailableMarket: Bool?
        
        enum CodingKeys: String, CodingKey {
            case id = "idfoselection"
            case name = "name"
            case hashCode = "selectionhashcode"
            case priceNumerator = "currentpriceup"
            case priceDenominator = "currentpricedown"
            case marketId = "idfomarket"
            case orderValue = "hadvalue"
            case externalReference = "externalreference"
            case isTradable = "istradable"
            case isOverUnder = "isunderover"
            case customBetAvailableMarket = "customBetAvailableMarket"
            case suspensiontype = "idfoselectionsuspensiontype"
        }

        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.Outcome.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.Outcome.CodingKeys.self)
            self.id = try container.decode(String.self, forKey: SportRadarModels.Outcome.CodingKeys.id)
            self.name = try container.decode(String.self, forKey: SportRadarModels.Outcome.CodingKeys.name)
            self.hashCode = try container.decode(String.self, forKey: SportRadarModels.Outcome.CodingKeys.hashCode)
            self.priceNumerator = try container.decodeIfPresent(String.self, forKey: SportRadarModels.Outcome.CodingKeys.priceNumerator)
            self.priceDenominator = try container.decodeIfPresent(String.self, forKey: SportRadarModels.Outcome.CodingKeys.priceDenominator)
            self.marketId = try container.decodeIfPresent(String.self, forKey: SportRadarModels.Outcome.CodingKeys.marketId)
            self.orderValue = try container.decodeIfPresent(String.self, forKey: SportRadarModels.Outcome.CodingKeys.orderValue)
            self.externalReference = try container.decodeIfPresent(String.self, forKey: SportRadarModels.Outcome.CodingKeys.externalReference)

            let numerator = Double(self.priceNumerator ?? "0.0") ?? 1.0
            let denominator = Double(self.priceDenominator ?? "0.0") ?? 1.0

            self.odd = .fraction(numerator: Int(numerator), denominator: Int(denominator) )
            self.isTradable = (try? container.decode(Bool.self, forKey: .isTradable)) ?? true

            self.isOverUnder = (try container.decodeIfPresent(Bool.self, forKey: SportRadarModels.Outcome.CodingKeys.isOverUnder)) ?? false
            if self.isOverUnder {
                if (self.orderValue ?? "").lowercased() == "h" {
                    self.orderValue = "a"
                }
                else if (self.orderValue ?? "").lowercased() == "a" {
                    self.orderValue = "h"
                }
            }
            
            self.customBetAvailableMarket = nil
            self.isTerminated = false
            
            let suspensiontype: String = (try? container.decode(String.self, forKey: SportRadarModels.Outcome.CodingKeys.suspensiontype)) ?? ""
            if suspensiontype.lowercased() == "n/o" {
                self.isTradable = false
                self.isTerminated = true
            }
        }

        func encode(to encoder: any Encoder) throws {
            
        }

    }

    struct SportNodeInfo: Codable {
        var id: String
        var regionNodes: [SportRegion]
        var navigationTypes: [String]?
        var name: String?
        var defaultOrder: Int?
        var numMarkets: String?
        var numEvents: String?
        var numOutrightMarkets: String?
        var numOutrightEvents: String?

        enum CodingKeys: String, CodingKey {
            case id = "idfwbonavigation"
            case regionNodes = "bonavigationnodes"
            case navigationTypes = "idfwbonavigationtypes"
            case name = "name"
            case defaultOrder = "defaultOrder"
            case numMarkets = "nummarkets"
            case numEvents = "numevents"
            case numOutrightMarkets = "numoutrightmarkets"
            case numOutrightEvents = "numoutrightevents"
        }
    }

    struct SportRegion: Codable {
        var id: String
        var name: String?
        var numberEvents: String
        var numberOutrightEvents: String

        enum CodingKeys: String, CodingKey {
            case id = "idfwbonavigation"
            case name = "name"
            case numberEvents = "numevents"
            case numberOutrightEvents = "numoutrightevents"
        }
    }

    struct SportRegionInfo: Codable {
        var id: String
        var name: String
        var competitionNodes: [SportCompetition]

        enum CodingKeys: String, CodingKey {
            case id = "idfwbonavigation"
            case name = "name"
            case competitionNodes = "bonavigationnodes"
        }
    }

    struct SportCompetition: Codable {
        var id: String
        var name: String
        var numberEvents: String
        var numberOutrightEvents: String

        enum CodingKeys: String, CodingKey {
            case id = "idfwbonavigation"
            case name = "name"
            case numberEvents = "numevents"
            case numberOutrightEvents = "numoutrightevents"
        }
        
    }

    struct SportCompetitionInfo: Codable {

        var id: String
        var name: String
        var marketGroups: [SportCompetitionMarketGroup]
        var numberOutrightEvents: String
        var numberOutrightMarkets: String
        var parentId: String?

        enum CodingKeys: String, CodingKey {
            case id = "idfwbonavigation"
            case name = "name"
            case marketGroups = "marketgroups"
            case numberOutrightEvents = "numoutrightevents"
            case numberOutrightMarkets = "numoutrightmarkets"
            case parentId = "idfwbonavigation_parent"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.SportCompetitionInfo.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.SportCompetitionInfo.CodingKeys.self)
            self.id = try container.decode(String.self, forKey: SportRadarModels.SportCompetitionInfo.CodingKeys.id)
            self.name = try container.decode(String.self, forKey: SportRadarModels.SportCompetitionInfo.CodingKeys.name)
            self.marketGroups = try container.decode([SportRadarModels.SportCompetitionMarketGroup].self, forKey: SportRadarModels.SportCompetitionInfo.CodingKeys.marketGroups)
            self.numberOutrightEvents = try container.decode(String.self, forKey: SportRadarModels.SportCompetitionInfo.CodingKeys.numberOutrightEvents)
            self.numberOutrightMarkets = try container.decode(String.self, forKey: SportRadarModels.SportCompetitionInfo.CodingKeys.numberOutrightMarkets)
            self.parentId = try container.decodeIfPresent(String.self, forKey: SportRadarModels.SportCompetitionInfo.CodingKeys.parentId)
        }
    }

    struct SportCompetitionMarketGroup: Codable {
        var id: String
        var name: String

        enum CodingKeys: String, CodingKey {
            case id = "idfwmarketgroup"
            case name = "name"
        }
    }

    struct CompetitionMarketGroup: Codable {
        var id: String
        var name: String
        var events: [Event]

        enum CodingKeys: String, CodingKey {
            case id = "idfwmarketgroup"
            case name = "name"
            case events = "events"
        }
    }

    struct CompetitionParentNode: Codable {
        var id: String
        var name: String
        var categoryName: String

        enum CodingKeys: String, CodingKey {
            case id = "idfwbonavigation"
            case name = "name"
            case categoryName = "contentcategoryname"
        }
    }

    // Banners
    struct BannerResponse: Codable {
        var bannerItems: [Banner]

        enum CodingKeys: String, CodingKey {
            case bannerItems = "headlineItems"
        }
    }

    struct Banner: Codable {
        var id: String
        var name: String
        var title: String
        var imageUrl: String
        var bodyText: String?
        var type: String
        var linkUrl: String?
        var marketId: String?

        enum CodingKeys: String, CodingKey {
            case id = "idfwheadline"
            case name = "name"
            case title = "title"
            case imageUrl = "imageurl"
            case bodyText = "bodytext"
            case type = "idfwheadlinetype"
            case linkUrl = "linkurl"
            case marketId = "idfomarket"
        }
    }

    // Favorites
    struct FavoritesListResponse: Codable {
        var favoritesList: [FavoriteList]

        enum CodingKeys: String, CodingKey {
            case favoritesList = "accountFavouriteCoupons"
        }
    }

    struct FavoriteList: Codable {
        var id: Int
        var name: String
        var customerId: Int

        enum CodingKeys: String, CodingKey {
            case id = "idfwAccountFavouriteCoupon"
            case name = "name"
            case customerId = "idmmCustomer"
        }
    }

    struct FavoritesListAddResponse: Codable {
        var listId: Int

        enum CodingKeys: String, CodingKey {
            case listId = "addAccountFavouriteCouponResult"
        }
    }

    struct FavoritesListDeleteResponse: Codable {
        var listId: String?

        enum CodingKeys: String, CodingKey {
            case listId = "addAccountFavouriteCouponResult"
        }
    }

    struct FavoriteAddResponse: Codable {
        var displayOrder: Int?
        var idAccountFavorite: Int?

        enum CodingKeys: String, CodingKey {
            case displayOrder = "displayOrder"
            case idAccountFavorite = "idAccountFavourite"
        }
    }

    struct FavoriteEventResponse: Codable {
        var favoriteEvents: [FavoriteEvent]

        enum CodingKeys: String, CodingKey {
            case favoriteEvents = "accountFavourites"
        }
    }

    struct FavoriteEvent: Codable {
        var id: String
        var name: String
        var favoriteListId: Int
        var accountFavoriteId: Int

        enum CodingKeys: String, CodingKey {
            case id = "favouriteId"
            case name = "favouriteName"
            case favoriteListId = "idfwAccountFavouriteCoupon"
            case accountFavoriteId = "idfwAccountFavourites"
        }

    }
    
    struct HighlightedEventPointer : Codable {
        var status: String
        var sportId: String
        var eventId: String
        var eventType: String?
        var countryId: String

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case sportId = "sport_id"
            case eventId = "orako_event_id"
            case eventType = "event_type"
            case countryId = "country_id"
        }
        
        init(status: String, sportId: String, eventId: String, eventType: String? = nil, countryId: String) {
            self.status = status
            self.sportId = sportId
            self.eventId = eventId
            self.eventType = eventType
            self.countryId = countryId
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.HighlightedEventPointer.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.HighlightedEventPointer.CodingKeys.self)
            self.status = try container.decode(String.self, forKey: SportRadarModels.HighlightedEventPointer.CodingKeys.status)
            self.sportId = try container.decode(String.self, forKey: SportRadarModels.HighlightedEventPointer.CodingKeys.sportId)
            self.eventId = try container.decode(String.self, forKey: SportRadarModels.HighlightedEventPointer.CodingKeys.eventId)
            self.eventType = try container.decodeIfPresent(String.self, forKey: SportRadarModels.HighlightedEventPointer.CodingKeys.eventType)
            self.countryId = try container.decode(String.self, forKey: SportRadarModels.HighlightedEventPointer.CodingKeys.countryId)
        }
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SportRadarModels+PromotedBetslips.swift
````swift
//
//  PromotedBetslipsResponse.swift
//
//
//  Created by Ruben Roques on 01/08/2024.
//

import Foundation

extension SportRadarModels {
    
    struct PromotedBetslipsBatchResponse: Codable {
        var promotedBetslips: [PromotedBetslip]
        var status: String
        
        enum CodingKeys: String, CodingKey {
            case data
            case status
        }
        
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            self.status = try container.decode(String.self, forKey: .status)
            
            let batchData = try container.decode(VaixBatchData.self, forKey: .data)
            self.promotedBetslips = batchData.promotedBetslips
        }
        
        func encode(to encoder: Encoder) throws {
            // Note: This encoding method doesn't preserve the original structure.
            // If you need to encode back to the original format, you'll need a more complex encoding method.
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(status, forKey: .status)
        }
    }
    
    private struct PromotedBetslipsInternalRequest: Codable {
        var body: VaixBatchBody
        var name: String
        var statusCode: Int
        
        enum CodingKeys: String, CodingKey {
            case body = "body"
            case name = "name"
            case statusCode = "status_code"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.PromotedBetslipsInternalRequest.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.PromotedBetslipsInternalRequest.CodingKeys.self)
            self.body = try container.decode(SportRadarModels.VaixBatchBody.self, forKey: SportRadarModels.PromotedBetslipsInternalRequest.CodingKeys.body)
            self.name = try container.decode(String.self, forKey: SportRadarModels.PromotedBetslipsInternalRequest.CodingKeys.name)
            self.statusCode = try container.decode(Int.self, forKey: SportRadarModels.PromotedBetslipsInternalRequest.CodingKeys.statusCode)
        }
    }
    
    private struct VaixBatchBody: Codable {
        var data: VaixBatchData
        var status: String
        
        enum CodingKeys: String, CodingKey {
            case data = "data"
            case status = "status"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.VaixBatchBody.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.VaixBatchBody.CodingKeys.self)
            self.data = try container.decode(SportRadarModels.VaixBatchData.self, forKey: SportRadarModels.VaixBatchBody.CodingKeys.data)
            self.status = try container.decode(String.self, forKey: SportRadarModels.VaixBatchBody.CodingKeys.status)
        }
    }
    
    private struct VaixBatchData: Codable {
        var promotedBetslips: [PromotedBetslip]
        var count: Int
        
        enum CodingKeys: String, CodingKey {
            case promotedBetslips = "betslips"
            case count = "count"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.VaixBatchData.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.VaixBatchData.CodingKeys.self)
            self.promotedBetslips = try container.decode([SportRadarModels.PromotedBetslip].self, forKey: SportRadarModels.VaixBatchData.CodingKeys.promotedBetslips)
            self.count = try container.decode(Int.self, forKey: SportRadarModels.VaixBatchData.CodingKeys.count)
        }
    }
    
    struct PromotedBetslip: Codable {
        var selections: [PromotedBetslipSelection]
        var betslipCount: Int
        
        enum CodingKeys: String, CodingKey {
            case selections = "betslip"
            case betslipCount = "betslip_count"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.PromotedBetslip.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.PromotedBetslip.CodingKeys.self)
            self.selections = try container.decode([SportRadarModels.PromotedBetslipSelection].self, forKey: SportRadarModels.PromotedBetslip.CodingKeys.selections)
            self.betslipCount = try container.decode(Int.self, forKey: SportRadarModels.PromotedBetslip.CodingKeys.betslipCount)
        }
    }
    
    struct PromotedBetslipSelection: Codable {
        var id: String?
        var beginDate: String?
        var betOfferId: Int?
        var country: String?
        var countryId: String?
        var eventId: String?
        var eventType: String?
        var league: String?
        var leagueId: String?
        var market: String?
        var marketId: Int?
        var marketType: String?
        var marketTypeId: Int?
        var orakoEventId: String
        var orakoMarketId: String
        var orakoSelectionId: String
        var outcomeType: String?
        var outcomeId: Int?
        var participantIds: [String]?
        var participants: [String]?
        var period: String?
        var periodId: Int?
        var quote: Double?
        var quoteGroup: String?
        var sport: String?
        var sportId: String?
        var status: String?

        enum CodingKeys: String, CodingKey {
            case id = "selection_id"
            case beginDate = "begin"
            case betOfferId = "bet_offer_id"
            case country = "country"
            case countryId = "country_id"
            case eventId = "event_id"
            case eventType = "event_type"
            case league = "league"
            case leagueId = "league_id"
            case market = "market"
            case marketId = "market_id"
            case marketType = "market_type"
            case marketTypeId = "market_type_id"
            case orakoEventId = "orako_event_id"
            case orakoMarketId = "orako_market_id"
            case orakoSelectionId = "orako_selection_id"
            case outcomeType = "outcome"
            case outcomeId = "outcome_id"
            case participantIds = "participant_ids"
            case participants = "participants"
            case period = "period"
            case periodId = "period_id"
            case quote = "quote"
            case quoteGroup = "quote_group"
            case sport = "sport"
            case sportId = "sport_id"
            case status = "status"
        }
        
        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.PromotedBetslipSelection.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.PromotedBetslipSelection.CodingKeys.self)

            // Required props
            self.orakoEventId = try container.decode(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.orakoEventId)
            self.orakoMarketId = try container.decode(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.orakoMarketId)
            self.orakoSelectionId = try container.decode(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.orakoSelectionId)

            // Optional props
            self.id = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.id)
            self.quote = try container.decodeIfPresent(Double.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.quote)
            self.beginDate = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.beginDate)
            self.league = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.league)
            self.marketType = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.marketType)
            self.participantIds = try container.decodeIfPresent([String].self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.participantIds)
            self.participants = try container.decodeIfPresent([String].self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.participants)
            self.sport = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.sport)
            self.sportId = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.sportId)
            self.status = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.status)
            self.outcomeType = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.outcomeType)

            self.betOfferId = try container.decodeIfPresent(Int.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.betOfferId)
            self.country = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.country)
            self.countryId = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.countryId)
            self.eventId = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.eventId)
            self.eventType = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.eventType)
            self.leagueId = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.leagueId)
            self.market = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.market)
            self.marketId = try container.decodeIfPresent(Int.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.marketId)
            self.marketTypeId = try container.decodeIfPresent(Int.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.marketTypeId)
            self.outcomeId = try container.decodeIfPresent(Int.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.outcomeId)
            self.period = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.period)
            self.periodId = try container.decodeIfPresent(Int.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.periodId)
            self.quoteGroup = try container.decodeIfPresent(String.self, forKey: SportRadarModels.PromotedBetslipSelection.CodingKeys.quoteGroup)

        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SportRadarModels+Scores.swift
````swift
//
//  Score.swift
//
//
//  Created by Ruben Roques on 03/04/2024.
//

import Foundation

extension SportRadarModels {
    
    enum Score: Codable, Hashable {
        case set(index: Int, home: Int?, away: Int?)
        case gamePart(home: Int?, away: Int?)
        case matchFull(home: Int?, away: Int?)
        
        enum CompetitorCodingKeys: String, CodingKey {
            case competitor = "COMPETITOR"
            case home
            case away
        }
        
        init?(stringValue: String, homeScore: Int?, awayScore: Int?) {
            guard
                let scoreCodingKeys = ScoreCodingKeys(stringValue: stringValue)
            else {
                return nil
            }
            
            switch scoreCodingKeys {
            case .gameScore:
                self = .gamePart(home: homeScore, away: awayScore)
            case .currentScore:
                self = .matchFull(home: homeScore, away: awayScore)
            case .matchScore:
                self = .matchFull(home: homeScore, away: awayScore)
            case .periodScore(let index):
                self = .set(index: index, home: homeScore, away: awayScore)
            case .setScore(let index):
                self = .set(index: index, home: homeScore, away: awayScore)
            case .frameScore(let index):
                self = .set(index: index, home: homeScore, away: awayScore)
            }
        }
        
        init(from container: KeyedDecodingContainer<CompetitorCodingKeys>, key: ScoreCodingKeys) throws {
            let homeScoreValue: Int
            let awayScoreValue: Int
            
            if let competitorContainer = try? container.nestedContainer(keyedBy: CompetitorCodingKeys.self, forKey: .competitor) {
                homeScoreValue = try competitorContainer.decode(Int.self, forKey: .home)
                awayScoreValue = try competitorContainer.decode(Int.self, forKey: .away)
            }
            else {
                homeScoreValue = try container.decode(Int.self, forKey: .home)
                awayScoreValue = try container.decode(Int.self, forKey: .away)
            }
            
            switch key {
            case .matchScore, .currentScore:
                self = .matchFull(home: homeScoreValue, away: awayScoreValue)
            case .gameScore:
                self = .gamePart(home: homeScoreValue, away: awayScoreValue)
            case .periodScore(let index), .setScore(let index), .frameScore(let index):
                self = .set(index: index, home: homeScoreValue, away: awayScoreValue)
            }
        }
        
        var sortValue: Int {
            switch self {
            case .set(let index, _, _):
                return index
            case .gamePart:
                return 100
            case .matchFull:
                return 200
            }
        }
        
        var key: String {
            switch self {
            case .set(let index, _, _):
                return "set\(index)"
            case .gamePart:
                return "gamePart"
            case .matchFull:
                return "matchFull"
            }
        }
        
    }
    
    
    enum ScoreCodingKeys: CodingKey {
        case gameScore
        case currentScore
        case matchScore
        case periodScore(Int)
        case setScore(Int)
        case frameScore(Int)
        
        init?(stringValue: String) {
            switch stringValue {
            case "GAME_SCORE":
                self = .gameScore
            case "CURRENT_SCORE":
                self = .currentScore
            case "MATCH_SCORE":
                self = .matchScore
            default:
                if let number = Self.extractNumber(from: stringValue, pattern: "PERIOD(\\d+)_SCORE") {
                    self = .periodScore(number)
                } else if let number = Self.extractNumber(from: stringValue, pattern: "SET(\\d+)_SCORE") {
                    self = .setScore(number)
                } else if let number = Self.extractNumber(from: stringValue, pattern: "FRAME(\\d+)_SCORE") {
                    self = .frameScore(number)
                } else {
                    return nil
                }
            }
        }
        
        init?(intValue: Int) {
            return nil
        }
        
        var stringValue: String {
            switch self {
            case .gameScore:
                return "GAME_SCORE"
            case .currentScore:
                return "CURRENT_SCORE"
            case .matchScore:
                return "MATCH_SCORE"
            case .periodScore(let number):
                return "PERIOD\(number)_SCORE"
            case .setScore(let number):
                return "SET\(number)_SCORE"
            case .frameScore(let number):
                return "FRAME\(number)_SCORE"
            }
        }
        
        var intValue: Int? {
            switch self {
            case .periodScore(let number), .setScore(let number), .frameScore(let number):
                return number
            default:
                return nil
            }
        }
        
        private static func extractNumber(from string: String, pattern: String) -> Int? {
            guard let regex = try? NSRegularExpression(pattern: pattern, options: []) else {
                return nil
            }
            let matches = regex.matches(in: string, options: [], range: NSRange(location: 0, length: string.utf16.count))
            guard let match = matches.first else {
                return nil
            }
            let range = match.range(at: 1)
            guard let swiftRange = Range(range, in: string) else {
                return nil
            }
            return Int(string[swiftRange])
        }
    }
}


extension SportRadarModels {
    enum ActivePlayerServe: String, Codable {
        case home
        case away
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SportRadarModels+SocketContent.swift
````swift
//
//  SportRadarModels.swift
//  
//
//  Created by Ruben Roques on 05/10/2022.
//

import Foundation

enum SportRadarModels {
    
}


extension SportRadarModels {
    
    enum NotificationType: Codable {
        
        case listeningStarted(sessionTokenId: String)
        case contentChanges(contents: [ContentContainer])
        case subscriberIdNotFoundError(oldId: String?)
        case genericError
        case unknown

        enum CodingKeys: String, CodingKey {
            case notificationType = "notificationType"
            case errorType = "errorType"
            case data = "data"
        }
        
        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            
            if let errorMessage: String = try? container.decode(String.self, forKey: .errorType) {
                if  errorMessage.lowercased() == "subscriber_not_found" {
                    let oldId: String? = (try? container.decode([String].self, forKey: .data))?.first
                    self = .subscriberIdNotFoundError(oldId: oldId)
                }
                else {
                    self = .genericError
                }
            }
            else if let typeString = try? container.decode(String.self, forKey: .notificationType) {
                switch typeString {
                case "LISTENING_STARTED":
                    let sessionTokenId = try container.decode(String.self, forKey: .data)
                    self = .listeningStarted(sessionTokenId: sessionTokenId)
                case "CONTENT_CHANGES":
                    let contents = try container.decode([FailableDecodable<SportRadarModels.ContentContainer>].self, forKey: .data)
                    let validContents = contents.compactMap({ $0.content })
                    self = .contentChanges(contents: validContents)
                default:
                    self = .unknown
                }
            }
            else {
                self = .unknown
            }
        }
        
        func encode(to encoder: Encoder) throws {
            
        }

    }

}



extension SportRadarModels {

    struct RestResponse<T: Codable>: Codable {
        let data: T?
        enum CodingKeys: String, CodingKey {
            case data = "data"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SportRadarModels+Sports.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 26/10/2022.
//

import Foundation

extension SportRadarModels {

    struct SportType: Codable, Hashable {
        var name: String
        var numericId: String?
        var alphaId: String?
        var numberEvents: Int
        var numberOutrightEvents: Int
        var numberOutrightMarkets: Int
        var numberLiveEvents: Int

        init(name: String,
                    numericId: String? = nil,
                    alphaId: String? = nil,
                    numberEvents: Int,
                    numberOutrightEvents: Int,
                    numberOutrightMarkets: Int,
             numberLiveEvents: Int) {

            self.name = name
            self.numericId = numericId
            self.alphaId = alphaId
            self.numberEvents = numberEvents
            self.numberOutrightEvents = numberOutrightEvents
            self.numberOutrightMarkets = numberOutrightMarkets
            self.numberLiveEvents = numberLiveEvents
        }
    }

    struct LiveSportTypeDetails: Codable {
        var sportType: SportType
        var eventsCount: Int
        var sportName: String

        enum CodingKeys: String, CodingKey {
            case sportType = "idfosporttype"
            case eventsCount = "numEvents"
            case sportName = "sporttypename"
        }

        init(sportType: SportType, eventsCount: Int, sportName: String) {
            self.sportType = sportType
            self.eventsCount = eventsCount
            self.sportName = sportName
        }

        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            let sportTypeIdString = try container.decode(String.self, forKey: .sportType)
            let sportTypeName = try container.decode(String.self, forKey: .sportName)
            let eventsCount = try container.decode(Int.self, forKey: .eventsCount)
            
            self.sportType = SportType(name: sportTypeName,
                                       numericId: nil,
                                       alphaId: sportTypeIdString,
                                       numberEvents: eventsCount,
                                       numberOutrightEvents: 0,
                                       numberOutrightMarkets: 0,
                                       numberLiveEvents: eventsCount)

            self.eventsCount = eventsCount
            self.sportName = sportTypeName
        }

        func encode(to encoder: Encoder) throws {
            var container = encoder.container(keyedBy: CodingKeys.self)
            try container.encode(self.sportType, forKey: .sportType)
            try container.encode(self.eventsCount, forKey: .eventsCount)
            try container.encode(self.sportName, forKey: .sportName)
        }

    }

    struct SportsList: Codable {
        var sportNodes: [SportNode]?

        enum CodingKeys: String, CodingKey {
            case sportNodes = "bonavigationnodes"
        }
    }

    struct SportNode: Codable {
        var id: String
        var name: String
        var numberEvents: Int
        var numberOutrightEvents: Int
        var numberOutrightMarkets: Int
        var numberLiveEvents: Int
        var alphaCode: String

        enum CodingKeys: String, CodingKey {
            case id = "idfwbonavigation"
            case name = "name"
            case numberEvents = "numevents"
            case numberOutrightEvents = "numoutrightevents"
            case numberOutrightMarkets = "numoutrightmarkets"
            case numberLiveEvents = "numinplayevents"
            case alphaCode = "focontentid"
        }

        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.SportNode.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.SportNode.CodingKeys.self)
            self.id = try container.decode(String.self, forKey: SportRadarModels.SportNode.CodingKeys.id)
            self.name = try container.decode(String.self, forKey: SportRadarModels.SportNode.CodingKeys.name)
            self.numberEvents = Int((try? container.decode(String.self, forKey: SportRadarModels.SportNode.CodingKeys.numberEvents)) ?? "0") ?? 0
            self.numberOutrightEvents = Int((try? container.decode(String.self, forKey: SportRadarModels.SportNode.CodingKeys.numberOutrightEvents)) ?? "0") ?? 0
            self.numberOutrightMarkets = Int((try? container.decode(String.self, forKey: SportRadarModels.SportNode.CodingKeys.numberOutrightMarkets)) ?? "0") ?? 0
            self.numberLiveEvents = Int((try? container.decode(String.self, forKey: SportRadarModels.SportNode.CodingKeys.numberLiveEvents)) ?? "0") ?? 0
            self.alphaCode = try container.decode(String.self, forKey: SportRadarModels.SportNode.CodingKeys.alphaCode)
        }
    }

    struct ScheduledSport: Codable {
        var id: String
        var name: String

        enum CodingKeys: String, CodingKey {
            case id = "idfosporttype"
            case name = "name"
        }

        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.ScheduledSport.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.ScheduledSport.CodingKeys.self)
            self.id = try container.decode(String.self, forKey: SportRadarModels.ScheduledSport.CodingKeys.id)
            self.name = try container.decode(String.self, forKey: SportRadarModels.ScheduledSport.CodingKeys.name)
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SportRadarModels+Transactions.swift
````swift
//
//  SportRadarModels+Transactions.swift
//  
//
//  Created by André Lascas on 13/02/2023.
//

import Foundation

extension SportRadarModels {

    struct TransactionsHistoryResponse: Codable {

        var status: String
        var transactions: [TransactionDetail]?

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case transactions = "transactionList"
        }
    }

    struct TransactionDetail: Codable {

        var id: Int
        var dateTime: String
        var type: String
        var amount: Double
        var postBalance: Double
        var amountBonus: Double
        var postBalanceBonus: Double
        var currency: String
        var paymentId: Int?
        var gameTranId: String?
        var reference: String?
        var escrowTranType: String?
        var escrowTranSubType: String?
        var escrowType: String?

        enum CodingKeys: String, CodingKey {
            case id = "id"
            case dateTime = "dateTime"
            case type = "tranType"
            case amount = "amount"
            case amountReal = "amountReal"
            case postBalance = "postBalance"
            case amountBonus = "amountBonus"
            case postBalanceBonus = "postBalanceBonus"
            case currency = "currency"
            case paymentId = "paymentId"
            case gameTranId = "gameTranId"
            case reference = "reference"
            case escrowTranType = "escrowTranType"
            case escrowTranSubType = "escrowTranSubType"
            case escrowType = "escrowType"
        }
        
        init(from decoder: any Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.TransactionDetail.CodingKeys> = try decoder.container(keyedBy: SportRadarModels.TransactionDetail.CodingKeys.self)
            self.id = try container.decode(Int.self, forKey: .id)
            self.dateTime = try container.decode(String.self, forKey: .dateTime)
            self.type = try container.decode(String.self, forKey: .type)
            self.amount = try container.decode(Double.self, forKey: .amount)
            self.postBalance = try container.decode(Double.self, forKey: .postBalance)
            self.amountBonus = try container.decode(Double.self, forKey: .amountBonus)
            self.postBalanceBonus = try container.decode(Double.self, forKey: .postBalanceBonus)
            self.currency = try container.decode(String.self, forKey: .currency)
            self.paymentId = try container.decodeIfPresent(Int.self, forKey: .paymentId)
            self.gameTranId = try container.decodeIfPresent(String.self, forKey: .gameTranId)
            self.reference = try container.decodeIfPresent(String.self, forKey: .reference)
            self.escrowTranType = try container.decodeIfPresent(String.self, forKey: .escrowTranType)
            self.escrowTranSubType = try container.decodeIfPresent(String.self, forKey: .escrowTranSubType)
            self.escrowType = try container.decodeIfPresent(String.self, forKey: .escrowType)
            
            if self.type == "BONUS_REL", let amountReal = try? container.decode(Double.self, forKey: .amountReal) {
                self.amount = amountReal
            }
            
        }
        
        func encode(to encoder: any Encoder) throws {
            var container = encoder.container(keyedBy: SportRadarModels.TransactionDetail.CodingKeys.self)
            try container.encode(self.id, forKey: SportRadarModels.TransactionDetail.CodingKeys.id)
            try container.encode(self.dateTime, forKey: SportRadarModels.TransactionDetail.CodingKeys.dateTime)
            try container.encode(self.type, forKey: SportRadarModels.TransactionDetail.CodingKeys.type)
            try container.encode(self.amount, forKey: SportRadarModels.TransactionDetail.CodingKeys.amount)
            try container.encode(self.postBalance, forKey: SportRadarModels.TransactionDetail.CodingKeys.postBalance)
            try container.encode(self.amountBonus, forKey: SportRadarModels.TransactionDetail.CodingKeys.amountBonus)
            try container.encode(self.postBalanceBonus, forKey: SportRadarModels.TransactionDetail.CodingKeys.postBalanceBonus)
            try container.encode(self.currency, forKey: SportRadarModels.TransactionDetail.CodingKeys.currency)
            try container.encodeIfPresent(self.paymentId, forKey: SportRadarModels.TransactionDetail.CodingKeys.paymentId)
            try container.encodeIfPresent(self.gameTranId, forKey: SportRadarModels.TransactionDetail.CodingKeys.gameTranId)
            try container.encodeIfPresent(self.reference, forKey: SportRadarModels.TransactionDetail.CodingKeys.reference)
            try container.encodeIfPresent(self.escrowTranType, forKey: SportRadarModels.TransactionDetail.CodingKeys.escrowTranType)
            try container.encodeIfPresent(self.escrowTranSubType, forKey: SportRadarModels.TransactionDetail.CodingKeys.escrowTranSubType)
            try container.encodeIfPresent(self.escrowType, forKey: SportRadarModels.TransactionDetail.CodingKeys.escrowType)
        }
        
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Business/SportRadarModels+User.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 26/10/2022.
//

import Foundation

extension SportRadarModels {
    
    struct LoginResponse: Codable {
        let status: String
        let partyId: String?
        let username: String?
        let language: String?
        let currency: String?
        let email: String?
        let sessionKey: String?
        let parentId: String?
        let level: String?
        let userType: String?
        let isFirstLogin: String?
        let registrationStatus: String?
        let pendingLimitConfirmation: String?
        let country: String?
        let kycStatus: String?
        let lockStatus: String?
        let securityVerificationRequiredFields: [String]?
        let message: String?
        let lockUntilDateFormatted: String?
        let kycStatusDetails: KYCStatusDetail?
    }
    
    struct KYCStatusDetail: Codable {
//        let kycTypeStatus: [String]?
        let expiryDate: String?
        
        enum CodingKeys: String, CodingKey {
//            case kycTypeStatus = "kycTypeStatus"
            case expiryDate = "expiryDate"
        }
        
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)

//            self.kycTypeStatus = try container.decodeIfPresent([String].self, forKey: .kycTypeStatus)
            self.expiryDate = try container.decodeIfPresent(String.self, forKey: .expiryDate)
        }
    }

    struct OpenSessionResponse: Codable {
        let status: String
        let launchToken: String
    }
    
    struct PlayerInfoResponse: Codable {
        let status: String
        
        let partyId: String
        let userId: String
        let email: String
        
        let firstName: String?
        let lastName: String?
        let middleName: String?
        let nickname: String?
        let language: String?
        let phone: String?
        let phoneCountryCode: String?
        let phoneLocalNumber: String?
        let phoneNeedsReview: Bool?
        let birthDate: String?
        let birthDateFormatted: Date
        let regDate: String?
        let regDateFormatted: Date?
        let mobilePhone: String?
        let mobileCountryCode: String?
        let mobileLocalNumber: String?
        let mobileNeedsReview: Bool?
        let currency: String?
        let lastLogin: String?
        let lastLoginFormatted: Date?
        let level: Int?
        let parentID: String?
        let userType: Int?
        let isAutopay: Bool?
        let registrationStatus: String?
        let sessionKey: String?

        let vipStatus: String?
        let kycStatus: String?
        let emailVerificationStatus: String
        let verificationStatus: String?
        let lockedStatus: String?
        
        let gender: String?
        let contactPreference: String?
        let verificationMethod: String?
        let docNumber: String?
        let readonlyFields: String?
        
        let accountNumber: String?
        let idCardNumber: String?
        let madeDeposit: Bool?
        let testPlayer: Bool?
        
        let address: String?
        let city: String?
        let province: String?
        let postalCode: String?
        let country: String?
        let nationality: String?
        let municipality: String?
        let streetNumber: String?
        let building: String?
        let unit: String?
        let floorNumber: String?
        let birthDepartment: String?
        let birthCity: String?
        let birthCoutryCode: String?
        
        let extraInfos: [ExtraInfo]?

        enum CodingKeys: String, CodingKey {
            case status = "status"

            case partyId = "partyId"
            case userId = "userId"
            case email = "email"

            case firstName = "firstName"
            case middleName = "middleName"
            case lastName = "lastName"
            case nickname = "nickname"
            case language = "language"
            case phone = "phone"
            case phoneCountryCode = "phoneCountryCode"
            case phoneLocalNumber = "phoneLocalNumber"
            case phoneNeedsReview = "phoneNeedsReview"
            case birthDate = "birthDate"
            case birthDateFormatted = "birthDateFormatted"
            case regDate = "regDate"
            case regDateFormatted = "regDateFormatted"
            case mobilePhone = "mobilePhone"
            case mobileCountryCode = "mobileCountryCode"
            case mobileLocalNumber = "mobileLocalNumber"
            case mobileNeedsReview = "mobileNeedsReview"
            case currency = "currency"
            case lastLogin = "lastLogin"
            case lastLoginFormatted = "lastLoginFormatted"
            case level = "level"
            case parentID = "parentID"
            case userType = "userType"
            case isAutopay = "isAutopay"
            case registrationStatus = "registrationStatus"
            case sessionKey = "sessionKey"

            case vipStatus = "vipStatus"
            case kycStatus = "kycStatus"
            case emailVerificationStatus = "emailVerificationStatus"
            case verificationStatus = "verificationStatus"
            case lockedStatus = "lockedStatus"

            case gender = "gender"
            case contactPreference = "contactPreference"
            case verificationMethod = "verificationMethod"
            case docNumber = "docNumber"
            case readonlyFields = "readonlyFields"

            case accountNumber = "accountNumber"
            case idCardNumber = "idCardNumber"
            case madeDeposit = "madeDeposit"
            case testPlayer = "testPlayer"

            case address = "address"
            case city = "city"
            case province = "province"
            case postalCode = "postalCode"
            case country = "country"
            case nationality = "nationality"
            case municipality = "municipality"
            case streetNumber = "streetNumber"
            case building = "building"
            case unit = "unit"
            case floorNumber = "floorNumber"
            case birthDepartment = "birthDepartment"
            case birthCity = "birthCity"

            case birthCoutryCode = "birthCountry"
            
            case extraInfos = "extraInfo"
        }

        struct ExtraInfo: Codable {

            let key: String
            let value: String

            enum CodingKeys: String, CodingKey {
                case key
                case value
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.key = try container.decode(String.self, forKey: .key)
                self.value = try container.decode(String.self, forKey: .value)
            }
        }

        public init(status: String, partyId: String, userId: String, email: String, firstName: String?, middleName: String?, lastName: String?, nickname: String?, language: String?, phone: String?, phoneCountryCode: String?, phoneLocalNumber: String?, phoneNeedsReview: Bool?, birthDate: String?, birthDateFormatted: Date, regDate: String?, regDateFormatted: Date?, mobilePhone: String?, mobileCountryCode: String?, mobileLocalNumber: String?, mobileNeedsReview: Bool?, currency: String?, lastLogin: String?, lastLoginFormatted: Date?, level: Int?, parentID: String?, userType: Int?, isAutopay: Bool?, registrationStatus: String?, sessionKey: String?, vipStatus: String?, kycStatus: String?, emailVerificationStatus: String, verificationStatus: String?, lockedStatus: String?, gender: String?, contactPreference: String?, verificationMethod: String?, docNumber: String?, readonlyFields: String?, accountNumber: String?, idCardNumber: String?, madeDeposit: Bool?, testPlayer: Bool?, address: String?, city: String?, province: String?, postalCode: String?, country: String?, nationality: String?, municipality: String?, streetNumber: String?, building: String?, unit: String?, floorNumber: String?, birthDepartment: String?, birthCity: String?, birthCoutryCode: String?) {

            self.status = status
            self.partyId = partyId
            self.userId = userId
            self.email = email
            self.firstName = firstName
            self.middleName = middleName
            self.lastName = lastName
            self.nickname = nickname
            self.language = language
            self.phone = phone
            self.phoneCountryCode = phoneCountryCode
            self.phoneLocalNumber = phoneLocalNumber
            self.phoneNeedsReview = phoneNeedsReview
            self.birthDate = birthDate
            self.birthDateFormatted = birthDateFormatted
            self.regDate = regDate
            self.regDateFormatted = regDateFormatted
            self.mobilePhone = mobilePhone
            self.mobileCountryCode = mobileCountryCode
            self.mobileLocalNumber = mobileLocalNumber
            self.mobileNeedsReview = mobileNeedsReview
            self.currency = currency
            self.lastLogin = lastLogin
            self.lastLoginFormatted = lastLoginFormatted
            self.level = level
            self.parentID = parentID
            self.userType = userType
            self.isAutopay = isAutopay
            self.registrationStatus = registrationStatus
            self.sessionKey = sessionKey
            self.vipStatus = vipStatus
            self.kycStatus = kycStatus
            self.emailVerificationStatus = emailVerificationStatus
            self.verificationStatus = verificationStatus
            self.lockedStatus = lockedStatus
            self.gender = gender
            self.contactPreference = contactPreference
            self.verificationMethod = verificationMethod
            self.docNumber = docNumber
            self.readonlyFields = readonlyFields
            self.accountNumber = accountNumber
            self.idCardNumber = idCardNumber
            self.madeDeposit = madeDeposit
            self.testPlayer = testPlayer
            self.address = address
            self.city = city
            self.province = province
            self.postalCode = postalCode
            self.country = country
            self.nationality = nationality
            self.municipality = municipality
            self.streetNumber = streetNumber
            self.building = building
            self.unit = unit
            self.floorNumber = floorNumber
            self.birthDepartment = birthDepartment
            self.birthCity = birthCity
            self.extraInfos = nil
            self.birthCoutryCode = birthCoutryCode
        }

        init(from decoder: Decoder) throws {
            let container: KeyedDecodingContainer<SportRadarModels.PlayerInfoResponse.CodingKeys> = try decoder.container(keyedBy: CodingKeys.self)

            self.status = try container.decode(String.self, forKey: .status)
            self.partyId = try container.decode(String.self, forKey: .partyId)
            self.userId = try container.decode(String.self, forKey: .userId)
            self.email = try container.decode(String.self, forKey: .email)
            self.firstName = try container.decodeIfPresent(String.self, forKey: .firstName)
            self.middleName = try container.decodeIfPresent(String.self, forKey: .middleName)
            self.lastName = try container.decodeIfPresent(String.self, forKey: .lastName)
            self.nickname = try container.decodeIfPresent(String.self, forKey: .nickname)
            self.language = try container.decodeIfPresent(String.self, forKey: .language)
            self.phone = try container.decodeIfPresent(String.self, forKey: .phone)
            self.phoneCountryCode = try container.decodeIfPresent(String.self, forKey: .phoneCountryCode)
            self.phoneLocalNumber = try container.decodeIfPresent(String.self, forKey: .phoneLocalNumber)
            self.phoneNeedsReview = try container.decodeIfPresent(Bool.self, forKey: .phoneNeedsReview)
            self.birthDate = try container.decodeIfPresent(String.self, forKey: .birthDate)
            self.birthDateFormatted = try container.decode(Date.self, forKey: .birthDateFormatted)
            self.regDate = try container.decodeIfPresent(String.self, forKey: .regDate)
            self.regDateFormatted = try container.decodeIfPresent(Date.self, forKey: .regDateFormatted)
            self.mobilePhone = try container.decodeIfPresent(String.self, forKey: .mobilePhone)
            self.mobileCountryCode = try container.decodeIfPresent(String.self, forKey: .mobileCountryCode)
            self.mobileLocalNumber = try container.decodeIfPresent(String.self, forKey: .mobileLocalNumber)
            self.mobileNeedsReview = try container.decodeIfPresent(Bool.self, forKey: .mobileNeedsReview)
            self.currency = try container.decodeIfPresent(String.self, forKey: .currency)
            self.lastLogin = try container.decodeIfPresent(String.self, forKey: .lastLogin)
            self.lastLoginFormatted = try container.decodeIfPresent(Date.self, forKey: .lastLoginFormatted)
            self.level = try container.decodeIfPresent(Int.self, forKey: .level)
            self.parentID = try container.decodeIfPresent(String.self, forKey: .parentID)
            self.userType = try container.decodeIfPresent(Int.self, forKey: .userType)
            self.isAutopay = try container.decodeIfPresent(Bool.self, forKey: .isAutopay)
            self.registrationStatus = try container.decodeIfPresent(String.self, forKey: .registrationStatus)
            self.sessionKey = try container.decodeIfPresent(String.self, forKey: .sessionKey)
            self.vipStatus = try container.decodeIfPresent(String.self, forKey: .vipStatus)
            self.kycStatus = try container.decodeIfPresent(String.self, forKey: .kycStatus)
            self.emailVerificationStatus = try container.decode(String.self, forKey: .emailVerificationStatus)
            self.verificationStatus = try container.decodeIfPresent(String.self, forKey: .verificationStatus)
            self.lockedStatus = try container.decodeIfPresent(String.self, forKey: .lockedStatus)
            self.gender = try container.decodeIfPresent(String.self, forKey: .gender)
            self.contactPreference = try container.decodeIfPresent(String.self, forKey: .contactPreference)
            self.verificationMethod = try container.decodeIfPresent(String.self, forKey: .verificationMethod)
            self.docNumber = try container.decodeIfPresent(String.self, forKey: .docNumber)
            self.readonlyFields = try container.decodeIfPresent(String.self, forKey: .readonlyFields)
            self.accountNumber = try container.decodeIfPresent(String.self, forKey: .accountNumber)
            self.idCardNumber = try container.decodeIfPresent(String.self, forKey: .idCardNumber)
            self.madeDeposit = try container.decodeIfPresent(Bool.self, forKey: .madeDeposit)
            self.testPlayer = try container.decodeIfPresent(Bool.self, forKey: .testPlayer)
            self.address = try container.decodeIfPresent(String.self, forKey: .address)
            self.city = try container.decodeIfPresent(String.self, forKey: .city)
            self.province = try container.decodeIfPresent(String.self, forKey: .province)
            self.postalCode = try container.decodeIfPresent(String.self, forKey: .postalCode)
            self.country = try container.decodeIfPresent(String.self, forKey: .country)
            self.nationality = try container.decodeIfPresent(String.self, forKey: .nationality)
            self.municipality = try container.decodeIfPresent(String.self, forKey: .municipality)
            self.streetNumber = try container.decodeIfPresent(String.self, forKey: .streetNumber)
            self.building = try container.decodeIfPresent(String.self, forKey: .building)
            self.unit = try container.decodeIfPresent(String.self, forKey: .unit)
            self.floorNumber = try container.decodeIfPresent(String.self, forKey: .floorNumber)
            self.birthDepartment = try container.decodeIfPresent(String.self, forKey: .birthDepartment)
            self.birthCity = try container.decodeIfPresent(String.self, forKey: .birthCity)
            self.birthCoutryCode = try container.decodeIfPresent(String.self, forKey: .birthCoutryCode)
            
            self.extraInfos = try? container.decodeIfPresent([ExtraInfo].self, forKey: .extraInfos)
        }

    }
    
    public struct CheckCredentialResponse: Codable {
        public let status: String
        public let exists: String
        public let fieldExist: Bool

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case exists = "exists"
            case fieldExist = "fieldExist"
        }

        public init(status: String, exists: String, fieldExist: Bool) {
            self.status = status
            self.exists = exists
            self.fieldExist = fieldExist
        }
    }

    struct GetCountriesResponse: Codable {
        let status: String
        let countries: [String]

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case countries = "countries"
        }
    }
    
    struct GetCountryInfoResponse: Codable {
        let status: String
        let countryInfo: CountryInfo

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case countryInfo = "countryInfo"
        }
    }

    // MARK: - CountryInfo
    struct CountryInfo: Codable {
        let name: String
        let iso2Code: String
        let phonePrefix: String

        enum CodingKeys: String, CodingKey {
            case name = "name"
            case iso2Code = "iso2Code"
            case phonePrefix = "phonePrefix"
        }
    }

}

extension SportRadarModels {
    
    struct BalanceResponse: Codable {
        let status: String
        let message: String?
        let currency: String?
        let loyaltyPoint: Int?
        let vipStatus: String?
        
        let totalBalance: String?
        let totalBalanceNumber: Double?
        let withdrawableBalance: String?
        let withdrawableBalanceNumber: Double?
        let bonusBalance: String?
        let bonusBalanceNumber: Double?
        let pendingBonusBalance: String?
        let pendingBonusBalanceNumber: Double?
        let casinoPlayableBonusBalance: String?
        let casinoPlayableBonusBalanceNumber: Double?
        let sportsbookPlayableBonusBalance: String?
        let sportsbookPlayableBonusBalanceNumber: Double?
        let withdrawableEscrowBalance: String?
        let withdrawableEscrowBalanceNumber: Double?
        let totalWithdrawableBalance: String?
        let totalWithdrawableBalanceNumber: Double?
        let withdrawRestrictionAmount: String?
        let withdrawRestrictionAmountNumber: Double?
        let totalEscrowBalance: String?
        let totalEscrowBalanceNumber: Double?
    }

}

extension SportRadarModels {
    
    struct StatusResponse: Codable {
        let status: String
        let errors: [FieldError]?
        let message: String?

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case errors = "errors"
            case message = "message"
        }
    }

    struct FieldError: Codable {
        let field: String
        let error: String

        enum CodingKeys: String, CodingKey {
            case field = "field"
            case error = "error"
        }
    }

    struct CheckUsernameResponse: Codable {

        let errors: [CheckUsernameError]?
        let status: String
        let message: String?
        let additionalInfos: [CheckUsernameAdditionalInfo]?

        enum CodingKeys: String, CodingKey {
            case errors = "errors"
            case status = "status"
            case message = "message"
            case additionalInfos = "additionalInfo"
        }

        struct CheckUsernameAdditionalInfo: Codable {

            let key: String
            let value: String

            enum CodingKeys: String, CodingKey {
                case key
                case value
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.key = try container.decode(String.self, forKey: .key)
                self.value = try container.decode(String.self, forKey: .value)
            }
        }

        struct CheckUsernameError: Codable {

            let field: String
            let error: String

            enum CodingKeys: String, CodingKey {
                case field
                case error
            }

            init(from decoder: Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                self.field = try container.decode(String.self, forKey: .field)
                self.error = try container.decode(String.self, forKey: .error)
            }
        }

        init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            self.errors = try container.decodeIfPresent([CheckUsernameError].self, forKey: .errors)
            self.status = try container.decode(String.self, forKey: .status)
            self.message = try container.decodeIfPresent(String.self, forKey: .message)

            self.additionalInfos = try? container.decodeIfPresent([CheckUsernameAdditionalInfo].self, forKey: .additionalInfos)
        }
        
    }




}

extension SportRadarModels {

    struct DocumentTypesResponse: Codable {
        var status: String
        var documentTypes: [DocumentType]

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case documentTypes = "documentTypes"
        }
    }

    struct DocumentType: Codable {
        var documentType: String
        var issueDateRequired: Bool?
        var expiryDateRequired: Bool?
        var documentNumberRequired: Bool?
        var multipleFileRequired: Bool?

        enum CodingKeys: String, CodingKey {
            case documentType = "documentType"
            case expiryDateRequired = "expiryDateRequired"
            case documentNumberRequired = "documentNumberRequired"
            case issueDateRequired = "issueDateRequired"
            case multipleFileRequired = "multipleFileRequired"
        }
    }

    struct UserDocumentsResponse: Codable {
        var status: String
        var userDocuments: [UserDocument]

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case userDocuments = "userDocuments"
        }
    }

    struct UserDocument: Codable {
        var documentType: String
        var fileName: String?
        var status: String
        var uploadDate: String
        var userDocumentFiles: [UserDocumentFile]?

        enum CodingKeys: String, CodingKey {
            case documentType = "documentType"
            case fileName = "fileName"
            case status = "status"
            case uploadDate = "uploadDate"
            case userDocumentFiles = "userDocumentFiles"
        }
    }

    struct UserDocumentFile: Codable {
        var fileName: String

        enum CodingKeys: String, CodingKey {
            case fileName = "fileName"
        }
    }

    struct UploadDocumentResponse: Codable {
        var status: String
        var message: String?

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case message = "message"
        }
    }

    struct PaymentsResponse: Codable {
        var status: String
        var depositMethods: [DepositMethod]

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case depositMethods = "depositMethods"
        }
    }

    struct DepositMethod: Codable {
        var code: String
        var paymentMethod: String
        var methods: [PaymentMethod]?

        enum CodingKeys: String, CodingKey {
            case code = "code"
            case paymentMethod = "paymentMethod"
            case methods = "methods"
        }
    }

    struct PaymentMethod: Codable {
        var name: String
        var type: String
        var brands: [String]?

        enum CodingKeys: String, CodingKey {
            case name = "name"
            case type = "type"
            case brands = "brands"
        }
    }
    struct ProcessDepositResponse: Codable {
        var status: String
        var paymentId: String?
        var continueUrl: String?
        var clientKey: String?
        var sessionId: String?
        var sessionData: String?
        var message: String?

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case paymentId = "paymentId"
            case continueUrl = "continueUrl"
            case clientKey = "clientKey"
            case sessionId = "sessionId"
            case sessionData = "sessionData"
            case message = "message"
        }
    }

    struct UpdatePaymentResponse: Codable {
        var resultCode: String
        var action: UpdatePaymentAction?

        enum CodingKeys: String, CodingKey {
            case resultCode = "resultCode"
            case action = "action"
        }
    }

    struct UpdatePaymentAction: Codable {
        var paymentMethodType: String
        var url: String
        var method: String
        var type: String

        enum CodingKeys: String, CodingKey {
            case paymentMethodType = "paymentMethodType"
            case url = "url"
            case method = "method"
            case type = "type"
        }
    }

    struct PersonalDepositLimitResponse: Codable {

        var status: String
        var dailyLimit: String?
        var weeklyLimit: String?
        var monthlyLimit: String?
        var currency: String
        var hasPendingWeeklyLimit: String?
        var pendingWeeklyLimit: String?
        var pendingWeeklyLimitEffectiveDate: String?

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case dailyLimit = "dailyLimit"
            case weeklyLimit = "weeklyLimit"
            case monthlyLimit = "monthlyLimit"
            case currency = "currency"
            case hasPendingWeeklyLimit = "hasPendingWeeklyLimit"
            case pendingWeeklyLimit = "pendingWeeklyLimit"
            case pendingWeeklyLimitEffectiveDate = "pendingWeeklyLimitEffectiveDate"
        }
    }

    struct LimitsResponse: Codable {

        var status: String
        var wagerLimit: String?
        var lossLimit: String?
        var currency: String
        var pendingWagerLimit: LimitPending?

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case wagerLimit = "wagerLimit"
            case lossLimit = "lossLimit"
            case currency = "currency"
            case pendingWagerLimit = "pendingWagerLimit"
        }
    }

    struct LimitPending: Codable {
        var effectiveDate: String
        var limit: String
        var limitNumber: Double

        enum CodingKeys: String, CodingKey {
            case effectiveDate = "effectiveDate"
            case limit = "limit"
            case limitNumber = "limitNumber"
        }
    }

    struct BasicResponse: Codable {
        var status: String
        var message: String?

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case message = "message"
        }
    }

    
    struct MobileVerifyResponse: Codable {
        var status: String
        var message: String?
        var requestId: Int?
        
        enum CodingKeys: String, CodingKey {
            case status = "status"
            case message = "message"
            case requestId = "verificationRequestId"
        }
    }
    
    struct PaymentStatusResponse: Codable {
        var status: String
        var paymentId: String?
        var paymentStatus: String?
        var message: String?

        enum CodingKeys: String, CodingKey {
            case status = "status"
            case paymentId = "paymentId"
            case paymentStatus = "paymentStatus"
            case message = "message"
        }
    }
    
    struct SupportResponse: Codable {
        var request: SupportRequest?
        var error: String?
        var description: String?

        enum CodingKeys: String, CodingKey {
            case request = "request"
            case error = "error"
            case description = "description"
        }
    }

    struct SupportRequest: Codable {
        var id: Int
        var status: String

        enum CodingKeys: String, CodingKey {
            case id = "id"
            case status = "status"
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Mapper/SportRadarModelMapper.swift
````swift
//
//  SportRadarModelMapper.swift
//  
//
//  Created by Ruben Roques on 11/10/2022.
//

import Foundation

struct SportRadarModelMapper {

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Mapper/SportRadarModelMapper+AnalyticsEvent.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 28/05/2024.
//

import Foundation


extension SportRadarModelMapper {
    static func vaixAnalyticsEvent(fromAnalyticsTrackedEvent analyticsTrackedEvent: AnalyticsTrackedEvent) -> VaixAnalyticsEvent {
        switch analyticsTrackedEvent {
        case .impressionsEvents(let eventsIds):
            return VaixAnalyticsEvent.impressionsEvents(eventsIds: eventsIds)
        case .clickEvent(let id):
            return VaixAnalyticsEvent.clickEvent(id: id)
        case .clickOutcome(let eventId, let outcomeId):
            return VaixAnalyticsEvent.clickOutcome(eventId: eventId, outcomeId: outcomeId)
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Mapper/SportRadarModelMapper+Betting.swift
````swift
//
//  SportRadarError.swift
//
//
//  Created by Ruben Roques on 10/10/2022.
//

import Foundation
import SharedModels

extension SportRadarModelMapper {

    static func bettingHistory(fromInternalBettingHistory internalBettingHistory: SportRadarModels.BettingHistory) -> BettingHistory {
        let betGroups = Dictionary.init(grouping: internalBettingHistory.bets, by: \.identifier)
        let bets = betGroups.map { identifier, internalBets in

            let firstBet: SportRadarModels.Bet? = internalBets.first

            let betSelections = internalBets.sorted { $0.order > $1.order }.map(Self.betSelection(fromInternalBet:))

            let firstConvertedBet = betSelections.first

            let potentialReturn: Double = internalBets.first?.potentialReturn ?? 0.0
            let totalReturn: Double = internalBets.first?.totalReturn ?? 0.0

            let uniqueEventIds = Set(betSelections.map(\.eventId))
            var betType = (firstBet?.type ?? "").lowercased()
            if betSelections.count >= 2, betType == "accumulator", uniqueEventIds.count == 1 {
                betType = "mix_match"
            }
            
            return Bet(identifier: identifier,
                       type: betType,
                       state: firstConvertedBet?.state ?? .undefined,
                       result: firstConvertedBet?.result ?? .notSpecified,
                       globalState: firstConvertedBet?.globalState ?? .undefined,
                       stake: firstBet?.totalStake ?? 0.0,
                       totalOdd: firstBet?.totalOdd ?? 0.0,
                       selections: betSelections,
                       potentialReturn: potentialReturn == 0.0 ? totalReturn : potentialReturn,
                       date: firstBet?.attemptedDate ?? Date(),
                       freebet: firstBet?.freeBet ?? false,
                       partialCashoutReturn: firstBet?.partialCashoutReturn,
                       partialCashoutStake: firstBet?.partialCashoutStake,
                       betslipId: firstBet?.betslipId,
                       cashbackReturn: firstBet?.cashbackReturn,
                       freebetReturn: firstBet?.freebetReturn,
                       potentialCashbackReturn: firstBet?.potentialCashbackReturn,
                       potentialFreebetReturn: firstBet?.potentialFreebetReturn)
        }
        return BettingHistory(bets: bets.sorted(by: { $0.date > $1.date }))
    }

    static func betSelection(fromInternalBet internalBet: SportRadarModels.Bet) -> BetSelection {

        let state: BetState
        switch internalBet.state {
        case .opened: state = .opened
        case .closed: state = .closed
        case .settled: state = .settled
        case .cancelled: state = .cancelled
        case .undefined: state = .undefined
        case .attempted: state = .attempted
        case .allStates: state = .undefined
        case .won: state = .won
        case .lost: state = .lost
        case .cashedOut: state = .cashedOut
        case .void: state = .void
        }

        let result: BetResult
        switch internalBet.result {
        case .open: result = .open
        case .won: result = .won
        case .lost: result = .lost
        case .drawn: result = .drawn
        case .pending: result = .pending
        case .notSpecified: result = .notSpecified
        case .void: result = .void
        }

        let globalState: BetState
        switch internalBet.globalState {
        case .opened: globalState = .opened
        case .closed: globalState = .closed
        case .settled: globalState = .settled
        case .cancelled: globalState = .cancelled
        case .undefined: globalState = .undefined
        case .attempted: globalState = .attempted
        case .allStates: globalState = .undefined
        case .won: globalState = .won
        case .lost: globalState = .lost
        case .void: globalState = .void
        case .cashedOut: globalState = .cashedOut
        }

        let cleanedEventResult = (internalBet.eventResult ?? "").replacingOccurrences(of: " ", with: "")

        let homeResult: String? = cleanedEventResult.split(separator: ":")[safe: 0].map(String.init)
        let awayResult: String? = cleanedEventResult.split(separator: ":")[safe: 1].map(String.init)

        let eventIdString = String(format: "%.1f", internalBet.eventId)

        let country: Country? = Country.country(withName: internalBet.tournamentCountryName ?? "")

        return BetSelection(identifier: internalBet.identifier,
                            state: state,
                            result: result,
                            globalState: globalState,
                            eventName: internalBet.eventName,
                            homeTeamName: internalBet.homeTeamName,
                            awayTeamName: internalBet.awayTeamName,
                            marketName: internalBet.marketName,
                            outcomeName: internalBet.outcomeName,
                            odd: OddFormat.fraction(numerator: Int(internalBet.oddNumerator),
                                                    denominator: Int(internalBet.oddDenominator)),
                            homeResult: homeResult,
                            awayResult: awayResult,
                            eventId: eventIdString,
                            eventDate: internalBet.eventDate,
                            country: country,
                            sportType: SportType(name: internalBet.sportTypeName),
                            tournamentName: internalBet.tournamentName ?? "",
                            marketId: nil,
                            outcomeId: nil,
                            homeLogoUrl: nil,
                            awayLogoUrl: nil)
    }

    //  ServiceProvider ----> SportRadar


    //  SportRadar ---> ServiceProvider
    static func placedBetsResponse(fromInternalPlacedBetsResponse placedBetsResponse: SportRadarModels.PlacedBetsResponse) -> PlacedBetsResponse {
        let bets = placedBetsResponse.bets.map(Self.placedBetEntry(fromInternalPlacedBetEntry:))
        return PlacedBetsResponse(identifier: placedBetsResponse.identifier,
                                  bets: bets,
                                  detailedBets: nil,
                                  requiredConfirmation: false,
                                  totalStake: placedBetsResponse.totalStake)
    }

    static func placedBetEntry(fromInternalPlacedBetEntry placedBetEntry: SportRadarModels.PlacedBetEntry) -> PlacedBetEntry {
        let betLegs = placedBetEntry.betLegs.map(Self.placedBetLeg(fromInternalPlacedBetLeg:))
        return PlacedBetEntry(identifier: placedBetEntry.identifier,
                              potentialReturn: placedBetEntry.potentialReturn,
                              totalStake: placedBetEntry.totalAvailableStake,
                              betLegs: betLegs, type: placedBetEntry.type)
    }

    static func placedBetLeg(fromInternalPlacedBetLeg placedBetLeg: SportRadarModels.PlacedBetLeg) -> PlacedBetLeg {
        return PlacedBetLeg(identifier: placedBetLeg.identifier,
                            priceType: placedBetLeg.priceType,
                            priceNumerator: placedBetLeg.priceNumerator,
                            priceDenominator: placedBetLeg.priceDenominator)
    }


    static func betType(fromInternalBetType betType: SportRadarModels.BetType) -> BetType {
        switch (betType.typeCode, betType.numberOfIndividualBets) {
        case ("S", _):
            return BetType.init(name: betType.typeName,
                                grouping: .single(identifier: betType.typeCode),
                                code: betType.typeCode,
                                numberOfBets: betType.numberOfIndividualBets,
                                potencialReturn: betType.potencialReturn)
        case ("C1", _):
            return BetType.init(name: betType.typeName,
                                grouping: .single(identifier: betType.typeCode),
                                code: betType.typeCode,
                                numberOfBets: betType.numberOfIndividualBets,
                                potencialReturn: betType.potencialReturn)
        case (_ , 1):
            return BetType.init(name: betType.typeName,
                                grouping: .multiple(identifier: betType.typeCode),
                                code: betType.typeCode,
                                numberOfBets: betType.numberOfIndividualBets,
                                potencialReturn: betType.potencialReturn)
        default:
            return BetType.init(name: betType.typeName,
                                grouping: .system(identifier: betType.typeCode, name: betType.typeName, numberOfBets: betType.numberOfIndividualBets),
                                code: betType.typeCode,
                                numberOfBets: betType.numberOfIndividualBets,
                                potencialReturn: betType.potencialReturn)
        }
    }

    static func cashout(fromInternalCashout cashout: SportRadarModels.Cashout) -> Cashout {
        return Cashout(cashoutValue: cashout.cashoutValue, partialCashoutAvailable: cashout.partialCashoutAvailable)
    }

    static func cashoutResult(fromInternalCashoutResult cashoutResult: SportRadarModels.CashoutResult) -> CashoutResult {

        return CashoutResult(cashoutResult: cashoutResult.cashoutResult, cashoutReoffer: cashoutResult.cashoutReoffer, message: cashoutResult.message)
    }

    static func sharedTicketResponse(fromInternalSharedTicketResponse internalSharedTicketResponse: SportRadarModels.SharedTicketResponse) -> SharedTicketResponse {

        let mappedSharedBets = internalSharedTicketResponse.bets.map(Self.sharedBet(fromInternalSharedBet:))

        return SharedTicketResponse(bets: mappedSharedBets, totalStake: internalSharedTicketResponse.totalStake, betId: internalSharedTicketResponse.betId)

    }

    static func sharedBet(fromInternalSharedBet internalSharedBet: SportRadarModels.SharedBet) -> SharedBet {

        let mappedSharedBetSelections = internalSharedBet.betSelections.map(Self.sharedBetSelection(fromInternalSharedBetSelection:))

        return SharedBet(betSelections: mappedSharedBetSelections, winStake: internalSharedBet.winStake, potentialReturn: internalSharedBet.potentialReturn, totalStake: internalSharedBet.totalStake)
    }

    static func sharedBetSelection(fromInternalSharedBetSelection internalSharedBetSelection: SportRadarModels.SharedBetSelection) -> SharedBetSelection {

        return SharedBetSelection(id: internalSharedBetSelection.id, priceDenominator: internalSharedBetSelection.priceDenominator, priceNumerator: internalSharedBetSelection.priceNumerator, priceType: internalSharedBetSelection.priceType)
    }

    static func ticketSelection(fromInternalTicketSelection internalTicketSelection: SportRadarModels.TicketSelection) -> TicketSelection {

        return TicketSelection(id: internalTicketSelection.id, marketId: internalTicketSelection.marketId, name: internalTicketSelection.name, priceDenominator: internalTicketSelection.priceDenominator, priceNumerator: internalTicketSelection.priceNumerator)
    }

    static func cashbackResult(fromInternalCashbackResult cashbackResult: SportRadarModels.CashbackResult) -> CashbackResult {
        return CashbackResult(id: cashbackResult.id, amount: cashbackResult.amount, amountFree: cashbackResult.amountFree)
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Mapper/SportRadarModelMapper+Events.swift
````swift
//
//  SportRadarError.swift
//
//
//  Created by Ruben Roques on 10/10/2022.
//

import Foundation
import SharedModels

extension SportRadarModelMapper {

    static func eventsGroup(fromInternalEventsGroup internalEventsGroup: SportRadarModels.EventsGroup) -> EventsGroup {
        let events = internalEventsGroup.events.map(Self.event(fromInternalEvent:))
        return EventsGroup(events: events,
                           marketGroupId: internalEventsGroup.marketGroupId)
    }

    static func eventsGroup(fromInternalEvents internalEvents: [SportRadarModels.Event]) -> EventsGroup {
        let events = internalEvents.map(Self.event(fromInternalEvent:))
        return EventsGroup(events: events, marketGroupId: nil)
    }

    static func event(fromInternalEvent internalEvent: SportRadarModels.Event) -> Event {

        let country: Country? = Country.country(withName: internalEvent.tournamentCountryName ?? "")

        let eventMarkets = internalEvent.markets
        let markets = eventMarkets.map(Self.market(fromInternalMarket:))

        let sportRadarSportType = SportRadarModels.SportType(name: internalEvent.sportTypeName ?? "",
                                                             alphaId: internalEvent.sportTypeCode,
                                                             numberEvents: 0,
                                                             numberOutrightEvents: 0,
                                                             numberOutrightMarkets: 0,
                                                             numberLiveEvents: 0)

        let sport = SportRadarModelMapper.sportType(fromSportRadarSportType: sportRadarSportType)

        let scores = Self.scoresDictionary(fromInternalScoresDictionary: internalEvent.scores)

        var mappedActivePlayerServing: ActivePlayerServe?
        if let internalActivePlayerServing = internalEvent.activePlayerServing {
            mappedActivePlayerServing = Self.activePlayerServe(fromInternalActivePlayerServe: internalActivePlayerServing)
        }

        return Event(id: internalEvent.id,
                     homeTeamName: internalEvent.homeName ?? "",
                     awayTeamName: internalEvent.awayName ?? "",
                     homeTeamScore: internalEvent.homeScore,
                     awayTeamScore: internalEvent.awayScore,
                     homeTeamLogoUrl: nil,
                     awayTeamLogoUrl: nil,
                     competitionId: internalEvent.competitionId ?? "",
                     competitionName: internalEvent.competitionName ?? "",
                     sport: sport,
                     sportIdCode: internalEvent.sportIdCode,
                     startDate: internalEvent.startDate ?? Date(),
                     markets: markets,
                     venueCountry: country,
                     numberMarkets: internalEvent.numberMarkets,
                     name: internalEvent.name,
                     trackableReference: internalEvent.trackableReference,
                     status: Self.eventStatus(fromInternalEvent: internalEvent.status),
                     matchTime: internalEvent.matchTime,
                     activePlayerServing: mappedActivePlayerServing,
                     boostedMarket: nil,
                     promoImageURL: nil,
                     scores: scores)
    }

    static func event(fromInternalMarkets internalMarkets: [SportRadarModels.Market]) -> Event? {
        let mappedMarkets = internalMarkets.map(SportRadarModelMapper.market(fromInternalMarket: ))

        guard
            let firstMarket = mappedMarkets.first,
            let eventId = firstMarket.eventId,
            let competitionId = firstMarket.competitionId,
            let competitionName = firstMarket.competitionName,
            let sport = firstMarket.sport
        else {
            return nil
        }

        let event = Event(id: eventId,
                          homeTeamName: "",
                          awayTeamName: "",
                          homeTeamScore: nil,
                          awayTeamScore: nil,
                          homeTeamLogoUrl: nil,
                          awayTeamLogoUrl: nil,
                          competitionId: competitionId,
                          competitionName: competitionName,
                          sport: sport,
                          sportIdCode: nil,
                          startDate: firstMarket.startDate ?? Date(timeIntervalSince1970: 0),
                          markets: mappedMarkets,
                          venueCountry: firstMarket.venueCountry,
                          trackableReference: nil,
                          status: nil,
                          matchTime: nil,
                          activePlayerServing: nil,
                          boostedMarket: nil,
                          promoImageURL: nil,
                          scores: [:])
        return event
    }

    static func scoresDictionary(fromInternalScoresDictionary internalScores: [String: SportRadarModels.Score]) -> [String: Score] {
        return internalScores.mapValues(Self.score(fromInternalScore:))
    }

    static func scores(fromInternalScores internalScores: [SportRadarModels.Score]) -> [Score] {
        return internalScores.map(Self.score(fromInternalScore:))
    }

    static func score(fromInternalScore internalScore: SportRadarModels.Score) -> Score {
        switch internalScore {

        case .set(index: let index, home: let home, away: let away):
            return Score.set(index: index, home: home, away: away)
        case .gamePart(home: let home, away: let away):
            return Score.gamePart(home: home, away: away)
        case .matchFull(home: let home, away: let away):
            return Score.matchFull(home: home, away: away)
        }

    }

    static func eventStatus(fromInternalEvent internalEventStatus: SportRadarModels.EventStatus) -> EventStatus? {
        switch internalEventStatus {
        case .unknown:
            return nil
        case .notStarted:
            return EventStatus.notStarted
        case .inProgress(let detail):
            return EventStatus.inProgress(detail)
        case .ended:
            return EventStatus.ended(internalEventStatus.stringValue)
        }
    }

    static func eventLiveData(fromInternalEventLiveData internalEventLiveData: SportRadarModels.EventLiveDataExtended) -> EventLiveData {

        var eventStatus: EventStatus?
        if let statusValue = internalEventLiveData.status {
            eventStatus = Self.eventStatus(fromInternalEvent: statusValue)
        }

        let mappedScores = Self.scoresDictionary(fromInternalScoresDictionary: internalEventLiveData.scores)

        var mappedActivePlayerServing: ActivePlayerServe?
        if let internalActivePlayerServing = internalEventLiveData.activePlayerServing {
            mappedActivePlayerServing = Self.activePlayerServe(fromInternalActivePlayerServe: internalActivePlayerServing)
        }

        return EventLiveData(id: internalEventLiveData.id,
                             homeScore: internalEventLiveData.homeScore,
                             awayScore: internalEventLiveData.awayScore,
                             matchTime: internalEventLiveData.matchTime,
                             status: eventStatus,
                             detailedScores: mappedScores,
                             activePlayerServing: mappedActivePlayerServing)
    }



    static func market(fromInternalMarket internalMarket: SportRadarModels.Market) -> Market {
        var country: Country?
        if let tournamentCountryName = internalMarket.tournamentCountryName {
           country = Country.country(withName: tournamentCountryName)
        }

        var mappedSport: SportType?
        if  let sportTypeCode = internalMarket.sportTypeCode {
            let sportRadarSportType = SportRadarModels.SportType(name: internalMarket.sportTypeName ?? "",
                                                                 alphaId: sportTypeCode,
                                                                 numberEvents: 0,
                                                                 numberOutrightEvents: 0,
                                                                 numberOutrightMarkets: 0,
                                                                 numberLiveEvents: 0)
            mappedSport = SportRadarModelMapper.sportType(fromSportRadarSportType: sportRadarSportType)
        }

        let outcomes = internalMarket.outcomes.map(Self.outcome(fromInternalOutcome:))

        var outcomesOrder: Market.OutcomesOrder
        switch internalMarket.outcomesOrder {
        case .name:
            outcomesOrder = .name
        case .odds:
            outcomesOrder = .odds
        case .setup:
            outcomesOrder = .setup
        case.none:
            outcomesOrder = .none
        }

        return Market(id: internalMarket.id,
                      name: internalMarket.name,
                      outcomes: outcomes,
                      marketTypeId: internalMarket.marketTypeId,
                      marketFilterId: internalMarket.marketFilterId,
                      eventMarketTypeId: internalMarket.eventMarketTypeId,
                      eventName: internalMarket.eventName,
                      isMainOutright: false,
                      eventMarketCount: internalMarket.eventMarketCount,
                      isTradable: internalMarket.isTradable,
                      startDate: internalMarket.startDate,
                      homeParticipant: internalMarket.homeParticipant,
                      awayParticipant: internalMarket.awayParticipant,
                      eventId: internalMarket.eventId,
                      marketDigitLine: internalMarket.marketDigitLine,
                      outcomesOrder: outcomesOrder,
                      // event related properties
                      competitionId: internalMarket.competitionId,
                      competitionName: internalMarket.competitionName,
                      sport: mappedSport,
                      sportIdCode: internalMarket.sportIdCode,
                      venueCountry: country,
                      customBetAvailable: internalMarket.customBetAvailable,
                      isMainMarket: internalMarket.isMainMarket)
    }

    static func outcome(fromInternalOutcome internalOutcome: SportRadarModels.Outcome) -> Outcome {
        return Outcome(id: internalOutcome.id,
                       name: internalOutcome.name,
                       odd: internalOutcome.odd,
                       marketId: internalOutcome.marketId,
                       orderValue: internalOutcome.orderValue,
                       externalReference: internalOutcome.externalReference,
                       isTradable: internalOutcome.isTradable ?? true,
                       isTerminated: internalOutcome.isTerminated ?? false,
                       customBetAvailableMarket: internalOutcome.customBetAvailableMarket)
    }

    static func banners(fromInternalBanners internalBanners: [SportRadarModels.Banner]) -> BannerResponse {
        let banners = internalBanners.map({ internalBanner in
            return banner(fromInternalBanner: internalBanner)
        })
        return BannerResponse(bannerItems: banners)
    }

    static func banner(fromInternalBanner internalBanner: SportRadarModels.Banner) -> EventBanner {
        return EventBanner(id: internalBanner.id,
                      name: internalBanner.name,
                      title: internalBanner.title,
                      imageUrl: internalBanner.imageUrl,
                      bodyText: internalBanner.bodyText,
                      type: internalBanner.type,
                      linkUrl: internalBanner.linkUrl,
                      marketId: internalBanner.marketId)
    }

    static func promotionalStoriesResponse(fromInternalPromotionalStoriesResponse internalPromotionalStoriesResponse: SportRadarModels.PromotionalStoriesResponse) -> PromotionalStoriesResponse {

        let promotionalStories = internalPromotionalStoriesResponse.promotionalStories.map({ promotionalStory -> PromotionalStory in

            let mappedPromotionalStory = Self.promotionalStory(fromInternalPromotionalStory: promotionalStory)

            return mappedPromotionalStory

        })

        return PromotionalStoriesResponse(promotionalStories: promotionalStories)

    }

    static func promotionalStory(fromInternalPromotionalStory internalPromotionalStory: SportRadarModels.PromotionalStory) -> PromotionalStory {
        return PromotionalStory(id: internalPromotionalStory.id,
                                title: internalPromotionalStory.title,
                                imageUrl: internalPromotionalStory.imageUrl,
                                linkUrl: internalPromotionalStory.linkUrl,
                                bodyText: internalPromotionalStory.bodyText,
                                callToActionText: nil)
    }

    // Favorites
    static func favoritesListResponse(fromInternalFavoritesListResponse internalFavoritesListResponse: SportRadarModels.FavoritesListResponse) -> FavoritesListResponse {

        let favoritesList = internalFavoritesListResponse.favoritesList.map({ favoriteList -> FavoriteList in
            let favoriteList = Self.favoriteList(fromInternalFavoriteList: favoriteList)

            return favoriteList

        })

        return FavoritesListResponse(favoritesList: favoritesList)

    }

    static func favoriteList(fromInternalFavoriteList internalFavoriteList: SportRadarModels.FavoriteList) -> FavoriteList {
        return FavoriteList(id: internalFavoriteList.id,
                            name: internalFavoriteList.name,
                            customerId: internalFavoriteList.customerId)
    }

    static func favoritesListAddResponse(fromInternalFavoritesListAddResponse internalFavoritesListAddResponse: SportRadarModels.FavoritesListAddResponse) -> FavoritesListAddResponse {

        let favoritesListAddResponse = FavoritesListAddResponse(listId: internalFavoritesListAddResponse.listId)

        return favoritesListAddResponse

    }

    static func favoritesListDeleteResponse(fromInternalFavoritesListDeleteResponse internalFavoritesListDeleteResponse: SportRadarModels.FavoritesListDeleteResponse) -> FavoritesListDeleteResponse {

        let favoritesListDeleteResponse = FavoritesListDeleteResponse(listId: internalFavoritesListDeleteResponse.listId)
        return favoritesListDeleteResponse
    }

    static func favoriteAddResponse(fromInternalFavoriteAddResponse internalFavoriteAddResponse: SportRadarModels.FavoriteAddResponse) -> FavoriteAddResponse {
        let favoriteAddResponse = FavoriteAddResponse(displayOrder: internalFavoriteAddResponse.displayOrder, idAccountFavorite: internalFavoriteAddResponse.idAccountFavorite)
        return favoriteAddResponse
    }

    static func favoritesEventResponse(fromInternalFavoritesEventResponse internalFavoritesEventResponse: SportRadarModels.FavoriteEventResponse) -> FavoriteEventResponse {

        let favoritesEvent = internalFavoritesEventResponse.favoriteEvents.map({ favoriteEvent -> FavoriteEvent in
            let favoriteEvent = Self.favoriteEvent(fromInternalFavoriteEvent: favoriteEvent)
            return favoriteEvent
        })

        return FavoriteEventResponse(favoriteEvents: favoritesEvent)
    }

    static func favoriteEvent(fromInternalFavoriteEvent internalFavoriteEvent: SportRadarModels.FavoriteEvent) -> FavoriteEvent {
        return FavoriteEvent(id: internalFavoriteEvent.id, name: internalFavoriteEvent.name, favoriteListId: internalFavoriteEvent.favoriteListId, accountFavoriteId: internalFavoriteEvent.accountFavoriteId)
    }

    static func topCompetitionData(fromInternalTopCompetitionData internalTopCompetitionData: SportRadarModels.TopCompetitionData) -> TopCompetitionData {

        let topCompetitions = internalTopCompetitionData.competitions.map({ topCompetition -> TopCompetitionPointer in
            let topCompetition = Self.topCompetitionPointer(fromInternalTopCompetitionPointer: topCompetition)
            return topCompetition
        })

        return TopCompetitionData(title: internalTopCompetitionData.title, competitions: topCompetitions)
    }

    static func topCompetitionPointer(fromInternalTopCompetitionPointer internalTopCompetition: SportRadarModels.TopCompetitionPointer) -> TopCompetitionPointer {
        return TopCompetitionPointer(id: internalTopCompetition.id,
                                     name: internalTopCompetition.name,
                                     competitionId: internalTopCompetition.competitionId)
    }

    static func activePlayerServe(fromInternalActivePlayerServe internalActivePlayerServe: SportRadarModels.ActivePlayerServe) -> ActivePlayerServe {
        switch internalActivePlayerServe {
        case .home: return .home
        case .away: return .away
        }
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Mapper/SportRadarModelMapper+PromotedBetslips.swift
````swift
//
//  File.swift
//
//
//  Created by Ruben Roques on 01/08/2024.
//

import Foundation

extension SportRadarModelMapper {
    
    static func promotedBetslipsBatchResponse(fromInternalPromotedBetslipsBatchResponse internalResponse: SportRadarModels.PromotedBetslipsBatchResponse) -> PromotedBetslipsBatchResponse {
        return PromotedBetslipsBatchResponse(
            promotedBetslips: internalResponse.promotedBetslips.map(promotedBetslip(fromInternalPromotedBetslip:))
        )
    }
    
    static func promotedBetslip(fromInternalPromotedBetslip internalBetslip: SportRadarModels.PromotedBetslip) -> PromotedBetslip {
        return PromotedBetslip(
            selections: internalBetslip.selections.map(promotedBetslipSelection(fromInternalPromotedBetslipSelection:)),
            betslipCount: internalBetslip.betslipCount
        )
    }
    
    static func promotedBetslipSelection(fromInternalPromotedBetslipSelection internalSelection: SportRadarModels.PromotedBetslipSelection) -> PromotedBetslipSelection {
        
        let numericSportId = Self.sportNumericId(fromVaixSportId: internalSelection.sportId ?? "") ?? ""

        let alphaSportId = Self.sportAlphaId(fromVaixSportId: internalSelection.sportId ?? "") ?? ""

        let sport = SportType(name: internalSelection.sport ?? "",
                              numericId: numericSportId,
                              alphaId: alphaSportId,
                              iconId: numericSportId,
                              showEventCategory: false,
                              numberEvents: 0,
                              numberOutrightEvents: 0,
                              numberOutrightMarkets: 0,
                              numberLiveEvents: 0)
        
        return PromotedBetslipSelection(id: internalSelection.id ?? "",
                                        countryName: internalSelection.country ?? "international",
                                        competitionName: internalSelection.league ?? "",
                                        eventId: internalSelection.orakoEventId,
                                        marketId: internalSelection.orakoMarketId,
                                        outcomeId: internalSelection.orakoSelectionId,
                                        marketName: internalSelection.marketType ?? "",
                                        outcomeType: internalSelection.outcomeType ?? "",
                                        participantIds: internalSelection.participantIds ?? [],
                                        participants: internalSelection.participants ?? [],
                                        sport: sport,
                                        odd: internalSelection.quote ?? 1.00)

    }
    
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Mapper/SportRadarModelMapper+Sports.swift
````swift
//
//  SportRadarError.swift
//
//
//  Created by Ruben Roques on 10/10/2022.
//

import Foundation
import SharedModels

extension SportRadarModelMapper {

    static func sportType(fromSportRadarSportType sportRadarSportType: SportRadarModels.SportType) -> SportType {

        // Try get the internal sport id by alpha code or name if it fails
        var sportTypeId = ""

        if let sportAlphaId = sportRadarSportType.alphaId {
            sportTypeId = SportTypeInfo.init(alphaCode: sportAlphaId)?.id ?? ""
        }
        else {
            let cleanedSportRadarSportTypeName = Self.simplify(string: sportRadarSportType.name)
            let sportTypeInfoId = SportTypeInfo.allCases.first { sportTypeInfo in
                let cleanedName = Self.simplify(string: sportTypeInfo.name)
                return cleanedName == cleanedSportRadarSportTypeName
            }?.id

            sportTypeId = sportTypeInfoId ?? ""
        }
        
        let sportType = SportType(name: sportRadarSportType.name,
                                  numericId: sportRadarSportType.numericId,
                                  alphaId: sportRadarSportType.alphaId,
                                  iconId: sportTypeId,
                                  showEventCategory: false,
                                  numberEvents: sportRadarSportType.numberEvents,
                                  numberOutrightEvents: sportRadarSportType.numberOutrightEvents,
                                  numberOutrightMarkets: sportRadarSportType.numberOutrightMarkets,
                                  numberLiveEvents: sportRadarSportType.numberLiveEvents)
        return sportType
    }

    static func sportType(fromSportNode sportNode: SportRadarModels.SportNode) -> SportRadarModels.SportType {

        let sportUnique = SportRadarModels.SportType(name: sportNode.name,
                                    numericId: sportNode.id,
                                                     alphaId: sportNode.alphaCode,
                                    numberEvents: sportNode.numberEvents,
                                    numberOutrightEvents: sportNode.numberOutrightEvents,
                                    numberOutrightMarkets: sportNode.numberOutrightMarkets,
                                                     numberLiveEvents: sportNode.numberLiveEvents)
        return sportUnique
    }

    static func sportType(fromScheduledSport scheduledSport: SportRadarModels.ScheduledSport) -> SportRadarModels.SportType {


        let sportUnique = SportRadarModels.SportType(name: scheduledSport.name,
                                                     numericId: nil,
                                                     alphaId: scheduledSport.id,
                                                     numberEvents: 0,
                                                     numberOutrightEvents: 0,
                                                     numberOutrightMarkets: 0, numberLiveEvents: 0)
        return sportUnique

    }
    
    static func sportTypeName(fromAlphaCode alphaCode: String) -> String {
        
        let sportTypeInfoName = SportTypeInfo.init(alphaCode: alphaCode)?.name ?? ""
        
        return sportTypeInfoName
    }

    private static func simplify(string: String) -> String {
        let validChars = Set("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLKMNOPQRSTUVWXYZ1234567890")
        return string.filter { validChars.contains($0) }.lowercased()
    }

    static func sportNodeInfo(fromInternalSportNodeInfo sportNodeInfo: SportRadarModels.SportNodeInfo) -> SportNodeInfo {
        let sportRegionNodes = sportNodeInfo.regionNodes.map(self.sportNodeRegion(fromInternalSportNodeRegion:))

        let sportNodeInfo = SportNodeInfo(id: sportNodeInfo.id, regionNodes: sportRegionNodes, defaultOrder: sportNodeInfo.defaultOrder)

        return sportNodeInfo
    }

    static func sportNodeRegion(fromInternalSportNodeRegion sportNodeRegion: SportRadarModels.SportRegion) -> SportRegion {

        let country: Country? = Country.country(withName: sportNodeRegion.name ?? "")

        let sportRegionNode = SportRegion(id: sportNodeRegion.id,
                                          name: sportNodeRegion.name,
                                          numberEvents: sportNodeRegion.numberEvents,
                                          numberOutrightEvents: sportNodeRegion.numberOutrightEvents,
                                          country: country)

        return sportRegionNode
    }

    static func sportRegionInfo(fromInternalSportRegionInfo sportRegionInfo: SportRadarModels.SportRegionInfo) -> SportRegionInfo {
        let regionCompetitionNodes = sportRegionInfo.competitionNodes.map(SportRadarModelMapper.regionCompetitionNode(fromInternalSportCompetition:))

        let sportRegionInfo = SportRegionInfo(id: sportRegionInfo.id, name: sportRegionInfo.name, competitionNodes: regionCompetitionNodes)

        return sportRegionInfo
    }

    static func regionCompetitionNode(fromInternalSportCompetition sportCompetition: SportRadarModels.SportCompetition) -> SportCompetition {

        let sportCompetition = SportCompetition(id: sportCompetition.id,
                                                name: sportCompetition.name,
                                                numberEvents: sportCompetition.numberEvents,
                                                numberOutrightEvents: sportCompetition.numberOutrightEvents)

        return sportCompetition
    }

    static func sportCompetitionInfo(fromInternalSportCompetitionInfo sportCompetitionInfo: SportRadarModels.SportCompetitionInfo) -> SportCompetitionInfo {
        let marketGroups = sportCompetitionInfo.marketGroups.map(self.competitionMarketGroup(fromInternalSportCompetitionMarketGroup:))

        let sportCompetitionInfo = SportCompetitionInfo(id: sportCompetitionInfo.id,
                                                        name: sportCompetitionInfo.name,
                                                        marketGroups: marketGroups,
                                                        numberOutrightEvents: sportCompetitionInfo.numberOutrightEvents,
                                                        numberOutrightMarkets: sportCompetitionInfo.numberOutrightMarkets)

        return sportCompetitionInfo
    }

    static func competitionMarketGroup(fromInternalSportCompetitionMarketGroup sportCompetitionMarketGroup: SportRadarModels.SportCompetitionMarketGroup) -> SportCompetitionMarketGroup {

        let sportCompetitionMarketGroup = SportCompetitionMarketGroup(id: sportCompetitionMarketGroup.id, name: sportCompetitionMarketGroup.name)

        return sportCompetitionMarketGroup
    }
    
    static func sportNumericId(fromVaixSportId sportId: String) -> String? {
        switch sportId.lowercased() {
        case "sr:sport:1": return "1"
        case "sr:sport:2": return "8"
        case "sr:sport:4": return "6"
        case "sr:sport:5": return "3"
        case "sr:sport:16": return "5"
        case "sr:sport:6": return "7"
        case "sr:sport:23": return "20"
        case "sr:sport:34": return "64"
        case "sr:sport:20": return "63"
        case "sr:sport:31": return nil
        case "sr:sport:12": return "39"
        case "sr:sport:3": return "9"
        case "sr:sport:21": return "26"
        case "sr:sport:22": return "45"
        case "sr:sport:29": return "49"
        case "sr:sport:19": return "36"
        case "sr:sport:40": return "929"
        case "sr:sport:37": return nil
        case "sr:sport:138": return "155"
        case "sr:sport:71": return nil
        case "sr:sport:137": return nil
        default: return nil
        }
    }
    
    static func sportAlphaId(fromVaixSportId sportId: String) -> String? {
        switch sportId.lowercased() {
        case "sr:sport:1": return "FBL"
        case "sr:sport:2": return "BKB"
        case "sr:sport:4": return "HKY"
        case "sr:sport:5": return "TNS"
        case "sr:sport:16": return "UFB"
        case "sr:sport:6": return "HBL"
        case "sr:sport:23": return "VBL"
        case "sr:sport:34": return "BVB"
        case "sr:sport:20": return "TBT"
        case "sr:sport:31": return nil
        case "sr:sport:12": return "39"
        case "sr:sport:3": return "BSB"
        case "sr:sport:21": return "26"
        case "sr:sport:22": return "45"
        case "sr:sport:29": return "49"
        case "sr:sport:19": return "36"
        case "sr:sport:40": return "FO1"
        case "sr:sport:37": return nil
        case "sr:sport:138": return "155"
        case "sr:sport:71": return nil
        case "sr:sport:137": return nil
        default: return nil
        }
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/Mapper/SportRadarModelMapper+User.swift
````swift
//
//  SportRadarError.swift
//
//
//  Created by Ruben Roques on 10/10/2022.
//

import Foundation

extension SportRadarModelMapper {

    static func userProfile(fromPlayerInfoResponse playerInfoResponse: SportRadarModels.PlayerInfoResponse, withKycExpire kycExpire: String? = nil) -> UserProfile? {

        let userRegistrationStatus = UserRegistrationStatus(fromStringKey: playerInfoResponse.registrationStatus ?? "")
        let emailVerificationStatus = EmailVerificationStatus(fromStringKey:  playerInfoResponse.emailVerificationStatus)
        let knowYourCustomerStatus = KnowYourCustomerStatus(fromStringKey: playerInfoResponse.kycStatus ?? "")
        let lockedStatus = LockedStatus(fromStringKey: playerInfoResponse.lockedStatus ?? "")
        let hasMadeDeposit = playerInfoResponse.madeDeposit ?? false

        var avatarName: String?
        var godfatherCode: String?
        // var placeOfBirth: String?
        var additionalStreetLine: String?

        for extraInfo in playerInfoResponse.extraInfos ?? [] {
            switch extraInfo.key {
            case "avatar": avatarName = extraInfo.value
            case "godfatherCode": godfatherCode = extraInfo.value
            //case "placeOfBirth": placeOfBirth = extraInfo.value
            case "streetLine2": additionalStreetLine = extraInfo.value
            default: ()
            }
        }

        var currency: String?

        if playerInfoResponse.currency == "EUR" {
            currency = "€"
        }
        else if playerInfoResponse.currency == "USD" {
            currency = "$"
        }
        else if playerInfoResponse.currency == "GBP" {
            currency = "£"
        }
        else {
            currency = "€"
        }

        let nationalityCode = playerInfoResponse.birthCoutryCode ?? playerInfoResponse.nationality
        
        return UserProfile(userIdentifier: playerInfoResponse.partyId,
                           sessionKey: playerInfoResponse.sessionKey ?? "",
                           username: playerInfoResponse.userId,
                           email: playerInfoResponse.email,
                           firstName: playerInfoResponse.firstName,
                           middleName: playerInfoResponse.middleName,
                           lastName: playerInfoResponse.lastName,
                           birthDate: playerInfoResponse.birthDateFormatted,
                           gender: playerInfoResponse.gender,
                           nationalityCode: nationalityCode,
                           countryCode: playerInfoResponse.country,
                           personalIdNumber: playerInfoResponse.idCardNumber,
                           address: playerInfoResponse.address,
                           province: playerInfoResponse.province,
                           city: playerInfoResponse.city,
                           postalCode: playerInfoResponse.postalCode,
                           birthDepartment: playerInfoResponse.birthDepartment,
                           streetNumber: playerInfoResponse.streetNumber,
                           phoneNumber: playerInfoResponse.phone,
                           mobilePhone: playerInfoResponse.mobilePhone,
                           mobileCountryCode: playerInfoResponse.mobileCountryCode,
                           mobileLocalNumber: playerInfoResponse.mobileLocalNumber,
                           avatarName: avatarName,
                           godfatherCode: godfatherCode,
                           placeOfBirth: playerInfoResponse.birthCity,
                           additionalStreetLine: additionalStreetLine,
                           emailVerificationStatus: emailVerificationStatus,
                           userRegistrationStatus: userRegistrationStatus,
                           kycStatus: knowYourCustomerStatus,
                           lockedStatus: lockedStatus,
                           hasMadeDeposit: hasMadeDeposit,
                           kycExpiryDate: kycExpire,
                           currency: currency)

    }

    static func userOverview(fromInternalLoginResponse loginResponse: SportRadarModels.LoginResponse) -> UserOverview? {
        guard
            let sessionKey = loginResponse.sessionKey,
            let username = loginResponse.username,
            let email = loginResponse.email
        else {
            return nil
        }
        return UserOverview(sessionKey: sessionKey,
                            username: username,
                            email: email,
                            partyID: loginResponse.partyId,
                            language: loginResponse.language,
                            currency: loginResponse.currency,
                            parentID: loginResponse.parentId,
                            level: loginResponse.level,
                            userType: loginResponse.userType,
                            isFirstLogin: loginResponse.isFirstLogin,
                            registrationStatus: loginResponse.registrationStatus,
                            country: loginResponse.country,
                            kycStatus: loginResponse.kycStatus,
                            lockStatus: loginResponse.lockStatus)
    }

    static func userWallet(fromBalanceResponse playerInfoResponse: SportRadarModels.BalanceResponse) -> UserWallet {
        return UserWallet(vipStatus: playerInfoResponse.vipStatus,
                           currency: playerInfoResponse.currency,
                           loyaltyPoint: playerInfoResponse.loyaltyPoint,
                           totalString: playerInfoResponse.totalBalance,
                           total: playerInfoResponse.totalBalanceNumber,
                           withdrawableString: playerInfoResponse.withdrawableBalance,
                           withdrawable: playerInfoResponse.withdrawableBalanceNumber,
                           bonusString: playerInfoResponse.bonusBalance,
                           bonus: playerInfoResponse.bonusBalanceNumber,
                           pendingBonusString: playerInfoResponse.pendingBonusBalance,
                           pendingBonus: playerInfoResponse.pendingBonusBalanceNumber,
                           casinoPlayableBonusString: playerInfoResponse.casinoPlayableBonusBalance,
                           casinoPlayableBonus: playerInfoResponse.casinoPlayableBonusBalanceNumber,
                           sportsbookPlayableBonusString: playerInfoResponse.sportsbookPlayableBonusBalance,
                           sportsbookPlayableBonus: playerInfoResponse.sportsbookPlayableBonusBalanceNumber,
                           withdrawableEscrowString: playerInfoResponse.withdrawableEscrowBalance,
                           withdrawableEscrow: playerInfoResponse.withdrawableEscrowBalanceNumber,
                           totalWithdrawableString: playerInfoResponse.totalWithdrawableBalance,
                           totalWithdrawable: playerInfoResponse.totalWithdrawableBalanceNumber,
                           withdrawRestrictionAmountString: playerInfoResponse.withdrawRestrictionAmount,
                           withdrawRestrictionAmount: playerInfoResponse.withdrawRestrictionAmountNumber,
                           totalEscrowString: playerInfoResponse.totalEscrowBalance,
                           totalEscrow: playerInfoResponse.totalEscrowBalanceNumber)
    }

    static func cashbackBalance(fromCashbackBalance cashbackBalance: SportRadarModels.CashbackBalance) -> CashbackBalance {
        
        return CashbackBalance(status: cashbackBalance.status,
                               balance: cashbackBalance.balance,
                               message: cashbackBalance.message)
    }
}

extension SportRadarModelMapper {

    static func documentTypesResponse(fromDocumentTypesResponse internalDocumentTypesResponse: SportRadarModels.DocumentTypesResponse) -> DocumentTypesResponse {

        let documentTypes = internalDocumentTypesResponse.documentTypes.map({ documentType -> DocumentType in
            let documentType = Self.documentType(fromDocumentType: documentType)

            return documentType

        })

        return DocumentTypesResponse(status: internalDocumentTypesResponse.status, documentTypes: documentTypes)
    }

    static func documentType(fromDocumentType internalDocumentType: SportRadarModels.DocumentType) -> DocumentType {

        let documentTypeGroup = DocumentTypeGroup.init(documentType: internalDocumentType.documentType)

        return DocumentType(documentType: internalDocumentType.documentType, issueDateRequired: internalDocumentType.issueDateRequired, expiryDateRequired: internalDocumentType.expiryDateRequired, documentNumberRequired: internalDocumentType.documentNumberRequired, documentTypeGroup: documentTypeGroup,
                            multipleFileRequired: internalDocumentType.multipleFileRequired)
    }

    static func userDocumentsResponse(fromUserDocumentsResponse internalUserDocumentsResponse: SportRadarModels.UserDocumentsResponse) -> UserDocumentsResponse {

        let userDocuments = internalUserDocumentsResponse.userDocuments.map({ userDocument -> UserDocument in
            let userDocument = Self.userDocument(fromUserDocument: userDocument)

            return userDocument

        })

        return UserDocumentsResponse(status: internalUserDocumentsResponse.status, userDocuments: userDocuments)
    }

    static func userDocument(fromUserDocument internalUserDocument: SportRadarModels.UserDocument) -> UserDocument {

        if let userDocumentFiles = internalUserDocument.userDocumentFiles {

            let mappedUserDocumentFiles = userDocumentFiles.map({ userDocumentFile -> UserDocumentFile in

                let userDocumentFile = Self.userDocumentFile(fromUserDocumentFile: userDocumentFile)

                return userDocumentFile

            })

            return UserDocument(documentType: internalUserDocument.documentType, fileName: internalUserDocument.fileName, status: internalUserDocument.status, uploadDate: internalUserDocument.uploadDate,
            userDocumentFiles: mappedUserDocumentFiles)

        }

        return UserDocument(documentType: internalUserDocument.documentType, fileName: internalUserDocument.fileName, status: internalUserDocument.status, uploadDate: internalUserDocument.uploadDate)
    }

    static func userDocumentFile(fromUserDocumentFile internalUserDocumentFile: SportRadarModels.UserDocumentFile) -> UserDocumentFile {

        return UserDocumentFile(fileName: internalUserDocumentFile.fileName)
    }

    static func uploadDocumentResponse(fromUploadDocumentResponse internalUploadDocumentResponse: SportRadarModels.UploadDocumentResponse) -> UploadDocumentResponse {

        return UploadDocumentResponse(status: internalUploadDocumentResponse.status, message: internalUploadDocumentResponse.message)
    }

    static func paymentsResponse(fromPaymentsResponse internalPaymentsResponse: SportRadarModels.PaymentsResponse) -> PaymentsResponse {

        let depositMethods = internalPaymentsResponse.depositMethods.map({ depositMethod -> DepositMethod in
            let depositMethod = Self.depositMethod(fromDepositMethod: depositMethod)

            return depositMethod

        })

        return PaymentsResponse(status: internalPaymentsResponse.status, depositMethods: depositMethods)
    }

    static func depositMethod(fromDepositMethod internalDepositMethod: SportRadarModels.DepositMethod) -> DepositMethod {

        if let methods = internalDepositMethod.methods {
            let paymentMethods = methods.map({ paymentMethod -> PaymentMethod in
                let paymentMethod = Self.paymentMethod(fromPaymentMethod: paymentMethod)

                return paymentMethod

            })

            return DepositMethod(code: internalDepositMethod.code, paymentMethod: internalDepositMethod.paymentMethod, methods: paymentMethods)
        }

        return DepositMethod(code: internalDepositMethod.code, paymentMethod: internalDepositMethod.paymentMethod, methods: [])
    }

    static func paymentMethod(fromPaymentMethod internalPaymentMethod: SportRadarModels.PaymentMethod) -> PaymentMethod {

        return PaymentMethod(name: internalPaymentMethod.name, type: internalPaymentMethod.type, brands: internalPaymentMethod.brands)
    }

    static func processDepositResponse(fromProcessDepositResponse internalProcessDepositResponse: SportRadarModels.ProcessDepositResponse) -> ProcessDepositResponse {

        return ProcessDepositResponse(status: internalProcessDepositResponse.status, paymentId: internalProcessDepositResponse.paymentId, continueUrl: internalProcessDepositResponse.continueUrl, clientKey: internalProcessDepositResponse.clientKey, sessionId: internalProcessDepositResponse.sessionId,
                                      sessionData: internalProcessDepositResponse.sessionData)
    }

    static func updatePaymentResponse(fromUpdatePaymentResponse internalUpdatePaymentResponse: SportRadarModels.UpdatePaymentResponse) -> UpdatePaymentResponse {

        var action: UpdatePaymentAction? = nil
        if let internalAction = internalUpdatePaymentResponse.action {
            action = Self.updatePaymentAction(fromUpdatePaymentAction: internalAction)
        }
        return UpdatePaymentResponse(resultCode: internalUpdatePaymentResponse.resultCode, action: action)
    }

    static func withdrawalMethodsResponse(fromWithdrawalMethodsResponse internalWithdrawalMethodsResponse: SportRadarModels.WithdrawalMethodsResponse) -> WithdrawalMethodsResponse {

        let withdrawalMethods = internalWithdrawalMethodsResponse.withdrawalMethods.map({ withdrawalMethod -> WithdrawalMethod in
            let withdrawalMethod = Self.withdrawalMethod(fromWithdrawalMethod: withdrawalMethod)

            return withdrawalMethod

        })

        return WithdrawalMethodsResponse(status: internalWithdrawalMethodsResponse.status,
                                         withdrawalMethods: withdrawalMethods)
    }

    static func withdrawalMethod(fromWithdrawalMethod internalWithdrawalMethod: SportRadarModels.WithdrawalMethod) -> WithdrawalMethod {

        return WithdrawalMethod(code: internalWithdrawalMethod.code,
                                paymentMethod: internalWithdrawalMethod.paymentMethod,
                                minimumWithdrawal: internalWithdrawalMethod.minimumWithdrawal,
                                maximumWithdrawal: internalWithdrawalMethod.maximumWithdrawal,
                                conversionRequired: internalWithdrawalMethod.conversionRequired)
    }

    static func processWithdrawalResponse(fromProcessWithdrawalResponse internalProcessWithdrawalResponse: SportRadarModels.ProcessWithdrawalResponse) -> ProcessWithdrawalResponse {

        return ProcessWithdrawalResponse(status: internalProcessWithdrawalResponse.status,
                                         paymentId: internalProcessWithdrawalResponse.paymentId,
                                         message: internalProcessWithdrawalResponse.message)
    }
    
    static func prepareWithdrawalResponse(fromPrepareWithdrawalResponse internalPrepareWithdrawalResponse: SportRadarModels.PrepareWithdrawalResponse) -> PrepareWithdrawalResponse {

        return PrepareWithdrawalResponse(status: internalPrepareWithdrawalResponse.status, conversionId: internalPrepareWithdrawalResponse.conversionId, message: internalPrepareWithdrawalResponse.message)
    }

    static func pendingWithdrawalResponse(fromPendingWithdrawalResponse internalPendingWithdrawalResponse: SportRadarModels.PendingWithdrawalResponse) -> PendingWithdrawalResponse {

        let pendingWithdrawals = internalPendingWithdrawalResponse.pendingWithdrawals.map({ pendingWithdrawal -> PendingWithdrawal in
            let pendingWithdrawal = Self.pendingWithdrawal(fromPendingWithdrawal: pendingWithdrawal)

            return pendingWithdrawal

        })

        return PendingWithdrawalResponse(status: internalPendingWithdrawalResponse.status,
                                         pendingWithdrawals: pendingWithdrawals)
    }

    static func pendingWithdrawal(fromPendingWithdrawal internalPendingWithdrawal: SportRadarModels.PendingWithdrawal) -> PendingWithdrawal {

        return PendingWithdrawal(status: internalPendingWithdrawal.status,
                                 paymentId: internalPendingWithdrawal.paymentId,
                                 amount: internalPendingWithdrawal.amount)
    }

    static func cancelWithdrawalResponse(fromCancelWithdrawalResponse internalCancelWithdrawalResponse: SportRadarModels.CancelWithdrawalResponse) -> CancelWithdrawalResponse {

        return CancelWithdrawalResponse(status: internalCancelWithdrawalResponse.status,
                                        amount: internalCancelWithdrawalResponse.amount,
                                        currency: internalCancelWithdrawalResponse.currency)
    }

    static func updatePaymentAction(fromUpdatePaymentAction internalUpdatePaymentAction: SportRadarModels.UpdatePaymentAction) -> UpdatePaymentAction {

        return UpdatePaymentAction(paymentMethodType: internalUpdatePaymentAction.paymentMethodType,
                                   url: internalUpdatePaymentAction.url,
                                   method: internalUpdatePaymentAction.method,
                                   type: internalUpdatePaymentAction.type)
    }

    static func paymentInformation(fromPaymentInformation internalPaymentInformation: SportRadarModels.PaymentInformation) -> PaymentInformation {

        let bankPaymentInfo = internalPaymentInformation.data.map({ bankPaymentInfo -> BankPaymentInfo in
            let bankPaymentInfo = Self.bankPaymentInfo(fromBankPaymentInfo: bankPaymentInfo)

            return bankPaymentInfo

        })

        return PaymentInformation(status: internalPaymentInformation.status,
                                  data: bankPaymentInfo)
    }

    static func bankPaymentInfo(fromBankPaymentInfo internalBankPaymentInfo: SportRadarModels.BankPaymentInfo) -> BankPaymentInfo {

        let bankPaymentDetails = internalBankPaymentInfo.details.map({ bankPaymentDetail -> BankPaymentDetail in

            let bankPaymentDetail = Self.bankPaymentDetail(fromBankPaymentDetail: bankPaymentDetail)

            return bankPaymentDetail

        })

        return BankPaymentInfo(id: internalBankPaymentInfo.id, partyId: internalBankPaymentInfo.partyId, type: internalBankPaymentInfo.type, description: internalBankPaymentInfo.description, priority: internalBankPaymentInfo.priority, details: bankPaymentDetails)
    }

    static func bankPaymentDetail(fromBankPaymentDetail internalBankPaymentDetail: SportRadarModels.BankPaymentDetail) -> BankPaymentDetail {

        return BankPaymentDetail(id: internalBankPaymentDetail.id, paymentInfoId: internalBankPaymentDetail.paymentInfoId, key: internalBankPaymentDetail.key, value: internalBankPaymentDetail.value)
    }

    static func addPaymentInformationResponse(fromAddPaymentInformationResponse internalAddPaymentInformationResponse: SportRadarModels.AddPaymentInformationResponse) -> AddPaymentInformationResponse {

        return AddPaymentInformationResponse(status: internalAddPaymentInformationResponse.status, message: internalAddPaymentInformationResponse.message)
    }

    static func personalDepositLimitsResponse(fromPersonalDepositLimitsResponse internalPersonalDepositLimitsResponse: SportRadarModels.PersonalDepositLimitResponse) -> PersonalDepositLimitResponse {

        return PersonalDepositLimitResponse(status: internalPersonalDepositLimitsResponse.status, dailyLimit: internalPersonalDepositLimitsResponse.dailyLimit, weeklyLimit: internalPersonalDepositLimitsResponse.weeklyLimit, monthlyLimit: internalPersonalDepositLimitsResponse.monthlyLimit, currency: internalPersonalDepositLimitsResponse.currency,
                                            hasPendingWeeklyLimit: internalPersonalDepositLimitsResponse.hasPendingWeeklyLimit,
                                            pendingWeeklyLimit: internalPersonalDepositLimitsResponse.pendingWeeklyLimit,
                                            pendingWeeklyLimitEffectiveDate: internalPersonalDepositLimitsResponse.pendingWeeklyLimitEffectiveDate)
    }

    static func limitsResponse(fromInternalLimitsResponse internalLimitsResponse: SportRadarModels.LimitsResponse) -> LimitsResponse {

        if let limitPending = internalLimitsResponse.pendingWagerLimit {

            return LimitsResponse(status: internalLimitsResponse.status, wagerLimit: internalLimitsResponse.wagerLimit, lossLimit: internalLimitsResponse.lossLimit, currency: internalLimitsResponse.currency,
                                  pendingWagerLimit: Self.limitPending(fromInternalLimitPending: limitPending))
        }

        return LimitsResponse(status: internalLimitsResponse.status, wagerLimit: internalLimitsResponse.wagerLimit, lossLimit: internalLimitsResponse.lossLimit, currency: internalLimitsResponse.currency,
                              pendingWagerLimit: nil)
    }

    static func limitPending(fromInternalLimitPending internalLimitPending: SportRadarModels.LimitPending) -> LimitPending {

        return LimitPending(effectiveDate: internalLimitPending.effectiveDate, limit: internalLimitPending.limit, limitNumber: internalLimitPending.limitNumber)
    }

    static func responsibleGamingLimitsResponse(fromResponsibleGamingLimitsResponse internalResponsibleGamingLimitsResponse: SportRadarModels.ResponsibleGamingLimitsResponse) -> ResponsibleGamingLimitsResponse {

        let responsibleGamingLimits = internalResponsibleGamingLimitsResponse.limits.map({ responsibleGamingLimit -> ResponsibleGamingLimit in

            let responsibleGamingLimit = Self.responsibleGamingLimit(fromResponsibleGamingLimit: responsibleGamingLimit)

            return responsibleGamingLimit

        })

        return ResponsibleGamingLimitsResponse(status: internalResponsibleGamingLimitsResponse.status, limits: responsibleGamingLimits)
    }

    static func responsibleGamingLimit(fromResponsibleGamingLimit internalResponsibleGamingLimit: SportRadarModels.ResponsibleGamingLimit) -> ResponsibleGamingLimit {
        return ResponsibleGamingLimit(id: internalResponsibleGamingLimit.id, partyId: internalResponsibleGamingLimit.partyId, limitType: internalResponsibleGamingLimit.limitType, periodType: internalResponsibleGamingLimit.periodType, effectiveDate: internalResponsibleGamingLimit.effectiveDate, expiryDate: internalResponsibleGamingLimit.expiryDate, limit: internalResponsibleGamingLimit.limit)
    }

    static func basicResponse(fromInternalBasicResponse internalBasicResponse: SportRadarModels.BasicResponse) -> BasicResponse {
        return BasicResponse(status: internalBasicResponse.status, message: internalBasicResponse.message)
    }
    
    static func mobileVerifyResponse(fromInternalMobileVerifyResponse internalMobileVerifyResponse: SportRadarModels.MobileVerifyResponse) -> MobileVerifyResponse {
        let requestIdString: String? = internalMobileVerifyResponse.requestId != nil ? String(internalMobileVerifyResponse.requestId ?? -1) : nil
        return MobileVerifyResponse(status: internalMobileVerifyResponse.status,
                                    message: internalMobileVerifyResponse.message,
                                    requestId: requestIdString)
    }
    
    static func paymentStatusResponse(fromPaymentStatusResponse paymentStatusResponse: SportRadarModels.PaymentStatusResponse) -> PaymentStatusResponse {
        return PaymentStatusResponse(status: paymentStatusResponse.status,
                                     paymentId: paymentStatusResponse.paymentId,
                                     paymentStatus: paymentStatusResponse.paymentStatus,
                                     message: paymentStatusResponse.message)
    }
    
    static func supportResponse(fromInternalSupportResponse internalSupportResponse: SportRadarModels.SupportResponse) -> SupportResponse {

        if let supportRequest = internalSupportResponse.request {
            let mappedSupportRequest = Self.supportRequest(fromInternalSupportRequest: supportRequest)

            return SupportResponse(request: mappedSupportRequest, error: internalSupportResponse.error, description: internalSupportResponse.description)

        }

        return SupportResponse(request: nil, error: internalSupportResponse.error, description: internalSupportResponse.description)
    }

    static func supportRequest(fromInternalSupportRequest internalSupportRequest: SportRadarModels.SupportRequest) -> SupportRequest {

        return SupportRequest(id: internalSupportRequest.id, status: internalSupportRequest.status)
    }

    static func transactionsHistoryResponse(fromTransactionsHistoryResponse internalTransactionsHistoryResponse: SportRadarModels.TransactionsHistoryResponse) -> TransactionsHistoryResponse {

        if let transactionDetails = internalTransactionsHistoryResponse.transactions {

            let transactions = transactionDetails.map({ transactionDetail -> TransactionDetail in
                let transactionDetail = Self.transactionDetail(fromInternalTransactionDetail: transactionDetail)

                return transactionDetail

            })

            return TransactionsHistoryResponse(status: internalTransactionsHistoryResponse.status, transactions: transactions)
        }

        return TransactionsHistoryResponse(status: internalTransactionsHistoryResponse.status, transactions: [])
    }

    static func transactionDetail(fromInternalTransactionDetail internalTransactionDetail: SportRadarModels.TransactionDetail) -> TransactionDetail {

        var transactionType = TransactionType.init(transactionType: internalTransactionDetail.type, escrowType: internalTransactionDetail.escrowType)

        if transactionType == .automatedWithdrawalThreshold {
            let transactionReference = internalTransactionDetail.reference
            
            if transactionReference == "Escrow Auto Withdrawal"
            {
                transactionType = .automatedWithdrawal
            }
        }

        let date: Date = OmegaAPIClient.parseOmegaDateString(internalTransactionDetail.dateTime) ?? Date(timeIntervalSinceReferenceDate: 0)
                
        return TransactionDetail(id: internalTransactionDetail.id,
                                 date: date,
                                 type: transactionType,
                                 amount: internalTransactionDetail.amount,
                                 postBalance: internalTransactionDetail.postBalance,
                                 amountBonus: internalTransactionDetail.amountBonus,
                                 postBalanceBonus: internalTransactionDetail.postBalanceBonus,
                                 currency: internalTransactionDetail.currency,
                                 paymentId: internalTransactionDetail.paymentId,
                                 gameTranId: internalTransactionDetail.gameTranId,
                                 reference: internalTransactionDetail.reference,
                                 escrowTranType: internalTransactionDetail.escrowTranType,
                                 escrowTranSubType: internalTransactionDetail.escrowTranSubType,
                                 escrowType: internalTransactionDetail.escrowType)
    }

    static func grantedBonusesResponse(fromGrantedBonusesResponse internalGrantedBonusesResponse: SportRadarModels.GrantedBonusResponse) -> GrantedBonusResponse {

        let bonuses = internalGrantedBonusesResponse.bonuses.map({ grantedBonus -> GrantedBonus in
            let grantedBonus = Self.grantedBonus(fromInternalGrantedBonus: grantedBonus)

            return grantedBonus

        })

        return GrantedBonusResponse(status: internalGrantedBonusesResponse.status, bonuses: bonuses)
    }

    static func grantedBonus(fromInternalGrantedBonus internalGrantedBonus: SportRadarModels.GrantedBonus) -> GrantedBonus {

        let triggerDate: Date? = OmegaAPIClient.parseOmegaDateString(internalGrantedBonus.triggerDate)
        let expiryDate: Date? = OmegaAPIClient.parseOmegaDateString(internalGrantedBonus.expiryDate)
        
        return GrantedBonus(id: internalGrantedBonus.id,
                            name: internalGrantedBonus.name,
                            status: internalGrantedBonus.status,
                            amount: internalGrantedBonus.amount,
                            triggerDate: triggerDate,
                            expiryDate: expiryDate,
                            wagerRequirement: internalGrantedBonus.wagerRequirement,
                            amountWagered: internalGrantedBonus.amountWagered)
    }

    static func availableBonusesResponse(fromAvailableBonusesResponse internalAvailableBonusesResponse: SportRadarModels.AvailableBonusResponse) -> AvailableBonusResponse {

        let bonuses = internalAvailableBonusesResponse.bonuses.map({ availableBonus -> AvailableBonus in
            let availableBonus = Self.availableBonus(fromInternAlavailableBonus: availableBonus)

            return availableBonus

        })

        return AvailableBonusResponse(status: internalAvailableBonusesResponse.status, bonuses: bonuses)
    }

    static func availableBonus(fromInternAlavailableBonus internalAvailableBonus: SportRadarModels.AvailableBonus) -> AvailableBonus {

        let triggerDate: Date? = OmegaAPIClient.parseOmegaDateString(internalAvailableBonus.triggerDate)
        let expiryDate: Date? = OmegaAPIClient.parseOmegaDateString(internalAvailableBonus.expiryDate)

        return AvailableBonus(id: internalAvailableBonus.id,
                              bonusPlanId: internalAvailableBonus.bonusPlanId,
                              name: internalAvailableBonus.name,
                              description: internalAvailableBonus.description,
                              type: internalAvailableBonus.type,
                              amount: internalAvailableBonus.amount,
                              triggerDate: triggerDate,
                              expiryDate: expiryDate,
                              wagerRequirement: internalAvailableBonus.wagerRequirement,
                              imageUrl: internalAvailableBonus.imageUrl)
    }

    static func redeemBonusesResponse(fromRedeemBonusesResponse internalRedeemBonusesResponse: SportRadarModels.RedeemBonusResponse) -> RedeemBonusResponse {

        if let redeemBonus = internalRedeemBonusesResponse.bonus {

            let bonus = Self.redeemBonus(fromRedeemBonus: redeemBonus)

            return RedeemBonusResponse(status: internalRedeemBonusesResponse.status, message: internalRedeemBonusesResponse.message, bonus: bonus)
        }

        return RedeemBonusResponse(status: internalRedeemBonusesResponse.status, message: internalRedeemBonusesResponse.message)
    }

    static func redeemBonus(fromRedeemBonus internalRedeemBonus: SportRadarModels.RedeemBonus) -> RedeemBonus {
       
        let triggerDate: Date? = OmegaAPIClient.parseOmegaDateString(internalRedeemBonus.triggerDate)
        let expiryDate: Date? = OmegaAPIClient.parseOmegaDateString(internalRedeemBonus.expiryDate)

        return RedeemBonus(id: internalRedeemBonus.id,
                           name: internalRedeemBonus.name,
                           status: internalRedeemBonus.status,
                           triggerDate: triggerDate,
                           expiryDate: expiryDate,
                           amount: internalRedeemBonus.amount,
                           wagerRequired: internalRedeemBonus.wagerRequired,
                           amountWagered: internalRedeemBonus.amountWagered)
    }

    static func userConsentResponse(fromUserConsentsResponse internalUserConsentsResponse: SportRadarModels.UserConsentsResponse) -> UserConsentsResponse {

        let userConsents = internalUserConsentsResponse.userConsents.map({ userConsent -> UserConsent in

            let userConsent = Self.userConsent(fromUserConsent: userConsent)

            return userConsent
        })

        return UserConsentsResponse(status: internalUserConsentsResponse.status, message: internalUserConsentsResponse.message, userConsents: userConsents)
    }

    static func userConsent(fromUserConsent internalUserConsent: SportRadarModels.UserConsent) -> UserConsent {

        let userConsentInfo = Self.userConsentInfo(fromUserConsentInfo: internalUserConsent.consentInfo)

        var userConsentStatus: UserConsentStatus = .unknown

        if internalUserConsent.consentStatus == "NOT_CONSENTED" {
            userConsentStatus = .notConsented
        }
        else if internalUserConsent.consentStatus == "CONSENTED" {
            userConsentStatus = .consented
        }
        else {
            userConsentStatus = .unknown
        }

        var userConsentType: UserConsentType = .unknown

        if userConsentInfo.key == "sms_promotions" {
            userConsentType = .sms
        }
        else if userConsentInfo.key == "email_promotions" {
            userConsentType = .email
        }
        else if userConsentInfo.key == "terms" {
            userConsentType = .terms
        }

        return UserConsent(info: userConsentInfo, status: userConsentStatus, type: userConsentType)
    }

    static func userConsentInfo(fromUserConsentInfo internalUserConsentInfo: SportRadarModels.UserConsentInfo) -> UserConsentInfo {

        return UserConsentInfo(id: internalUserConsentInfo.id,
                               key: internalUserConsentInfo.key,
                               name: internalUserConsentInfo.name,
                               consentVersionId: internalUserConsentInfo.consentVersionId,
                               isMandatory: internalUserConsentInfo.isMandatory)
    }

    static func accessTokenResponse(fromInternalAccessTokenResponse internalAccessTokenResponse: SportRadarModels.AccessTokenResponse) -> AccessTokenResponse {

        return AccessTokenResponse(token: internalAccessTokenResponse.token, userId: internalAccessTokenResponse.userId, description: internalAccessTokenResponse.description, code: internalAccessTokenResponse.code)
    }

    static func applicantDataResponse(fromInternalApplicantDataResponse internalApplicantDataResponse: SportRadarModels.ApplicantDataResponse) -> ApplicantDataResponse {

        if let info = internalApplicantDataResponse.info,
           let reviewData = internalApplicantDataResponse.reviewData {

            let mappedInfo = Self.applicantDataInfo(fromInternalApplicantDataInfo: info)

            let mappedReviewData = Self.applicantReviewData(fromInternalApplicantReviewData: reviewData)

            return ApplicantDataResponse(externalUserId: internalApplicantDataResponse.externalUserId, info: mappedInfo, reviewData: mappedReviewData, description: internalApplicantDataResponse.description)
        }
        else if let reviewData = internalApplicantDataResponse.reviewData {
            
            let mappedReviewData = Self.applicantReviewData(fromInternalApplicantReviewData: reviewData)

            return ApplicantDataResponse(externalUserId: internalApplicantDataResponse.externalUserId, info: nil, reviewData: mappedReviewData, description: internalApplicantDataResponse.description)
        }

        return ApplicantDataResponse(externalUserId: internalApplicantDataResponse.externalUserId, info: nil, reviewData: nil, description: internalApplicantDataResponse.description)
    }

    static func applicantDataInfo(fromInternalApplicantDataInfo internalApplicantDataInfo: SportRadarModels.ApplicantDataInfo) -> ApplicantDataInfo {

        if let applicantDocs = internalApplicantDataInfo.applicantDocs {

            let mappedApplicantDocs = applicantDocs.map({
                applicantDoc -> ApplicantDoc in

                let applicantDoc = Self.applicantDoc(fromInternalApplicantDoc: applicantDoc)

                return applicantDoc
            })

            return ApplicantDataInfo(applicantDocs: mappedApplicantDocs)
        }

        return ApplicantDataInfo(applicantDocs: [])
    }

    static func applicantDoc(fromInternalApplicantDoc internalApplicantDoc: SportRadarModels.ApplicantDoc) -> ApplicantDoc {

        return ApplicantDoc(docType: internalApplicantDoc.docType)
    }

    static func applicantReviewData(fromInternalApplicantReviewData internalApplicantReviewData: SportRadarModels.ApplicantReviewData) -> ApplicantReviewData {

        if let applicantReviewResult = internalApplicantReviewData.reviewResult {

            let mappedApplicantReviewResult = Self.applicantReviewResult(fromInternalApplicantReviewResult: applicantReviewResult)

            return ApplicantReviewData(attemptCount: internalApplicantReviewData.attemptCount, createDate: internalApplicantReviewData.createDate, reviewDate: internalApplicantReviewData.reviewDate, reviewResult: mappedApplicantReviewResult, reviewStatus: internalApplicantReviewData.reviewStatus, levelName: internalApplicantReviewData.levelName)
        }


        return ApplicantReviewData(attemptCount: internalApplicantReviewData.attemptCount, createDate: internalApplicantReviewData.createDate, reviewDate: internalApplicantReviewData.reviewDate, reviewResult: nil, reviewStatus: internalApplicantReviewData.reviewStatus,
                                   levelName: internalApplicantReviewData.levelName)
    }

    static func applicantReviewResult(fromInternalApplicantReviewResult internalApplicantReviewResult: SportRadarModels.ApplicantReviewResult) -> ApplicantReviewResult {

        return ApplicantReviewResult(reviewAnswer: internalApplicantReviewResult.reviewAnswer, reviewRejectType: internalApplicantReviewResult.reviewRejectType,
                                     moderationComment: internalApplicantReviewResult.moderationComment)
    }

    static func referralResponse(fromInternalReferralResponse internalReferralResponse: SportRadarModels.ReferralResponse) -> ReferralResponse {
        
        let referralLinks = internalReferralResponse.referralLinks.map( {
            Self.referralLink(fromInternalReferralLink: $0)
        })
        
        return ReferralResponse(status: internalReferralResponse.status, referralLinks: referralLinks)
    }
    
    static func referralLink(fromInternalReferralLink internalReferralLin: SportRadarModels.ReferralLink) -> ReferralLink {
        
        return ReferralLink(code: internalReferralLin.code, link: internalReferralLin.link)
    }
    
    static func refereesResponse(fromInternalRefereesResponse internalRefereesResponse: SportRadarModels.RefereesResponse) -> RefereesResponse {
        
        let referees = internalRefereesResponse.referees.map( {
            Self.referee(fromInternalReferee: $0)
        })
        
        return RefereesResponse(status: internalRefereesResponse.status, referees: referees)
    }
    
    static func referee(fromInternalReferee internalReferee: SportRadarModels.Referee) -> Referee {
        
        return Referee(id: internalReferee.id, username: internalReferee.username, registeredAt: internalReferee.registeredAt, kycStatus: internalReferee.kycStatus, depositPassed: internalReferee.depositPassed)
    }
}

private extension UserRegistrationStatus {
    init(fromStringKey key: String) {
        switch key.uppercased() {
        case "QUICK_OPEN":
            self = .quickOpen
        case "QUICK_REG":
            self = .quickRegister
        case "PLAYER":
            self = .completed
        default:
            self = .quickOpen
        }
    }
}

private extension EmailVerificationStatus {
    init(fromStringKey key: String) {
        switch key.uppercased() {
        case "VERIFIED":
            self = .verified
        default:
            self = .unverified
        }
    }
}

private extension KnowYourCustomerStatus {
    init(fromStringKey key: String) {
        switch key.uppercased() {
        case "PASS":
            self = .pass
        case "PASS_COND":
            self = .passConditional
        default:
            self = .request
        }
    }
}

private extension LockedStatus {
    init(fromStringKey key: String) {
        switch key.uppercased() {
        case "NOT_LOCKED":
            self = .notLocked
        case "LOCKED":
            self = .notLocked
        default:
            self = .notLocked
        }
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Models/SportRadarError.swift
````swift
//
//  SportRadarError.swift
//
//
//  Created by Ruben Roques on 10/10/2022.
//

import Foundation

enum SportRadarError: Error {
    case unkownSportId
    case unkownContentId
    case ignoredContentInitialData
    case ignoredContentUpdate
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/Sumsub/SumsubDataProvider.swift
````swift
//
//  SumsubDataProvider.swift
//  
//
//  Created by André Lascas on 13/06/2023.
//

import Foundation
import Combine
import CryptoKit

public class SumsubDataProvider {

    // Sumsub keys
    let sumsubAppToken = "sbx:yjCFqKsuTX6mTY7XMFFPe6hR.v9i5YpFrNND0CeLcZiHeJnnejrCUDZKT"
    let sumsubSecretKey = "4PH7gdufQfrFpFS35gJiwz9d2NFZs4kM"
    let customAllowedEncodingSet = NSCharacterSet(charactersIn:" ").inverted

    init() {

    }

    public func getSumsubAccessToken(userId: String, levelName: String) -> AnyPublisher<AccessTokenResponse, ServiceProviderError> {

        let urlString = "https://api.sumsub.com/resources/accessTokens?userId=\(userId)&levelName=\(levelName)".addingPercentEncoding(withAllowedCharacters: self.customAllowedEncodingSet) ?? ""

        let secretKeyData = self.sumsubSecretKey.data(using: String.Encoding.utf8) ?? Data()

        guard let url = URL(string: urlString) else {
            return Fail(error: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        }

        var request = URLRequest(url: url)
        request.httpMethod = "POST"

        let urlPath = url.path + "?\(url.query ?? "")"
        let headers = generateSignatureHeaders(url: urlPath, method: request.httpMethod ?? "", secretKeyData: secretKeyData, appToken: self.sumsubAppToken)

        for (key, header) in headers {
            request.addValue(header, forHTTPHeaderField: key)
        }

        return URLSession.shared.dataTaskPublisher(for: request)
            .tryMap { data, response -> Data in
                guard let httpResponse = response as? HTTPURLResponse,
                      (200...299).contains(httpResponse.statusCode) else {
                    throw ServiceProviderError.internalServerError
                }
                return data
            }
            .decode(type: AccessTokenResponse.self, decoder: JSONDecoder())
            .mapError { error -> ServiceProviderError in
                if let error = error as? ServiceProviderError {
                    return error
                } else {
                    return .internalServerError
                }
            }
            .eraseToAnyPublisher()

    }

    public func getApplicantData(userId: String) -> AnyPublisher<ApplicantDataResponse, ServiceProviderError> {

        let urlString = "https://api.sumsub.com/resources/applicants/-;externalUserId=\(userId)/one".addingPercentEncoding(withAllowedCharacters: self.customAllowedEncodingSet) ?? ""

        let secretKeyData = self.sumsubSecretKey.data(using: .utf8) ?? Data()

        guard let url = URL(string: urlString) else {
            return Fail(error: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        }

        var request = URLRequest(url: url)
        request.httpMethod = "GET"

        let urlPath = url.path
        let headers = generateSignatureHeaders(url: urlPath, method: request.httpMethod ?? "", secretKeyData: secretKeyData, appToken: self.sumsubAppToken)

        for (key, header) in headers {
            request.addValue(header, forHTTPHeaderField: key)
        }

        return URLSession.shared.dataTaskPublisher(for: request)
            .tryMap { data, response -> Data in
                guard let httpResponse = response as? HTTPURLResponse,
                      (200...299).contains(httpResponse.statusCode) else {
                    throw ServiceProviderError.internalServerError
                }
                return data
            }
            .decode(type: ApplicantDataResponse.self, decoder: JSONDecoder())
            .mapError { error -> ServiceProviderError in
                if let error = error as? ServiceProviderError {
                    return error
                } else {
                    return .internalServerError
                }
            }
            .eraseToAnyPublisher()
    }

    private func generateSignatureHeaders(url: String, method: String, bodyData: Data? = nil, secretKeyData: Data, appToken: String) -> [String: String] {

        let ts = Int(Date().timeIntervalSince1970)

        var dataToSign = "\(ts)\(method.uppercased())\(url)"

        if let bodyData {
            dataToSign += String(data: bodyData, encoding: .utf8) ?? ""
        }

        let data = Data(dataToSign.utf8)

        let hmac = HMAC<SHA256>.authenticationCode(for: data, using: SymmetricKey(data: secretKeyData))
        let signature = hmac.compactMap { String(format: "%02x", $0) }.joined()

        let headers = [
            "X-App-Token": "\(appToken)",
            "X-App-Access-Sig": signature,
            "X-App-Access-Ts": "\(ts)"
        ]

        return headers
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/SportRadarAnalyticsProvider.swift
````swift
//
//  SportRadarAnalyticsProvider.swift
//
//
//  Created by Ruben Roques on 14/05/2024.
//

import Foundation
import Combine

struct SportRadarAnalyticsProvider: AnalyticsProvider {

    private let session: URLSession
    private let decoder: JSONDecoder

    init(session: URLSession = URLSession(configuration: URLSessionConfiguration.default), decoder: JSONDecoder = JSONDecoder()) {
        self.session = session
        self.decoder = decoder
    }

    func request<T: Codable>(_ endpoint: Endpoint) -> AnyPublisher<T, ServiceProviderError> {

        guard
            let request = endpoint.request()
        else {
            let error = ServiceProviderError.invalidRequestFormat
            return AnyPublisher(Fail<T, ServiceProviderError>(error: error))
        }

        return self.session.dataTaskPublisher(for: request)
            .tryMap { result in
                if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 204 {
                    // SUCCESS
                    return "{\"status\":\"OK\"}".data(using: .utf8) ?? Data()
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 401 {
                    throw ServiceProviderError.unauthorized
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode == 403 {
                    throw ServiceProviderError.forbidden
                }
                else if let httpResponse = result.response as? HTTPURLResponse, httpResponse.statusCode != 200 {
                    throw ServiceProviderError.unknown
                }

                return result.data
            }
            .decode(type: T.self, decoder: self.decoder)
            .mapError { error in
                // Debug helper
                print("ServiceProvider-NetworkManager Error \(error)")

                if "\(error)" == "emptyData" {
                    return ServiceProviderError.emptyData
                }

                if let typedError = error as? ServiceProviderError,
                    case .resourceUnavailableOrDeleted = typedError {
                    return typedError
                }

                if let decodingError = error as? DecodingError {
                    let errorMessage = "\(decodingError)"
                    return ServiceProviderError.decodingError(message: errorMessage)
                }

                return ServiceProviderError.invalidResponse
            }
            .eraseToAnyPublisher()
    }

    func trackEvent(_ event: AnalyticsEvent, userIdentifer: String?) -> AnyPublisher<Void, ServiceProviderError> {

        guard
            let typeEvent = event as? VaixAnalyticsEvent
        else {
            return Fail(outputType: Void.self, failure: ServiceProviderError.invalidRequestFormat).eraseToAnyPublisher()
        }

        let endpoint = VaixAPIClient.analyticsTrackEvent(event: typeEvent, userId: userIdentifer ?? "0")
        let publisher: AnyPublisher<BasicResponse, ServiceProviderError> = self.request(endpoint)

        return publisher
            .map({ basicResponse -> Void in
                return ()
            })
            .eraseToAnyPublisher()
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/SportRadarBettingProvider.swift
````swift
//
//  SportRadarBettingProvider.swift
//
//
//  Created by Ruben Roques on 16/11/2022.
//

import Foundation
import Combine

class SportRadarBettingProvider: BettingProvider, Connector {

    var sessionCoordinator: SportRadarSessionCoordinator

    private var connector: BettingConnector
    private var cancellables: Set<AnyCancellable> = []

    var connectionStatePublisher: AnyPublisher<ConnectorState, Never> {
        return self.connectionStateSubject.eraseToAnyPublisher()
    }
    private var connectionStateSubject: CurrentValueSubject<ConnectorState, Never> = .init(.disconnected)

    init(sessionCoordinator: SportRadarSessionCoordinator, connector: BettingConnector = BettingConnector()) {
        self.sessionCoordinator = sessionCoordinator
        self.connector = connector

        self.sessionCoordinator.token(forKey: .launchToken)
            .sink { [weak self] launchToken in
                if let launchTokenValue = launchToken  {
                    self?.connector.saveSessionKey(launchTokenValue)
                }
                else {
                    self?.connector.clearSessionKey()
                }
            }
            .store(in: &cancellables)

        self.connectionStateSubject.send(self.connector.connectionStateSubject.value)

        self.connector.requestTokenRefresher = { [weak self] in
            if let self = self, let refresher = self.sessionCoordinator.forceTokenRefresh(forKey: .launchToken) {
                return refresher
            }
            else {
                return Just(Optional<String>.none).eraseToAnyPublisher()
            }
        }
    }

    func getBetHistory(pageIndex: Int) -> AnyPublisher<BettingHistory, ServiceProviderError> {
        let endpoint = BettingAPIClient.betHistory(page: pageIndex, startDate: nil, endDate: nil, betState: nil, betResult: nil, pageSize: 10)
        let publisher: AnyPublisher<[FailableDecodable<SportRadarModels.Bet>], ServiceProviderError> = self.connector.request(endpoint)

        return publisher
            .map { failableBets in
                // Filter out any nil contents (failed decodes)
                let validBets = failableBets.compactMap { $0.content }
                return SportRadarModels.BettingHistory(bets: validBets)
            }
            .map(SportRadarModelMapper.bettingHistory(fromInternalBettingHistory:))
            .eraseToAnyPublisher()
    }

    func getOpenBetsHistory(pageIndex: Int, startDate: String?, endDate: String?) -> AnyPublisher<BettingHistory, ServiceProviderError> {
        let endpoint = BettingAPIClient.betHistory(page: pageIndex, startDate: startDate, endDate: endDate, betState: [SportRadarModels.BetState.opened], betResult: [SportRadarModels.BetResult.notSpecified], pageSize: 20)

        let publisher: AnyPublisher<[FailableDecodable<SportRadarModels.Bet>], ServiceProviderError> = self.connector.request(endpoint)

        return publisher
            .map { failableBets in
                // Filter out any nil contents (failed decodes)
                let validBets = failableBets.compactMap { $0.content }
                return SportRadarModels.BettingHistory(bets: validBets)
            }
            .map(SportRadarModelMapper.bettingHistory(fromInternalBettingHistory:))
            .eraseToAnyPublisher()
    }

    func getResolvedBetsHistory(pageIndex: Int, startDate: String?, endDate: String?) -> AnyPublisher<BettingHistory, ServiceProviderError> {
        let endpoint = BettingAPIClient.betHistory(page: pageIndex, startDate: startDate, endDate: endDate, betState: [SportRadarModels.BetState.settled, SportRadarModels.BetState.closed, SportRadarModels.BetState.cancelled], betResult: [SportRadarModels.BetResult.notSpecified], pageSize: 20)
        let publisher: AnyPublisher<[FailableDecodable<SportRadarModels.Bet>], ServiceProviderError> = self.connector.request(endpoint)

        return publisher
            .map { failableBets in
                // Filter out any nil contents (failed decodes)
                let validBets = failableBets.compactMap { $0.content }
                return SportRadarModels.BettingHistory(bets: validBets)
            }
            .map(SportRadarModelMapper.bettingHistory(fromInternalBettingHistory:))
            .eraseToAnyPublisher()
    }

    func getWonBetsHistory(pageIndex: Int, startDate: String?, endDate: String?) -> AnyPublisher<BettingHistory, ServiceProviderError> {
        let endpoint = BettingAPIClient.betHistory(page: pageIndex, startDate: startDate, endDate: endDate, betState: [SportRadarModels.BetState.settled, SportRadarModels.BetState.closed, SportRadarModels.BetState.cancelled], betResult: [SportRadarModels.BetResult.notSpecified], pageSize: 20)
        let publisher: AnyPublisher<[FailableDecodable<SportRadarModels.Bet>], ServiceProviderError> = self.connector.request(endpoint)

        return publisher
            .map { failableBets in
                // Filter out any nil contents (failed decodes)
                let validBets = failableBets.compactMap { $0.content }
                return SportRadarModels.BettingHistory(bets: validBets)
            }
            .map(SportRadarModelMapper.bettingHistory(fromInternalBettingHistory:))
            .eraseToAnyPublisher()
    }

    func getAllowedBetTypes(withBetTicketSelections betTicketSelections: [BetTicketSelection]) -> AnyPublisher<[BetType], ServiceProviderError> {
        let endpoint = BettingAPIClient.getAllowedBetTypes(betTicketSelections: betTicketSelections)
        let publisher: AnyPublisher<[SportRadarModels.BetType], ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .map { (sportRadarBetTypes: [SportRadarModels.BetType]) -> [BetType] in
                let mappedBetTypes = sportRadarBetTypes.map(SportRadarModelMapper.betType(fromInternalBetType:))
                return mappedBetTypes
            }
            .eraseToAnyPublisher()
    }

    func calculatePotentialReturn(forBetTicket betTicket: BetTicket)  -> AnyPublisher<BetslipPotentialReturn, ServiceProviderError> {
        let endpoint = BettingAPIClient.calculateReturns(betTicket: betTicket)
        let publisher: AnyPublisher<SportRadarModels.BetslipPotentialReturnResponse, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .map { (betslipPotentialReturn: SportRadarModels.BetslipPotentialReturnResponse) -> BetslipPotentialReturn in
                return BetslipPotentialReturn(potentialReturn: betslipPotentialReturn.potentialReturn,
                                              totalStake: betslipPotentialReturn.totalStake,
                                              numberOfBets: betslipPotentialReturn.numberOfBets,
                                              totalOdd: betslipPotentialReturn.totalOdd ?? 1.0)
            }
            .eraseToAnyPublisher()
    }

    func placeBets(betTickets: [BetTicket], useFreebetBalance: Bool) -> AnyPublisher<PlacedBetsResponse, ServiceProviderError> {
        let endpoint = BettingAPIClient.placeBets(betTickets: betTickets, useFreebetBalance: useFreebetBalance)
        let publisher: AnyPublisher<SportRadarModels.PlacedBetsResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher
            .flatMap { (internalPlacedBetsResponse: SportRadarModels.PlacedBetsResponse) -> AnyPublisher<PlacedBetsResponse, ServiceProviderError> in

//                if internalPlacedBetsResponse.responseCode == "1" ||
//                    internalPlacedBetsResponse.responseCode == "2" ||
//                    internalPlacedBetsResponse.responseCode == "3"

                if internalPlacedBetsResponse.responseCode == "2" {
                    let placedBetsResponse = SportRadarModelMapper.placedBetsResponse(fromInternalPlacedBetsResponse: internalPlacedBetsResponse)
                    return Just( placedBetsResponse ).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                }
                else if internalPlacedBetsResponse.responseCode == "1" && internalPlacedBetsResponse.detailedResponseCode == "66" {
                    var placedBetsResponse = SportRadarModelMapper.placedBetsResponse(fromInternalPlacedBetsResponse: internalPlacedBetsResponse)
                    placedBetsResponse.requiredConfirmation = true

                    let notPlacedBetError = ServiceProviderError.betNeedsUserConfirmation(betDetails: placedBetsResponse)
                    return Fail(outputType: PlacedBetsResponse.self, failure: notPlacedBetError)
                        .eraseToAnyPublisher()
                }
                else {

                    if internalPlacedBetsResponse.responseCode == "4",
                       let message = internalPlacedBetsResponse.errorMessage,
                       message.contains("wager limit") {

                        let notPlacedBetError = ServiceProviderError.notPlacedBet(message: "bet_error_wager_limit")
                        return Fail(outputType: PlacedBetsResponse.self, failure: notPlacedBetError)
                            .eraseToAnyPublisher()
                    }

                    let notPlacedBetError = ServiceProviderError.notPlacedBet(message: internalPlacedBetsResponse.errorMessage ?? "")
                    return Fail(outputType: PlacedBetsResponse.self, failure: notPlacedBetError)
                        .eraseToAnyPublisher()
                }
            }
            .eraseToAnyPublisher()
    }

    func confirmBoostedBet(identifier: String) -> AnyPublisher<Bool, ServiceProviderError> {
        let endpoint = BettingAPIClient.confirmBoostedBet(identifier: identifier)
        let publisher: AnyPublisher<SportRadarModels.ConfirmBetPlaceResponse, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .mapError { error in
                return ServiceProviderError.invalidResponse
            }
            .map({ confirmBetPlaceResponse -> Bool in
                return confirmBetPlaceResponse.state == 2
            })
            .eraseToAnyPublisher()
    }

    func rejectBoostedBet(identifier: String) -> AnyPublisher<Bool, ServiceProviderError> {
        let endpoint = BettingAPIClient.rejectBoostedBet(identifier: identifier)
        let publisher: AnyPublisher<NoReply, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .tryCatch { error -> AnyPublisher<NoReply, ServiceProviderError> in
                guard
                    case .decodingError = error
                else {
                    throw ServiceProviderError.invalidResponse
                }

                return Just( NoReply() )
                    .setFailureType(to: ServiceProviderError.self)
                    .eraseToAnyPublisher()
            }
            .mapError { _ in
                return ServiceProviderError.invalidResponse
            }
            .map({ noReplay -> Bool in
                return true
            })
            .eraseToAnyPublisher()
    }

    func getBetDetails(identifier: String) -> AnyPublisher<Bet, ServiceProviderError> {
//        let endpoint = BettingAPIClient.betDetails(identifier: identifier)
//        let publisher: AnyPublisher<SportRadarModels.Bet, ServiceProviderError> = self.connector.request(endpoint)
//        return publisher.map(SportRadarModelMapper.bettingHistory(fromInternalBettingHistory: <#T##SportRadarModels.BettingHistory#>)

        return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
    }

    func calculateCashout(betId: String, stakeValue: String? = nil) -> AnyPublisher<Cashout, ServiceProviderError> {
        let endpoint = BettingAPIClient.calculateCashout(betId: betId, stakeValue: stakeValue)
        let publisher: AnyPublisher<SportRadarModels.Cashout, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .map( { cashout in
                let cashout = SportRadarModelMapper.cashout(fromInternalCashout: cashout)

                return cashout
            }).eraseToAnyPublisher()
    }

    func allowedCashoutBetIds() -> AnyPublisher<[String], ServiceProviderError> {
        let endpoint = BettingAPIClient.getAllowedCashoutBetIds
        let publisher: AnyPublisher<[Double], ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .map({ idsArray in
                let mappedDoubles = idsArray.map { value in
                    return String(format: "%.2f", value)
                }
                return mappedDoubles
            }).eraseToAnyPublisher()
    }

    func cashoutBet(betId: String, cashoutValue: Double, stakeValue: Double? = nil) -> AnyPublisher<CashoutResult, ServiceProviderError> {
        let endpoint = BettingAPIClient.cashoutBet(betId: betId, cashoutValue: cashoutValue, stakeValue: stakeValue)
        let publisher: AnyPublisher<SportRadarModels.CashoutResult, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .flatMap({ cashoutResult -> AnyPublisher<CashoutResult, ServiceProviderError> in
                if let message = cashoutResult.message {
                    return Fail(outputType: CashoutResult.self, failure: ServiceProviderError.errorMessage(message: message)).eraseToAnyPublisher()
                }
                let cashoutResult = SportRadarModelMapper.cashoutResult(fromInternalCashoutResult: cashoutResult)

                return Just(cashoutResult).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }).eraseToAnyPublisher()
    }

    func getBetslipSettings() -> AnyPublisher<BetslipSettings?, Never> {

        let endpoint = BettingAPIClient.getBetslipSettings
        let publisher: AnyPublisher<SportRadarModels.BetslipSettings, ServiceProviderError> = self.connector.request(endpoint)

        return publisher
            .map({ internalBetslipSettings in
                return BetslipSettings(oddChangeLegacy: internalBetslipSettings.oddChangeLegacy,
                                       oddChangeRunningOrPreMatch: internalBetslipSettings.oddChangeRunningOrPreMatch)
            })
            .replaceError(with: nil)
            .eraseToAnyPublisher()
    }

    func updateBetslipSettings(_ betslipSettings: BetslipSettings) -> AnyPublisher<Bool, Never> {

        if let oddChangeRunningOrPreMatch = betslipSettings.oddChangeRunningOrPreMatch {
            let endpointPreMatch = BettingAPIClient.updateBetslipSettingsPreMatch(oddChange: oddChangeRunningOrPreMatch)
            let publisherPreMatch: AnyPublisher<String, ServiceProviderError> = self.connector.request(endpointPreMatch)

            let endpointRunning = BettingAPIClient.updateBetslipSettingsRunning(oddChange: oddChangeRunningOrPreMatch)
            let publisherRunning: AnyPublisher<String, ServiceProviderError> = self.connector.request(endpointRunning)

            return Publishers.CombineLatest(publisherPreMatch, publisherRunning)
                .map({ publisherPreMatchResponse, publisherRunningResponse -> Bool in
                    return true
                })
                .replaceError(with: false)
                .eraseToAnyPublisher()
        }
        else if let oddChangeLegacy = betslipSettings.oddChangeLegacy {
            let endpointLegacy = BettingAPIClient.updateBetslipSettings(oddChange: oddChangeLegacy)
            let publisherLegacy: AnyPublisher<String, ServiceProviderError> = self.connector.request(endpointLegacy)
            return publisherLegacy
                .mapError({ error in
                    return error
                })
                .map({ internlBetslipSettings -> Bool in
                    return true
                })
                .replaceError(with: false)
                .eraseToAnyPublisher()
        }
        else {
            return Just(false).eraseToAnyPublisher()
        }


    }

    func getFreebet() -> AnyPublisher<FreebetBalance, ServiceProviderError> {

        let endpoint = BettingAPIClient.getFreebetBalance
        let publisher: AnyPublisher<SportRadarModels.FreebetResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher
            .map({ freeBet -> FreebetBalance in
                return FreebetBalance(balance: freeBet.balance)
            })
            .eraseToAnyPublisher()
    }

    func getSharedTicket(betslipId: String) -> AnyPublisher<SharedTicketResponse, ServiceProviderError> {
        let endpoint = BettingAPIClient.getSharedTicket(betslipId: betslipId)
        let publisher: AnyPublisher<SportRadarModels.SharedTicketResponse, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .map { (sharedTicketResponse: SportRadarModels.SharedTicketResponse) -> SharedTicketResponse in

                return SportRadarModelMapper.sharedTicketResponse(fromInternalSharedTicketResponse: sharedTicketResponse)
            }
            .eraseToAnyPublisher()
    }

    func getTicketSelection(ticketSelectionId: String) -> AnyPublisher<TicketSelection, ServiceProviderError> {
        let endpoint = BettingAPIClient.getTicketSelection(ticketSelectionId: ticketSelectionId)
        let publisher: AnyPublisher<SportRadarModels.TicketSelectionResponse, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .flatMap { (ticketSelectionResponse: SportRadarModels.TicketSelectionResponse) -> AnyPublisher<TicketSelection, ServiceProviderError> in

                if let error = ticketSelectionResponse.errorType {
                    return Fail(outputType: TicketSelection.self, failure: ServiceProviderError.errorMessage(message: error)).eraseToAnyPublisher()
                }

                if let ticketSelection = ticketSelectionResponse.data {
                    let mappedTicketSelection = SportRadarModelMapper.ticketSelection(fromInternalTicketSelection: ticketSelection)

                    return Just(mappedTicketSelection).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                }

                return Fail(outputType: TicketSelection.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()

            }
            .eraseToAnyPublisher()
    }

    func calculateCashback(forBetTicket betTicket: BetTicket)  -> AnyPublisher<CashbackResult, ServiceProviderError> {
        let endpoint = BettingAPIClient.calculateCashback(betTicket: betTicket)
        let publisher: AnyPublisher<[SportRadarModels.CashbackResult], ServiceProviderError> = self.connector.request(endpoint)

        return publisher
            .mapError({ error in
                print("CASHBACK ERROR: \(error)")
                return error
            })
            .flatMap { (cashbackResultResponse: [SportRadarModels.CashbackResult]) -> AnyPublisher<CashbackResult, ServiceProviderError> in
                if let cashbackResult = cashbackResultResponse.first {
                    let mappedCashbackResult = SportRadarModelMapper.cashbackResult(fromInternalCashbackResult: cashbackResult)
                    return Just(mappedCashbackResult).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                }
                return Fail(outputType: CashbackResult.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
            .eraseToAnyPublisher()

    }

    func calculateBetBuilderPotentialReturn(forBetTicket betTicket: BetTicket)  -> AnyPublisher<BetBuilderPotentialReturn, ServiceProviderError> {
        let endpoint = BettingAPIClient.calculateBetBuilderReturn(betTicket: betTicket)
        let publisher: AnyPublisher<SportRadarModels.BetBuilderPotentialReturn, ServiceProviderError> = self.connector.request(endpoint)
        return publisher
            .map { (betslipPotentialReturn: SportRadarModels.BetBuilderPotentialReturn) -> BetBuilderPotentialReturn in
                return BetBuilderPotentialReturn(potentialReturn: betslipPotentialReturn.potentialReturn,
                                                 calculatedOdds: betslipPotentialReturn.calculatedOdds)
            }
            .mapError({ serviceProviderError in
                print("calculateBetBuilderPotentialReturn error: \(serviceProviderError)")
                return serviceProviderError
            })
            .eraseToAnyPublisher()
    }

    func placeBetBuilderBet(betTicket: BetTicket, calculatedOdd: Double) -> AnyPublisher<PlacedBetsResponse, ServiceProviderError> {
        let endpoint = BettingAPIClient.placeBetBuilderBet(betTicket: betTicket, calculatedOdd: calculatedOdd)
        let publisher: AnyPublisher<SportRadarModels.PlacedBetsResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher
            .flatMap { (internalPlacedBetsResponse: SportRadarModels.PlacedBetsResponse) -> AnyPublisher<PlacedBetsResponse, ServiceProviderError> in
                if internalPlacedBetsResponse.responseCode == "2" {
                    let placedBetsResponse = SportRadarModelMapper.placedBetsResponse(fromInternalPlacedBetsResponse: internalPlacedBetsResponse)
                    return Just( placedBetsResponse ).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                }
                else if internalPlacedBetsResponse.responseCode == "1" && internalPlacedBetsResponse.detailedResponseCode == "66" {
                    var placedBetsResponse = SportRadarModelMapper.placedBetsResponse(fromInternalPlacedBetsResponse: internalPlacedBetsResponse)
                    placedBetsResponse.requiredConfirmation = true

                    let notPlacedBetError = ServiceProviderError.betNeedsUserConfirmation(betDetails: placedBetsResponse)
                    return Fail(outputType: PlacedBetsResponse.self, failure: notPlacedBetError)
                        .eraseToAnyPublisher()
                }
                else {

                    if internalPlacedBetsResponse.responseCode == "4",
                       let message = internalPlacedBetsResponse.errorMessage,
                       message.contains("wager limit") {

                        let notPlacedBetError = ServiceProviderError.notPlacedBet(message: "bet_error_wager_limit")
                        return Fail(outputType: PlacedBetsResponse.self, failure: notPlacedBetError)
                            .eraseToAnyPublisher()
                    }

                    let notPlacedBetError = ServiceProviderError.notPlacedBet(message: internalPlacedBetsResponse.errorMessage ?? "")
                    return Fail(outputType: PlacedBetsResponse.self, failure: notPlacedBetError)
                        .eraseToAnyPublisher()
                }
            }
            .eraseToAnyPublisher()
    }
}

extension SportRadarBettingProvider {

    func updateTicketOdds(betId: String) -> AnyPublisher<Bet, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func getTicketQRCode(betId: String) -> AnyPublisher<BetQRCode, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func getSocialSharedTicket(shareId: String) -> AnyPublisher<Bet, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func deleteTicket(betId: String) -> AnyPublisher<Bool, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
    func updateTicket(betId: String, betTicket: BetTicket) -> AnyPublisher<PlacedBetsResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
    
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/SportRadarConfiguration.swift
````swift
//
//  File.swift
//
//
//  Created by Ruben Roques on 21/11/2022.
//

import Foundation
import Extensions

public struct SportRadarConfiguration {

    enum Environment {
        case production
        case staging
        case development
    }

    var environment: Environment
    public static var shared = SportRadarConfiguration(environment: .production)

    init(environment: Environment) {
        self.environment = environment
    }

    public var socketHostname: String {
        switch self.environment {
        case .production: return "wss://velnt-bson-ssb-pr.betsson.fr"
        case .staging, .development: return "wss://velnt-bson-ssb-ua.betsson.fr"
        }
    }

    public var socketURL: String {
        return socketHostname + "/notification/listen/websocket"
    }

    public var servicesRestHostname: String {
        switch self.environment {
        case .production: return "https://www-bson-ssb-pr.betsson.fr"
        default: return "https://www-bson-ssb-ua.betsson.fr"
        }
    }

    public var servicesSubscribeRestHostname: String {
        switch self.environment {
        case .production: return "https://velsv-bson-ssb-pr.betsson.fr"
        default: return "https://velsv-bson-ssb-ua.betsson.fr"
        }
    }

    public var socketLanguageCode: String {
        return "FR"
    }

    public var pamHostname: String {
        switch self.environment {
        case .production: return "https://ips.betsson.fr"
        default: return "https://ips-stg.betsson.fr"
        }
    }

    public var apiRestHostname: String {
        switch self.environment {
        case .production: return "https://api-bson-ssb-pr.betsson.fr"
        default: return "https://api-bson-ssb-ua.betsson.fr"
        }
    }

    public var sportRadarFrontEndURL: String {
        switch self.environment {
        case .production: return "https://cdn1-bson-ssb-pr.betsson.fr"
        default: return "https://cdn1-bson-ssb-ua.betsson.fr"
        }
    }

    public var supportHostname: String {
        switch self.environment {
        case .production: return "https://betssonfrance.zendesk.com"
        default: return "https://betssonfrance.zendesk.com"
        }
    }

    public var sumsubHostname: String {
        switch self.environment {
        case .production: return "https://api.sumsub.com"
        default: return "https://api.sumsub.com"
        }
    }

    public var frontEndCode: String {
        return "1356"
    }

    public var clientBaseUrl: String {
        switch self.environment {
        case .production:
            return "https://betsson.fr"
        default:
            return "https://sportsbook-stage.gomagaming.com"
        }
    }


    public var vaixHostname: String {
        switch self.environment {
        case .production: return "https://api.vaix.ai/api/"
        default: return "https://staging-api.vaix.ai/api/"
        }
    }

    public var vaixAuthTokenValue: String {
        switch self.environment {
        case .production: return "db5d16b721e3176e9723554747c54b02f1a3eaf74b933865ef71ab4b604fc927"
        default: return "a27724e2756e427d99db9e7f3d58c164ced4d6c941d2355feaefca14af0bcc02"


        }
    }

}




/**



 //    =======================================
 //       GOMA ENV
 //    =======================================

 //    Events via socket
 //
 //    static var socketHostname = "wss://velnt-spor-int.optimahq.com"
 //    static var socketURL: String {
 //        return socketHostname + "/notification/listen/websocket"
 //    }
 //    static var servicesRestHostname = "https://www-sportbook-goma-int.optimahq.com" // To subscribe to contentIDs
 //    static var socketLanguageCode = "UK"
 //
 //    // PAM
 //    //static var pamHostname = "https://ps.omegasys.eu"
 //    static var pamHostname = "https://bfr-ps.omegasys.eu"
 //
 //    // Betting
 //    static var apiRestHostname = "https://www-sportbook-goma-int.optimahq.com"
 //
 //    // Others
 //    static var sportRadarFrontEndURL = "https://cdn1.optimahq.com"

 //    ===================================================================================================================


 //    =======================================
 //       BETSSON
 //    =======================================
 //
 //    //Events via socket
     static var socketHostname = "wss://velnt-bson-ssb-ua.betsson.fr"
     static var socketURL: String {
         return socketHostname + "/notification/listen/websocket"
     }
     static var servicesRestHostname = "https://www-bson-ssb-ua.betsson.fr"

     static var servicesSubscribeRestHostname = "https://velsv-bson-ssb-ua.betsson.fr" // To subscribe to contentIDs, as in velsv-bson-ssb-ua.betsson.fr/services

     static var socketLanguageCode = "FR" // Localization.localized("sportradar_content_languange_code")

     // PAM
     // //static var pamHostname = "https://ps.omegasys.eu"
     static var pamHostname = "https://ips-stg.betsson.fr"
     // Betting
     static var apiRestHostname = "https://api-bson-ssb-ua.betsson.fr" // as in api-bson-ssb-ua.betsson.fr/API

     // Others
     static var sportRadarFrontEndURL = "https://cdn1-bson-ssb-ua.betsson.fr"

     // Support
     static var supportHostname = "https://betssonfrance.zendesk.com"

     // Sumsub
     static var sumsubHostname = "https://api.sumsub.com"

     static var frontEndCode = "1356"

     //static var sportRadarLegacyFrontEndURL = "https://cdn1.optimahq.com"

 //    ===================================================================================================================


 //    =======================================
 //       DEMO VIDEO ENV
 //    =======================================
 //
 //    Events via socket
 //
 //    static var socketHostname = "wss://velnt-spor-uat.optimahq.com"
 //    static var socketURL: String {
 //        return socketHostname + "/notification/listen/websocket"
 //    }
 //    static var servicesRestHostname = "https://www-pam-uat.optimahq.com" // To subscribe to contentIDs
 //    static var socketLanguageCode = "UK"
 //
 //    // PAM
 //    // //static var pamHostname = "https://ps.omegasys.eu"
 //    static var pamHostname = "https://bfr-ps.omegasys.eu"
 //    // Betting
 //    static var apiRestHostname = "https://www-pam-uat.optimahq.com"
 //
 //    // Others
 //    static var sportRadarFrontEndURL = "https://cdn1.optimahq.com"

 //    ===================================================================================================================



 */
````

## File: Sources/ServicesProvider/Providers/Sportsradar/SportRadarEventsProvider.swift
````swift
//
//  SportRadarEventsProvider.swift
//
//
//  Created by Ruben Roques on 29/09/2022.
//

import Foundation
import Combine
import OrderedCollections
import Extensions
import SharedModels

class SportRadarEventsProvider: EventsProvider {

    private var socketConnector: SportRadarSocketConnector
    private var restConnector: SportRadarRestConnector

    var sessionCoordinator: SportRadarSessionCoordinator

    var connectionStatePublisher: AnyPublisher<ConnectorState, Never> {
        return self.connectionStateSubject.eraseToAnyPublisher()
    }
    private var connectionStateSubject: CurrentValueSubject<ConnectorState, Never> = .init(.disconnected)

    private var cancellables = Set<AnyCancellable>()

    private var sportsMerger: SportsMerger?

    required init(sessionCoordinator: SportRadarSessionCoordinator,
                  socketConnector: SportRadarSocketConnector = SportRadarSocketConnector(),
                  restConnector: SportRadarRestConnector = SportRadarRestConnector()) {
        print("[SERVICEPROVIDER][PROVIDER] Initializing SportRadarEventsProvider")
        self.sessionCoordinator = sessionCoordinator

        self.socketConnector = socketConnector
        self.restConnector = restConnector

        self.socketConnector.connectionStatePublisher.sink { completion in
            print("[SERVICEPROVIDER][SOCKET] Socket connection publisher completed")
        } receiveValue: { [weak self] connectorState in
            print("[SERVICEPROVIDER][SOCKET] Socket connection state changed to: \(connectorState)")
            self?.connectionStateSubject.send(connectorState)
        }
        .store(in: &self.cancellables)

        self.sessionCoordinator.token(forKey: .launchToken)
            .sink { [weak self] launchToken in
                if let launchTokenValue = launchToken  {
                    print("[SERVICEPROVIDER][PROVIDER] Launch token received: \(launchTokenValue)")
                    self?.restConnector.saveSessionKey(launchTokenValue)
                }
                else {
                    print("[SERVICEPROVIDER][PROVIDER] No launch token available, clearing session key")
                    self?.restConnector.clearSessionKey()
                }
            }
            .store(in: &self.cancellables)

        self.socketConnector.tokenPublisher
            .removeDuplicates()
            .compactMap({ $0 })
            .withPrevious()
            .sink(receiveValue: { [weak self] (oldToken, newToken) in
                print("[SERVICEPROVIDER][SOCKET] Socket token updated")
                self?.sessionCoordinator.saveToken(newToken.hash, withKey: .socketSessionToken)

                if let oldToken, oldToken != newToken {
                    print("[SERVICEPROVIDER][SOCKET] Socket reconnected with new token: \(newToken.hash)")
                    self?.subscribePreviousTopics(withNewSocketToken: newToken.hash)
                }
                else {
                    print("[SERVICEPROVIDER][SOCKET] Initial socket connection with token: \(newToken.hash)")
                }
            })
            .store(in: &self.cancellables)

        self.socketConnector.messageSubscriber = self
        print("[SERVICEPROVIDER][SOCKET] Initiating socket connection")
        self.socketConnector.connect()

    }

    private weak var liveSportsSubscription: Subscription?
    private weak var allSportTypesSubscription: Subscription?

    private var liveSportTypesPublisher: CurrentValueSubject<SubscribableContent<[SportType]>, ServiceProviderError>?

    private var allSportTypesPublisher: CurrentValueSubject<SubscribableContent<[SportType]>, ServiceProviderError>?

    private var allSportsListTypesPublisher: CurrentValueSubject<SubscribableContent<[SportType]>, ServiceProviderError>?

    private var eventsPaginators: [String: SportRadarEventsPaginator] = [:]
    private var eventDetailsCoordinators: [String: SportRadarEventDetailsCoordinator] = [:]
    private var liveEventDetailsCoordinators: [String: SportRadarLiveEventDataCoordinator] = [:]
    private var marketUpdatesCoordinators: [String: SportRadarMarketDetailsCoordinator] = [:]

    private var eventsSecundaryMarketsUpdatesCoordinators: [String: SportRadarEventMarketsCoordinator] = [:]

    private var competitionEventsPublisher: [ContentIdentifier: CurrentValueSubject<SubscribableContent<[EventsGroup]>, ServiceProviderError>] = [:]
    private var outrightDetailsPublisher: CurrentValueSubject<SubscribableContent<[EventsGroup]>, ServiceProviderError>?
    private var eventSummaryPublisher: CurrentValueSubject<SubscribableContent<[EventsGroup]>, ServiceProviderError>?
    private var eventLiveDataPublisher: CurrentValueSubject<SubscribableContent<[Event]>, ServiceProviderError>?

    //
    // Keep a reference for all the subscriptions. This allows the ServiceProvider to subscribe to the same content in two different app places
    private var activeSubscriptions: NSMapTable<ContentIdentifier, Subscription> = .init(keyOptions: .strongMemory , valueOptions: .weakMemory)

    private let defaultEventCount = 10

    func reconnectIfNeeded() {
        print("[SERVICEPROVIDER][SOCKET] Attempting socket reconnection if needed")
        self.socketConnector.refreshConnection()
    }

    func subscribePreviousTopics(withNewSocketToken newSocketToken: String) {
        print("[SERVICEPROVIDER][PROVIDER] Resubscribing to previous topics with new socket token")
        self.eventsPaginators = self.eventsPaginators.filter { $0.value.isActive }
        for paginator in self.eventsPaginators.values where paginator.isActive {
            print("[SERVICEPROVIDER][PROVIDER] Reconnecting paginator")
            paginator.reconnect(withNewSessionToken: newSocketToken)
        }

        for eventDetailsCoordinator in self.getValidEventDetailsCoordinators() {
            print("[SERVICEPROVIDER][PROVIDER] Reconnecting event details coordinator")
            eventDetailsCoordinator.reconnect(withNewSessionToken: newSocketToken)
        }

        for liveEventDetailsCoordinator in self.getValidLiveEventDetailsCoordinators() {
            print("[SERVICEPROVIDER][PROVIDER] Reconnecting live event details coordinator")
            liveEventDetailsCoordinator.reconnect(withNewSessionToken: newSocketToken)
        }

        self.marketUpdatesCoordinators = self.marketUpdatesCoordinators.filter { $0.value.isActive }
        for marketUpdatesCoordinator in self.marketUpdatesCoordinators.values {
            print("[SERVICEPROVIDER][PROVIDER] Reconnecting market updates coordinator")
            marketUpdatesCoordinator.reconnect(withNewSessionToken: newSocketToken)
        }
    }

    func subscribePreLiveMatches(forSportType sportType: SportType, initialDate: Date? = nil, endDate: Date? = nil, eventCount: Int? = nil, sortType: EventListSort) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {

        // Get the session
        guard
            let sessionToken = socketConnector.token
        else {
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }

        guard
            let sportId = sportType.alphaId
        else {
            return Fail(error: ServiceProviderError.incompletedSportData).eraseToAnyPublisher()
        }

        let eventCountValue = eventCount ?? self.defaultEventCount

        // contentType -> eventListBySportTypeDate
        let contentType = ContentType.preLiveEvents
        // contentId -> FBL/202210210000/202210212359/0/20/T
        let contentRoute = ContentRoute.preLiveEvents(sportAlphaId: sportId,
                                                      startDate: initialDate,
                                                      endDate: endDate,
                                                      pageIndex: 0,
                                                      eventCount: eventCountValue,
                                                      sortType: sortType)

        let contentIdentifier = ContentIdentifier(contentType: contentType, contentRoute: contentRoute)

        if let paginator = self.eventsPaginators[contentIdentifier.pageableId], paginator.isActive {
            return paginator.eventsGroupPublisher
        }
        else {
            let paginator = SportRadarEventsPaginator(contentIdentifier: contentIdentifier,
                                                      sessionToken: sessionToken.hash,
                                                      storage: SportRadarEventsStorage())

            self.eventsPaginators[contentIdentifier.pageableId] = paginator
            return paginator.eventsGroupPublisher
        }
    }

    func requestPreLiveMatchesNextPage(forSportType sportType: SportType, initialDate: Date? = nil, endDate: Date? = nil, sortType: EventListSort) -> AnyPublisher<Bool, ServiceProviderError> {
        // Get the session
        guard
            socketConnector.token != nil
        else {
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }

        guard
            let sportId = sportType.alphaId
        else {
            return Fail(outputType: Bool.self, failure: ServiceProviderError.incompletedSportData).eraseToAnyPublisher()
        }
        // contentType -> eventListBySportTypeDate
        let contentType = ContentType.preLiveEvents

        // contentId -> FBL/202210210000/202210212359/0/20/T
        let contentRoute = ContentRoute.preLiveEvents(sportAlphaId: sportId,
                                                      startDate: initialDate,
                                                      endDate: endDate,
                                                      pageIndex: 0,
                                                      eventCount: self.defaultEventCount,
                                                      sortType: sortType)

        let contentIdentifier = ContentIdentifier(contentType: contentType, contentRoute: contentRoute)

        if let paginator = self.eventsPaginators[contentIdentifier.pageableId], paginator.isActive {
            return paginator.requestNextPage().eraseToAnyPublisher()
        }
        else {
            return Fail(outputType: Bool.self, failure: ServiceProviderError.subscriptionNotFound).eraseToAnyPublisher()
        }
    }

    func subscribeLiveMatches(forSportType sportType: SportType) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {

        // Get the session
        guard
            let sessionToken = socketConnector.token
        else {
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }

        guard
            let sportId = sportType.alphaId
        else {
            return Fail(error: ServiceProviderError.incompletedSportData).eraseToAnyPublisher()
        }

        // contentType -> liveDataSummaryAdvancedListBySportType
        let contentType = ContentType.liveEvents
        // contentId -> FBL/0 -> /0 means page 0 of pagination
        let contentRoute = ContentRoute.liveEvents(sportAlphaId: sportId, pageIndex: 0)

        let contentIdentifier = ContentIdentifier(contentType: contentType, contentRoute: contentRoute)

        if let paginator = self.eventsPaginators[contentIdentifier.pageableId], paginator.isActive {
            return paginator.eventsGroupPublisher
        }
        else {
            let paginator = SportRadarEventsPaginator(contentIdentifier: contentIdentifier,
                                                      sessionToken: sessionToken.hash,
                                                      storage: SportRadarEventsStorage())
            self.eventsPaginators[contentIdentifier.pageableId] = paginator
            return paginator.eventsGroupPublisher
        }

    }

    func requestLiveMatchesNextPage(forSportType sportType: SportType) -> AnyPublisher<Bool, ServiceProviderError> {
        // Get the session
        guard
            socketConnector.token != nil
        else {
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }

        guard
            let sportId = sportType.alphaId
        else {
            return Fail(outputType: Bool.self, failure: ServiceProviderError.incompletedSportData).eraseToAnyPublisher()
        }

        // contentType -> liveDataSummaryAdvancedListBySportType
        let contentType = ContentType.liveEvents
        // contentId -> FBL/0 -> /0 means page 0 of pagination
        let contentRoute = ContentRoute.liveEvents(sportAlphaId: sportId, pageIndex: 0)
        let contentIdentifier = ContentIdentifier(contentType: contentType, contentRoute: contentRoute)

        if let paginator = self.eventsPaginators[contentIdentifier.pageableId] {
            return paginator.requestNextPage().eraseToAnyPublisher()
        }
        else {
            return Fail(outputType: Bool.self, failure: ServiceProviderError.subscriptionNotFound).eraseToAnyPublisher()
        }
    }

    //
    // MARK: - Competition and Match Details
    //
    func subscribeCompetitionMatches(forMarketGroupId marketGroupId: String) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {

        // Get the session
        guard
            let sessionToken = self.socketConnector.token
        else {
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }

        // Create the contentIdentifier
        let contentType = ContentType.eventGroup
        let contentRoute = ContentRoute.eventGroup(marketGroupId: marketGroupId)
        let contentIdentifier = ContentIdentifier(contentType: contentType, contentRoute: contentRoute)

        if let publisher = self.competitionEventsPublisher[contentIdentifier],
           let subscription = self.activeSubscriptions.object(forKey: contentIdentifier) {
            // We already have a publisher for this events and a subscription object for the caller to store
            return publisher
                .prepend(.connected(subscription: subscription))
                .eraseToAnyPublisher()
        }
        else {
            // We have neither a publisher nor a subscription object
            let publisher = CurrentValueSubject<SubscribableContent<[EventsGroup]>, ServiceProviderError>.init(.disconnected)

            let subscription = Subscription(contentIdentifier: contentIdentifier, sessionToken: sessionToken.hash, unsubscriber: self)

            let bodyData = self.createPayloadData(with: sessionToken, contentType: contentType, contentRoute: contentRoute)
            let request = self.createSubscribeRequest(withHTTPBody: bodyData)

            // print("NetworkLogs: ", request.cURL(pretty: true), "\nNetworkLogs: ==========================================")

            let sessionDataTask = URLSession.shared.dataTask(with: request) { data, response, error in
                guard
                    (error == nil),
                    let httpResponse = response as? HTTPURLResponse,
                    (200...299).contains(httpResponse.statusCode)
                else {
                    print("SportRadarEventsProvider: eventListBySportTypeDate - error on subscribe to topic")
                    publisher.send(completion: .failure(ServiceProviderError.onSubscribe))
                    return
                }
                publisher.send(.connected(subscription: subscription))
            }
            sessionDataTask.resume()

            self.activeSubscriptions.setObject(subscription, forKey: contentIdentifier)
            self.competitionEventsPublisher[contentIdentifier] = publisher

            return publisher.eraseToAnyPublisher()
        }
    }

    func subscribeSportTypes() -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError> {
        print("[SERVICEPROVIDER][PROVIDER] Starting sports types subscription")
        guard let sessionToken = self.socketConnector.token else {
            print("[SERVICEPROVIDER][PROVIDER] Failed to subscribe to sport types: No session token available")
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }

        if let existingMerger = sportsMerger, existingMerger.isActive {
            print("[SERVICEPROVIDER][PROVIDER] Reusing existing active sports merger")
            return existingMerger.sportsPublisher
        }

        print("[SERVICEPROVIDER][PROVIDER] Creating new SportsMerger instance")
        let merger = SportsMerger(sessionToken: sessionToken.hash)
        self.sportsMerger = merger
        self.socketConnector.messageSubscriber = self
        print("[SERVICEPROVIDER][PROVIDER] SportsMerger created and message subscriber set")

        return merger.sportsPublisher
    }

    // Remove these methods as they are now handled by SportsMerger
    func subscribeLiveSportTypes() -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError> {
        fatalError("Use subscribeSportTypes() instead")
    }

    func subscribeAllSportTypes() -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError> {
        fatalError("Use subscribeSportTypes() instead")
    }

    func subscribePreLiveSportTypes(initialDate: Date? = nil, endDate: Date? = nil) -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError> {
        fatalError("Use subscribeSportTypes() instead")
    }

    //
    //
    func subscribeEndedMatches(forSportType sportType: SportType) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func requestEndedMatchesNextPage(forSportType sportType: SportType) -> AnyPublisher<Bool, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    //
    func subscribeOutrightEvent(forMarketGroupId marketGroupId: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {

        return self.getEventForMarketGroup(withId: marketGroupId)
            .map({ event in
                return SubscribableContent.contentUpdate(content: event)
            })
//            .flatMap { event in
//                self.subscribeEventDetails(eventId: event.id)
//            }
            .eraseToAnyPublisher()

    }

    func subscribeOutrightMarkets(forMarketGroupId marketGroupId: String) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {

        guard
            let sessionToken = socketConnector.token
        else {
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }

        let contentType = ContentType.eventGroup
        let contentRoute = ContentRoute.eventGroup(marketGroupId: marketGroupId)
        let contentIdentifier = ContentIdentifier(contentType: contentType, contentRoute: contentRoute)

        if let publisher = self.competitionEventsPublisher[contentIdentifier], let subscription = self.activeSubscriptions.object(forKey: contentIdentifier) {
            // We already have a publisher for this events and a subscription object for the caller to store
            return publisher
                .prepend(.connected(subscription: subscription))
                .eraseToAnyPublisher()
        }
        else {
            // We have neither a publisher nor a subscription object
            let publisher = CurrentValueSubject<SubscribableContent<[EventsGroup]>, ServiceProviderError>.init(.disconnected)

            let subscription = Subscription(contentIdentifier: contentIdentifier, sessionToken: sessionToken.hash, unsubscriber: self)

            let bodyData = self.createPayloadData(with: sessionToken, contentType: contentType, contentRoute: contentRoute)
            let request = self.createSubscribeRequest(withHTTPBody: bodyData)

            // print("NetworkLogs: ", request.cURL(pretty: true), "\nNetworkLogs: ==========================================")

            let sessionDataTask = URLSession.shared.dataTask(with: request) { data, response, error in
                guard
                    (error == nil),
                    let httpResponse = response as? HTTPURLResponse,
                    (200...299).contains(httpResponse.statusCode)
                else {
                    print("SportRadarEventsProvider: eventListBySportTypeDate - error on subscribe to topic")
                    publisher.send(completion: .failure(ServiceProviderError.onSubscribe))
                    return
                }
                publisher.send(.connected(subscription: subscription))
            }
            sessionDataTask.resume()

            self.activeSubscriptions.setObject(subscription, forKey: contentIdentifier)
            self.competitionEventsPublisher[contentIdentifier] = publisher

            return publisher.eraseToAnyPublisher()
        }

    }

    func subscribeEventSummary(eventId: String) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {

        self.eventSummaryPublisher = CurrentValueSubject<SubscribableContent<[EventsGroup]>, ServiceProviderError>.init(.disconnected)

        guard
            let sessionToken = socketConnector.token,
            let publisher = self.eventSummaryPublisher
        else {
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }

        let contentType = ContentType.eventSummary
        let contentRoute = ContentRoute.eventSummary(eventId: eventId)
        let contentIdentifier = ContentIdentifier(contentType: contentType, contentRoute: contentRoute)

        let subscription = Subscription(contentIdentifier: contentIdentifier, sessionToken: sessionToken.hash, unsubscriber: self)

        let bodyData = self.createPayloadData(with: sessionToken, contentType: contentType, contentRoute: contentRoute)
        let request = self.createSubscribeRequest(withHTTPBody: bodyData)

        // print("NetworkLogs: ", request.cURL(pretty: true), "\nNetworkLogs: ==========================================")

        let sessionDataTask = URLSession.shared.dataTask(with: request) { data, response, error in
            guard
                error == nil,
                let httpResponse = response as? HTTPURLResponse,
                (200...299).contains(httpResponse.statusCode)
            else {
                print("ServiceProvider subscribeEventSummary \(String(describing: error)) \(String(describing: response))")
                publisher.send(completion: .failure(ServiceProviderError.onSubscribe))
                return
            }
            // TODO: send subscription
            publisher.send(.connected(subscription: subscription))
        }
        sessionDataTask.resume()
        return publisher.eraseToAnyPublisher()
    }

    func subscribeEventDetails(eventId: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {

        guard
            let sessionToken = socketConnector.token
        else {
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }

        if let eventDetailsCoordinator = self.getValidEventDetailsCoordinator(forKey: eventId) {
            return eventDetailsCoordinator.eventDetailsPublisher
        }
        else {
            // Check if we already have a subscription to
            var liveDataExtendedSubscription: Subscription?
            if let liveEventDetailsCoordinator = self.getValidLiveEventDetailsCoordinator(forKey: eventId) {
                liveDataExtendedSubscription = liveEventDetailsCoordinator.liveDataExtendedSubscription
            }

            let eventDetailsCoordinator = SportRadarEventDetailsCoordinator(matchId: eventId,
                                                                            sessionToken: sessionToken.hash,
                                                                            storage: SportRadarEventStorage(),
                                                                            liveDataExtendedSubscription: liveDataExtendedSubscription,
                                                                            marketsSubscription: nil)
            self.addEventDetailsCoordinator(eventDetailsCoordinator, withKey: eventId)
            return eventDetailsCoordinator.eventDetailsPublisher
        }

    }

    // Independent Live Data extended info
    public func subscribeToLiveDataUpdates(forEventWithId id: String) -> AnyPublisher<SubscribableContent<EventLiveData>, ServiceProviderError> {

        guard
            let sessionToken = self.socketConnector.token
        else {
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }

        // event details
        if let liveEventDetailsCoordinator = self.getValidLiveEventDetailsCoordinator(forKey: id),
           liveEventDetailsCoordinator.containsEvent(withid: id) {
            return liveEventDetailsCoordinator.eventLiveDataPublisher
        }
        else {
            // Check if we already have a subscription to
            var liveDataExtendedSubscription: Subscription?
            if let eventDetailsCoordinator = self.getValidEventDetailsCoordinator(forKey: id) {
                liveDataExtendedSubscription = eventDetailsCoordinator.liveDataExtendedSubscription
            }

            let liveEventDetailsCoordinator = SportRadarLiveEventDataCoordinator(eventId: id,
                                                                                 sessionToken: sessionToken.hash,
                                                                                 storage: SportRadarEventStorage(),
                                                                                 liveDataExtendedSubscription: liveDataExtendedSubscription)
            self.addLiveEventDetailsCoordinator(liveEventDetailsCoordinator, withKey: id)
            return liveEventDetailsCoordinator.eventLiveDataPublisher
        }

    }

    // live info associated with the paginator lists and event details
    public func subscribeToEventOnListsLiveDataUpdates(withId id: String) -> AnyPublisher<Event?, ServiceProviderError> {

        guard
            self.socketConnector.token != nil
        else {
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }
        
        // events lists
        for paginator in self.eventsPaginators.values {
            if paginator.containsEvent(withid: id), let publisher = paginator.subscribeToEventOnListsLiveDataUpdates(withId: id) {
                return publisher.map(Optional.init).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
        }

        // event details
        for eventDetailsCoordinator in self.getValidEventDetailsCoordinators() {
            if eventDetailsCoordinator.containsEvent(withid: id) {
                let publisher = eventDetailsCoordinator.subscribeToEventOnListsLiveDataUpdates(withId: id)
                return publisher.setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
        }

        return Fail(error: ServiceProviderError.resourceNotFound).eraseToAnyPublisher()
    }


    public func subscribeToEventOnListsMarketUpdates(withId id: String) -> AnyPublisher<Market?, ServiceProviderError> {

        // events lists
        for paginator in self.eventsPaginators.values {
            if paginator.containsMarket(withid: id), let publisher = paginator.subscribeToEventOnListsMarketUpdates(withId: id) {
                return publisher.map(Optional.init).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
        }

        // event details
        for eventDetailsCoordinator in self.getValidEventDetailsCoordinators() {
            if eventDetailsCoordinator.containsMarket(withid: id),
               let publisher = eventDetailsCoordinator.subscribeToEventOnListsMarketUpdates(withId: id) {
                return publisher.map(Optional.init).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
        }

        // Event secundary markets details
        for eventMarketsCoordinator in self.getValidEventMarketsCoordinators() {
            if eventMarketsCoordinator.containsMarket(withid: id),
               let publisher = eventMarketsCoordinator.subscribeToEventOnListsMarketUpdates(withId: id) {
                return publisher.map(Optional.init).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
        }

        return Just(nil).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
    }

    public func subscribeToEventOnListsOutcomeUpdates(withId id: String) -> AnyPublisher<Outcome?, ServiceProviderError> {

        // events lists
        for paginator in self.eventsPaginators.values {
            if paginator.containsOutcome(withid: id), let publisher = paginator.subscribeToEventOnListsOutcomeUpdates(withId: id) {
                return publisher.map(Optional.init).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
        }

        // event details
        for eventDetailsCoordinator in self.getValidEventDetailsCoordinators() {
            if eventDetailsCoordinator.containsOutcome(withid: id),
               let publisher = eventDetailsCoordinator.subscribeToEventOnListsOutcomeUpdates(withId: id) {
                return publisher.map(Optional.init).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
        }

        // Secundary Markets - event details

        for eventMarketsCoordinator in self.getValidEventMarketsCoordinators() {
            if eventMarketsCoordinator.containsOutcome(withid: id),
               let publisher = eventMarketsCoordinator.subscribeToEventOnListsOutcomeUpdates(withId: id) {
                return publisher.map(Optional.init).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
        }

        return Just(nil).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
    }


    public func subscribeToMarketDetails(withId marketId: String, onEventId eventId: String) -> AnyPublisher<SubscribableContent<Market>, ServiceProviderError> {

        // Get the session
        guard
            let sessionToken = socketConnector.token
        else {
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }

        // contentType -> liveDataSummaryAdvancedListBySportType
        let contentType: ContentType = ContentType.market
        // contentId -> FBL/0 -> /0 means page 0 of pagination
        let contentRoute = ContentRoute.market(marketId: marketId)

        let contentIdentifier = ContentIdentifier(contentType: contentType, contentRoute: contentRoute)

        if let coordinators = self.marketUpdatesCoordinators[marketId], coordinators.isActive {
            print("DebugSgt: marketUpdatesCoordinators \(marketId) isActive")
            return coordinators.marketPublisher
        }
        else {
            print("DebugSgt: marketUpdatesCoordinators \(marketId) not active")
            let coordinator = SportRadarMarketDetailsCoordinator.init(marketId: marketId,
                                                                      eventId: eventId,
                                                                      sessionToken: sessionToken.hash,
                                                                      contentIdentifier: contentIdentifier)
            self.marketUpdatesCoordinators[marketId] = coordinator
            return coordinator.marketPublisher
        }

    }

}

//
// MARK: - Socket event delegate
//
extension SportRadarEventsProvider: SportRadarConnectorSubscriber {

    //
    // EVENTS
    //
    func liveEventsUpdated(forContentIdentifier identifier: ContentIdentifier, withEvents events: [EventsGroup]) {
        if let eventPaginator = self.eventsPaginators[identifier.pageableId] {
            let flattenedEvents = events.flatMap({ $0.events })
            eventPaginator.updateEventsList(events: flattenedEvents)
        }
    }

    func preLiveEventsUpdated(forContentIdentifier identifier: ContentIdentifier, withEvents events: [EventsGroup]) {
        if let eventPaginator = self.eventsPaginators[identifier.pageableId] {
            let flattenedEvents = events.flatMap({ $0.events })
            eventPaginator.updateEventsList(events: flattenedEvents)
        }
    }

    //
    // SPORTS
    //
    // Update the socket delegate methods to use SportsMerger
    func liveSportsUpdated(withSportTypes sportTypes: [SportRadarModels.SportType]) {
        print("[SERVICEPROVIDER][DELEGATE] Received live sports update with \(sportTypes.count) sports")
        let sports = sportTypes.map(SportRadarModelMapper.sportType(fromSportRadarSportType:))
        sportsMerger?.updateSports(sports, forContentIdentifier: ContentIdentifier(contentType: .liveSports, contentRoute: .liveSports))
    }

    func preLiveSportsUpdated(withSportTypes sportTypes: [SportRadarModels.SportType]) {
        print("[SERVICEPROVIDER][DELEGATE] Received pre-live sports update with \(sportTypes.count) sports")
        if let allSportTypesPublisher = self.allSportTypesPublisher {
            let sports = sportTypes.map(SportRadarModelMapper.sportType(fromSportRadarSportType:))
            allSportTypesPublisher.send(.contentUpdate(content: sports))
        }
    }

    func allSportsUpdated(withSportTypes sportTypes: [SportRadarModels.SportType]) {
        print("[SERVICEPROVIDER][DELEGATE] Received all sports update with \(sportTypes.count) sports")
        let sports = sportTypes.map(SportRadarModelMapper.sportType(fromSportRadarSportType:))
        sportsMerger?.updateSports(sports, forContentIdentifier: ContentIdentifier(contentType: .allSports, contentRoute: .allSports))
    }


    func updateSportLiveCount(nodeId: String, liveCount: Int) {
        print("[SERVICEPROVIDER][DELEGATE] Updating live count for sport \(nodeId): \(liveCount)")
        guard let merger = self.sportsMerger else {
            print("[SERVICEPROVIDER][DELEGATE] Error: SportsMerger not available")
            return
        }
        merger.updateSportLiveCount(nodeId: nodeId, liveCount: liveCount)
    }

    func updateSportEventCount(nodeId: String, eventCount: Int) {
        print("[SERVICEPROVIDER][DELEGATE] Updating event count for sport \(nodeId): \(eventCount)")
        guard let merger = self.sportsMerger else {
            print("[SERVICEPROVIDER][DELEGATE] Error: SportsMerger not available")
            return
        }
        merger.updateSportEventCount(nodeId: nodeId, eventCount: eventCount)
    }

    //
    // EVENTS DETAILS
    //
    func eventDetailsUpdated(forContentIdentifier identifier: ContentIdentifier, event: Event) {
        for eventDetailsCoordinator in self.getValidEventDetailsCoordinators() {
            eventDetailsCoordinator.updateEventDetails(event, forContentIdentifier: identifier)
        }
    }

    // Competition events
    func eventGroups(forContentIdentifier identifier: ContentIdentifier, withEvents events: [EventsGroup]) {
        if let publisher = self.competitionEventsPublisher[identifier] {
            publisher.send(.contentUpdate(content: events))
        }
    }

    func outrightEventGroups(events: [EventsGroup]) {
        if let publisher = self.outrightDetailsPublisher {
            publisher.send(.contentUpdate(content: events))
        }
    }

    func marketDetails(forContentIdentifier identifier: ContentIdentifier, market: Market) {
        if let marketUpdatesCoordinator = marketUpdatesCoordinators[market.id] {
            marketUpdatesCoordinator.updateMarket(market)
        }
    }

    func eventDetailsLiveData(contentIdentifier: ContentIdentifier, eventLiveDataExtended: SportRadarModels.EventLiveDataExtended) {

        for eventDetailsCoordinator in self.getValidEventDetailsCoordinators() {
            eventDetailsCoordinator.updatedLiveData(eventLiveDataExtended: eventLiveDataExtended, forContentIdentifier: contentIdentifier)
        }

        for liveEventDetailsCoordinator in self.getValidLiveEventDetailsCoordinators() {
            liveEventDetailsCoordinator.updatedLiveData(eventLiveDataExtended: eventLiveDataExtended, forContentIdentifier: contentIdentifier)
        }

    }

    func updateEventSecundaryMarkets(forContentIdentifier identifier: ContentIdentifier, event: Event) {
        for eventDetailsCoordinator in self.getValidEventMarketsCoordinators() {
            eventDetailsCoordinator.updatedSecundaryMarkets(forContentIdentifier: identifier,
                                                            onEvent: event)
        }
    }

    func updateEventMainMarket(forContentIdentifier identifier: ContentIdentifier, event: Event) {
        for eventDetailsCoordinator in self.getValidEventMarketsCoordinators() {
            eventDetailsCoordinator.updatedMainMarket(forContentIdentifier: identifier,
                                                            onEvent: event)
        }
    }

    func didReceiveGenericUpdate(content: SportRadarModels.ContentContainer) {
        if let contentIdentifier = content.contentIdentifier,
           let contentIdentifierPaginator = self.eventsPaginators[contentIdentifier.pageableId] {
            contentIdentifierPaginator.handleContentUpdate(content)
        }

        for eventDetailsCoordinator in self.getValidEventDetailsCoordinators() {
            eventDetailsCoordinator.handleContentUpdate(content)
        }

        for liveEventDetailsCoordinator in self.getValidLiveEventDetailsCoordinators() {
            liveEventDetailsCoordinator.handleContentUpdate(content)
        }

        for marketUpdatesCoordinator in self.marketUpdatesCoordinators.values {
            marketUpdatesCoordinator.handleContentUpdate(content)
        }

        for secundaryMarketsCoordinators in self.getValidEventMarketsCoordinators() {
            secundaryMarketsCoordinators.handleContentUpdate(content)
        }
    }

}
//
//
extension SportRadarEventsProvider {

    func getAlertBanners() -> AnyPublisher<[AlertBanner], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getNews() -> AnyPublisher<[News], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getPromotedEventGroupsPointers() -> AnyPublisher<[EventGroupPointer], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getPromotedEventsGroups() -> AnyPublisher<[EventsGroup], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getPromotionalSlidingTopEventsPointers() -> AnyPublisher<[EventMetadataPointer], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getHighlightedBoostedEventsPointers() -> AnyPublisher<[EventMetadataPointer], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getHighlightedVisualImageEventsPointers() -> AnyPublisher<[EventMetadataPointer], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getPromotedEventsBySport() -> AnyPublisher<[SportType : [Event]], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func addFavoriteItem(favoriteId: Int, type: String) -> AnyPublisher<BasicMessageResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func deleteFavoriteItem(favoriteId: Int, type: String) -> AnyPublisher<BasicMessageResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getFeaturedTips(page: Int?, limit: Int?, topTips: Bool?, followersTips: Bool?, friendsTips: Bool?, userId: String?, homeTips: Bool?) -> AnyPublisher<FeaturedTips, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }
}

//
// MARK: - Competition and Match Details
//
extension SportRadarEventsProvider {

    func getMarketGroups(forEvent event: Event) -> AnyPublisher<[MarketGroup], Never> {

        let fallbackMarketGroup = [MarketGroup.init(type: "0",
                                                    id: "0",
                                                    groupKey: "All Markets",
                                                    translatedName: "All Markets",
                                                    position: 0,
                                                    isDefault: true,
                                                    numberOfMarkets: nil,
                                                    loaded: true,
                                                    markets: event.markets)]

        let endpoint = SportRadarRestAPIClient.marketsFilter
        let requestPublisher: AnyPublisher<MarketFilter, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher
            .flatMap({ marketFilters -> AnyPublisher<[MarketGroup], ServiceProviderError> in
                let marketGroups = self.processMarketFilters(marketFilter: marketFilters, match: event)
                return Just(marketGroups).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            })
            .replaceError(with: fallbackMarketGroup)
            .eraseToAnyPublisher()

    }

    func getFieldWidgetId(eventId: String) -> AnyPublisher<FieldWidget, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.fieldWidgetId(eventId: eventId)
        let requestPublisher: AnyPublisher<FieldWidget, ServiceProviderError> = self.restConnector.request(endpoint)
        return requestPublisher
    }

    func getFieldWidget(eventId: String, isDarkTheme: Bool? = nil) -> AnyPublisher<FieldWidgetRenderDataType, ServiceProviderError> {

        var fieldWidgetFile = "field_widget_light.html"
        if isDarkTheme ?? true {
            fieldWidgetFile = "field_widget_dark.html"
        }

        return self.getFieldWidgetId(eventId: eventId).flatMap({ fieldWidget -> AnyPublisher<FieldWidgetRenderDataType, ServiceProviderError> in

            let fileStringSplit = fieldWidgetFile.components(separatedBy: ".")

            let filePath = Bundle.main.path(forResource: fileStringSplit[0], ofType: fileStringSplit[1])
            let contentData = FileManager.default.contents(atPath: filePath!)
            guard
                let widgetHTMLTemplate = NSString(data: contentData!, encoding: String.Encoding.utf8.rawValue) as? String,
                let fieldWidgetId = fieldWidget.data,
                let bundleUrl = Bundle.main.url(forResource: fileStringSplit[0], withExtension: fileStringSplit[1])
            else {
                //
                return Fail(outputType: FieldWidgetRenderDataType.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }

            var replacedHtmlContent = widgetHTMLTemplate.replacingOccurrences(of: "@eventId", with: fieldWidgetId)
            replacedHtmlContent = replacedHtmlContent.replacingOccurrences(of: "@languageCode", with: "fr")

            let fieldWidgetRenderDataType = FieldWidgetRenderDataType.htmlString(url: bundleUrl, htmlString: replacedHtmlContent)
            return Just(fieldWidgetRenderDataType).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

        }).eraseToAnyPublisher()

    }

    func getStatsWidget(eventId: String, marketTypeName: String, isDarkTheme: Bool?) -> AnyPublisher<StatsWidgetRenderDataType, ServiceProviderError> {

        var statsWidgetFile = "stats_widget_light.html"
        if isDarkTheme ?? true {
            statsWidgetFile = "stats_widget_dark.html"
        }

        return self.getFieldWidgetId(eventId: eventId).flatMap({ statsWidget -> AnyPublisher<StatsWidgetRenderDataType, ServiceProviderError> in

            let fileStringSplit = statsWidgetFile.components(separatedBy: ".")

            let filePath = Bundle.main.path(forResource: fileStringSplit[0], ofType: fileStringSplit[1])
            let contentData = FileManager.default.contents(atPath: filePath!)
            let widgetHTMLTemplate = NSString(data: contentData!, encoding: String.Encoding.utf8.rawValue) as? String
            if let statsWidgetId = statsWidget.data,
               let replacedHtmlContent = widgetHTMLTemplate?.replacingOccurrences(of: "@MATCH_ID_PLACEHOLDER", with: statsWidgetId)
                .replacingOccurrences(of: "@MARKET_TYPE_PLACEHOLDER", with: marketTypeName)
                .replacingOccurrences(of: "@LANGUAGE_CODE_PLACEHOLDER", with: "fr"),

                let bundleUrl = Bundle.main.url(forResource: fileStringSplit[0], withExtension: fileStringSplit[1]) {

                let statsWidgetRenderDataType = StatsWidgetRenderDataType.htmlString(url: bundleUrl, htmlString: replacedHtmlContent)
                return Just(statsWidgetRenderDataType).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }

            return Fail(outputType: StatsWidgetRenderDataType.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()

        })
        .eraseToAnyPublisher()


    }

    func getAvailableSportTypes(initialDate: Date? = nil, endDate: Date? = nil) -> AnyPublisher<[SportType], ServiceProviderError> {

        // Navigation Sports
        let sportsEndpoint = SportRadarRestAPIClient.sportsBoNavigationList
        let sportsRequestPublisher: AnyPublisher<SportRadarModels.RestResponse<SportRadarModels.SportsList>, ServiceProviderError> = self.restConnector.request(sportsEndpoint)

        // Code Sports
//        let dateRange = ContentDateFormatter.getDateRangeId(startDate: initialDate, endDate: endDate)
//        let codeSportsEndpoint = SportRadarRestAPIClient.sportsScheduledList(dateRange: dateRange)
//
//        let codeSportsRequestPublisher: AnyPublisher<SportRadarModels.RestResponse<[SportRadarModels.ScheduledSport]>, ServiceProviderError> = self.restConnector.request(codeSportsEndpoint)

//        return Publishers.CombineLatest(sportsRequestPublisher, codeSportsRequestPublisher)
//            .flatMap({ numericSportsList, alphaSportsList -> AnyPublisher<[SportType], ServiceProviderError> in
//                if
//                    let numericSports = numericSportsList.data?.sportNodes?.filter({
//                        $0.numberEvents > 0 || $0.numberOutrightEvents > 0 //|| $0.numberOutrightMarkets > 0
//                    }),
//                    let alphaSports = alphaSportsList.data
//                {
//                    let newNumericSports = numericSports.map(SportRadarModelMapper.sportType(fromSportNode:))
//                    let newAlphaSports = alphaSports.map(SportRadarModelMapper.sportType(fromScheduledSport:))
//                    let unifiedSportsList = self.mergeSports(numericSportArray: newNumericSports, alphaSportArray: newAlphaSports)
//                    let sportTypes = unifiedSportsList.map(SportRadarModelMapper.sportType(fromSportRadarSportType:))
//                    return Just(sportTypes).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
//                }
//                return Fail(outputType: [SportType].self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
//            })
//            .eraseToAnyPublisher()

        return sportsRequestPublisher.flatMap({ numericSportsList -> AnyPublisher<[SportType], ServiceProviderError> in
            if
                let numericSports = numericSportsList.data?.sportNodes?.filter({
                    $0.numberEvents > 0 || $0.numberOutrightEvents > 0 || $0.numberLiveEvents > 0
                }) {

                let mappedNumericSports = numericSports.map(SportRadarModelMapper.sportType(fromSportNode:))

                let sportTypes = mappedNumericSports.map(SportRadarModelMapper.sportType(fromSportRadarSportType:))

                return Just(sportTypes).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            return Fail(outputType: [SportType].self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func getSportRegions(sportId: String) -> AnyPublisher<SportNodeInfo, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.sportRegionsNavigationList(sportId: sportId)
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.SportNodeInfo>, ServiceProviderError> = self.restConnector.request(endpoint)


        return requestPublisher.map( { sportRadarResponse -> SportNodeInfo in
            let sportNodeInfo = sportRadarResponse.data
            let mappedSportNodeInfo = SportRadarModelMapper.sportNodeInfo(fromInternalSportNodeInfo:sportNodeInfo)

            let filteredRegionNode = mappedSportNodeInfo.regionNodes.filter({
                $0.numberEvents != "0" || $0.numberOutrightEvents != "0"
            })

            let filteredSportNodeInfo = SportNodeInfo(id: mappedSportNodeInfo.id, regionNodes: filteredRegionNode)

            return filteredSportNodeInfo

        }).eraseToAnyPublisher()

    }

    func getRegionCompetitions(regionId: String) -> AnyPublisher<SportRegionInfo, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.regionCompetitions(regionId: regionId)
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.SportRegionInfo>, ServiceProviderError> = self.restConnector.request(endpoint)


        return requestPublisher.map( { sportRadarResponse -> SportRegionInfo in
            let sportRegionInfo = sportRadarResponse.data
            let mappedSportRegionInfo = SportRadarModelMapper.sportRegionInfo(fromInternalSportRegionInfo: sportRegionInfo)

            let filteredCompetitionNodes = mappedSportRegionInfo.competitionNodes.filter({
                $0.numberEvents != "0" || $0.numberOutrightEvents != "0"
            })

            let filteredSportRegionInfo = SportRegionInfo(id: mappedSportRegionInfo.id, name: mappedSportRegionInfo.name, competitionNodes: filteredCompetitionNodes)

            return filteredSportRegionInfo

        }).eraseToAnyPublisher()

    }

    func getCompetitionMarketGroups(competitionId: String) -> AnyPublisher<SportCompetitionInfo, ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.competitionMarketGroups(competitionId: competitionId)
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.SportCompetitionInfo>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { sportRadarResponse -> SportCompetitionInfo in
            let sportCompetitionInfo = sportRadarResponse.data
            let mappedSportCompetitionInfo = SportRadarModelMapper.sportCompetitionInfo(fromInternalSportCompetitionInfo: sportCompetitionInfo)
            return mappedSportCompetitionInfo
        })
        .eraseToAnyPublisher()
    }

    func getSearchEvents(query: String, resultLimit: String, page: String, isLive: Bool = false) -> AnyPublisher<EventsGroup, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.search(query: query, resultLimit: resultLimit, page: page, isLive: isLive)

        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<[SportRadarModels.Event]>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { sportRadarResponse -> EventsGroup in
            let events = sportRadarResponse.data
            let mappedEventsGroup = SportRadarModelMapper.eventsGroup(fromInternalEvents: events)

            let filteredEvents = mappedEventsGroup.events.filter({
                $0.id != "_TOKEN_"
            })

            let filteredEventsGroup = EventsGroup(events: filteredEvents, marketGroupId: mappedEventsGroup.marketGroupId)

            return filteredEventsGroup
        })
        .eraseToAnyPublisher()

    }

    func getHomeSliders() -> AnyPublisher<BannerResponse, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.homeSliders

        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.BannerResponse>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { sportRadarResponse -> BannerResponse in
            let bannersResponse = sportRadarResponse.data
            let mappedBannersResponse = SportRadarModelMapper.banners(fromInternalBanners: bannersResponse.bannerItems)
            //            let mappedEventsGroup = SportRadarModelMapper.events(fromInternalEvents: events)

            return mappedBannersResponse
        })
        .eraseToAnyPublisher()

    }

    public func getPromotionalTopBanners() -> AnyPublisher<[PromotionalBanner], ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.promotionalTopBanners
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<[SportRadarModels.PromotionalBannersResponse]>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { sportRadarResponse -> [PromotionalBanner] in
            let promotionalBannersResponse = sportRadarResponse.data.flatMap({ $0.promotionalBannerItems })
            let mappedBannersResponse: [PromotionalBanner] = promotionalBannersResponse.map(SportRadarModelMapper.promotionalBanner(fromInternalPromotionalBanner:))
            return mappedBannersResponse
        })
        .eraseToAnyPublisher()
    }

    public func getPromotionalSlidingTopEvents() -> AnyPublisher<[Event], ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.promotionalTopEvents
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.HeadlineResponse>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher
            .map(\.data)
            .flatMap({ headlineResponse -> AnyPublisher<[Event], ServiceProviderError> in

                let headlineItems = headlineResponse.headlineItems ?? []
                var headlineItemsImages: [String: String] = [:]
                headlineItems.forEach({ item in
                    if let id = item.marketId, let imageURL = item.imageURL {
                        headlineItemsImages[id] = imageURL
                    }
                })
                let marketIds = headlineItems.map({ item in return item.marketId }).compactMap({ $0 })

                let publishers = marketIds.map(self.getEventForMarket(withId:))
                let finalPublisher = Publishers.MergeMany(publishers)
                    .collect()
                    .map({ (events: [Event?]) -> [Event] in
                        return events.compactMap({ $0 })
                    })
                    .map({ events -> [Event] in // Configure the image of each market
                        for event in events {
                            let firstMarketId = event.markets.first?.id ?? ""
                            event.promoImageURL =  headlineItemsImages[firstMarketId]
                        }

                        let cleanedEvents = events.compactMap({ $0 })

                        // create a dictionary from cleanedEvents using marketId as a key
                        var eventDict: [String: Event] = [:] // Dictionary(uniqueKeysWithValues: cleanedEvents.map { ($0.markets.first?.id ?? "", $0) })
                        cleanedEvents.forEach({ event in
                            let firstMarketId = event.markets.first?.id ?? ""
                            eventDict[firstMarketId] = event
                        })

                        // re-order the cleanedEvents based on the order of marketIds in headlineItems
                        let orderedEvents = headlineItems.compactMap { eventDict[$0.marketId ?? ""] }
                        return orderedEvents
                    })
                    .eraseToAnyPublisher()

                return finalPublisher
                    .setFailureType(to: ServiceProviderError.self)
                    .eraseToAnyPublisher()
            })
            .eraseToAnyPublisher()
    }

    func getHighlightedBoostedEvents() -> AnyPublisher<[Event], ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.highlightsBoostedOddsEvents
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.HeadlineResponse>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher
            .map(\.data)
            .flatMap({ headlineResponse -> AnyPublisher<[Event], ServiceProviderError> in

                let headlineItems = headlineResponse.headlineItems ?? []
                var headlineItemsOldMarkets: [String: String] = [:]
                headlineItems.forEach({ item in
                    if let id = item.marketId, let oldMarketId = item.oldMarketId {
                        headlineItemsOldMarkets[id] = oldMarketId
                    }
                })

                let marketIds = headlineItems.map({ item in return item.marketId }).compactMap({ $0 })

                let publishers = marketIds.map(self.getEventForMarket(withId:))
                let finalPublisher = Publishers.MergeMany(publishers)
                    .collect()
                    .map({ (events: [Event?]) -> [Event] in
                        return events.compactMap({ $0 })
                    })
                    .map({ (events: [Event]) -> [Event] in

                        for event in events {
                            let firstMarketId = event.markets.first?.id ?? ""
                            event.oldMainMarketId =  headlineItemsOldMarkets[firstMarketId]
                        }

                        let cleanedEvents = events.compactMap({ $0 })

                        // create a dictionary from cleanedEvents using marketId as a key
                        var eventDict: [String: Event] = [:]
                        cleanedEvents.forEach({ event in
                            let firstMarketId = event.markets.first?.id ?? ""
                            eventDict[firstMarketId] = event
                        })

                        // re-order the cleanedEvents based on the order of marketIds in headlineItems
                        let orderedEvents = headlineItems.compactMap { item in eventDict[item.marketId ?? ""] }
                        return orderedEvents
                    })

                    .eraseToAnyPublisher()

                return finalPublisher
                    .setFailureType(to: ServiceProviderError.self)
                    .eraseToAnyPublisher()
            })
            .eraseToAnyPublisher()
    }

    func getHighlightedVisualImageEvents() -> AnyPublisher<[Event], ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.highlightsImageVisualEvents
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.HeadlineResponse>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher
            .map(\.data)
            .flatMap({ headlineResponse -> AnyPublisher<[Event], ServiceProviderError> in

                let headlineItems = headlineResponse.headlineItems ?? []
                var headlineItemsImages: [String: String] = [:]

                headlineItems.forEach({ item in
                    if let id = item.marketId, let imageURL = item.imageURL {
                        headlineItemsImages[id] = imageURL
                    }
                })
                let marketIds = headlineItems.map({ item in return item.marketId }).compactMap({ $0 })

                let publishers = marketIds.map(self.getEventForMarket(withId:))
                let finalPublisher = Publishers.MergeMany(publishers)
                    .collect()
                    .map({ (events: [Event?]) -> [Event] in
                        return events.compactMap({ $0 })
                    })
                    .map({ events -> [Event] in // Configure the image of each market
                        for event in events {
                            let firstMarketId = event.markets.first?.id ?? ""
                            event.promoImageURL =  headlineItemsImages[firstMarketId]
                        }

                        let cleanedEvents = events.compactMap({ $0 })

                        // create a dictionary from cleanedEvents using marketId as a key
                        var eventDict: [String: Event] = [:]
                        cleanedEvents.forEach({ event in
                            let firstMarketId = event.markets.first?.id ?? ""
                            eventDict[firstMarketId] = event
                        })

                        // re-order the cleanedEvents based on the order of marketIds in headlineItems
                        let orderedEvents = headlineItems.compactMap { eventDict[$0.marketId ?? ""] }
                        return orderedEvents
                    })
                    .eraseToAnyPublisher()

                return finalPublisher
                    .setFailureType(to: ServiceProviderError.self)
                    .eraseToAnyPublisher()
            })
            .eraseToAnyPublisher()
    }

    public func getHighlightedMarkets() -> AnyPublisher<[HighlightMarket], ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.highlightsMarkets
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.HeadlineResponse>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher
            .map(\.data)
            .flatMap { headlineResponse -> AnyPublisher<[HighlightMarket], ServiceProviderError> in
                let headlineItems = headlineResponse.headlineItems ?? []
                var headlineItemsImages: [String: String] = [:]
                var headlineItemsPresentedSelection: [String: String] = [:]

                headlineItems.forEach { item in
                    if let id = item.marketId, let imageURL = item.imageURL {
                        headlineItemsImages[id] = imageURL
                        headlineItemsPresentedSelection[id] = item.numofselections
                    }
                }

                // Mapeia `marketIds` com índices para preservar a ordem original
                let marketIds = headlineItems.compactMap { $0.marketId }

                var uniqueMarketIds = [String]()
                for id in marketIds {
                    if !uniqueMarketIds.contains(id) {
                        uniqueMarketIds.append(id)
                    }
                }

                let marketIdIndexMap = Dictionary(uniqueKeysWithValues: uniqueMarketIds.enumerated().map { ($1, $0) })

                let publishers = marketIds.map { id in
                    return self.getMarketInfo(marketId: id)
                        .map { market in
                            return Optional(market)
                        }
                        .replaceError(with: nil)
                }

                let finalPublisher = Publishers.MergeMany(publishers)
                    .collect()
                    .map { (markets: [Market?]) -> [HighlightMarket] in
                        let marketValue = markets.compactMap { $0 }
                        var highlightMarkets = [HighlightMarket]()

                        for market in marketValue {
                            let enableSelections = headlineItemsPresentedSelection[market.id] ?? "0"
                            let enabledSelectionsCount = Int(enableSelections) ?? 0
                            let imageURL = headlineItemsImages[market.id]

                            let highlightMarket = HighlightMarket(
                                market: market,
                                enabledSelectionsCount: enabledSelectionsCount,
                                promotionImageURl: imageURL
                            )
                            highlightMarkets.append(highlightMarket)
                        }

                        // Ordena `highlightMarkets` com base na posição original em `marketIdIndexMap`
                        return highlightMarkets.sorted {
                            guard let index1 = marketIdIndexMap[$0.market.id],
                                  let index2 = marketIdIndexMap[$1.market.id]
                            else { return false }
                            return index1 < index2
                        }
                    }
                    .eraseToAnyPublisher()

                return finalPublisher
                    .setFailureType(to: ServiceProviderError.self)
                    .eraseToAnyPublisher()
            }
            .eraseToAnyPublisher()
    }


    public func getPromotionalTopStories() -> AnyPublisher<[PromotionalStory], ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.promotionalTopStories

        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.PromotionalStoriesResponse>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { sportRadarResponse -> [PromotionalStory] in

            let promotionalStoriesResponse = sportRadarResponse.data

            let mappedPromotionalStoriesResponse = SportRadarModelMapper.promotionalStoriesResponse(fromInternalPromotionalStoriesResponse: promotionalStoriesResponse)

            let mappedPromotionalStories = mappedPromotionalStoriesResponse.promotionalStories

            return mappedPromotionalStories
        })
        .eraseToAnyPublisher()
    }

    func getHeroGameEvent() -> AnyPublisher<[Event], ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.getHeroGameCard
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.HeadlineResponse>, ServiceProviderError> = self.restConnector.request(endpoint)

        var eventMarketGroupRelations: [String: String] = [:]
        var uniqueMarketGroupIds: [String] = []

        return requestPublisher
            .map(\.data)
            .flatMap({ headlineResponse -> AnyPublisher<[Event], ServiceProviderError> in

                let headlineItems = headlineResponse.headlineItems ?? []
                var headlineItemImage = [String: String]()


                headlineItems.forEach({ item in
                    if let id = item.marketGroupId, let imageURL = item.imageURL {
                        headlineItemImage[id] = imageURL
                    }
                })

                let marketGroupIds = headlineItems.map { $0.marketGroupId }.compactMap { $0 }

                var seen = Set<String>() // Adjust the type according to the type of `marketGroupId`

                uniqueMarketGroupIds = marketGroupIds.filter { marketGroupId in
                    guard !seen.contains(marketGroupId) else { return false }
                    seen.insert(marketGroupId)
                    return true
                }

                // Support multiple events
                let publishers = uniqueMarketGroupIds.map { marketGroupId in
                    self.getEventForMarketGroup(withId: marketGroupId)
                        .map({ event -> Event in

                            eventMarketGroupRelations[event.id] = marketGroupId

                            event.promoImageURL = headlineItemImage[marketGroupId] ?? ""

                            let firstMarket = event.markets.first
                            event.homeTeamName = firstMarket?.homeParticipant ?? ""
                            event.awayTeamName = firstMarket?.awayParticipant ?? ""
                            event.name = firstMarket?.eventName ?? ""
                            return event
                        })
                        .eraseToAnyPublisher()
                }

                // Combine all the publishers into a single one that emits an array of events
                return Publishers.MergeMany(publishers)
                    .collect()
                    // Restore the original order of events
                    .map { events in
                        return events.sorted { leftEvent, rightEvent in
                            let leftEventMarketGroupId = eventMarketGroupRelations[leftEvent.id] ?? ""
                            let rightEventMarketGroupId = eventMarketGroupRelations[rightEvent.id] ?? ""

                            let leftPosition = uniqueMarketGroupIds.firstIndex(of: leftEventMarketGroupId) ?? 100
                            let rightPosition = uniqueMarketGroupIds.firstIndex(of: rightEventMarketGroupId) ?? 101

                            return leftPosition < rightPosition
                        }
                    }
                    .eraseToAnyPublisher()

            })
            .eraseToAnyPublisher()
    }

    public func getPromotedSports() -> AnyPublisher<[PromotedSport], ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.promotedSports
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.PromotedSportsResponse>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { sportRadarResponse -> [PromotedSport] in
            let promotedSports = sportRadarResponse.data.promotedSports
            let mappedPromotedSports = promotedSports.map(SportRadarModelMapper.promotedSport(fromInternalPromotedSport:))
            return mappedPromotedSports
        })
        .eraseToAnyPublisher()
    }

    func getCashbackSuccessBanner() -> AnyPublisher<BannerResponse, ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.getCashbackSuccessBanner
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.BannerResponse>, ServiceProviderError> = self.restConnector.request(endpoint)
        return requestPublisher.map( { sportRadarResponse -> BannerResponse in
            let bannersResponse = sportRadarResponse.data
            let mappedBannersResponse = SportRadarModelMapper.banners(fromInternalBanners: bannersResponse.bannerItems)
            return mappedBannersResponse
        })
        .eraseToAnyPublisher()

    }

    func getTopCompetitionsPointers() -> AnyPublisher<[TopCompetitionPointer], ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.getTopCompetitions
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<[SportRadarModels.TopCompetitionData]>, ServiceProviderError> = self.restConnector.request(endpoint)
        return requestPublisher.map( { sportRadarResponse -> [TopCompetitionPointer] in
            let topCompetitions = sportRadarResponse.data.flatMap({
                $0.competitions
            })
            let mappedTopCompetitions = topCompetitions.map(SportRadarModelMapper.topCompetitionPointer(fromInternalTopCompetitionPointer:))
            return mappedTopCompetitions
        })
        .eraseToAnyPublisher()
    }

    func getTopCompetitions() -> AnyPublisher<[TopCompetition], ServiceProviderError> {

        let publisher = self.getTopCompetitionsPointers()
            .flatMap({ (topCompetitionPointers: [TopCompetitionPointer]) -> AnyPublisher<[TopCompetition], ServiceProviderError> in

                let getCompetitonNodesRequests: [AnyPublisher<SportRadarModels.SportCompetitionInfo?, ServiceProviderError>] = topCompetitionPointers
                    .map { topCompetitionPointer in
                        let competitionIdComponents = topCompetitionPointer.competitionId.components(separatedBy: "/")
                        let competitionId: String = (competitionIdComponents.last ?? "").lowercased()

                        if !competitionId.hasSuffix(".1") {
                            return Just(Optional<SportRadarModels.SportCompetitionInfo>.none)
                                .setFailureType(to: ServiceProviderError.self)
                                .eraseToAnyPublisher()
                        }

                        let endpoint = SportRadarRestAPIClient.competitionMarketGroups(competitionId: competitionId)
                        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.SportCompetitionInfo>, ServiceProviderError> = self.restConnector.request(endpoint)
                        return requestPublisher.map({ response in
                            return response.data
                        })
                        .catch({ (error: ServiceProviderError) -> AnyPublisher<SportRadarModels.SportCompetitionInfo?, ServiceProviderError> in
                            return Just(Optional<SportRadarModels.SportCompetitionInfo>.none)
                                .setFailureType(to: ServiceProviderError.self)
                                .eraseToAnyPublisher()
                        })
                        .eraseToAnyPublisher()
                    }

                let mergedPublishers = Publishers.MergeMany(getCompetitonNodesRequests)
                    .compactMap({ $0 })
                    .collect()
                    .flatMap { competitionsInfoArray -> AnyPublisher<[TopCompetition], ServiceProviderError> in

                        let getCompetitonCountryRequests: [AnyPublisher<SportRadarModels.CompetitionParentNode, ServiceProviderError>] = competitionsInfoArray
                            .map { (competitionsInfo: SportRadarModels.SportCompetitionInfo) -> AnyPublisher<SportRadarModels.CompetitionParentNode, ServiceProviderError>? in

                                guard
                                    let parentId = competitionsInfo.parentId
                                else {
                                    // If no parent id, we cannot request country info
                                    return nil
                                }

                                let endpoint = SportRadarRestAPIClient.getTopCompetitionCountry(competitionId: parentId)
                                let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.CompetitionParentNode>, ServiceProviderError> = self.restConnector.request(endpoint)

                                return requestPublisher.map({ (response: SportRadarModels.SportRadarResponse<SportRadarModels.CompetitionParentNode>) -> SportRadarModels.CompetitionParentNode in
                                    return response.data
                                })
                                .eraseToAnyPublisher()
                            }
                            .compactMap({ $0 })

                        return Publishers.MergeMany(getCompetitonCountryRequests)
                            .collect()
                            .map { (competitionParentNodes: [SportRadarModels.CompetitionParentNode]) -> [TopCompetition] in
                                var topCompetitionsArray: [TopCompetition] = []

                                var competitionCountriesDictionary: [String: String] = [:]
                                for competitionParentNode in competitionParentNodes {
                                    competitionCountriesDictionary[competitionParentNode.id] = competitionParentNode.name
                                }

                                var competitionAndParentIdDictionary: [String: String] = [:]
                                for competitionsInfo in competitionsInfoArray {
                                    if let parentId = competitionsInfo.parentId {
                                        competitionAndParentIdDictionary[competitionsInfo.id] = parentId
                                    }
                                }

                                for topCompetitionPointer in topCompetitionPointers {

                                    let competitionIdComponents = topCompetitionPointer.competitionId.components(separatedBy: "/")
                                    let competitionId: String = (competitionIdComponents.last ?? "").lowercased()

                                    let competitionParentId = competitionAndParentIdDictionary[competitionId] ?? ""

                                    guard
                                        let competitonCountryName = competitionCountriesDictionary[competitionParentId]
                                    else {
                                        continue
                                    }

                                    let country: Country? = Country.country(withName: competitonCountryName)

                                    let sportNameComponents = topCompetitionPointer.competitionId.components(separatedBy: "/")
                                    let sportName: String = (sportNameComponents[safe: sportNameComponents.count - 3] ?? "").lowercased()

                                    let namedSport: SportRadarModels.SportType = SportRadarModels.SportType.init(name: sportName, numberEvents: 0, numberOutrightEvents: 0, numberOutrightMarkets: 0, numberLiveEvents: 0)
                                    let mappedSport = SportRadarModelMapper.sportType(fromSportRadarSportType: namedSport)

                                    topCompetitionsArray.append(
                                        TopCompetition(id: competitionId,
                                                       name: topCompetitionPointer.name,
                                                       country: country,
                                                       sportType: mappedSport))
                                }
                                return topCompetitionsArray
                            }
                            .eraseToAnyPublisher()
                    }

                return mergedPublishers.eraseToAnyPublisher()
            })

        return publisher.eraseToAnyPublisher()
    }

    func getEventSummary(eventId: String, marketLimit: Int?) -> AnyPublisher<Event, ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.getEventSummary(eventId: eventId)
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.Event>, ServiceProviderError> = self.restConnector.request(endpoint)
        return requestPublisher.map( { sportRadarResponse -> Event in
            let event = sportRadarResponse.data
            let mappedEvent = SportRadarModelMapper.event(fromInternalEvent: event)
            return mappedEvent
        })
        .eraseToAnyPublisher()
    }

    func getEventSummary(forMarketId marketId: String) -> AnyPublisher<Event, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.getMarketInfo(marketId: marketId)
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.Event>, ServiceProviderError> = self.restConnector.request(endpoint)
        return requestPublisher.map( { sportRadarResponse -> Event in
            let event = sportRadarResponse.data
            let mappedEvent = SportRadarModelMapper.event(fromInternalEvent: event)
            return mappedEvent
        })
        .eraseToAnyPublisher()

    }

    func getMarketInfo(marketId: String) -> AnyPublisher<Market, ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.getMarketInfo(marketId: marketId)
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.Market>, ServiceProviderError> = self.restConnector.request(endpoint)
        return requestPublisher.map( { sportRadarResponse -> Market in
            let market = sportRadarResponse.data
            let mappedMarket = SportRadarModelMapper.market(fromInternalMarket: market)
            return mappedMarket
        })
        .eraseToAnyPublisher()
    }

    func getEventForMarketGroup(withId marketGroupId: String) -> AnyPublisher<Event, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.getEventForMarketGroup(marketGroupId: marketGroupId)

        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.MarketGroup>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.tryMap( { sportRadarResponse -> Event in
            guard
                let event = SportRadarModelMapper.event(fromInternalMarkets: sportRadarResponse.data.markets)
                else {
                throw ServiceProviderError.errorMessage(message: "No event found for marketGroup")
            }
            return event
        })
        .mapError { error -> ServiceProviderError in
            if let serviceProviderError = error as? ServiceProviderError {
                return serviceProviderError
            } else {
                return ServiceProviderError.errorMessage(message: error.localizedDescription)
            }
        }
        .eraseToAnyPublisher()
    }

    public func getEventsForEventGroup(withId eventGroupId: String) -> AnyPublisher<EventsGroup, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.getEventsForEventGroup(eventGroupId: eventGroupId)

        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.EventsGroup>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { sportRadarResponse -> EventsGroup in
            let eventsGroup = sportRadarResponse.data
            let mappedEventsGroup = SportRadarModelMapper.eventsGroup(fromInternalEventsGroup: eventsGroup)

            let filteredEvents = mappedEventsGroup.events.filter({
                $0.id != "_TOKEN_"
            })

            let filteredEventsGroup = EventsGroup(events: filteredEvents, marketGroupId: eventsGroup.marketGroupId)
            return filteredEventsGroup
        })
        .eraseToAnyPublisher()
    }

    func getEventForMarket(withId marketId: String) -> AnyPublisher<Event?, Never> {
        let endpoint = SportRadarRestAPIClient.getEventForMarket(marketId: marketId)
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.Event>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { sportRadarResponse -> Event in
            let event = sportRadarResponse.data
            let mappedEvent = SportRadarModelMapper.event(fromInternalEvent: event)
            return mappedEvent
        })
        .replaceError(with: nil)
        .eraseToAnyPublisher()
    }

    //
    // MARK: - Favorites
    //
    func getFavoritesList() -> AnyPublisher<FavoritesListResponse, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.favoritesList

        let requestPublisher: AnyPublisher<SportRadarModels.FavoritesListResponse, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { favoritesListResponse -> FavoritesListResponse in

            let mappedFavoritesListResponse = SportRadarModelMapper.favoritesListResponse(fromInternalFavoritesListResponse: favoritesListResponse)

            return mappedFavoritesListResponse
        })
        .eraseToAnyPublisher()
    }

    func addFavoritesList(name: String) -> AnyPublisher<FavoritesListAddResponse, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.addFavoriteList(name: name)

        let requestPublisher: AnyPublisher<SportRadarModels.FavoritesListAddResponse, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { favoritesListAddResponse -> FavoritesListAddResponse in

            let mappedFavoritesListAddResponse = SportRadarModelMapper.favoritesListAddResponse(fromInternalFavoritesListAddResponse: favoritesListAddResponse)

            return mappedFavoritesListAddResponse
        })
        .eraseToAnyPublisher()
    }

    func deleteFavoritesList(listId: Int) -> AnyPublisher<FavoritesListDeleteResponse, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.deleteFavoriteList(listId: listId)

        let requestPublisher: AnyPublisher<SportRadarModels.FavoritesListDeleteResponse, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { favoritesListDeleteResponse -> FavoritesListDeleteResponse in

            let mappedFavoritesListDeleteResponse = SportRadarModelMapper.favoritesListDeleteResponse(fromInternalFavoritesListDeleteResponse: favoritesListDeleteResponse)

            return mappedFavoritesListDeleteResponse
        })
        .eraseToAnyPublisher()
    }

    func addFavoriteToList(listId: Int, eventId: String) -> AnyPublisher<FavoriteAddResponse, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.addFavoriteToList(listId: listId, eventId: eventId)

        let requestPublisher: AnyPublisher<SportRadarModels.FavoriteAddResponse, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { favoriteAddResponse -> FavoriteAddResponse in

            let mappedFavoriteAddResponse = SportRadarModelMapper.favoriteAddResponse(fromInternalFavoriteAddResponse: favoriteAddResponse)

            return mappedFavoriteAddResponse
        })
        .eraseToAnyPublisher()
    }

    func getFavoritesFromList(listId: Int) -> AnyPublisher<FavoriteEventResponse, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.getFavoritesFromList(listId: listId)

        let requestPublisher: AnyPublisher<SportRadarModels.FavoriteEventResponse, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { favoriteEventResponse -> FavoriteEventResponse in

            let mappedFavoriteEventResponse = SportRadarModelMapper.favoritesEventResponse(fromInternalFavoritesEventResponse: favoriteEventResponse)

            return mappedFavoriteEventResponse
        })
        .eraseToAnyPublisher()
    }

    func deleteFavoriteFromList(eventId: Int) -> AnyPublisher<FavoritesListDeleteResponse, ServiceProviderError> {

        let endpoint = SportRadarRestAPIClient.deleteFavoriteFromList(eventId: eventId)

        let requestPublisher: AnyPublisher<SportRadarModels.FavoritesListDeleteResponse, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { favoritesListDeleteResponse -> FavoritesListDeleteResponse in

            let mappedFavoritesListDeleteResponse = SportRadarModelMapper.favoritesListDeleteResponse(fromInternalFavoritesListDeleteResponse: favoritesListDeleteResponse)

            return mappedFavoritesListDeleteResponse
        })
        .eraseToAnyPublisher()
    }

    func getEventDetails(eventId: String) -> AnyPublisher<Event, ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.getEventDetails(eventId: eventId)

        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.Event>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { sportRadarResponse -> Event in
            let event = sportRadarResponse.data
            let mappedEvent = SportRadarModelMapper.event(fromInternalEvent: event)
            return mappedEvent
        })
        .eraseToAnyPublisher()
    }


    func getEventLiveData(eventId: String) -> AnyPublisher<EventLiveData, ServiceProviderError> {

        let liveDataContentType = ContentType.eventDetailsLiveData
        let liveDataContentRoute = ContentRoute.eventDetailsLiveData(eventId: eventId)
        let liveDataContentIdentifier = ContentIdentifier(contentType: liveDataContentType, contentRoute: liveDataContentRoute)

        let endpoint = SportRadarRestAPIClient.get(contentIdentifier: liveDataContentIdentifier)

        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.EventLiveDataExtended>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { sportRadarResponse -> EventLiveData in
            return SportRadarModelMapper.eventLiveData(fromInternalEventLiveData: sportRadarResponse.data)
        })
        .eraseToAnyPublisher()

    }

    func getEventSecundaryMarkets(eventId: String) -> AnyPublisher<Event, ServiceProviderError> {
        let endpoint = SportRadarRestAPIClient.getEventSecundaryMarkets(eventId: eventId)

        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<SportRadarModels.Event>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { sportRadarResponse -> Event in
            return SportRadarModelMapper.event(fromInternalEvent: sportRadarResponse.data)
        })
        .eraseToAnyPublisher()
    }


    func subscribeEventMarkets(eventId: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {

        guard
            let sessionToken = socketConnector.token
        else {
            return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
        }

        if let eventDetailsCoordinator = self.getValidEventMarketsCoordinator(forKey: eventId) {
            return eventDetailsCoordinator.eventWithSecundaryMarketsPublisher
        }
        else {
            let eventDetailsCoordinator = SportRadarEventMarketsCoordinator(matchId: eventId,
                                                                            sessionToken: sessionToken.hash,
                                                                            storage: SportRadarEventStorage())
            self.addEventMarketsCoordinator(eventDetailsCoordinator, withKey: eventId)
            eventDetailsCoordinator.start() // Triggers the subscription
            return eventDetailsCoordinator.eventWithSecundaryMarketsPublisher
        }

    }

    func getPromotedBetslips(userId: String?) -> AnyPublisher<[PromotedBetslip], ServiceProviderError> {
        let endpoint = VaixAPIClient.promotedBetslips(userId: userId)

        let requestPublisher: AnyPublisher<SportRadarModels.PromotedBetslipsBatchResponse, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher
            .mapError({ error in
                return error
            })
            .map { response in
                let promotedBetslipsBatchResponse = SportRadarModelMapper.promotedBetslipsBatchResponse(fromInternalPromotedBetslipsBatchResponse: response)
                return promotedBetslipsBatchResponse.promotedBetslips
            }
            .eraseToAnyPublisher()
    }

    func getHighlightedLiveEventsPointers(eventCount: Int, userId: String?) -> AnyPublisher<[String], ServiceProviderError> {
        let endpoint = VaixAPIClient.popularEvents(eventsCount: eventCount, userId: userId)
        let requestPublisher: AnyPublisher<SportRadarModels.SportRadarResponse<[SportRadarModels.HighlightedEventPointer]>, ServiceProviderError> = self.restConnector.request(endpoint)

        return requestPublisher.map( { highlightedEventPointerResponse -> [String] in
            let eventsIds = highlightedEventPointerResponse.data
                .compactMap { fullEvent in
                    return fullEvent.eventId.split(separator: ":").last
                }
                .map(String.init)
            return eventsIds
        })
        .mapError({ error in
            return error
        })
        .eraseToAnyPublisher()

    }

    func getHighlightedLiveEvents(eventCount: Int, userId: String?) -> AnyPublisher<[Event], ServiceProviderError> {

        let publisher = self.getHighlightedLiveEventsPointers(eventCount: eventCount, userId: userId) // Get the ids
            .flatMap({ (eventPointers: [String]) -> AnyPublisher<[Event], ServiceProviderError> in

                let getEventSummaryRequests: [AnyPublisher<Event?, ServiceProviderError>] = eventPointers
                    .map { (eventId: String) -> AnyPublisher<Event?, ServiceProviderError> in
                        return self.getEventSummary(eventId: eventId, marketLimit: nil) // Get the event summary for each id
                            .map({ Optional<Event>.some($0) })
                            // Replace the errors for nil so we can continue with other requests
                            .catch({ (error: ServiceProviderError) -> AnyPublisher<Event?, ServiceProviderError> in
                                return Just(Optional<Event>.none)
                                    .setFailureType(to: ServiceProviderError.self)
                                    .eraseToAnyPublisher()
                            })
                            .compactMap({ $0 })
                            .eraseToAnyPublisher()
                    }

                let mergedPublishers = Publishers.MergeMany(getEventSummaryRequests) // Combine the publishers
                    .compactMap({ $0 }) //
                    .collect()
                    .map({ validEvents in
                        print("getHighlightedLiveEvents: \(validEvents.count)")
                        return validEvents
                    })
                return mergedPublishers.eraseToAnyPublisher()
            })
        return publisher.eraseToAnyPublisher()
    }

    func subscribeToEventAndSecondaryMarkets(withId id: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {
        return Fail(error: ServiceProviderError.userSessionNotFound).eraseToAnyPublisher()
    }

}

//
//extension SportRadarEventsProvider: UnsubscriptionController {
//    func getSuggestedBets() -> {
//
//    }
//}
//

extension SportRadarEventsProvider: UnsubscriptionController {

    func unsubscribe(subscription: Subscription) {
        let endpoint = SportRadarRestAPIClient.unsubscribe(sessionToken: subscription.sessionToken, contentIdentifier: subscription.contentIdentifier)
        guard let request = endpoint.request() else { return }
        let sessionDataTask = URLSession.shared.dataTask(with: request) { data, response, error in
            guard
                error == nil,
                let httpResponse = response as? HTTPURLResponse,
                (200...299).contains(httpResponse.statusCode)
            else {
                print("SportRadarEventsProvider unsubscribe failed")
                return
            }
            print("SportRadarEventsProvider unsubscribe ok")
        }
        sessionDataTask.resume()
    }

}

// Helpers
extension SportRadarEventsProvider {

}

extension SportRadarEventsProvider {

    private func mergeSports(numericSportArray: [SportRadarModels.SportType], alphaSportArray: [SportRadarModels.SportType]) -> [SportRadarModels.SportType] {

        var uniqueSportsArray: [SportRadarModels.SportType] = []

        for numericSport in numericSportArray {

            if numericSport.name.lowercased() == "top bets"
                || numericSport.name.lowercased() == "top bet"
                || numericSport.name.lowercased() == "outrights"
                || numericSport.name.lowercased() == "popular" {
                continue
            }

            let alphaFilter = alphaSportArray.filter({ $0.name.lowercased() == numericSport.name.lowercased() })

            if let alphaSport = alphaFilter.first {
                let mergedSport = SportRadarModels.SportType(name: numericSport.name,
                                                             numericId: numericSport.numericId,
                                                             alphaId: alphaSport.alphaId,
                                                             numberEvents: numericSport.numberEvents,
                                                             numberOutrightEvents: numericSport.numberOutrightEvents,
                                                             numberOutrightMarkets: numericSport.numberOutrightMarkets,
                                                             numberLiveEvents: numericSport.numberLiveEvents)
                uniqueSportsArray.append(mergedSport)
            }
            else {
                uniqueSportsArray.append(numericSport)
            }
        }

        for alphaSport in alphaSportArray {
            if !uniqueSportsArray.contains(where: { $0.name.lowercased() == alphaSport.name.lowercased() }) {
                uniqueSportsArray.append(alphaSport)
            }
        }

        return uniqueSportsArray
    }

    private func processMarketFilters(marketFilter: MarketFilter, match: Event) -> [MarketGroup] {

        var eventMarkets: [MarketGroupPointer] = []
        var marketGroups: OrderedDictionary<String, MarketGroup> = [:]
        var availableMarkets: [String: [AvailableMarket]] = [:]

        var marketPositions: [String: Int] = [:] //mmarket id : market position

        // NEW PARSE
        for marketFilter in marketFilter.marketFilters {
            let marketGroupKey = (marketFilter.translations?.english ?? "")
            // SPECIFIC MARKET IDS
            var selectedMarketIds: [String] = []

            if let selectedMarketSports = marketFilter.marketsSportType?.marketSports {

                for marketSportType in selectedMarketSports {
                    let eventSportCode = match.sport.alphaId ?? ""
                    for marketSport in marketSportType.value {

                        if eventSportCode.contains(marketSportType.key) || marketSportType.key.lowercased() == "all" {
                            let marketSportId = marketSport.ids[0]
                            let marketPosition = marketSport.marketOrder

                            marketPositions["\(marketGroupKey)-\(marketSportId)"] = marketPosition

                            selectedMarketIds.append(marketSportId)
                        }
                    }
                }
            }
            let id = marketFilter.translations?.english ??  "\(marketFilter.displayOrder)"
            let eventMarket = MarketGroupPointer(id: id,
                                                 name: marketGroupKey,
                                                 marketGroupIds: selectedMarketIds,
                                                 groupOrder: marketFilter.displayOrder)
            eventMarkets.append(eventMarket)
        }

        let matchMarkets = match.markets

        for matchMarket in matchMarkets {

            if let marketFilterId = matchMarket.marketFilterId {

                for eventMarket in eventMarkets {

                    if eventMarket.marketGroupIds.contains(marketFilterId) {

                        if availableMarkets[eventMarket.name] == nil {
                            let availableMarket = AvailableMarket(marketId: matchMarket.id,
                                                                  marketGroupId: eventMarket.id,
                                                                  market: matchMarket,
                                                                  orderGroupOrder: eventMarket.groupOrder)
                            availableMarkets[eventMarket.name] = [availableMarket]
                        }
                        else {
                            let availableMarket = AvailableMarket(marketId: matchMarket.id,
                                                                  marketGroupId: eventMarket.id,
                                                                  market: matchMarket,
                                                                  orderGroupOrder: eventMarket.groupOrder)
                            availableMarkets[eventMarket.name]?.append(availableMarket)
                        }

                    }

                }

                // Add to All Market aswell
                let allEventMarket = eventMarkets.filter({
                    $0.name.lowercased() == "all markets"
                })

                let eventMarket = allEventMarket[0]

                if availableMarkets[eventMarket.name] == nil {
                    let availableMarket = AvailableMarket(marketId: matchMarket.id,
                                                          marketGroupId: eventMarket.id,
                                                          market: matchMarket,
                                                          orderGroupOrder: eventMarket.groupOrder)
                    availableMarkets[eventMarket.name] = [availableMarket]
                }
                else {
                    let availableMarket = AvailableMarket(marketId: matchMarket.id,
                                                          marketGroupId: eventMarket.id,
                                                          market: matchMarket,
                                                          orderGroupOrder: eventMarket.groupOrder)
                    availableMarkets[eventMarket.name]?.append(availableMarket)
                }

            }
            else {
                let allEventMarket = eventMarkets.filter({
                    $0.name.lowercased() == "all markets"
                })

                let eventMarket = allEventMarket[0]
                if availableMarkets[eventMarket.name] == nil {
                    let availableMarket = AvailableMarket(marketId: matchMarket.id,
                                                          marketGroupId: eventMarket.id,
                                                          market: matchMarket,
                                                          orderGroupOrder: eventMarket.groupOrder)
                    availableMarkets[eventMarket.name] = [availableMarket]
                }
                else {
                    let availableMarket = AvailableMarket(marketId: matchMarket.id,
                                                          marketGroupId: eventMarket.id,
                                                          market: matchMarket,
                                                          orderGroupOrder: eventMarket.groupOrder)
                    availableMarkets[eventMarket.name]?.append(availableMarket)
                }
            }
        }

        for availableMarket in availableMarkets {
            let groupMarkets = availableMarket.value
                .map(\.market)

            let sortedMarkets = groupMarkets
                .sorted { lhs, rhs in
                    let lhsKey = "\(availableMarket.key)-\(lhs.marketFilterId ?? "")"
                    let rhsKey = "\(availableMarket.key)-\(rhs.marketFilterId ?? "")"

                    let lhsPosition = marketPositions[lhsKey] ?? 999
                    let rhsPosition = marketPositions[rhsKey] ?? 999

                    return lhsPosition < rhsPosition
                }

            let marketGroup = MarketGroup(type: availableMarket.key,
                                          id: availableMarket.value.first?.marketGroupId ?? "0",
                                          groupKey: "\(availableMarket.value.first?.marketGroupId ?? "0")",
                                          translatedName: availableMarket.key.capitalized,
                                          position: availableMarket.value.first?.orderGroupOrder ?? 120,
                                          isDefault: false,
                                          numberOfMarkets: availableMarket.value.count,
                                          loaded: true,
                                          markets: sortedMarkets)

            marketGroups[availableMarket.key] = marketGroup
        }

        var marketGroupsArray = Array(marketGroups.values)
        var sortedMarketGroupsArray: [MarketGroup]

        // Make sure all markets is last
        if let allMarketsIndex = marketGroupsArray.firstIndex(where: { $0.id.lowercased() == "all markets" }) {
            // Remove "All Markets" from the array
            let allMarketsItem = marketGroupsArray.remove(at: allMarketsIndex)

            // Sort the remaining items
            let remainingItems = marketGroupsArray.sorted(by: {
                if ($0.position ?? 0) == ($1.position ?? 0) {
                    return ($0.groupKey ?? "") < ($1.groupKey ?? "")
                }
                return ($0.position ?? 0) < ($1.position ?? 999)
            })

            // Insert "All Markets" at the start of the sorted array
            // sortedMarketGroupsArray = [allMarketsItem] + remainingItems

            // Now AllMarkets group tab should be in the end
            sortedMarketGroupsArray = remainingItems + [allMarketsItem]

        } else {
            // If "All Markets" is not found, just sort the array as usual
            sortedMarketGroupsArray = marketGroupsArray.sorted(by: {
                if ($0.position ?? 0) == ($1.position ?? 0) {
                    return ($0.groupKey ?? "") < ($1.groupKey ?? "")
                }
                return ($0.position ?? 0) < ($1.position ?? 999)
            })
        }

        // Verify for BetBuilder markets
        let betBuilderMarkets = matchMarkets.filter( {
            $0.customBetAvailable ?? false
        })

        let betBuilderMarketGroup = MarketGroup(type: "MixMatch",
                                                id: "99",
                                                groupKey: "99",
                                                translatedName: "MixMatch",
                                                position: 99,
                                                isDefault: false,
                                                numberOfMarkets: betBuilderMarkets.count,
                                                loaded: true,
                                                markets: betBuilderMarkets)

        if sortedMarketGroupsArray.count >= 1 && !betBuilderMarkets.isEmpty {
            sortedMarketGroupsArray.insert(betBuilderMarketGroup, at: 1)
        }

        //self.marketGroupsPublisher.send(sortedMarketGroupsArray)
        return sortedMarketGroupsArray
    }

    func getDatesFilter(timeRange: String) -> [Date] {
        var dates = [Date]()

        let days = timeRange.components(separatedBy: "-")

        if let initialDay = Int(days[safe: 0] ?? "0"),
           let endDay = Int(days[safe: 1] ?? "90") {
            if let startDate = Calendar.current.date(byAdding: .day, value: initialDay, to: Date()),
               let endDate = Calendar.current.date(byAdding: .day, value: endDay, to: Date()) {
                dates.append(startDate)
                dates.append(endDate)
            }
        }

        return dates
    }

}

extension SportRadarEventsProvider {

    func getValidEventDetailsCoordinators() -> [SportRadarEventDetailsCoordinator] {
        self.eventDetailsCoordinators = self.eventDetailsCoordinators.filter({ $0.value.isActive })
        return Array(self.eventDetailsCoordinators.values)
    }

    func getValidEventDetailsCoordinator(forKey key: String) -> SportRadarEventDetailsCoordinator? {
        self.eventDetailsCoordinators = self.eventDetailsCoordinators.filter({ $0.value.isActive })
        return self.eventDetailsCoordinators[key]
    }

    func addEventDetailsCoordinator(_ coordinator: SportRadarEventDetailsCoordinator, withKey key: String) {
        self.eventDetailsCoordinators = self.eventDetailsCoordinators.filter({ $0.value.isActive })
        self.eventDetailsCoordinators[key] = coordinator
    }

}

extension SportRadarEventsProvider {

    func getValidLiveEventDetailsCoordinators() -> [SportRadarLiveEventDataCoordinator] {
        self.liveEventDetailsCoordinators = self.liveEventDetailsCoordinators.filter({ $0.value.isActive })
        return Array(self.liveEventDetailsCoordinators.values)
    }

    func getValidLiveEventDetailsCoordinator(forKey key: String) -> SportRadarLiveEventDataCoordinator? {
        self.liveEventDetailsCoordinators = self.liveEventDetailsCoordinators.filter({ $0.value.isActive })
        return self.liveEventDetailsCoordinators[key]
    }

    func addLiveEventDetailsCoordinator(_ coordinator: SportRadarLiveEventDataCoordinator, withKey key: String) {
        self.liveEventDetailsCoordinators = self.liveEventDetailsCoordinators.filter({ $0.value.isActive })
        self.liveEventDetailsCoordinators[key] = coordinator
    }

}

extension SportRadarEventsProvider {

    func getValidEventMarketsCoordinators() -> [SportRadarEventMarketsCoordinator] {

        let oldList = self.eventsSecundaryMarketsUpdatesCoordinators
        let newValidList = oldList.filter({ coordinatorPair in
            coordinatorPair.value.isActive
        })

        self.eventsSecundaryMarketsUpdatesCoordinators = newValidList

        return Array(self.eventsSecundaryMarketsUpdatesCoordinators.values)
    }

    func getValidEventMarketsCoordinator(forKey key: String) -> SportRadarEventMarketsCoordinator? {
        self.eventsSecundaryMarketsUpdatesCoordinators = self.eventsSecundaryMarketsUpdatesCoordinators.filter({ $0.value.isActive })
        return self.eventsSecundaryMarketsUpdatesCoordinators[key]
    }

    func addEventMarketsCoordinator(_ coordinator: SportRadarEventMarketsCoordinator, withKey key: String) {
        self.eventsSecundaryMarketsUpdatesCoordinators = self.eventsSecundaryMarketsUpdatesCoordinators.filter({ $0.value.isActive })
        self.eventsSecundaryMarketsUpdatesCoordinators[key] = coordinator
    }

}

extension SportRadarEventsProvider {

    private func createPayloadData(with sessionAccessToken: SportRadarSessionAccessToken, contentType: ContentType, contentRoute: ContentRoute) -> Data {
        let bodyString =
        """
        {
            "subscriberId": "\(sessionAccessToken.hash)",
            "contentId": {
                "type": "\(contentType.rawValue)",
                "id": "\(contentRoute.fullRoute)"
            },
            "clientContext": {
                "language": "\(SportRadarConfiguration.shared.socketLanguageCode)",
                "ipAddress": "127.0.0.1"
            }
        }
        """
        return bodyString.data(using: String.Encoding.utf8) ?? Data()
    }

    private func createSubscribeRequest(withHTTPBody body: Data? = nil) -> URLRequest {
        let hostname = SportRadarConfiguration.shared.servicesRestHostname
        let url = URL(string: "\(hostname)/services/content/subscribe")!
        var request = URLRequest(url: url)
        request.httpBody = body
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Media-Type")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        return request
    }

    private func createUnsubscribeRequest(withHTTPBody body: Data? = nil) -> URLRequest {
        let hostname = SportRadarConfiguration.shared.servicesRestHostname
        let url = URL(string: "\(hostname)/services/content/unsubscribe")!
        var request = URLRequest(url: url)
        request.httpBody = body
        request.httpMethod = "POST"
        request.addValue("application/json", forHTTPHeaderField: "Media-Type")
        request.addValue("application/json", forHTTPHeaderField: "Content-Type")
        return request
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/SportRadarManagedContentProvider.swift
````swift
//
//  SportRadarManagedContentProvider.swift
//
//
//  Created on: May 15, 2024
//

import Foundation
import Combine

/// Implementation of ManagedContentProvider for the Sportradar API
class SportRadarManagedContentProvider: ManagedContentProvider {
    // MARK: - Properties

    var connectionStatePublisher: AnyPublisher<ConnectorState, Never> {
        connectionStateSubject.eraseToAnyPublisher()
    }

    private let connectionStateSubject = CurrentValueSubject<ConnectorState, Never>(.disconnected)
    private let sessionCoordinator: SportRadarSessionCoordinator
    private var cancellables = Set<AnyCancellable>()

    // MARK: - Initialization

    init(sessionCoordinator: SportRadarSessionCoordinator) {
        self.sessionCoordinator = sessionCoordinator

        // Set up token handling
        self.sessionCoordinator.token(forKey: .launchToken)
            .sink { [weak self] launchToken in
                if launchToken != nil {
                    self?.connectionStateSubject.send(.connected)
                } else {
                    self?.connectionStateSubject.send(.disconnected)
                }
            }
            .store(in: &cancellables)
    }

    // MARK: - ManagedContentProvider Implementation

    func getHomeTemplate() -> AnyPublisher<HomeTemplate, ServiceProviderError> {
        fatalError("")
    }

    func getAlertBanner() -> AnyPublisher<AlertBanner?, ServiceProviderError> {
        fatalError("")
    }

    func getBanners() -> AnyPublisher<[Banner], ServiceProviderError> {
        fatalError("")
    }

    func getSportBanners() -> AnyPublisher<[SportBanner], ServiceProviderError> {
        fatalError("")
    }

    func getBoostedOddsBanners() -> AnyPublisher<[BoostedOddsBanner], ServiceProviderError> {
        fatalError("")
    }

    func getHeroCards() -> AnyPublisher<[HeroCard], ServiceProviderError> {
        fatalError("")
    }

    func getStories() -> AnyPublisher<[Story], ServiceProviderError> {
        fatalError("")
    }

    func getNews(pageIndex: Int, pageSize: Int) -> AnyPublisher<[NewsItem], ServiceProviderError> {
        fatalError("")
    }

    func getProChoices() -> AnyPublisher<[ProChoice], ServiceProviderError> {
        fatalError("")
    }

}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/SportRadarPrivilegedAccessManager.swift
````swift
//
//  SportRadarPrivilegedAccessManager.swift
//
//
//  Created by Ruben Roques on 24/10/2022.
//

import Foundation
import Combine
import SharedModels
import CryptoKit

class SportRadarPrivilegedAccessManager: PrivilegedAccessManager {
  
    var connector: OmegaConnector
    var userSessionStatePublisher: AnyPublisher<UserSessionStatus, Error> {
        return userSessionStateSubject.eraseToAnyPublisher()
    }
    var userProfilePublisher: AnyPublisher<UserProfile?, Error> {
        return userProfileSubject.eraseToAnyPublisher()
    }

    var hasSecurityQuestions: Bool = false

    private var sessionCoordinator: SportRadarSessionCoordinator

    private let userSessionStateSubject: CurrentValueSubject<UserSessionStatus, Error> = .init(.anonymous)
    private let userProfileSubject: CurrentValueSubject<UserProfile?, Error> = .init(nil)

    private var cancellables: Set<AnyCancellable> = []

    //Sumsub
    private let sumsubAppToken = "sbx:yjCFqKsuTX6mTY7XMFFPe6hR.v9i5YpFrNND0CeLcZiHeJnnejrCUDZKT"
    private let sumsubSecretKey = "4PH7gdufQfrFpFS35gJiwz9d2NFZs4kM"

    init(sessionCoordinator: SportRadarSessionCoordinator, connector: OmegaConnector = OmegaConnector()) {

        self.connector = connector
        self.sessionCoordinator = sessionCoordinator

        self.connector.tokenPublisher.sink { [weak self] omegaSessionAccessToken in
            if let omegaSessionAccessToken {
                self?.sessionCoordinator.saveToken(omegaSessionAccessToken.sessionKey, withKey: .restSessionToken)

                if let launchToken = omegaSessionAccessToken.launchKey {
                    self?.sessionCoordinator.saveToken(launchToken, withKey: .launchToken)
                }
                else {
                    self?.sessionCoordinator.clearToken(withKey: .launchToken)
                }
            }
            else {
                self?.sessionCoordinator.clearToken(withKey: .restSessionToken)
            }
        }
        .store(in: &cancellables)

    }

    func login(username: String, password: String) -> AnyPublisher<UserProfile, ServiceProviderError> {

        return self.connector.login(username: username, password: password)
            .flatMap({ [weak self] loginResponse -> AnyPublisher<UserProfile, ServiceProviderError> in

            guard
                let self = self
            else {
                return Fail(outputType: UserProfile.self, failure: ServiceProviderError.unknown).eraseToAnyPublisher()
            }

            if loginResponse.status == "FAIL_UN_PW" {
                return Fail(outputType: UserProfile.self, failure: ServiceProviderError.invalidEmailPassword).eraseToAnyPublisher()
            }
            else if loginResponse.status == "FAIL_QUICK_OPEN_STATUS" {
                return Fail(outputType: UserProfile.self, failure: ServiceProviderError.quickSignUpIncomplete).eraseToAnyPublisher()
            }
            else if loginResponse.status == "SUCCESS" {
                if let kycExpire = loginResponse.kycStatusDetails?.expiryDate {
                    return self.getUserProfile(withKycExpire: kycExpire)
                }
                return self.getUserProfile(withKycExpire: nil)
            }
            return Fail(outputType: UserProfile.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func logout() {
        return self.connector.logout()
    }

    // TODO: SP Migration 
    func depositOnWallet(amount: Double) -> AnyPublisher<Bool, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getUserProfile(withKycExpire kycExpire: String?) -> AnyPublisher<UserProfile, ServiceProviderError> {

        let endpoint = OmegaAPIClient.playerInfo
        let publisher: AnyPublisher<SportRadarModels.PlayerInfoResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ playerInfoResponse -> AnyPublisher<UserProfile, ServiceProviderError> in
            if playerInfoResponse.status == "SUCCESS", let userOverview = SportRadarModelMapper.userProfile(fromPlayerInfoResponse: playerInfoResponse, withKycExpire: kycExpire) {
                print("getUserProfile(withKycExpire \(userOverview))")
                return Just(userOverview).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            return Fail(outputType: UserProfile.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func checkEmailRegistered(_ email: String) -> AnyPublisher<Bool, ServiceProviderError> {
        let endpoint = OmegaAPIClient.checkCredentialEmail(email: email)

        let publisher: AnyPublisher<SportRadarModels.CheckCredentialResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ checkCredentialResponse -> AnyPublisher<Bool, ServiceProviderError> in
            if checkCredentialResponse.exists == "true" {
                return Just(true).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else if checkCredentialResponse.exists == "false"  {
                return Just(false).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            return Fail(outputType: Bool.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()

    }

    func validateUsername(_ username: String) -> AnyPublisher<UsernameValidation, ServiceProviderError> {
        let endpoint = OmegaAPIClient.checkUsername(username: username)

        let publisher: AnyPublisher<SportRadarModels.CheckUsernameResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ checkCredentialResponse -> AnyPublisher<UsernameValidation, ServiceProviderError> in

            let suggestions = checkCredentialResponse.additionalInfos?
                .compactMap({ $0 })
                .map { additionalInfo -> String in
                    return additionalInfo.value
                }

            if checkCredentialResponse.status == "SUCCESS", let suggestionsValue = suggestions, !suggestionsValue.isEmpty {
                let usernameValidation = UsernameValidation(username: username,
                                                            isAvailable: false,
                                                            suggestedUsernames: suggestionsValue,
                                                            hasErrors: false)
                return Just(usernameValidation)
                    .setFailureType(to: ServiceProviderError.self)
                    .eraseToAnyPublisher()
            }
            else if checkCredentialResponse.status == "USERNAME_AVAILABLE" {
                if (checkCredentialResponse.errors ?? []).isEmpty {
                    let usernameValidation = UsernameValidation(username: username,
                                                                isAvailable: true,
                                                                suggestedUsernames: nil,
                                                                hasErrors: false)
                    return Just(usernameValidation)
                        .setFailureType(to: ServiceProviderError.self)
                        .eraseToAnyPublisher()
                }
                else {
                    let usernameValidation = UsernameValidation(username: username,
                                                                isAvailable: true,
                                                                suggestedUsernames: nil,
                                                                hasErrors: true)
                    return Just(usernameValidation)
                        .setFailureType(to: ServiceProviderError.self)
                        .eraseToAnyPublisher()
                }
            }
            return Fail(outputType: UsernameValidation.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func simpleSignUp(form: SimpleSignUpForm) -> AnyPublisher<Bool, ServiceProviderError> {

        let endpoint = OmegaAPIClient.quickSignup(email: form.email,
                                                  username: form.username,
                                                  password: form.password,
                                                  birthDate: form.birthDate,
                                                  mobilePrefix: form.mobilePrefix,
                                                  mobileNumber: form.mobileNumber,
                                                  countryIsoCode: form.countryIsoCode,
                                                  currencyCode: form.currencyCode)

        let publisher: AnyPublisher<SportRadarModels.StatusResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ statusResponse -> AnyPublisher<Bool, ServiceProviderError> in
            if statusResponse.status == "SUCCESS" {
                return Just(true).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else if let errors = statusResponse.errors {
                if errors.contains(where: { $0.field == "username" }) {
                    return Fail(outputType: Bool.self, failure: ServiceProviderError.invalidSignUpUsername).eraseToAnyPublisher()
                }
                else if errors.contains(where: { $0.field == "email" }) {
                    return Fail(outputType: Bool.self, failure: ServiceProviderError.invalidSignUpEmail).eraseToAnyPublisher()
                }
                else if errors.contains(where: { $0.field == "password" }) {
                    return Fail(outputType: Bool.self, failure: ServiceProviderError.invalidSignUpPassword).eraseToAnyPublisher()
                }
            }
            return Fail(outputType: Bool.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func signUp(form: SignUpForm) -> AnyPublisher<SignUpResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.signUp(email: form.email,
                                             username: form.username,
                                             password: form.password,
                                             birthDate: form.birthDate,
                                             mobilePrefix: form.mobilePrefix,
                                             mobileNumber: form.mobileNumber,
                                             nationalityIso2Code: form.nationalityIsoCode,
                                             currencyCode: form.currencyCode,
                                             firstName: form.firstName,
                                             lastName: form.lastName,
                                             middleName: form.middleName,
                                             gender: form.gender,
                                             address: form.address,
                                             city: form.city,
                                             postalCode: form.postCode,
                                             countryIso2Code: form.countryIsoCode,
                                             bonusCode: form.bonusCode,
                                             receiveMarketingEmails: form.receiveMarketingEmails,
                                             avatarName: form.avatarName,
                                             godfatherCode: form.godfatherCode,
                                             birthDepartment: form.birthDepartment,
                                             birthCity: form.birthCity,
                                             birthCountry: form.birthCountry,
                                             streetNumber: form.streetNumber,
                                             consentedIds: form.consentedIds,
                                             unconsentedIds: form.unConsentedIds,
                                             mobileVerificationRequestId: form.mobileVerificationRequestId)

        let publisher: AnyPublisher<SportRadarModels.StatusResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ (statusResponse: SportRadarModels.StatusResponse) -> AnyPublisher<SignUpResponse, ServiceProviderError> in
            if statusResponse.status == "SUCCESS" || statusResponse.status == "BONUSPLAN_NOT_FOUND" {
                return Just( SignUpResponse(successful: true) ).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else if let errors = statusResponse.errors {
                let mappedErrors = errors.map { error -> SignUpResponse.SignUpError in
                    return SignUpResponse.SignUpError(field: error.field, error: error.error)
                }
                return Just( SignUpResponse(successful: false, errors: mappedErrors) ).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            return Fail(outputType: SignUpResponse.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func updateUserProfile(form: UpdateUserProfileForm) -> AnyPublisher<Bool, ServiceProviderError> {

        let endpoint = OmegaAPIClient.updatePlayerInfo(username: form.username,
                                                       email: form.email,
                                                       firstName: form.firstName,
                                                       lastName: form.lastName,
                                                       birthDate: form.birthDate,
                                                       gender: form.gender,
                                                       address: form.address,
                                                       province: form.province,
                                                       city: form.city,
                                                       postalCode: form.postalCode,
                                                       country: form.country?.iso2Code,
                                                       cardId: form.cardId)

        let publisher: AnyPublisher<SportRadarModels.StatusResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ statusResponse -> AnyPublisher<Bool, ServiceProviderError> in
            if statusResponse.status == "SUCCESS" {
                return Just(true).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            return Fail(outputType: Bool.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func updateExtraInfo(placeOfBirth: String?, address2: String?) -> AnyPublisher<BasicResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.updateExtraInfo(placeOfBirth: placeOfBirth, address2: address2)

        let publisher: AnyPublisher<SportRadarModels.BasicResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ basicResponse -> AnyPublisher<BasicResponse, ServiceProviderError> in
            if basicResponse.status == "SUCCESS" {

                let basicResponse = SportRadarModelMapper.basicResponse(fromInternalBasicResponse: basicResponse)

                return Just(basicResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            return Fail(outputType: BasicResponse.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func updateDeviceIdentifier(deviceIdentifier: String, appVersion: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.updateDeviceIdentifier(deviceIdentifier: deviceIdentifier, appVersion: appVersion)
        let publisher: AnyPublisher<SportRadarModels.BasicResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ basicResponse -> AnyPublisher<BasicResponse, ServiceProviderError> in
            if basicResponse.status == "SUCCESS" {

                let basicResponse = SportRadarModelMapper.basicResponse(fromInternalBasicResponse: basicResponse)

                return Just(basicResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            return Fail(outputType: BasicResponse.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    public func getAllCountries() -> AnyPublisher<[SharedModels.Country], ServiceProviderError> {
        let allCountries = Country.allCountries
        return Just(allCountries).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
    }

    public func getCountries() -> AnyPublisher<[Country], ServiceProviderError> {

        let endpoint = OmegaAPIClient.getCountries
        let publisher: AnyPublisher<SportRadarModels.GetCountriesResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ countriesResponse -> AnyPublisher<[Country], ServiceProviderError> in
            if countriesResponse.status == "SUCCESS" {
                let countries: [Country] = countriesResponse.countries.map({ isoCode in
                    return Country(isoCode: isoCode)
                }).compactMap({ $0 })

                return Just(countries).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: [Country].self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    public func getCurrentCountry() -> AnyPublisher<Country?, ServiceProviderError> {

        let endpoint = OmegaAPIClient.getCurrentCountry
        let publisher: AnyPublisher<SportRadarModels.GetCountryInfoResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ countryInfo -> AnyPublisher<Country?, ServiceProviderError> in
            if countryInfo.status == "SUCCESS" {
                return Just(Country(isoCode: countryInfo.countryInfo.iso2Code)).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: Country?.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func signupConfirmation(_ email: String, confirmationCode: String) -> AnyPublisher<Bool, ServiceProviderError> {
        let endpoint = OmegaAPIClient.signupConfirmation(email: email, confirmationCode: confirmationCode)
        let publisher: AnyPublisher<SportRadarModels.StatusResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ statusResponse -> AnyPublisher<Bool, ServiceProviderError> in
            if statusResponse.status == "SUCCESS" {
                return Just(true).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            if !(statusResponse.errors?.isEmpty ?? true), let message = statusResponse.message {
                return Fail(outputType: Bool.self, failure: ServiceProviderError.errorMessage(message: message)).eraseToAnyPublisher()
            }
            return Fail(outputType: Bool.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func forgotPassword(email: String, secretQuestion: String? = nil, secretAnswer: String? = nil) -> AnyPublisher<Bool, ServiceProviderError> {
        let endpoint = OmegaAPIClient.forgotPassword(email: email, secretQuestion: secretQuestion, secretAnswer: secretAnswer)
        let publisher: AnyPublisher<SportRadarModels.StatusResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ statusResponse -> AnyPublisher<Bool, ServiceProviderError> in
            if statusResponse.status == "SUCCESS" {
                return Just(true).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }

            return Fail(outputType: Bool.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()

    }

    func updatePassword(oldPassword: String, newPassword: String) -> AnyPublisher<Bool, ServiceProviderError> {
        let endpoint = OmegaAPIClient.updatePassword(oldPassword: oldPassword, newPassword: newPassword)
        let publisher: AnyPublisher<SportRadarModels.StatusResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ statusResponse -> AnyPublisher<Bool, ServiceProviderError> in
            if statusResponse.status == "SUCCESS" {
                return Just(true).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }

            return Fail(outputType: Bool.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()

    }

    func getPasswordPolicy() -> AnyPublisher<PasswordPolicy, ServiceProviderError> {

        let passwordPolicy = PasswordPolicy(regularExpression: "", message: "Your password must be between 8-16 characters long, have uppercase and lowercase letters, a number and one special character.")

        let publisher = Just(passwordPolicy).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

        return publisher
    }

    func updateWeeklyDepositLimits(newLimit: Double) -> AnyPublisher<Bool, ServiceProviderError> {
        let endpoint = OmegaAPIClient.updateWeeklyDepositLimits(newLimit: newLimit)
        let publisher: AnyPublisher<SportRadarModels.StatusResponse, ServiceProviderError> = self.connector.request(endpoint)


        return publisher.flatMap({ statusResponse -> AnyPublisher<Bool, ServiceProviderError> in
            if statusResponse.status == "SUCCESS" {
                return Just(true).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }

            return Fail(outputType: Bool.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func updateWeeklyBettingLimits(newLimit: Double) -> AnyPublisher<Bool, ServiceProviderError> {
        let endpoint = OmegaAPIClient.updateWeeklyBettingLimits(newLimit: newLimit)
        let publisher: AnyPublisher<SportRadarModels.StatusResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ statusResponse -> AnyPublisher<Bool, ServiceProviderError> in
            if statusResponse.status == "SUCCESS" {
                return Just(true).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            if let fieldError = statusResponse.errors?[0] {
                let messageError = fieldError.error

                return Fail(outputType: Bool.self, failure: ServiceProviderError.errorMessage(message: messageError)).eraseToAnyPublisher()
            }

            return Fail(outputType: Bool.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func updateResponsibleGamingLimits(newLimit: Double, limitType: String, hasRollingWeeklyLimits: Bool) -> AnyPublisher<Bool, ServiceProviderError> {

        var endpointLimitType = ""
        var endpointLimitPeriod = "Weekly"

        if hasRollingWeeklyLimits {
            endpointLimitPeriod = "RollingWeekly"
        }

        if limitType == "deposit" {
            endpointLimitType = "DEPOSIT_LIMIT"
        }
        else if limitType == "betting" {
            endpointLimitType = "WAGER_LIMIT"

        }
        else if limitType == "autoPayout" {
            endpointLimitType = "BALANCE_LIMIT"
            endpointLimitPeriod = "Permanent"
        }

        let endpoint = OmegaAPIClient.updateResponsibleGamingLimits(newLimit: newLimit, limitType: endpointLimitType, limitPeriod: endpointLimitPeriod)
        let publisher: AnyPublisher<SportRadarModels.StatusResponse, ServiceProviderError> = self.connector.request(endpoint)

        print("LimitDebug-\(limitType): \(endpointLimitType):\(endpointLimitPeriod) > \(newLimit)")

        return publisher.flatMap({ statusResponse -> AnyPublisher<Bool, ServiceProviderError> in
            if statusResponse.status.lowercased() == "success" {
                return Just(true).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else if let errorMessage = statusResponse.message {
                return Fail(outputType: Bool.self, failure: ServiceProviderError.errorDetailedMessage(key: "", message: errorMessage)).eraseToAnyPublisher()
            }
            return Fail(outputType: Bool.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func getPersonalDepositLimits() -> AnyPublisher<PersonalDepositLimitResponse, ServiceProviderError> {
        let endpoint = OmegaAPIClient.getPersonalDepositLimits
        let publisher: AnyPublisher<SportRadarModels.PersonalDepositLimitResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ personalDepositLimitResponse -> AnyPublisher<PersonalDepositLimitResponse, ServiceProviderError> in
            if personalDepositLimitResponse.status == "SUCCESS" {

                let personalDepositLimitResponse = SportRadarModelMapper.personalDepositLimitsResponse(fromPersonalDepositLimitsResponse: personalDepositLimitResponse)

                return Just(personalDepositLimitResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }

            return Fail(outputType: PersonalDepositLimitResponse.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func getLimits() -> AnyPublisher<LimitsResponse, ServiceProviderError> {
        let endpoint = OmegaAPIClient.getLimits

        let publisher: AnyPublisher<SportRadarModels.LimitsResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ limitsResponse -> AnyPublisher<LimitsResponse, ServiceProviderError> in
            if limitsResponse.status == "SUCCESS" {

                let limitsResponse = SportRadarModelMapper.limitsResponse(fromInternalLimitsResponse: limitsResponse)

                return Just(limitsResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }

            return Fail(outputType: LimitsResponse.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func getResponsibleGamingLimits(periodTypes: String?, limitTypes: String?) -> AnyPublisher<ResponsibleGamingLimitsResponse, ServiceProviderError> {

        var limitType = "BALANCE_LIMIT"
        var periodType = "PERMANENT"

        if let periodTypes {
            periodType = periodTypes
        }

        if let limitTypes {
            limitType = limitTypes
        }

        let endpoint = OmegaAPIClient.getResponsibleGamingLimits(limitType: limitType, periodType: periodType)

        let publisher: AnyPublisher<SportRadarModels.ResponsibleGamingLimitsResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ responsibleGamingLimitsResponse -> AnyPublisher<ResponsibleGamingLimitsResponse, ServiceProviderError> in
            if responsibleGamingLimitsResponse.status == "SUCCESS" {
                let responsibleGamingLimitsResponse = SportRadarModelMapper.responsibleGamingLimitsResponse(fromResponsibleGamingLimitsResponse: responsibleGamingLimitsResponse)

                return Just(responsibleGamingLimitsResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }

            return Fail(outputType: ResponsibleGamingLimitsResponse.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func lockPlayer(isPermanent: Bool? = nil, lockPeriodUnit: String? = nil, lockPeriod: String? = nil) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        let endpoint = OmegaAPIClient.lockPlayer(isPermanent: isPermanent, lockPeriodUnit: lockPeriodUnit, lockPeriod: lockPeriod)

        let publisher: AnyPublisher<SportRadarModels.BasicResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ lockPlayerResponse -> AnyPublisher<BasicResponse, ServiceProviderError> in
            if lockPlayerResponse.status == "SUCCESS" {

                let lockPlayerResponse = SportRadarModelMapper.basicResponse(fromInternalBasicResponse: lockPlayerResponse)

                return Just(lockPlayerResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }

            return Fail(outputType: BasicResponse.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func getUserBalance() -> AnyPublisher<UserWallet, ServiceProviderError> {
        let endpoint = OmegaAPIClient.getBalance
        let publisher: AnyPublisher<SportRadarModels.BalanceResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ balanceResponse -> AnyPublisher<UserWallet, ServiceProviderError> in
            if balanceResponse.status == "SUCCESS" {
                let userWallet = SportRadarModelMapper.userWallet(fromBalanceResponse: balanceResponse)
                return Just(userWallet).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            return Fail(outputType: UserWallet.self,
                        failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func getUserCashbackBalance() -> AnyPublisher<CashbackBalance, ServiceProviderError> {
        let endpoint = OmegaAPIClient.getCashbackBalance
        let publisher: AnyPublisher<SportRadarModels.CashbackBalance, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ cashbackBalance -> AnyPublisher<CashbackBalance, ServiceProviderError> in
            if cashbackBalance.status == "SUCCESS" {

                let mappedCashbackBalance = SportRadarModelMapper.cashbackBalance(fromCashbackBalance: cashbackBalance)

                return Just(mappedCashbackBalance).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            return Fail(outputType: CashbackBalance.self,
                        failure: ServiceProviderError.errorMessage(message: cashbackBalance.message ?? "Error")).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func signUpCompletion(form: ServicesProvider.UpdateUserProfileForm)  -> AnyPublisher<Bool, ServiceProviderError> {
        let endpoint = OmegaAPIClient.quickSignupCompletion(firstName: form.firstName,
                                                            lastName: form.lastName,
                                                            birthDate: form.birthDate,
                                                            gender: form.gender,
                                                            mobileNumber: form.mobileNumber,
                                                            address: form.address,
                                                            province: form.province,
                                                            city: form.city,
                                                            postalCode: form.postalCode,
                                                            country: form.country?.iso2Code,
                                                            cardId: form.cardId,
                                                            securityQuestion: form.securityQuestion,
                                                            securityAnswer: form.securityAnswer)

        let publisher: AnyPublisher<SportRadarModels.StatusResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ statusResponse -> AnyPublisher<Bool, ServiceProviderError> in
            if statusResponse.status == "SUCCESS" {
                return Just(true).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }

            return Fail(outputType: Bool.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()

    }

    // Documents
    func getDocumentTypes() -> AnyPublisher<DocumentTypesResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.getDocumentTypes
        let publisher: AnyPublisher<SportRadarModels.DocumentTypesResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ documentTypesResponse -> AnyPublisher<DocumentTypesResponse, ServiceProviderError> in
            if documentTypesResponse.status == "SUCCESS" {
                let documentTypesResponse = SportRadarModelMapper.documentTypesResponse(fromDocumentTypesResponse: documentTypesResponse)
                return Just(documentTypesResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: DocumentTypesResponse.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func getUserDocuments() -> AnyPublisher<UserDocumentsResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.getUserDocuments
        let publisher: AnyPublisher<SportRadarModels.UserDocumentsResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ userDocumentsResponse -> AnyPublisher<UserDocumentsResponse, ServiceProviderError> in
            if userDocumentsResponse.status == "SUCCESS" {
                let userDocumentsResponse = SportRadarModelMapper.userDocumentsResponse(fromUserDocumentsResponse: userDocumentsResponse)
                return Just(userDocumentsResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: UserDocumentsResponse.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func uploadUserDocument(documentType: String, file: Data, fileName: String) -> AnyPublisher<UploadDocumentResponse, ServiceProviderError> {

        var multipart = MultipartRequest()

        let mimeType = mimeType(for: file)

        multipart.add(key: "documentType", value: documentType)

        multipart.add(
            key: "file",
            fileName: fileName,
            fileMimeType: mimeType,
            fileData: file
        )

        let currentDate = Date()

//        var issuedDateComponent = DateComponents()
//        issuedDateComponent.year = -1
//        let issuedDate = Calendar.current.date(byAdding: issuedDateComponent, to: currentDate) ?? currentDate
        let issuedDate = currentDate

        var expiryDateComponent = DateComponents()
        expiryDateComponent.year = 1
        let expiryDate = Calendar.current.date(byAdding: expiryDateComponent, to: currentDate) ?? currentDate

        // Create a date formatter
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"

        let expiryDateString = dateFormatter.string(from: expiryDate)
        let issuedDateString = dateFormatter.string(from: issuedDate)

        if documentType == "IDENTITY_CARD" {
            multipart.add(key: "issueDate", value: issuedDateString)
            multipart.add(key: "expiryDate", value: expiryDateString)
            multipart.add(key: "documentNumber", value: "123456789")
        }
        else if documentType == "RESIDENCE_ID" {
            multipart.add(key: "issueDate", value: issuedDateString)
            multipart.add(key: "expiryDate", value: expiryDateString)
            multipart.add(key: "documentNumber", value: "123456789")
        }
        else if documentType == "DRIVING_LICENCE" {
            multipart.add(key: "issueDate", value: issuedDateString)
            multipart.add(key: "expiryDate", value: expiryDateString)
            multipart.add(key: "documentNumber", value: "123456789")
        }
        else if documentType == "PASSPORT" {
            multipart.add(key: "issueDate", value: issuedDateString)
            multipart.add(key: "expiryDate", value: expiryDateString)
            multipart.add(key: "documentNumber", value: "123456789")
        }
        else if documentType == "OTHERS" {
            multipart.add(key: "expiryDate", value: expiryDateString)
            multipart.add(key: "documentNumber", value: "123456789")
        }

        let endpoint = OmegaAPIClient.uploadUserDocument(documentType: documentType, file: file, body: multipart.httpBody, header: multipart.httpContentTypeHeaderValue)

        let publisher: AnyPublisher<SportRadarModels.UploadDocumentResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ uploadDocumentResponse -> AnyPublisher<UploadDocumentResponse, ServiceProviderError> in
            if uploadDocumentResponse.status == "SUCCESS" {
                let uploadDocumentResponse = SportRadarModelMapper.uploadDocumentResponse(fromUploadDocumentResponse: uploadDocumentResponse)
                return Just(uploadDocumentResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: UploadDocumentResponse.self, failure: ServiceProviderError.errorMessage(message: uploadDocumentResponse.message ?? "Error")).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func uploadMultipleUserDocuments(documentType: String, files: [String: Data]) -> AnyPublisher<UploadDocumentResponse, ServiceProviderError> {

        var multipart = MultipartRequest()

        multipart.add(key: "documentType", value: documentType)

        var fileCount = 0

        for (key, file) in files {
            let mimeType = mimeType(for: file)

            multipart.add(
                key: "_file_\(fileCount)",
                fileName: key,
                fileMimeType: mimeType,
                fileData: file
            )

            fileCount += 1
        }

        let currentDate = Date()

//        var issuedDateComponent = DateComponents()
//        issuedDateComponent.year = -1
//        let issuedDate = Calendar.current.date(byAdding: issuedDateComponent, to: currentDate) ?? currentDate
        let issuedDate = currentDate

        var expiryDateComponent = DateComponents()
        expiryDateComponent.year = 1
        let expiryDate = Calendar.current.date(byAdding: expiryDateComponent, to: currentDate) ?? currentDate

        // Create a date formatter
        let dateFormatter = DateFormatter()
        dateFormatter.dateFormat = "yyyy-MM-dd"

        let expiryDateString = dateFormatter.string(from: expiryDate)
        let issuedDateString = dateFormatter.string(from: issuedDate)

        if documentType == "IDENTITY_CARD" {
            multipart.add(key: "issueDate", value: issuedDateString)
            multipart.add(key: "expiryDate", value: expiryDateString)
            multipart.add(key: "documentNumber", value: "123456789")
        }
        else if documentType == "RESIDENCE_ID" {
            multipart.add(key: "issueDate", value: issuedDateString)
            multipart.add(key: "expiryDate", value: expiryDateString)
            multipart.add(key: "documentNumber", value: "123456789")
        }
        else if documentType == "DRIVING_LICENCE" {
            multipart.add(key: "issueDate", value: issuedDateString)
            multipart.add(key: "expiryDate", value: expiryDateString)
            multipart.add(key: "documentNumber", value: "123456789")
        }
        else if documentType == "RESIDENCE_ID" {
            multipart.add(key: "issueDate", value: issuedDateString)
            multipart.add(key: "expiryDate", value: expiryDateString)
            multipart.add(key: "documentNumber", value: "123456789")
        }
        else if documentType == "OTHERS" {
            multipart.add(key: "expiryDate", value: expiryDateString)
            multipart.add(key: "documentNumber", value: "123456789")
        }

        let endpoint = OmegaAPIClient.uploadMultipleUserDocuments(documentType: documentType, files: files, body: multipart.httpBody, header: multipart.httpContentTypeHeaderValue)

        let publisher: AnyPublisher<SportRadarModels.UploadDocumentResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ uploadDocumentResponse -> AnyPublisher<UploadDocumentResponse, ServiceProviderError> in
            if uploadDocumentResponse.status == "SUCCESS" {
                let uploadDocumentResponse = SportRadarModelMapper.uploadDocumentResponse(fromUploadDocumentResponse: uploadDocumentResponse)
                return Just(uploadDocumentResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: UploadDocumentResponse.self, failure: ServiceProviderError.errorMessage(message: uploadDocumentResponse.message ?? "Error")).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func getPayments() -> AnyPublisher<SimplePaymentMethodsResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.getPayments
        let publisher: AnyPublisher<SportRadarModels.PaymentsResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ paymentsResponse -> AnyPublisher<SimplePaymentMethodsResponse, ServiceProviderError> in
            if paymentsResponse.status == "SUCCESS" {
                let paymentsResponse = SportRadarModelMapper.paymentsResponse(fromPaymentsResponse: paymentsResponse)

                // Only ADYEN_ALL methods
                let allPaymentMethods = paymentsResponse.depositMethods.filter({
                    $0.code == "ADYEN_ALL"
                })

                // Aditional encoding/decoding data needed for Omega
                // If needed to get all methods
                let paymentMethods = allPaymentMethods.compactMap({ $0.methods }).filter({!$0.isEmpty}).flatMap({$0})

                if !paymentMethods.isEmpty {

                    let simplePaymentMethods = paymentMethods.map({ method -> SimplePaymentMethod in
                        return SimplePaymentMethod(name: method.name, type: method.type, brands: method.brands)
                    })

//                    // Remove duplicates
//                    var uniqueSimplePaymentMethods = [SimplePaymentMethod]()
//
//                    for method in simplePaymentMethods {
//                        if !uniqueSimplePaymentMethods.contains(method) {
//                            uniqueSimplePaymentMethods.append(method)
//                        }
//                    }

                    let simplePaymentMethodsResponse = SimplePaymentMethodsResponse(paymentMethods: simplePaymentMethods)

                    return Just(simplePaymentMethodsResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                }
                else {
                    return Fail(outputType: SimplePaymentMethodsResponse.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
                }

            }
            else {
                return Fail(outputType: SimplePaymentMethodsResponse.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func processDeposit(paymentMethod: String, amount: Double, option: String) -> AnyPublisher<ProcessDepositResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.processDeposit(paymentMethod: paymentMethod, amount: amount, option: option)
        let publisher: AnyPublisher<SportRadarModels.ProcessDepositResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ processDepositResponse -> AnyPublisher<ProcessDepositResponse, ServiceProviderError> in
            if processDepositResponse.status == "CONTINUE_TO_PAYMENT_SITE" {
                let processDepositResponse = SportRadarModelMapper.processDepositResponse(fromProcessDepositResponse: processDepositResponse)
                return Just(processDepositResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                let messageKeyError = self.localizeOmegaErrorMessage(status: processDepositResponse.status)

                return Fail(outputType: ProcessDepositResponse.self, failure: ServiceProviderError.errorMessage(message: messageKeyError)).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func updatePayment(amount: Double, paymentId: String, type: String, returnUrl: String?, nameOnCard: String?, encryptedExpiryYear: String?, encryptedExpiryMonth: String?, encryptedSecurityCode: String?, encryptedCardNumber: String?) -> AnyPublisher<UpdatePaymentResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.updatePayment(amount: amount, paymentId: paymentId, type: type, returnUrl: returnUrl, nameOnCard: nameOnCard, encryptedExpiryYear: encryptedExpiryYear, encryptedExpiryMonth: encryptedExpiryMonth, encryptedSecurityCode: encryptedSecurityCode, encryptedCardNumber: encryptedCardNumber)

        let publisher: AnyPublisher<SportRadarModels.UpdatePaymentResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ updatePaymentResponse -> AnyPublisher<UpdatePaymentResponse, ServiceProviderError> in

            if updatePaymentResponse.resultCode == "RedirectShopper" {

                let updatePaymentResponse = SportRadarModelMapper.updatePaymentResponse(fromUpdatePaymentResponse: updatePaymentResponse)
                return Just(updatePaymentResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else if updatePaymentResponse.resultCode == "Authorised" && updatePaymentResponse.action == nil {
                return Just(UpdatePaymentResponse(resultCode: updatePaymentResponse.resultCode)).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: UpdatePaymentResponse.self, failure: ServiceProviderError.errorMessage(message: "Update Payment Error")).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func cancelDeposit(paymentId: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.cancelDeposit(paymentId: paymentId)

        let publisher: AnyPublisher<SportRadarModels.BasicResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ basicResponse -> AnyPublisher<BasicResponse, ServiceProviderError> in

            if basicResponse.status == "SUCCESS" {

                let basicResponse = SportRadarModelMapper.basicResponse(fromInternalBasicResponse: basicResponse)

                return Just(basicResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: BasicResponse.self, failure: ServiceProviderError.errorMessage(message: basicResponse.message ?? "Error"))
                    .eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func checkPaymentStatus(paymentMethod: String, paymentId: String) -> AnyPublisher<PaymentStatusResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.checkPaymentStatus(paymentMethod: paymentMethod, paymentId: paymentId)
        let publisher: AnyPublisher<SportRadarModels.PaymentStatusResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ paymentStatusResponse -> AnyPublisher<PaymentStatusResponse, ServiceProviderError> in
            if paymentStatusResponse.status == "SUCCESS" {
                let basicResponse = SportRadarModelMapper.paymentStatusResponse(fromPaymentStatusResponse: paymentStatusResponse)
                return Just(basicResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: PaymentStatusResponse.self, failure: ServiceProviderError.errorMessage(message: paymentStatusResponse.message ?? "Error"))
                    .eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func getWithdrawalMethods() -> AnyPublisher<[WithdrawalMethod], ServiceProviderError> {

        let endpoint = OmegaAPIClient.getWithdrawalsMethods
        let publisher: AnyPublisher<SportRadarModels.WithdrawalMethodsResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ withdrawalMethodsResponse -> AnyPublisher<[WithdrawalMethod], ServiceProviderError> in
            if withdrawalMethodsResponse.status == "SUCCESS" {

                let withdrawalMethodsResponse = SportRadarModelMapper.withdrawalMethodsResponse(fromWithdrawalMethodsResponse: withdrawalMethodsResponse)

                return Just(withdrawalMethodsResponse.withdrawalMethods).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

            }
            else {
                return Fail(outputType: [WithdrawalMethod].self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func processWithdrawal(paymentMethod: String, amount: Double, conversionId: String?) -> AnyPublisher<ProcessWithdrawalResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.processWithdrawal(withdrawalMethod: paymentMethod, amount: amount, conversionId: conversionId)
        let publisher: AnyPublisher<SportRadarModels.ProcessWithdrawalResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ processWithdrawalResponse -> AnyPublisher<ProcessWithdrawalResponse, ServiceProviderError> in
            if processWithdrawalResponse.status == "SUCCESS" {

                let processWithdrawalResponse = SportRadarModelMapper.processWithdrawalResponse(fromProcessWithdrawalResponse: processWithdrawalResponse)

                return Just(processWithdrawalResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                let messageKeyError = self.localizeOmegaErrorMessage(status: processWithdrawalResponse.status)

                return Fail(outputType: ProcessWithdrawalResponse.self, failure: ServiceProviderError.errorMessage(message: messageKeyError)).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func prepareWithdrawal(paymentMethod: String) -> AnyPublisher<PrepareWithdrawalResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.prepareWithdrawal(withdrawalMethod: paymentMethod)
        let publisher: AnyPublisher<SportRadarModels.PrepareWithdrawalResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ prepareWithdrawalResponse -> AnyPublisher<PrepareWithdrawalResponse, ServiceProviderError> in
            if prepareWithdrawalResponse.status == "SUCCESS" {

                let prepareWithdrawalResponse = SportRadarModelMapper.prepareWithdrawalResponse(fromPrepareWithdrawalResponse: prepareWithdrawalResponse)

                return Just(prepareWithdrawalResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                let messageKeyError = self.localizeOmegaErrorMessage(status: prepareWithdrawalResponse.status)

                return Fail(outputType: PrepareWithdrawalResponse.self, failure: ServiceProviderError.errorMessage(message: messageKeyError)).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func getPendingWithdrawals() -> AnyPublisher<[PendingWithdrawal], ServiceProviderError> {

        let endpoint = OmegaAPIClient.getPendingWithdrawals
        let publisher: AnyPublisher<SportRadarModels.PendingWithdrawalResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ pendingWithdrawalsResponse -> AnyPublisher<[PendingWithdrawal], ServiceProviderError> in
            if pendingWithdrawalsResponse.status == "SUCCESS" {

                let pendingWithdrawalsResponse = SportRadarModelMapper.pendingWithdrawalResponse(fromPendingWithdrawalResponse: pendingWithdrawalsResponse)

                return Just(pendingWithdrawalsResponse.pendingWithdrawals).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

            }
            else {
                return Fail(outputType: [PendingWithdrawal].self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func cancelWithdrawal(paymentId: Int) -> AnyPublisher<CancelWithdrawalResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.cancelWithdrawal(paymentId: paymentId)
        let publisher: AnyPublisher<SportRadarModels.CancelWithdrawalResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ cancelWithdrawalResponse -> AnyPublisher<CancelWithdrawalResponse, ServiceProviderError> in
            if cancelWithdrawalResponse.status == "SUCCESS" {

                let cancelWithdrawalResponse = SportRadarModelMapper.cancelWithdrawalResponse(fromCancelWithdrawalResponse: cancelWithdrawalResponse)

                return Just(cancelWithdrawalResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: CancelWithdrawalResponse.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func getPaymentInformation() -> AnyPublisher<PaymentInformation, ServiceProviderError> {

        let endpoint = OmegaAPIClient.getPaymentInformation
        let publisher: AnyPublisher<SportRadarModels.PaymentInformation, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ paymentInformation -> AnyPublisher<PaymentInformation, ServiceProviderError> in
            if paymentInformation.status == "SUCCESS" {

                let paymentInformation = SportRadarModelMapper.paymentInformation(fromPaymentInformation: paymentInformation)

                return Just(paymentInformation).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

            }
            else {
                return Fail(outputType: PaymentInformation.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func addPaymentInformation(type: String, fields: String) -> AnyPublisher<AddPaymentInformationResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.addPaymentInformation(type: type, fields: fields)
        let publisher: AnyPublisher<SportRadarModels.AddPaymentInformationResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ addPaymentInformation -> AnyPublisher<AddPaymentInformationResponse, ServiceProviderError> in
            if addPaymentInformation.status == "SUCCESS" {

                let addPaymentInformation = SportRadarModelMapper.addPaymentInformationResponse(fromAddPaymentInformationResponse: addPaymentInformation)

                return Just(addPaymentInformation).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

            }
            else {
                return Fail(outputType: AddPaymentInformationResponse.self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func getTransactionsHistory(startDate: String, endDate: String, transactionTypes: [TransactionType]? = nil, pageNumber: Int? = nil) -> AnyPublisher<[TransactionDetail], ServiceProviderError> {

        var transactionTypesKeys = [String]()

        if let transactionTypes {
            for transactionType in transactionTypes {
                transactionTypesKeys.append(transactionType.transactionKey)
            }
        }

        let endpoint = OmegaAPIClient.getTransactionsHistory(startDate: startDate, endDate: endDate, transactionType: transactionTypesKeys, pageNumber: pageNumber, pageSize: 10)

        let publisher: AnyPublisher<SportRadarModels.TransactionsHistoryResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ transactionsHistoryResponse -> AnyPublisher<[TransactionDetail], ServiceProviderError> in
            if transactionsHistoryResponse.status == "SUCCESS" {

                let mappedTransactionsHistoryResponse = SportRadarModelMapper.transactionsHistoryResponse(fromTransactionsHistoryResponse: transactionsHistoryResponse)

                if let transactions = mappedTransactionsHistoryResponse.transactions {

                    return Just(transactions).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                }

                return Just([]).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

            }
            else {
                return Fail(outputType: [TransactionDetail].self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func getGrantedBonuses() -> AnyPublisher<[GrantedBonus], ServiceProviderError> {

        let endpoint = OmegaAPIClient.getGrantedBonuses

        let publisher: AnyPublisher<SportRadarModels.GrantedBonusResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ grantedBonusResponse -> AnyPublisher<[GrantedBonus], ServiceProviderError> in
            if grantedBonusResponse.status == "SUCCESS" {

                let grantedBonusResponse = SportRadarModelMapper.grantedBonusesResponse(fromGrantedBonusesResponse: grantedBonusResponse)

                let grantedBonuses = grantedBonusResponse.bonuses

                return Just(grantedBonuses).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

            }
            else {
                return Fail(outputType: [GrantedBonus].self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func redeemBonus(code: String) -> AnyPublisher<RedeemBonusResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.redeemBonus(code: code)

        let publisher: AnyPublisher<SportRadarModels.RedeemBonusResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ redeemBonusResponse -> AnyPublisher<RedeemBonusResponse, ServiceProviderError> in
            if redeemBonusResponse.status == "SUCCESS" {

                let redeemBonusResponse = SportRadarModelMapper.redeemBonusesResponse(fromRedeemBonusesResponse: redeemBonusResponse)


                return Just(redeemBonusResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

            }
            else {
                return Fail(outputType: RedeemBonusResponse.self, failure: ServiceProviderError.errorMessage(message: redeemBonusResponse.status)).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func getAvailableBonuses() -> AnyPublisher<[AvailableBonus], ServiceProviderError> {

        let endpoint = OmegaAPIClient.getAvailableBonuses

        let publisher: AnyPublisher<SportRadarModels.AvailableBonusResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ availableBonusResponse -> AnyPublisher<[AvailableBonus], ServiceProviderError> in
            if availableBonusResponse.status == "SUCCESS" {

                let availableBonusResponse = SportRadarModelMapper.availableBonusesResponse(fromAvailableBonusesResponse: availableBonusResponse)

                let availableBonuses = availableBonusResponse.bonuses

                return Just(availableBonuses).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

            }
            else {
                return Fail(outputType: [AvailableBonus].self, failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func redeemAvailableBonus(partyId: String, code: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.redeemAvailableBonuses(partyId: partyId, bonusId: code)

        let publisher: AnyPublisher<SportRadarModels.BasicResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ basicResponse -> AnyPublisher<BasicResponse, ServiceProviderError> in
            if basicResponse.status == "SUCCESS" {

                let basicResponse = SportRadarModelMapper.basicResponse(fromInternalBasicResponse: basicResponse)

                return Just(basicResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

            }
            else {
                return Fail(outputType: BasicResponse.self, failure: ServiceProviderError.errorMessage(message: basicResponse.message ?? "Error")).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func cancelBonus(bonusId: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.cancelBonus(bonusId: bonusId)

        let publisher: AnyPublisher<SportRadarModels.BasicResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ basicResponse -> AnyPublisher<BasicResponse, ServiceProviderError> in
            if basicResponse.status == "SUCCESS" {

                let basicResponse = SportRadarModelMapper.basicResponse(fromInternalBasicResponse: basicResponse)

                return Just(basicResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

            }
            else {
                return Fail(outputType: BasicResponse.self, failure: ServiceProviderError.errorMessage(message: basicResponse.message ?? "Error")).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func optOutBonus(partyId: String, code: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.optOutBonus(partyId: partyId, bonusId: code)

        let publisher: AnyPublisher<SportRadarModels.BasicResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ basicResponse -> AnyPublisher<BasicResponse, ServiceProviderError> in
            if basicResponse.status == "SUCCESS" {

                let basicResponse = SportRadarModelMapper.basicResponse(fromInternalBasicResponse: basicResponse)

                return Just(basicResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

            }
            else {
                return Fail(outputType: BasicResponse.self, failure: ServiceProviderError.errorMessage(message: basicResponse.message ?? "Error")).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func contactUs(firstName: String, lastName: String, email: String, subject: String, message: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.contactUs(firstName: firstName, lastName: lastName, email: email, subject: subject, message: message)

        let publisher: AnyPublisher<SportRadarModels.BasicResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ basicResponse -> AnyPublisher<BasicResponse, ServiceProviderError> in
            if basicResponse.status == "SUCCESS" {

                let basicResponse = SportRadarModelMapper.basicResponse(fromInternalBasicResponse: basicResponse)

                return Just(basicResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

            }
            else {
                return Fail(outputType: BasicResponse.self, failure: ServiceProviderError.errorMessage(message: basicResponse.message ?? "Error")).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func contactSupport(userIdentifier: String, firstName: String, lastName: String, email: String, subject: String, subjectType: String, message: String, isLogged: Bool) -> AnyPublisher<SupportResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.contactSupport(userIdentifier: userIdentifier, firstName: firstName, lastName: lastName, email: email, subject: subject, subjectType: subjectType, message: message, isLogged: isLogged)

        let publisher: AnyPublisher<SportRadarModels.SupportResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ supportResponse -> AnyPublisher<SupportResponse, ServiceProviderError> in

            if supportResponse.request != nil {

                let supportResponse = SportRadarModelMapper.supportResponse(fromInternalSupportResponse: supportResponse)

                return Just(supportResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

            }
            else {
                return Fail(outputType: SupportResponse.self, failure: ServiceProviderError.errorMessage(message: supportResponse.description ?? "Error")).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func getAllConsents() -> AnyPublisher<[ConsentInfo], ServiceProviderError> {
        let endpoint = OmegaAPIClient.getAllConsents

        let publisher: AnyPublisher<SportRadarModels.ConsentsResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ userConsentsResponse -> AnyPublisher<[ConsentInfo], ServiceProviderError> in
            if userConsentsResponse.status == "SUCCESS" {
                let mappedConsents = userConsentsResponse.consents.map({ consent in
                    return ConsentInfo(id: consent.id,
                                       key: consent.key,
                                       name: consent.name,
                                       consentVersionId: consent.consentVersionId,
                                       status: consent.status,
                                       isMandatory: consent.isMandatory )
                })
                return Just(mappedConsents).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: [ConsentInfo].self,
                            failure: ServiceProviderError.invalidResponse).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func getUserConsents() -> AnyPublisher<[UserConsent], ServiceProviderError> {

        let endpoint = OmegaAPIClient.getUserConsents

        let publisher: AnyPublisher<SportRadarModels.UserConsentsResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ userConsentsResponse -> AnyPublisher<[UserConsent], ServiceProviderError> in
            if userConsentsResponse.status == "SUCCESS" {
                let mappedUserConsentsResponse = SportRadarModelMapper.userConsentResponse(fromUserConsentsResponse: userConsentsResponse)
                return Just(mappedUserConsentsResponse.userConsents).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: [UserConsent].self, failure: ServiceProviderError.errorMessage(message: userConsentsResponse.message ?? "Error")).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func setUserConsents(consentVersionIds: [Int]?, unconsenVersionIds: [Int]?) -> AnyPublisher<BasicResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.setUserConsents(consentVersionIds: consentVersionIds, unconsentVersionIds: unconsenVersionIds)

        let publisher: AnyPublisher<SportRadarModels.BasicResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ basicResponse -> AnyPublisher<BasicResponse, ServiceProviderError> in
            if basicResponse.status == "SUCCESS" {
                let basicResponse = SportRadarModelMapper.basicResponse(fromInternalBasicResponse: basicResponse)
                return Just(basicResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            return Fail(outputType: BasicResponse.self, failure: ServiceProviderError.errorMessage(message: basicResponse.message ?? "Error")).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()
    }

    func getSumsubAccessToken(userId: String, levelName: String) -> AnyPublisher<AccessTokenResponse, ServiceProviderError> {

        // let url = "/resources/accessTokens?userId=\(userId)&levelName=\(levelName)&ttlInSecs=600".replacingOccurrences(of: " ", with: "%20")
        let customAllowedSet =  NSCharacterSet(charactersIn:"; ").inverted

        let url = "/resources/accessTokens?userId=\(userId)&levelName=\(levelName)".addingPercentEncoding(withAllowedCharacters: customAllowedSet) ?? ""

        let method = "post"

        let secretKeyData = self.sumsubSecretKey.data(using: String.Encoding.utf8) ?? Data()

        let signatureHeaders = self.generateSignatureHeaders(url: url, method: method, secretKeyData: secretKeyData, appToken: self.sumsubAppToken)

        let endpoint = OmegaAPIClient.getSumsubAccessToken(userId: userId, levelName: levelName, body: nil, header: signatureHeaders)

        let publisher: AnyPublisher<SportRadarModels.AccessTokenResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ accessTokenResponse -> AnyPublisher<AccessTokenResponse, ServiceProviderError> in
            if accessTokenResponse.token != nil {
                let mappedAccessTokenResponse = SportRadarModelMapper.accessTokenResponse(fromInternalAccessTokenResponse: accessTokenResponse)

                return Just(mappedAccessTokenResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: AccessTokenResponse.self, failure: ServiceProviderError.errorMessage(message: accessTokenResponse.description ?? "Error")).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func getSumsubApplicantData(userId: String) -> AnyPublisher<ApplicantDataResponse, ServiceProviderError> {

        //let url = "/resources/applicants/-;externalUserId=\(userId)/one".replacingOccurrences(of: " ", with: "%20")
        let customAllowedSet =  NSCharacterSet(charactersIn:" ").inverted

        let url = "/resources/applicants/-;externalUserId=\(userId)/one".addingPercentEncoding(withAllowedCharacters: customAllowedSet) ?? ""

        let method = "get"

        let secretKeyData = self.sumsubSecretKey.data(using: String.Encoding.utf8) ?? Data()

        let signatureHeaders = self.generateSignatureHeaders(url: url, method: method, secretKeyData: secretKeyData, appToken: self.sumsubAppToken)

        let endpoint = OmegaAPIClient.getSumsubApplicantData(userId: userId, header: signatureHeaders)

        let publisher: AnyPublisher<SportRadarModels.ApplicantDataResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ applicantDataResponse -> AnyPublisher<ApplicantDataResponse, ServiceProviderError> in
            if applicantDataResponse.info != nil {
                let mappedApplicantDataResponse = SportRadarModelMapper.applicantDataResponse(fromInternalApplicantDataResponse: applicantDataResponse)

                return Just(mappedApplicantDataResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: ApplicantDataResponse.self, failure: ServiceProviderError.errorMessage(message: applicantDataResponse.description ?? "Error")).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func generateDocumentTypeToken(docType: String) -> AnyPublisher<AccessTokenResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.generateDocumentTypeToken(docType: docType)

        let publisher: AnyPublisher<SportRadarModels.AccessTokenResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ accessTokenResponse -> AnyPublisher<AccessTokenResponse, ServiceProviderError> in
            if accessTokenResponse.token != nil {

                let mappedAccessTokenResponse = SportRadarModelMapper.accessTokenResponse(fromInternalAccessTokenResponse: accessTokenResponse)

                return Just(mappedAccessTokenResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: AccessTokenResponse.self, failure: ServiceProviderError.errorMessage(message: accessTokenResponse.description ?? "Error")).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func checkDocumentationData() -> AnyPublisher<ApplicantDataResponse, ServiceProviderError> {

        let endpoint = OmegaAPIClient.checkDocumentationData

        let publisher: AnyPublisher<SportRadarModels.ApplicantRootResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ applicantRootResponse -> AnyPublisher<ApplicantDataResponse, ServiceProviderError> in

            if applicantRootResponse.status == "SUCCESS" {

                let mappedApplicantDataResponse = SportRadarModelMapper.applicantDataResponse(fromInternalApplicantDataResponse: applicantRootResponse.data)

                return Just(mappedApplicantDataResponse).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: ApplicantDataResponse.self, failure: ServiceProviderError.errorMessage(message: applicantRootResponse.message ?? "Error")).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func getMobileVerificationCode(forMobileNumber mobileNumber: String) -> AnyPublisher<MobileVerifyResponse, ServiceProviderError> {
        let endpoint = OmegaAPIClient.getMobileVerificationCode(mobileNumber: mobileNumber)

        let publisher: AnyPublisher<SportRadarModels.MobileVerifyResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ mobileVerifyResponse -> AnyPublisher<MobileVerifyResponse, ServiceProviderError> in
            if mobileVerifyResponse.status == "PENDING" {
                let response = SportRadarModelMapper.mobileVerifyResponse(fromInternalMobileVerifyResponse: mobileVerifyResponse)
                return Just(response).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            return Fail(outputType: MobileVerifyResponse.self, failure: ServiceProviderError.errorMessage(message: mobileVerifyResponse.message ?? "Error")).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()

    }

    func verifyMobileCode(code: String, requestId: String) -> AnyPublisher<MobileVerifyResponse, ServiceProviderError> {
        let endpoint = OmegaAPIClient.verifyMobileCode(code: code, requestId: requestId)

        let publisher: AnyPublisher<SportRadarModels.MobileVerifyResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ mobileVerifyResponse -> AnyPublisher<MobileVerifyResponse, ServiceProviderError> in
            if mobileVerifyResponse.status == "SUCCESS" {
                let response = SportRadarModelMapper.mobileVerifyResponse(fromInternalMobileVerifyResponse: mobileVerifyResponse)
                return Just(response).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
            }
            else if mobileVerifyResponse.status == "INVALID_VALUE" {
                return Fail(outputType: MobileVerifyResponse.self, failure: ServiceProviderError.invalidMobileVerifyCode).eraseToAnyPublisher()
            }

            return Fail(outputType: MobileVerifyResponse.self, failure: ServiceProviderError.errorMessage(message: mobileVerifyResponse.message ?? "Error")).eraseToAnyPublisher()
        })
        .eraseToAnyPublisher()

    }

    func getReferralLink() -> AnyPublisher<ReferralLink, ServiceProviderError> {

        let endpoint = OmegaAPIClient.getReferralLink

        let publisher: AnyPublisher<SportRadarModels.ReferralResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ referralResponse -> AnyPublisher<ReferralLink, ServiceProviderError> in

            if referralResponse.status == "SUCCESS" {

                let mappedReferralResponse = SportRadarModelMapper.referralResponse(fromInternalReferralResponse: referralResponse)

                if let referralLink = mappedReferralResponse.referralLinks.first {

                    return Just(referralLink).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()
                }

                return Fail(outputType: ReferralLink.self, failure: ServiceProviderError.errorMessage(message: referralResponse.status)).eraseToAnyPublisher()
            }
            else {
                return Fail(outputType: ReferralLink.self, failure: ServiceProviderError.errorMessage(message: referralResponse.status)).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }

    func getReferees() -> AnyPublisher<[Referee], ServiceProviderError> {

        let endpoint = OmegaAPIClient.getReferees

        let publisher: AnyPublisher<SportRadarModels.RefereesResponse, ServiceProviderError> = self.connector.request(endpoint)

        return publisher.flatMap({ refereesResponse -> AnyPublisher<[Referee], ServiceProviderError> in

            if refereesResponse.status == "SUCCESS" {

                let mappedRefereesResponse = SportRadarModelMapper.refereesResponse(fromInternalRefereesResponse: refereesResponse)

                return Just(mappedRefereesResponse.referees).setFailureType(to: ServiceProviderError.self).eraseToAnyPublisher()

            }
            else {
                return Fail(outputType: [Referee].self, failure: ServiceProviderError.errorMessage(message: refereesResponse.status)).eraseToAnyPublisher()
            }
        }).eraseToAnyPublisher()
    }
}

extension SportRadarPrivilegedAccessManager {
        
    func getFollowees() -> AnyPublisher<[Follower], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getTotalFollowees() -> AnyPublisher<Int, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getFollowers() -> AnyPublisher<[Follower], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getTotalFollowers() -> AnyPublisher<Int, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func addFollowee(userId: String) -> AnyPublisher<[String], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func removeFollowee(userId: String) -> AnyPublisher<[String], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getTipsRankings(type: String?, followers: Bool?) -> AnyPublisher<[TipRanking], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getUserProfileInfo(userId: String) -> AnyPublisher<UserProfileInfo, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getUserNotifications() -> AnyPublisher<UserNotificationsSettings, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func updateUserNotifications(settings: UserNotificationsSettings) -> AnyPublisher<Bool, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getFriendRequests() -> AnyPublisher<[FriendRequest], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getFriends() -> AnyPublisher<[GomaFriend], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func addFriends(userIds: [String], request: Bool) -> AnyPublisher<AddFriendResponse, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func removeFriend(userId: Int) -> AnyPublisher<String, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func getChatrooms() -> AnyPublisher<[ChatroomData], ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func addGroup(name: String, userIds: [String]) -> AnyPublisher<ChatroomId, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func deleteGroup(id: Int) -> AnyPublisher<String, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func editGroup(id: Int, name: String) -> AnyPublisher<String, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func leaveGroup(id: Int) -> AnyPublisher<String, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func addUsersToGroup(groupId: Int, userIds: [String]) -> AnyPublisher<String, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func removeUsersToGroup(groupId: Int, userIds: [String]) -> AnyPublisher<String, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

    func searchUserWithCode(code: String) -> AnyPublisher<SearchUser, ServiceProviderError> {
        return Fail(error: ServiceProviderError.notSupportedForProvider).eraseToAnyPublisher()
    }

}

extension SportRadarPrivilegedAccessManager: SportRadarSessionTokenUpdater {
    func forceTokenRefresh(forKey key: SessionCoordinatorKey) -> AnyPublisher<String?, Never> {

        if key == .launchToken {
            return self.connector
                .forceRefreshSession()
                .map(\.launchKey)
                .replaceError(with: nil)
                .eraseToAnyPublisher()
        }
        else if key == .restSessionToken {
            return self.connector
                .forceRefreshSession()
                .map(\.sessionKey)
                .map(Optional<String>.init)
                .replaceError(with: nil)
                .eraseToAnyPublisher()
        }
        else {
            return Just(nil)
                .eraseToAnyPublisher()
        }

    }

    func generateSignatureHeaders(url: String, method: String, bodyData: Data? = nil, secretKeyData: Data, appToken: String) -> [String: String] {

        let ts = Int(Date().timeIntervalSince1970)

        var dataToSign = "\(ts)\(method.uppercased())\(url)"

        if let bodyData {
            dataToSign += String(data: bodyData, encoding: .utf8) ?? ""
        }

        let data = Data(dataToSign.utf8)

        let hmac = HMAC<SHA256>.authenticationCode(for: data, using: SymmetricKey(data: secretKeyData))
        let signature = hmac.compactMap { String(format: "%02x", $0) }.joined()

        let headers = [
            "X-App-Token": "\(appToken)",
            "X-App-Access-Sig": signature,
            "X-App-Access-Ts": "\(ts)"
        ]

        return headers
    }

    func localizeOmegaErrorMessage(status: String) -> String {

        let sanitizedStatusName = status.replacingOccurrences(of: "[^a-zA-Z0-9]", with: "_", options: .regularExpression).lowercased()
        let concatenatedString = "omega_error_\(sanitizedStatusName)"

        return concatenatedString
    }
}
````

## File: Sources/ServicesProvider/Providers/Sportsradar/SportRadarSessionCoordinator.swift
````swift
//
//  SportRadarSessionCoordinator.swift
//
//
//  Created by Ruben Roques on 15/11/2022.
//

import Foundation
import Combine

protocol SportRadarSessionTokenUpdater: AnyObject {
    func forceTokenRefresh(forKey key: SessionCoordinatorKey) -> AnyPublisher<String?, Never>
}

enum SessionCoordinatorKey: String {
    case socketSessionToken
    case launchToken
    case restSessionToken
}

class SportRadarSessionCoordinator {

    private var accessTokensPublishers: [String: CurrentValueSubject<String?, Never>]

    private var accessTokensUpdaters: [String: SportRadarSessionTokenUpdater]

    init() {
        self.accessTokensPublishers = [:]
        self.accessTokensUpdaters = [:]
    }

    func clearSession() {
        for publisher in self.accessTokensPublishers.values {
            publisher.send(nil)
        }
    }

    func saveToken(_ token: String, withKey key: SessionCoordinatorKey) {
        self.accessTokensPublishers[key.rawValue]?.send(token)
    }

    func clearToken(withKey key: SessionCoordinatorKey) {
        self.accessTokensPublishers[key.rawValue]?.send(nil)
    }

    func token(forKey key: SessionCoordinatorKey) -> AnyPublisher<String?, Never> {
        if let publisher = self.accessTokensPublishers[key.rawValue] {
            return publisher.eraseToAnyPublisher()
        }
        else {
            self.accessTokensPublishers[key.rawValue] = .init(nil)
            return self.accessTokensPublishers[key.rawValue]!.eraseToAnyPublisher()
        }
    }

    func registerUpdater(_ updater: SportRadarSessionTokenUpdater, forKey key: SessionCoordinatorKey) {
        self.accessTokensUpdaters[key.rawValue] = updater
    }

    func forceTokenRefresh(forKey key: SessionCoordinatorKey) -> AnyPublisher<String?, Never>? {
        self.accessTokensPublishers[key.rawValue]?.send(nil)

        if let accessTokensRefresher = self.accessTokensUpdaters[key.rawValue] {
            return accessTokensRefresher.forceTokenRefresh(forKey: key)
        }
        return nil
    }

}
````

## File: Sources/ServicesProvider/ServiceProviderClient.swift
````swift
import Combine
import Foundation
import SharedModels

public class ServicesProviderClient {

    public enum ProviderType {
        case everymatrix
        case sportradar
    }

    public var privilegedAccessManagerConnectionStatePublisher: AnyPublisher<ConnectorState, Never> = Just(ConnectorState.disconnected).eraseToAnyPublisher()

    public var eventsConnectionStatePublisher: AnyPublisher<ConnectorState, Never> {
        return self.eventsConnectionStateSubject.eraseToAnyPublisher()
    }
    private var eventsConnectionStateSubject: CurrentValueSubject<ConnectorState, Never> = .init(.disconnected)

    public var bettingConnectionStatePublisher: AnyPublisher<ConnectorState, Never> = Just(ConnectorState.disconnected).eraseToAnyPublisher()

    private var providerType: ProviderType = .everymatrix

    private var privilegedAccessManager: (any PrivilegedAccessManager)?
    private var bettingProvider: (any BettingProvider)?
    private var eventsProvider: (any EventsProvider)?
    private var promotionsProvider: (any PromotionsProvider)? // TODO: SP Merge - Use login connectors
    

    private var analyticsProvider: (any AnalyticsProvider)?

    private var cancellables = Set<AnyCancellable>()

    public var sumsubDataProvider: SumsubDataProvider?

    private var configuration = ServicesProviderConfiguration() {
        didSet {
            switch self.configuration.environment {
            case .production:
                SportRadarConfiguration.shared.environment = .production
            case .staging:
                SportRadarConfiguration.shared.environment = .staging
            case .development:
                SportRadarConfiguration.shared.environment = .development
            }

        }
    }

    public var appBaseUrl: String = SportRadarConfiguration.shared.clientBaseUrl

    public init(providerType: ProviderType, configuration: ServicesProviderConfiguration) {
        self.providerType = providerType
        self.configuration = configuration

        switch configuration.environment {
        case .production:
            SportRadarConfiguration.shared.environment = .production
        case .staging:
            SportRadarConfiguration.shared.environment = .staging
        case .development:
            SportRadarConfiguration.shared.environment = .development
        }
    }

    public func connect() {
        switch self.providerType {
        case .everymatrix:
            fatalError()
            // let everymatrixProvider = EverymatrixProvider()
            // self.privilegedAccessManager = everymatrixProvider
            // self.bettingProvider = everymatrixProvider
            // self.eventsProvider = everymatrixProvider
        case .sportradar:

            // Session Coordinator
            let sessionCoordinator = SportRadarSessionCoordinator()

            let sportRadarPrivilegedAccessManager = SportRadarPrivilegedAccessManager(sessionCoordinator: sessionCoordinator,
                                                                             connector: OmegaConnector())

            self.privilegedAccessManager = sportRadarPrivilegedAccessManager
            self.eventsProvider = SportRadarEventsProvider(sessionCoordinator: sessionCoordinator,
                                                           socketConnector: SportRadarSocketConnector(),
                                                           restConnector: SportRadarRestConnector())
            self.bettingProvider = SportRadarBettingProvider(sessionCoordinator: sessionCoordinator)

            sessionCoordinator.registerUpdater(sportRadarPrivilegedAccessManager, forKey: .launchToken)

            self.eventsProvider!.connectionStatePublisher
                .sink(receiveCompletion: { completion in

                }, receiveValue: { [weak self] connectorState in
                    self?.eventsConnectionStateSubject.send(connectorState)
                }).store(in: &self.cancellables)

            self.bettingConnectionStatePublisher = self.bettingProvider!.connectionStatePublisher

            self.sumsubDataProvider = SumsubDataProvider()

            self.analyticsProvider = SportRadarAnalyticsProvider()
        }
    }

    public func forceReconnect() {

    }

    public func disconnect() {

    }

    public func reconnectIfNeeded() {
        self.eventsProvider?.reconnectIfNeeded()
    }

}

extension ServicesProviderClient {

    //
    // Sports
    //
    public func subscribePreLiveSportTypes(initialDate: Date? = nil, endDate: Date? = nil) -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribePreLiveSportTypes(initialDate: initialDate, endDate: endDate)
    }

    public func subscribeLiveSportTypes() -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeLiveSportTypes()
    }

    public func subscribeAllSportTypes() -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeAllSportTypes()
    }

    //
    // Events
    //
    public func subscribeLiveMatches(forSportType sportType: SportType) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeLiveMatches(forSportType: sportType)
    }

    public func requestLiveMatchesNextPage(forSportType sportType: SportType) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.requestLiveMatchesNextPage(forSportType: sportType)
    }

    public func subscribePreLiveMatches(forSportType sportType: SportType,
                                        initialDate: Date? = nil,
                                        endDate: Date? = nil,
                                        eventCount: Int? = nil,
                                        sortType: EventListSort) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribePreLiveMatches(forSportType: sportType,
                                                      initialDate: initialDate,
                                                      endDate: endDate,
                                                      eventCount: eventCount,
                                                      sortType: sortType)
    }

    public func requestPreLiveMatchesNextPage(forSportType sportType: SportType, initialDate: Date? = nil, endDate: Date? = nil, sortType: EventListSort) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.requestPreLiveMatchesNextPage(forSportType: sportType,
                                                      initialDate: initialDate,
                                                      endDate: endDate,
                                                      sortType: sortType)
    }

    func subscribeEndedMatches(forSportType sportType: SportType) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeEndedMatches(forSportType: sportType)
    }

    func requestEndedMatchesNextPage(forSportType sportType: SportType) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.requestEndedMatchesNextPage(forSportType: sportType)
    }

    //
    // Creates new Subscriptions
    public func subscribeToMarketDetails(withId id: String, onEventId eventId: String) -> AnyPublisher<SubscribableContent<Market>, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeToMarketDetails(withId: id, onEventId: eventId)
    }

    public func subscribeEventDetails(eventId: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeEventDetails(eventId: eventId)
    }

    public func subscribeCompetitionMatches(forMarketGroupId marketGroupId: String) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {

        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeCompetitionMatches(forMarketGroupId: marketGroupId)
    }


    public func subscribeOutrightEvent(forMarketGroupId marketGroupId: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {

        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeOutrightEvent(forMarketGroupId: marketGroupId)
    }


    public func subscribeOutrightMarkets(forMarketGroupId marketGroupId: String) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {

        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeOutrightMarkets(forMarketGroupId: marketGroupId)
    }

    public func subscribeEventSummary(eventId: String) -> AnyPublisher<SubscribableContent<[EventsGroup]>, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeEventSummary(eventId: eventId)
    }

    public func subscribeToLiveDataUpdates(forEventWithId id: String) -> AnyPublisher<SubscribableContent<EventLiveData>, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeToLiveDataUpdates(forEventWithId: id)
    }

    //
    // Uses the publishers from the events list (prelive and live)
    //
    public func subscribeToEventOnListsLiveDataUpdates(withId id: String) -> AnyPublisher<Event?, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeToEventOnListsLiveDataUpdates(withId: id)
    }

    public func subscribeToEventOnListsMarketUpdates(withId id: String) -> AnyPublisher<Market?, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeToEventOnListsMarketUpdates(withId: id)
    }

    public func subscribeToEventOnListsOutcomeUpdates(withId id: String) -> AnyPublisher<Outcome?, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeToEventOnListsOutcomeUpdates(withId: id)
    }

    //
    //
    public func getEventDetails(eventId: String) -> AnyPublisher<Event, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getEventDetails(eventId: eventId)
    }

    public func getEventSecundaryMarkets(eventId: String) -> AnyPublisher<Event, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getEventSecundaryMarkets(eventId: eventId)
    }

    public func getEventLiveData(eventId : String) -> AnyPublisher<EventLiveData, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getEventLiveData(eventId: eventId)
    }

    public func subscribeEventMarkets(eventId: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeEventMarkets(eventId: eventId)
    }

    public func subscribeSportTypes() -> AnyPublisher<SubscribableContent<[SportType]>, ServiceProviderError> {
         guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.subscribeSportTypes()
    }

    public func addFavoriteToList(listId: Int, eventId: String) -> AnyPublisher<FavoriteAddResponse, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.addFavoriteToList(listId: listId, eventId: eventId)
    }

    public func getAlertBanners() -> AnyPublisher<[AlertBanner], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getAlertBanners()
    }

    public func getNews() -> AnyPublisher<[News], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getNews()
    }

    public func getPromotedEventGroupsPointers() -> AnyPublisher<[EventGroupPointer], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getPromotedEventGroupsPointers()
    }

    public func getPromotedEventsGroups() -> AnyPublisher<[EventsGroup], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getPromotedEventsGroups()
    }

    public func getPromotionalSlidingTopEventsPointers() -> AnyPublisher<[EventMetadataPointer], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getPromotionalSlidingTopEventsPointers()
    }

    public func getHighlightedBoostedEventsPointers() -> AnyPublisher<[EventMetadataPointer], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getHighlightedBoostedEventsPointers()
    }

    public func getHighlightedVisualImageEventsPointers() -> AnyPublisher<[EventMetadataPointer], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getHighlightedVisualImageEventsPointers()
    }

    public func getPromotedEventsBySport() -> AnyPublisher<[SportType : [Event]], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getPromotedEventsBySport()
    }

    public func addFavoriteItem(favoriteId: Int, type: String) -> AnyPublisher<BasicMessageResponse, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.addFavoriteItem(favoriteId: favoriteId, type: type)
    }

    public func deleteFavoriteItem(favoriteId: Int, type: String) -> AnyPublisher<BasicMessageResponse, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.deleteFavoriteItem(favoriteId: favoriteId, type: type)
    }

    public func getFeaturedTips(page: Int?, limit: Int?, topTips: Bool?, followersTips: Bool?, friendsTips: Bool?, userId: String?, homeTips: Bool?) -> AnyPublisher<FeaturedTips, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: ServiceProviderError.eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getFeaturedTips(page: page, limit: limit, topTips: topTips, followersTips: followersTips, friendsTips: friendsTips, userId: userId, homeTips: homeTips)
    }

}

extension ServicesProviderClient {
    public func getMarketGroups(forEvent event: Event) -> AnyPublisher<[MarketGroup], Never> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            let defaultMarketGroup = [MarketGroup.init(type: "0",
                                                       id: "0",
                                                       groupKey: "All Markets",
                                                       translatedName: "All Markets",
                                                       position: 0,
                                                       isDefault: true,
                                                       numberOfMarkets: nil,
                                                       loaded: true,
                                                       markets: event.markets)]
            return Just(defaultMarketGroup).eraseToAnyPublisher()
        }
        return eventsProvider.getMarketGroups(forEvent: event)
    }

    public func getFieldWidgetId(eventId: String) -> AnyPublisher<FieldWidget, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getFieldWidgetId(eventId: eventId)
    }

    public func getFieldWidget(eventId: String, isDarkTheme: Bool? = nil) -> AnyPublisher<FieldWidgetRenderDataType, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getFieldWidget(eventId: eventId, isDarkTheme: isDarkTheme)
    }

    public func getStatsWidget(eventId: String, marketTypeName: String, isDarkTheme: Bool?) -> AnyPublisher<StatsWidgetRenderDataType, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getStatsWidget(eventId: eventId, marketTypeName: marketTypeName, isDarkTheme: isDarkTheme)
    }

    public func getAvailableSportTypes(initialDate: Date? = nil, endDate: Date? = nil) -> AnyPublisher<[SportType], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getAvailableSportTypes(initialDate: initialDate, endDate: endDate)
    }

    public func getSportRegions(sportId: String) -> AnyPublisher<SportNodeInfo, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getSportRegions(sportId: sportId)
    }

    public func getRegionCompetitions(regionId: String) -> AnyPublisher<SportRegionInfo, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getRegionCompetitions(regionId: regionId)
    }

    public func getCompetitionMarketGroups(competitionId: String) -> AnyPublisher<SportCompetitionInfo, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getCompetitionMarketGroups(competitionId: competitionId)
    }

    public func getSearchEvents(query: String, resultLimit: String, page: String, isLive: Bool = false) -> AnyPublisher<EventsGroup, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getSearchEvents(query: query, resultLimit: resultLimit, page: page, isLive: isLive)
    }

    public func getHomeSliders() -> AnyPublisher<BannerResponse, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getHomeSliders()
    }

    public func getPromotionalTopBanners() -> AnyPublisher<[PromotionalBanner], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getPromotionalTopBanners()
    }

    public func getPromotionalSlidingTopEvents() -> AnyPublisher<[Event], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getPromotionalSlidingTopEvents()
    }

    public func getPromotionalTopStories() -> AnyPublisher<[PromotionalStory], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getPromotionalTopStories()
    }


    public func getHighlightedBoostedEvents() -> AnyPublisher<[Event], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getHighlightedBoostedEvents()
    }

    public func getHighlightedVisualImageEvents() -> AnyPublisher<[Event], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getHighlightedVisualImageEvents()
    }

    public func getHighlightedMarkets() -> AnyPublisher<[HighlightMarket], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getHighlightedMarkets()
    }

    public func getHeroGameEvent() -> AnyPublisher<[Event], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }
        return eventsProvider.getHeroGameEvent()
    }

    //
    //
    public func getPromotedSports() -> AnyPublisher<[PromotedSport], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getPromotedSports()
    }

    public func getCashbackSuccessBanner() -> AnyPublisher<BannerResponse, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getHomeSliders()
    }

    public func getTopCompetitionsPointers() -> AnyPublisher<[TopCompetitionPointer], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getTopCompetitionsPointers()
    }

    public func getTopCompetitions() -> AnyPublisher<[TopCompetition], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getTopCompetitions()
    }

    public func getEventForMarketGroup(withId marketGroupId: String) -> AnyPublisher<Event, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getEventForMarketGroup(withId: marketGroupId)
    }


    public func getEventsForEventGroup(withId eventGroupId: String) -> AnyPublisher<EventsGroup, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getEventsForEventGroup(withId: eventGroupId)
    }

    //
    //
    public func getEventSummary(eventId: String, marketLimit: Int?) -> AnyPublisher<Event, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getEventSummary(eventId: eventId, marketLimit: marketLimit)
    }

    public func getEventSummary(forMarketId marketId: String) -> AnyPublisher<Event, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getEventSummary(forMarketId: marketId)
    }

    public func getMarketInfo(marketId: String) -> AnyPublisher<Market, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getMarketInfo(marketId: marketId)
    }

    public func getFavoritesList() -> AnyPublisher<FavoritesListResponse, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getFavoritesList()
    }

    public func addFavoritesList(name: String) -> AnyPublisher<FavoritesListAddResponse, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.addFavoritesList(name: name)
    }

    public func deleteFavoritesList(listId: Int) -> AnyPublisher<FavoritesListDeleteResponse, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.deleteFavoritesList(listId: listId)
    }

    public func addFavoritesToList(listId: Int, eventId: String) -> AnyPublisher<FavoriteAddResponse, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.addFavoriteToList(listId: listId, eventId: eventId)
    }

    public func getFavoritesFromList(listId: Int) -> AnyPublisher<FavoriteEventResponse, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getFavoritesFromList(listId: listId)
    }

    public func deleteFavoriteFromList(eventId: Int) -> AnyPublisher<FavoritesListDeleteResponse, ServiceProviderError> {

        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.deleteFavoriteFromList(eventId: eventId)
    }

    public func subscribeToEventAndSecondaryMarkets(withId id: String) -> AnyPublisher<SubscribableContent<Event>, ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.subscribeToEventAndSecondaryMarkets(withId: id)
    }

    public func getPromotedBetslips(userId: String?) -> AnyPublisher<[PromotedBetslip], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getPromotedBetslips(userId: userId)
    }

    public func getHighlightedLiveEventsPointers(eventCount: Int, userId: String?) -> AnyPublisher<[String], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getHighlightedLiveEventsPointers(eventCount: eventCount, userId: userId)
    }

    public func getHighlightedLiveEvents(eventCount: Int, userId: String?) -> AnyPublisher<[Event], ServiceProviderError> {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return Fail(error: .eventsProviderNotFound).eraseToAnyPublisher()
        }

        return eventsProvider.getHighlightedLiveEvents(eventCount: eventCount, userId: userId)
    }

}


extension ServicesProviderClient {

    //
    // PrivilegedAccessManager
    //
    public func loginUser(withUsername username: String, andPassword password: String) -> AnyPublisher<UserProfile, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.login(username: username, password: password)
    }

    public func getProfile() -> AnyPublisher<UserProfile, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.getUserProfile(withKycExpire: nil)
    }

    public func hasSecurityQuestions() -> Bool {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return false
        }
        return privilegedAccessManager.hasSecurityQuestions
    }

    public func updateUserProfile(form: UpdateUserProfileForm) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.updateUserProfile(form: form)
    }

    public func simpleSignUp(form: SimpleSignUpForm) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.simpleSignUp(form: form)
    }
 
    public func signUp(form: SignUpForm) -> AnyPublisher<SignUpResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.signUp(form: form)
    }

    public func updateExtraInfo(placeOfBirth: String?, address2: String?) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.updateExtraInfo(placeOfBirth: placeOfBirth, address2: address2)
    }

    public func updateDeviceIdentifier(deviceIdentifier: String, appVersion: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.updateDeviceIdentifier(deviceIdentifier: deviceIdentifier, appVersion: appVersion)
    }


    public func checkEmailRegistered(_ email: String) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.checkEmailRegistered(email)
    }

    public func validateUsername(_ username: String) -> AnyPublisher<UsernameValidation, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.validateUsername(username)
    }

    public func signupConfirmation(_ email: String, confirmationCode: String) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.signupConfirmation(email, confirmationCode: confirmationCode)
    }

    public func forgotPassword(email: String, secretQuestion: String? = nil, secrestAnswer: String? = nil) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.forgotPassword(email: email, secretQuestion: secretQuestion, secretAnswer: secrestAnswer)
    }

    public func updatePassword(oldPassword: String, newPassword: String) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.updatePassword(oldPassword: oldPassword, newPassword: newPassword)
    }

    public func getPasswordPolicy() -> AnyPublisher<PasswordPolicy, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.getPasswordPolicy()
    }

    public func updateWeeklyDepositLimits(newLimit: Double) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.updateWeeklyDepositLimits(newLimit: newLimit)
    }

    public func updateWeeklyBettingLimits(newLimit: Double) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.updateWeeklyBettingLimits(newLimit: newLimit)
    }

    public func updateResponsibleGamingLimits(newLimit: Double, limitType: String, hasRollingWeeklyLimits: Bool) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.updateResponsibleGamingLimits(newLimit: newLimit, limitType: limitType, hasRollingWeeklyLimits: hasRollingWeeklyLimits)
    }

    public func getPersonalDepositLimits() -> AnyPublisher<PersonalDepositLimitResponse, ServiceProviderError> {

        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.getPersonalDepositLimits()
    }

    public func getLimits() -> AnyPublisher<LimitsResponse, ServiceProviderError> {

        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.getLimits()
    }

    public func getResponsibleGamingLimits(periodTypes: String? = nil, limitTypes: String? = nil) -> AnyPublisher<ResponsibleGamingLimitsResponse, ServiceProviderError> {

        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.getResponsibleGamingLimits(periodTypes: periodTypes, limitTypes: limitTypes)
    }

    public func lockPlayer(isPermanent: Bool? = nil, lockPeriodUnit: String? = nil, lockPeriod: String? = nil) -> AnyPublisher<BasicResponse, ServiceProviderError> {

        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.lockPlayer(isPermanent: isPermanent, lockPeriodUnit: lockPeriodUnit, lockPeriod: lockPeriod)
    }

    public func getUserBalance() -> AnyPublisher<UserWallet, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.getUserBalance()
    }

    public func getUserCashbackBalance() -> AnyPublisher<CashbackBalance, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.getUserCashbackBalance()
    }

    public func signUpCompletion(form: ServicesProvider.UpdateUserProfileForm) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.signUpCompletion(form: form)
    }


    public func getMobileVerificationCode(forMobileNumber mobileNumber: String) -> AnyPublisher<MobileVerifyResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.getMobileVerificationCode(forMobileNumber: mobileNumber)
    }

    public func verifyMobileCode(code: String, requestId: String) -> AnyPublisher<MobileVerifyResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.verifyMobileCode(code: code, requestId: requestId)
    }


}

extension ServicesProviderClient {

    public func getAllCountries() -> AnyPublisher<[SharedModels.Country], ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getAllCountries()
    }

    public func getCountries() -> AnyPublisher<[SharedModels.Country], ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getCountries()
    }

    public func getCurrentCountry() -> AnyPublisher<SharedModels.Country?, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }
        return privilegedAccessManager.getCurrentCountry()
    }

}

extension ServicesProviderClient {

    //
    // Betslip
    //
    public func getAllowedBetTypes(withBetTicketSelections betTicketSelections: [BetTicketSelection]) -> AnyPublisher<[BetType], ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.getAllowedBetTypes(withBetTicketSelections: betTicketSelections)
    }

    public func calculatePotentialReturn(forBetTicket betTicket: BetTicket) -> AnyPublisher<BetslipPotentialReturn, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(outputType: BetslipPotentialReturn.self,
                        failure: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.calculatePotentialReturn(forBetTicket: betTicket)
    }

    public func placeBets(betTickets: [BetTicket], useFreebetBalance: Bool) -> AnyPublisher<PlacedBetsResponse, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.placeBets(betTickets: betTickets, useFreebetBalance: useFreebetBalance)
    }

    public func confirmBoostedBet(identifier: String) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.confirmBoostedBet(identifier: identifier)
    }

    public func rejectBoostedBet(identifier: String) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.rejectBoostedBet(identifier: identifier)
    }

    public func calculateBetBuilderPotentialReturn(forBetTicket betTicket: BetTicket) -> AnyPublisher<BetBuilderPotentialReturn, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.calculateBetBuilderPotentialReturn(forBetTicket: betTicket)
    }

    public func placeBetBuilderBet(betTicket: BetTicket, calculatedOdd: Double) -> AnyPublisher<PlacedBetsResponse, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.placeBetBuilderBet(betTicket: betTicket, calculatedOdd: calculatedOdd)
    }

    //
    // My Bets
    //
    public func getBettingHistory(pageIndex: Int) -> AnyPublisher<BettingHistory, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }

        return bettingProvider.getBetHistory(pageIndex: pageIndex)
    }

    public func getOpenBetsHistory(pageIndex: Int, startDate: String? = nil, endDate: String? = nil) -> AnyPublisher<BettingHistory, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }

        return bettingProvider.getOpenBetsHistory(pageIndex: pageIndex, startDate: startDate, endDate: endDate)
    }

    public func getResolvedBetsHistory(pageIndex: Int, startDate: String? = nil, endDate: String? = nil) -> AnyPublisher<BettingHistory, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }

        return bettingProvider.getResolvedBetsHistory(pageIndex: pageIndex, startDate: startDate, endDate: endDate)
    }

    public func getWonBetsHistory(pageIndex: Int, startDate: String? = nil, endDate: String? = nil) -> AnyPublisher<BettingHistory, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }

        return bettingProvider.getWonBetsHistory(pageIndex: pageIndex, startDate: startDate, endDate: endDate)
    }

    public func getBetDetails(identifier: String) -> AnyPublisher<Bet, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }

        return bettingProvider.getBetDetails(identifier: identifier)
    }

    public func getBetslipSettings() -> AnyPublisher<BetslipSettings?, Never> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Just(nil).eraseToAnyPublisher()
        }

        return bettingProvider.getBetslipSettings()
    }

    public func updateBetslipSettings(_ betslipSettings: BetslipSettings) -> AnyPublisher<Bool, Never> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Just(false).eraseToAnyPublisher()
        }

        return bettingProvider.updateBetslipSettings(betslipSettings)
    }

    public func getBetHistory(pageIndex: Int) -> AnyPublisher<BettingHistory, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.getBetHistory(pageIndex: pageIndex)
    }

    public func updateTicketOdds(betId: String) -> AnyPublisher<Bet, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.updateTicketOdds(betId: betId)
    }

    public func getTicketQRCode(betId: String) -> AnyPublisher<BetQRCode, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.getTicketQRCode(betId: betId)
    }

    public func getSocialSharedTicket(shareId: String) -> AnyPublisher<Bet, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.getSocialSharedTicket(shareId: shareId)
    }

    public func deleteTicket(betId: String) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.deleteTicket(betId: betId)
    }

    public func updateTicket(betId: String, betTicket: BetTicket) -> AnyPublisher<PlacedBetsResponse, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.updateTicket(betId: betId, betTicket: betTicket)
    }

}

// Documents
extension ServicesProviderClient {

    public func getDocumentTypes() -> AnyPublisher<DocumentTypesResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getDocumentTypes()
    }

    public func getUserDocuments() -> AnyPublisher<UserDocumentsResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getUserDocuments()
    }

    public func uploadUserDocument(documentType: String, file: Data, fileName: String) -> AnyPublisher<UploadDocumentResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.uploadUserDocument(documentType: documentType, file: file, fileName: fileName)
    }

    public func uploadMultipleUserDocuments(documentType: String, files: [String: Data]) -> AnyPublisher<UploadDocumentResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.uploadMultipleUserDocuments(documentType: documentType, files: files)
    }

    public func getPayments() -> AnyPublisher<SimplePaymentMethodsResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getPayments()
    }

    public func processDeposit(paymentMethod: String, amount: Double, option: String) -> AnyPublisher<ProcessDepositResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.processDeposit(paymentMethod: paymentMethod, amount: amount, option: option)
    }

    public func updatePayment(amount: Double, paymentId: String, type: String, returnUrl: String?, nameOnCard: String? = nil, encryptedExpiryYear: String? = nil, encryptedExpiryMonth: String? = nil, encryptedSecurityCode: String? = nil, encryptedCardNumber: String? = nil) -> AnyPublisher<UpdatePaymentResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.updatePayment(amount: amount, paymentId: paymentId, type: type, returnUrl: returnUrl, nameOnCard: nameOnCard, encryptedExpiryYear: encryptedExpiryYear, encryptedExpiryMonth: encryptedExpiryMonth, encryptedSecurityCode: encryptedSecurityCode, encryptedCardNumber: encryptedCardNumber)
    }

    public func cancelDeposit(paymentId: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.cancelDeposit(paymentId: paymentId)
    }

    public func checkPaymentStatus(paymentMethod: String, paymentId: String) -> AnyPublisher<PaymentStatusResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.checkPaymentStatus(paymentMethod: paymentMethod, paymentId: paymentId)
    }

    public func getWithdrawalMethods() -> AnyPublisher<[WithdrawalMethod], ServiceProviderError> {

        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getWithdrawalMethods()
    }

    public func processWithdrawal(paymentMethod: String, amount: Double, conversionId: String? = nil) -> AnyPublisher<ProcessWithdrawalResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.processWithdrawal(paymentMethod: paymentMethod, amount: amount, conversionId: conversionId)
    }

    public func prepareWithdrawal(paymentMethod: String) -> AnyPublisher<PrepareWithdrawalResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.prepareWithdrawal(paymentMethod: paymentMethod)
    }

    public func getPendingWithdrawals() -> AnyPublisher<[PendingWithdrawal], ServiceProviderError> {

        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getPendingWithdrawals()
    }

    public func cancelWithdrawal(paymentId: Int) -> AnyPublisher<CancelWithdrawalResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.cancelWithdrawal(paymentId: paymentId)
    }

    public func getPaymentInformation() -> AnyPublisher<PaymentInformation, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getPaymentInformation()
    }

    public func addPaymentInformation(type: String, fields: String) -> AnyPublisher<AddPaymentInformationResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.addPaymentInformation(type: type, fields: fields)
    }

    public func getTransactionsHistory(startDate: String, endDate: String, transactionTypes: [TransactionType]? = nil, pageNumber: Int? = nil) -> AnyPublisher<[TransactionDetail], ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getTransactionsHistory(startDate: startDate, endDate: endDate, transactionTypes: transactionTypes, pageNumber: pageNumber)
    }

    public func getGrantedBonuses() -> AnyPublisher<[GrantedBonus], ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getGrantedBonuses()
    }

    public func redeemBonus(code: String) -> AnyPublisher<RedeemBonusResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.redeemBonus(code: code)
    }

    public func getAvailableBonuses() -> AnyPublisher<[AvailableBonus], ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getAvailableBonuses()
    }

    public func redeemAvailableBonus(partyId: String, code: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.redeemAvailableBonus(partyId: partyId, code: code)
    }

    public func cancelBonus(bonusId: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.cancelBonus(bonusId: bonusId)
    }

    public func optOutBonus(partyId: String, code: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.optOutBonus(partyId: partyId, code: code)
    }

    public func contactUs(firstName: String, lastName: String, email: String, subject: String, message: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.contactUs(firstName: firstName, lastName: lastName, email: email, subject: subject, message: message)
    }

    public func contactSupport(userIdentifier: String, firstName: String, lastName: String, email: String, subject: String, subjectType: String, message: String, isLogged: Bool) -> AnyPublisher<SupportResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.contactSupport(userIdentifier: userIdentifier, firstName: firstName, lastName: lastName, email: email, subject: subject, subjectType: subjectType, message: message, isLogged: isLogged)
    }

    public func calculateCashout(betId: String, stakeValue: String? = nil) -> AnyPublisher<Cashout, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }

        return bettingProvider.calculateCashout(betId: betId, stakeValue: stakeValue)
    }

    public func allowedCashoutBetIds() -> AnyPublisher<[String], ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }

        return bettingProvider.allowedCashoutBetIds()
    }

    public func cashoutBet(betId: String, cashoutValue: Double, stakeValue: Double? = nil) -> AnyPublisher<CashoutResult, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }

        return bettingProvider.cashoutBet(betId: betId, cashoutValue: cashoutValue, stakeValue: stakeValue)
    }

    public func getFreebet() -> AnyPublisher<FreebetBalance, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.getFreebet()
    }

    public func calculateCashback(forBetTicket betTicket: BetTicket)  -> AnyPublisher<CashbackResult, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }

        return bettingProvider.calculateCashback(forBetTicket: betTicket)
    }

    public func getSharedTicket(betslipId: String) -> AnyPublisher<SharedTicketResponse, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.getSharedTicket(betslipId: betslipId)
    }

    public func getTicketSelection(ticketSelectionId: String) -> AnyPublisher<TicketSelection, ServiceProviderError> {
        guard
            let bettingProvider = self.bettingProvider
        else {
            return Fail(error: ServiceProviderError.bettingProviderNotFound).eraseToAnyPublisher()
        }
        return bettingProvider.getTicketSelection(ticketSelectionId: ticketSelectionId)
    }

    public func getAllConsents() -> AnyPublisher<[ConsentInfo], ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getAllConsents()
    }

    public func getUserConsents() -> AnyPublisher<[UserConsent], ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getUserConsents()
    }

    public func setUserConsents(consentVersionIds: [Int]? = nil, unconsetVersionIds: [Int]? = nil) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.setUserConsents(consentVersionIds: consentVersionIds, unconsenVersionIds: unconsetVersionIds)
    }

    public func getSumsubAccessToken(userId: String, levelName: String) -> AnyPublisher<AccessTokenResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getSumsubAccessToken(userId: userId, levelName: levelName)
    }

    public func getSumsubApplicantData(userId: String) -> AnyPublisher<ApplicantDataResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getSumsubApplicantData(userId: userId)
    }

    public func generateDocumentTypeToken(docType: String) -> AnyPublisher<AccessTokenResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.generateDocumentTypeToken(docType: docType)
    }

    public func checkDocumentationData() -> AnyPublisher<ApplicantDataResponse, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.checkDocumentationData()
    }

    public func getReferralLink() -> AnyPublisher<ReferralLink, ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getReferralLink()
    }

    public func getReferees() -> AnyPublisher<[Referee], ServiceProviderError> {
        guard
            let privilegedAccessManager = self.privilegedAccessManager
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        return privilegedAccessManager.getReferees()
    }
}

// AnalyticsProvider
extension ServicesProviderClient {

    public func trackEvent(_ event: AnalyticsTrackedEvent, userIdentifer: String?) -> AnyPublisher<Void, ServiceProviderError> {
        guard
            let analyticsProvider = self.analyticsProvider
        else {
            return Fail(error: ServiceProviderError.privilegedAccessManagerNotFound).eraseToAnyPublisher()
        }

        let vaixAnalyticsEvent = SportRadarModelMapper.vaixAnalyticsEvent(fromAnalyticsTrackedEvent: event)

        return analyticsProvider.trackEvent(vaixAnalyticsEvent, userIdentifer: userIdentifer).eraseToAnyPublisher()
    }
    
}

extension ServicesProviderClient {

    public func updateDeviceIdentifier(deviceIdentifier: String) -> AnyPublisher<BasicResponse, ServiceProviderError> {
        guard
            let promotionsProvider = self.promotionsProvider
        else {
            return Fail(error: ServiceProviderError.promotionsProviderNotFound).eraseToAnyPublisher()
        }

        return promotionsProvider.updateDeviceIdentifier(deviceIdentifier: deviceIdentifier)
    }

    public func isPromotionsProviderEnabled(isEnabled: Bool) -> AnyPublisher<Bool, ServiceProviderError> {
        guard
            let promotionsProvider = self.promotionsProvider
        else {
            return Fail(error: ServiceProviderError.promotionsProviderNotFound).eraseToAnyPublisher()
        }

        return promotionsProvider.isPromotionsProviderEnabled(isEnabled: isEnabled)
    }

    public func login(username: String, password: String) -> AnyPublisher<UserProfile, ServiceProviderError> {
        guard
            let promotionsProvider = self.promotionsProvider
        else {
            return Fail(error: ServiceProviderError.promotionsProviderNotFound).eraseToAnyPublisher()
        }

        return promotionsProvider.login(username: username, password: password)
    }

    public func anonymousLogin() -> AnyPublisher<String, ServiceProviderError> {
        guard
            let promotionsProvider = self.promotionsProvider
        else {
            return Fail(error: ServiceProviderError.promotionsProviderNotFound).eraseToAnyPublisher()
        }

        return promotionsProvider.anonymousLogin()
    }

    public func logoutUser() -> AnyPublisher<String, ServiceProviderError> {
        guard
            let promotionsProvider = self.promotionsProvider
        else {
            return Fail(error: ServiceProviderError.promotionsProviderNotFound).eraseToAnyPublisher()
        }

        return promotionsProvider.logoutUser()
    }

    public func basicSignUp(form: SignUpForm) -> AnyPublisher<DetailedSignUpResponse, ServiceProviderError> {
        guard
            let promotionsProvider = self.promotionsProvider
        else {
            return Fail(error: ServiceProviderError.promotionsProviderNotFound).eraseToAnyPublisher()
        }

        return promotionsProvider.basicSignUp(form: form)
    }
}

// Utilities
extension ServicesProviderClient {

    public func getDatesFilter(timeRange: String) -> [Date] {
        guard
            let eventsProvider = self.eventsProvider
        else {
            return []
        }

        return eventsProvider.getDatesFilter(timeRange: timeRange)
    }
}
````

## File: Sources/ServicesProvider/ServicesProviderConfiguration.swift
````swift
//
//  File.swift
//  
//
//  Created by Ruben Roques on 27/09/2023.
//

import Foundation

public struct ServicesProviderConfiguration {
    
    public enum Environment {
        case production // PROD
        case staging // UAT
        case development
    }
    
    private(set) var environment: Environment = .production
    
    public init(environment: Environment = .production) {
        self.environment = environment
    }
    
}
````

## File: Tests/ServicesProviderTests/Models/Promotions/HomeTemplateTests.swift
````swift
import XCTest
@testable import ServicesProvider

final class HomeTemplateTests: XCTestCase {

    // MARK: - HomeTemplate Tests

    func testHomeTemplateInitialization() {
        // Given
        let widgetData = HomeWidget.WidgetData(
            id: 1,
            type: "banners",
            description: "Test Banners Widget",
            userState: "any",
            sortOrder: 1,
            orientation: "horizontal"
        )

        let widget = HomeWidget.banners(widgetData)

        // When
        let template = HomeTemplate(id: 101, type: "home", widgets: [widget])

        // Then
        XCTAssertEqual(template.id, 101)
        XCTAssertEqual(template.type, "home")
        XCTAssertEqual(template.widgets.count, 1)

        if case let .banners(data) = template.widgets[0] {
            XCTAssertEqual(data.id, 1)
            XCTAssertEqual(data.type, "banners")
            XCTAssertEqual(data.description, "Test Banners Widget")
            XCTAssertEqual(data.userState, HomeWidget.WidgetData.UserState.any)
            XCTAssertEqual(data.sortOrder, 1)
            XCTAssertEqual(data.orientation, HomeWidget.WidgetData.Orientation.horizontal)
        } else {
            XCTFail("Wrong widget type")
        }
    }

    // MARK: - HomeWidget Tests

    func testHomeWidgetFallibleInitializer() {
        // Test successful initialization for each widget type
        var widget: HomeWidget?

        // Alert banners
        widget = HomeWidget(
            id: 1,
            type: "alertbanners",
            description: "Alert Banners",
            userState: "any",
            sortOrder: 1,
            orientation: "horizontal"
        )
        XCTAssertNotNil(widget)
        if case .alertBanners = widget! {
            // Success
        } else {
            XCTFail("Wrong widget type")
        }

        // Banners
        widget = HomeWidget(
            id: 2,
            type: "banners",
            description: "Banners",
            userState: "authenticated",
            sortOrder: 2,
            orientation: "vertical"
        )
        XCTAssertNotNil(widget)
        if case .banners = widget! {
            // Success
        } else {
            XCTFail("Wrong widget type")
        }

        // Carousel Events
        widget = HomeWidget(
            id: 3,
            type: "carouselevents",
            description: "Carousel Events",
            userState: "anonymous",
            sortOrder: 3,
            orientation: nil
        )
        XCTAssertNotNil(widget)
        if case .carouselEvents = widget! {
            // Success
        } else {
            XCTFail("Wrong widget type")
        }

        // Invalid type
        widget = HomeWidget(
            id: 999,
            type: "invalidType",
            description: "Invalid",
            userState: "any",
            sortOrder: 999,
            orientation: "horizontal"
        )
        XCTAssertNil(widget)
    }

    func testHomeWidgetDataInitialization() {
        // Test with valid orientation
        let widgetData1 = HomeWidget.WidgetData(
            id: 1,
            type: "banners",
            description: "Banners Widget",
            userState: "horizontal",
            sortOrder: 1,
            orientation: "horizontal"
        )

        XCTAssertEqual(widgetData1.id, 1)
        XCTAssertEqual(widgetData1.type, "banners")
        XCTAssertEqual(widgetData1.description, "Banners Widget")
        XCTAssertEqual(widgetData1.userState, HomeWidget.WidgetData.UserState.any)  // Default is "any" when userState is not valid
        XCTAssertEqual(widgetData1.sortOrder, 1)
        XCTAssertEqual(widgetData1.orientation, HomeWidget.WidgetData.Orientation.horizontal)

        // Test with nil orientation
        let widgetData2 = HomeWidget.WidgetData(
            id: 2,
            type: "stories",
            description: "Stories Widget",
            userState: "authenticated",
            sortOrder: 2,
            orientation: nil
        )

        XCTAssertEqual(widgetData2.id, 2)
        XCTAssertEqual(widgetData2.type, "stories")
        XCTAssertEqual(widgetData2.description, "Stories Widget")
        XCTAssertEqual(widgetData2.userState, HomeWidget.WidgetData.UserState.authenticated)
        XCTAssertEqual(widgetData2.sortOrder, 2)
        XCTAssertNil(widgetData2.orientation)

        // Test with invalid orientation
        let widgetData3 = HomeWidget.WidgetData(
            id: 3,
            type: "betSwipe",
            description: "BetSwipe Widget",
            userState: "anonymous",
            sortOrder: 3,
            orientation: "diagonal"  // Invalid orientation
        )

        XCTAssertEqual(widgetData3.id, 3)
        XCTAssertEqual(widgetData3.type, "betSwipe")
        XCTAssertEqual(widgetData3.description, "BetSwipe Widget")
        XCTAssertEqual(widgetData3.userState, HomeWidget.WidgetData.UserState.anonymous)
        XCTAssertEqual(widgetData3.sortOrder, 3)
        XCTAssertNil(widgetData3.orientation)  // Should be nil for invalid orientation
    }

    func testHomeWidgetConvenienceAccessors() {
        // Given
        let widgetData = HomeWidget.WidgetData(
            id: 5,
            type: "highlightedEvents",
            description: "Highlighted Events Widget",
            userState: "any",
            sortOrder: 5,
            orientation: "vertical"
        )

        let widget = HomeWidget.highlightedEvents(widgetData)

        // When/Then - Test all convenience accessors
        XCTAssertEqual(widget.id, 5)
        XCTAssertEqual(widget.type, "highlightedEvents")
        XCTAssertEqual(widget.description, "Highlighted Events Widget")
        XCTAssertEqual(widget.userType, HomeWidget.WidgetData.UserState.any)
        XCTAssertEqual(widget.sortOrder, 5)
        XCTAssertEqual(widget.orientation, HomeWidget.WidgetData.Orientation.vertical)

        // Verify that widgetData accessor returns the associated value
        XCTAssertEqual(widget.widgetData.id, 5)
        XCTAssertEqual(widget.widgetData.type, "highlightedEvents")
        XCTAssertEqual(widget.widgetData.description, "Highlighted Events Widget")
        XCTAssertEqual(widget.widgetData.userState, HomeWidget.WidgetData.UserState.any)
        XCTAssertEqual(widget.widgetData.sortOrder, 5)
        XCTAssertEqual(widget.widgetData.orientation, HomeWidget.WidgetData.Orientation.vertical)
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/Helpers/auth_helper.py
````python
#!/usr/bin/env python3
# auth_helper.py
# Helper script to obtain and manage authentication tokens for integration tests

import json
import os
import requests
import time
from pathlib import Path

# Constants
API_BASE_URL = "https://api.gomademo.com"
API_KEY = "i4iStOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSvqPNhi"
DEVICE_UUID = "68de20be-0e53-3cac-a822-ad0414f13502"
DEVICE_TYPE = "ios"

# Path to store the authentication token
SCRIPT_DIR = Path(__file__).parent.absolute()
AUTH_FILE_PATH = SCRIPT_DIR / "auth_token.json"

def get_auth_token(force_refresh=False):
    """
    Get authentication token, either from cached file or by making a new request.
    
    Args:
        force_refresh (bool): If True, always get a new token regardless of expiration
        
    Returns:
        str: The authentication token
    """
    # Check if we have a cached token that's still valid
    if not force_refresh and os.path.exists(AUTH_FILE_PATH):
        try:
            with open(AUTH_FILE_PATH, 'r') as f:
                auth_data = json.load(f)
                
            # Check if token is still valid (with 5 minute buffer)
            if auth_data.get('expires_at', 0) > time.time() + 300:
                print(f"Using cached token (expires at {time.ctime(auth_data['expires_at'])})")
                return auth_data['token']
            else:
                print("Cached token has expired, requesting new token")
        except Exception as e:
            print(f"Error reading cached token: {e}")
    
    # Request a new token
    return request_new_token()

def request_new_token():
    """
    Request a new authentication token from the API
    
    Returns:
        str: The new authentication token
    """
    url = f"{API_BASE_URL}/api/auth/v1"
    headers = {
        "Accept": "application/json",
        "Content-Type": "application/json",
        "x-api-key": API_KEY
    }
    payload = {
        "device_uuid": DEVICE_UUID,
        "device_type": DEVICE_TYPE
    }
    
    try:
        response = requests.post(url, headers=headers, json=payload)
        response.raise_for_status()
        
        auth_data = response.json()
        
        # Save the token to file
        with open(AUTH_FILE_PATH, 'w') as f:
            json.dump(auth_data, f, indent=2)
        
        print(f"New token obtained (expires at {time.ctime(auth_data['expires_at'])})")
        return auth_data['token']
    
    except Exception as e:
        print(f"Error obtaining authentication token: {e}")
        if hasattr(response, 'text'):
            print(f"Response: {response.text}")
        raise

def extract_token_from_response(response_json):
    """
    Extract token from authentication response
    
    Args:
        response_json (dict): The JSON response from the authentication API
        
    Returns:
        str: The authentication token
    """
    return response_json.get('token', '')

if __name__ == "__main__":
    # When run directly, get a new token and print it
    token = get_auth_token(force_refresh=True)
    print(f"Authentication Token: {token}")
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/Helpers/auth_token.json
````json
{
  "token": "7892|RUIcnvoAoIqpTpha5de9MKay6pXm5ykKTAImaqlne1b67648",
  "expires_at": 1741307671,
  "type": "bearer"
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/Helpers/fetch_responses.py
````python
#!/usr/bin/env python3
# fetch_responses.py
# Helper script to fetch and save API responses for integration tests

import json
import os
import requests
from pathlib import Path
import sys

# Add the current directory to the path so we can import auth_helper
sys.path.append(str(Path(__file__).parent.absolute()))
from auth_helper import get_auth_token

# Constants
API_BASE_URL = "https://api.gomademo.com"
API_KEY = "i4iStOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSvqPNhi"

# Path to store the mock responses
SCRIPT_DIR = Path(__file__).parent.absolute()
MOCK_RESPONSES_DIR = SCRIPT_DIR.parent / "MockResponses"

# Endpoint definitions
ENDPOINTS = {
    "HomeTemplate": {
        "path": "/api/home/v1/template",
        "method": "GET",
        "params": {"platform": "ios"}
    },
    "AlertBanner": {
        "path": "/api/promotions/v1/alert-banner",
        "method": "GET",
        "params": {}
    },
    "Banners": {
        "path": "/api/promotions/v1/banners",
        "method": "GET",
        "params": {}
    },
    "SportBanners": {
        "path": "/api/promotions/v1/sport-banners",
        "method": "GET",
        "params": {}
    },
    "BoostedOddsBanners": {
        "path": "/api/promotions/v1/boosted-odds-banners",
        "method": "GET",
        "params": {}
    },
    "HeroCards": {
        "path": "/api/promotions/v1/hero-cards",
        "method": "GET",
        "params": {}
    },
    "Stories": {
        "path": "/api/promotions/v1/stories",
        "method": "GET",
        "params": {}
    },
    "News": {
        "path": "/api/promotions/v1/news",
        "method": "GET",
        "params": {"pageIndex": 0, "pageSize": 10}
    },
    "ProChoices": {
        "path": "/api/promotions/v1/pro-choices",
        "method": "GET",
        "params": {}
    },
    "InitialDump": {
        "path": "/api/initial-dump/v1",
        "method": "GET",
        "params": {"platform": "ios"}
    }
}

def fetch_and_save_response(endpoint_name, endpoint_config):
    """
    Fetch response from the API and save it to a file

    Args:
        endpoint_name (str): Name of the endpoint
        endpoint_config (dict): Configuration for the endpoint
    """
    # Get authentication token
    token = get_auth_token()

    # Prepare request
    url = f"{API_BASE_URL}{endpoint_config['path']}"
    headers = {
        "Accept": "application/json",
        "Authorization": f"Bearer {token}",
        "x-api-key": API_KEY
    }

    # Make request
    try:
        if endpoint_config['method'] == "GET":
            response = requests.get(url, headers=headers, params=endpoint_config['params'])
        else:
            response = requests.post(url, headers=headers, json=endpoint_config['params'])

        response.raise_for_status()

        # Parse response
        response_data = response.json()

        # Create directory if it doesn't exist
        output_dir = MOCK_RESPONSES_DIR / endpoint_name
        os.makedirs(output_dir, exist_ok=True)

        # Save response to file
        output_file = output_dir / "response.json"
        with open(output_file, 'w') as f:
            json.dump(response_data, f, indent=2)

        print(f"✅ Successfully saved {endpoint_name} response to {output_file}")

    except Exception as e:
        print(f"❌ Error fetching {endpoint_name}: {e}")
        if hasattr(response, 'text'):
            print(f"Response: {response.text}")

def fetch_all_responses():
    """
    Fetch and save responses for all endpoints
    """
    print("Fetching responses for all endpoints...")

    for endpoint_name, endpoint_config in ENDPOINTS.items():
        print(f"\nFetching {endpoint_name}...")
        fetch_and_save_response(endpoint_name, endpoint_config)

    print("\nAll responses fetched and saved.")

if __name__ == "__main__":
    fetch_all_responses()
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/Helpers/JSONLoader.swift
````swift
import Foundation
import XCTest

/// Utility for loading JSON files in tests
class JSONLoader {
    
    /// Error types that can occur when loading JSON
    enum JSONLoaderError: Error {
        case fileNotFound(String)
        case invalidJSON(String)
        case decodingFailed(String)
    }
    
    /// The base directory for mock responses
    static let mockResponsesDirectory = "MockResponses"
    
    /// Load a JSON file from the mock responses directory
    /// - Parameters:
    ///   - fileName: The name of the file to load (default: "response.json")
    ///   - subdirectory: The subdirectory within the mock responses directory
    /// - Returns: The loaded JSON data
    static func loadJSON(fileName: String = "response.json", subdirectory: String) throws -> Data {
        // Build the path to the JSON file
        let bundle = Bundle(for: JSONLoader.self)
        
        // First try to find the file in the test bundle
        if let path = bundle.path(forResource: fileName, ofType: nil, inDirectory: "\(mockResponsesDirectory)/\(subdirectory)") {
            return try Data(contentsOf: URL(fileURLWithPath: path))
        }
        
        // If not found in the bundle, try to find it relative to the current file
        let currentFilePath = #file
        let currentDirectoryURL = URL(fileURLWithPath: currentFilePath).deletingLastPathComponent()
        let mockResponsesURL = currentDirectoryURL.appendingPathComponent("../MockResponses/\(subdirectory)/\(fileName)")
        
        do {
            return try Data(contentsOf: mockResponsesURL)
        } catch {
            throw JSONLoaderError.fileNotFound("Could not find JSON file at path: \(mockResponsesURL.path)")
        }
    }
    
    /// Load and decode a JSON file into a Decodable type
    /// - Parameters:
    ///   - fileName: The name of the file to load (default: "response.json")
    ///   - subdirectory: The subdirectory within the mock responses directory
    ///   - type: The type to decode the JSON into
    /// - Returns: The decoded object
    static func decode<T: Decodable>(fileName: String = "response.json", subdirectory: String, as type: T.Type) throws -> T {
        let data = try loadJSON(fileName: fileName, subdirectory: subdirectory)
        
        do {
            let decoder = JSONDecoder()
            decoder.keyDecodingStrategy = .convertFromSnakeCase
            decoder.dateDecodingStrategy = .iso8601
            
            return try decoder.decode(type, from: data)
        } catch {
            throw JSONLoaderError.decodingFailed("Failed to decode JSON as \(String(describing: type)): \(error)")
        }
    }
    
    /// Load a JSON file and convert it to a dictionary
    /// - Parameters:
    ///   - fileName: The name of the file to load (default: "response.json")
    ///   - subdirectory: The subdirectory within the mock responses directory
    /// - Returns: The JSON as a dictionary
    static func loadJSONAsDictionary(fileName: String = "response.json", subdirectory: String) throws -> [String: Any] {
        let data = try loadJSON(fileName: fileName, subdirectory: subdirectory)
        
        do {
            guard let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any] else {
                throw JSONLoaderError.invalidJSON("JSON is not a dictionary")
            }
            return json
        } catch {
            throw JSONLoaderError.invalidJSON("Failed to parse JSON: \(error)")
        }
    }
    
    /// Load a JSON file and convert it to an array
    /// - Parameters:
    ///   - fileName: The name of the file to load (default: "response.json")
    ///   - subdirectory: The subdirectory within the mock responses directory
    /// - Returns: The JSON as an array
    static func loadJSONAsArray(fileName: String = "response.json", subdirectory: String) throws -> [[String: Any]] {
        let data = try loadJSON(fileName: fileName, subdirectory: subdirectory)
        
        do {
            guard let json = try JSONSerialization.jsonObject(with: data, options: []) as? [[String: Any]] else {
                throw JSONLoaderError.invalidJSON("JSON is not an array of dictionaries")
            }
            return json
        } catch {
            throw JSONLoaderError.invalidJSON("Failed to parse JSON: \(error)")
        }
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/Helpers/MockURLProtocol.swift
````swift
import Foundation

/// A URLProtocol subclass that intercepts network requests and returns mock responses
class MockURLProtocol: URLProtocol {
    
    /// Dictionary mapping URL strings to mock response data
    static var mockResponses: [String: (data: Data, statusCode: Int, headers: [String: String])] = [:]
    
    /// Dictionary mapping URL patterns (regex) to mock response data
    static var mockResponsePatterns: [(pattern: NSRegularExpression, handler: (URLRequest) -> (data: Data, statusCode: Int, headers: [String: String])?)] = []
    
    /// Dictionary to track requests that have been made
    static var requestsMap: [String: Int] = [:]
    
    /// Dictionary to store requests by URL
    static var requestsByURL: [String: [URLRequest]] = [:]
    
    /// Reset all mock responses and request tracking
    static func reset() {
        mockResponses = [:]
        mockResponsePatterns = []
        requestsMap = [:]
        requestsByURL = [:]
    }
    
    /// Returns all requests made to a specific endpoint
    /// - Parameter endpoint: The endpoint path to check for (e.g., "/api/promotions/v1/home-template")
    /// - Returns: An array of URLRequests made to the endpoint
    static func requestsForEndpoint(_ endpoint: String) -> [URLRequest] {
        let requests = requestsByURL.flatMap { (key, requests) -> [URLRequest] in
            if key.contains(endpoint) {
                return requests
            }
            return []
        }
        return requests
    }
    
    /// Register a mock response for a specific URL
    /// - Parameters:
    ///   - url: The URL to mock
    ///   - data: The response data
    ///   - statusCode: The HTTP status code (default: 200)
    ///   - headers: The HTTP headers (default: empty)
    static func registerMockResponse(for url: URL, 
                                    data: Data, 
                                    statusCode: Int = 200, 
                                    headers: [String: String] = [:]) {
        mockResponses[url.absoluteString] = (data, statusCode, headers)
    }
    
    /// Register a mock response for a URL pattern (regex)
    /// - Parameters:
    ///   - pattern: The regex pattern to match URLs
    ///   - handler: A closure that returns the mock response for a matching request
    static func registerMockResponsePattern(pattern: String, 
                                           handler: @escaping (URLRequest) -> (data: Data, statusCode: Int, headers: [String: String])?) {
        do {
            let regex = try NSRegularExpression(pattern: pattern, options: [])
            mockResponsePatterns.append((regex, handler))
        } catch {
            print("Error creating regex for pattern \(pattern): \(error)")
        }
    }
    
    /// Register a mock response for a specific endpoint in the Goma API
    /// - Parameters:
    ///   - endpoint: The endpoint path (e.g., "/api/promotions/v1/home-template")
    ///   - subdirectory: The subdirectory in the mock responses directory
    ///   - fileName: The name of the JSON file (default: "response.json")
    ///   - statusCode: The HTTP status code (default: 200)
    ///   - headers: The HTTP headers (default: empty)
    static func registerMockResponseForGomaEndpoint(endpoint: String,
                                                  subdirectory: String,
                                                  fileName: String = "response.json",
                                                  statusCode: Int = 200,
                                                  headers: [String: String] = [:]) throws {
        let data = try JSONLoader.loadJSON(fileName: fileName, subdirectory: subdirectory)
        
        // Create a pattern that matches the endpoint with any query parameters
        let pattern = "https://api\\.gomademo\\.com\(endpoint)(\\?.*)?$"
        
        registerMockResponsePattern(pattern: pattern) { _ in
            return (data, statusCode, headers)
        }
    }
    
    /// Check if this protocol can handle the given request
    override class func canInit(with request: URLRequest) -> Bool {
        return true
    }
    
    /// Canonicalize the request (required by URLProtocol)
    override class func canonicalRequest(for request: URLRequest) -> URLRequest {
        return request
    }
    
    /// Start loading the request
    override func startLoading() {
        guard let url = request.url?.absoluteString else {
            client?.urlProtocol(self, didFailWithError: NSError(domain: "MockURLProtocol", code: -1, userInfo: [NSLocalizedDescriptionKey: "URL is nil"]))
            return
        }
        
        // Track the request
        MockURLProtocol.requestsMap[url] = (MockURLProtocol.requestsMap[url] ?? 0) + 1
        
        // Store the request by URL
        var requests = MockURLProtocol.requestsByURL[url] ?? []
        requests.append(request)
        MockURLProtocol.requestsByURL[url] = requests
        
        // Check for exact URL match
        if let mockResponse = MockURLProtocol.mockResponses[url] {
            sendResponse(mockResponse.data, statusCode: mockResponse.statusCode, headers: mockResponse.headers)
            return
        }
        
        // Check for pattern matches
        for (pattern, handler) in MockURLProtocol.mockResponsePatterns {
            let urlRange = NSRange(location: 0, length: url.count)
            if pattern.firstMatch(in: url, options: [], range: urlRange) != nil {
                if let mockResponse = handler(request) {
                    sendResponse(mockResponse.data, statusCode: mockResponse.statusCode, headers: mockResponse.headers)
                    return
                }
            }
        }
        
        // No mock found, return a 404
        let errorData = "No mock response found for URL: \(url)".data(using: .utf8)!
        sendResponse(errorData, statusCode: 404, headers: ["Content-Type": "text/plain"])
    }
    
    /// Stop loading the request (required by URLProtocol)
    override func stopLoading() {
        // Nothing to do
    }
    
    /// Send a mock response to the client
    /// - Parameters:
    ///   - data: The response data
    ///   - statusCode: The HTTP status code
    ///   - headers: The HTTP headers
    private func sendResponse(_ data: Data, statusCode: Int, headers: [String: String]) {
        guard let url = request.url else { return }
        
        // Create a response
        var responseHeaders = headers
        responseHeaders["Content-Length"] = "\(data.count)"
        
        let response = HTTPURLResponse(url: url, 
                                      statusCode: statusCode, 
                                      httpVersion: "HTTP/1.1", 
                                      headerFields: responseHeaders)!
        
        // Send the response to the client
        client?.urlProtocol(self, didReceive: response, cacheStoragePolicy: .notAllowed)
        client?.urlProtocol(self, didLoad: data)
        client?.urlProtocolDidFinishLoading(self)
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/Helpers/ModelComparison.swift
````swift
import Foundation
import XCTest

/// Helper functions for comparing models in tests
struct ModelComparison {
    
    /// Compare two URLs for equality, handling nil values
    /// - Parameters:
    ///   - url1: The first URL
    ///   - url2: The second URL
    ///   - file: The file where the assertion is made
    ///   - line: The line where the assertion is made
    /// - Returns: True if the URLs are equal
    static func compareURLs(_ url1: URL?, _ url2: URL?, file: StaticString = #file, line: UInt = #line) -> Bool {
        switch (url1, url2) {
        case (nil, nil):
            return true
        case (let url1?, let url2?):
            let equal = url1.absoluteString == url2.absoluteString
            if !equal {
                XCTFail("URLs don't match: \(url1.absoluteString) vs \(url2.absoluteString)", file: file, line: line)
            }
            return equal
        default:
            XCTFail("One URL is nil and the other is not", file: file, line: line)
            return false
        }
    }
    
    /// Compare two dates for equality, handling nil values
    /// - Parameters:
    ///   - date1: The first date
    ///   - date2: The second date
    ///   - file: The file where the assertion is made
    ///   - line: The line where the assertion is made
    /// - Returns: True if the dates are equal
    static func compareDates(_ date1: Date?, _ date2: Date?, file: StaticString = #file, line: UInt = #line) -> Bool {
        switch (date1, date2) {
        case (nil, nil):
            return true
        case (let date1?, let date2?):
            // Compare dates with a small tolerance for floating point precision
            let timeInterval1 = date1.timeIntervalSince1970
            let timeInterval2 = date2.timeIntervalSince1970
            let equal = abs(timeInterval1 - timeInterval2) < 0.001
            if !equal {
                XCTFail("Dates don't match: \(date1) vs \(date2)", file: file, line: line)
            }
            return equal
        default:
            XCTFail("One date is nil and the other is not", file: file, line: line)
            return false
        }
    }
    
    /// Compare two arrays for equality
    /// - Parameters:
    ///   - array1: The first array
    ///   - array2: The second array
    ///   - compareElement: A closure that compares two elements
    ///   - file: The file where the assertion is made
    ///   - line: The line where the assertion is made
    /// - Returns: True if the arrays are equal
    static func compareArrays<T, U>(_ array1: [T], _ array2: [U], compareElement: (T, U) -> Bool, file: StaticString = #file, line: UInt = #line) -> Bool {
        guard array1.count == array2.count else {
            XCTFail("Array counts don't match: \(array1.count) vs \(array2.count)", file: file, line: line)
            return false
        }
        
        for i in 0..<array1.count {
            if !compareElement(array1[i], array2[i]) {
                XCTFail("Array elements at index \(i) don't match", file: file, line: line)
                return false
            }
        }
        
        return true
    }
    
    /// Compare two dictionaries for equality
    /// - Parameters:
    ///   - dict1: The first dictionary
    ///   - dict2: The second dictionary
    ///   - compareValue: A closure that compares two values
    ///   - file: The file where the assertion is made
    ///   - line: The line where the assertion is made
    /// - Returns: True if the dictionaries are equal
    static func compareDictionaries<K: Hashable, V1, V2>(_ dict1: [K: V1], _ dict2: [K: V2], compareValue: (V1, V2) -> Bool, file: StaticString = #file, line: UInt = #line) -> Bool {
        guard dict1.count == dict2.count else {
            XCTFail("Dictionary counts don't match: \(dict1.count) vs \(dict2.count)", file: file, line: line)
            return false
        }
        
        for (key, value1) in dict1 {
            guard let value2 = dict2[key] else {
                XCTFail("Key \(key) exists in first dictionary but not in second", file: file, line: line)
                return false
            }
            
            if !compareValue(value1, value2) {
                XCTFail("Dictionary values for key \(key) don't match", file: file, line: line)
                return false
            }
        }
        
        return true
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/Helpers/TestConfiguration.swift
````swift
import Foundation

/// Configuration for integration tests
struct TestConfiguration {

    /// Endpoint paths for the Goma API
    struct EndpointPaths {
        static let homeTemplate = "/api/home/v1/template"
        static let alertBanner = "/api/promotions/v1/alert-banner"
        static let banners = "/api/promotions/v1/banners"
        static let sportBanners = "/api/promotions/v1/sport-banners"
        static let boostedOddsBanners = "/api/promotions/v1/boosted-odds-banners"
        static let heroCards = "/api/promotions/v1/hero-cards"
        static let stories = "/api/promotions/v1/stories"
        static let news = "/api/promotions/v1/news"
        static let proChoices = "/api/promotions/v1/pro-choices"
        static let initialDump = "/api/initial-dump/v1"
    }

    /// Subdirectory names for mock responses
    struct MockResponseDirectories {
        static let homeTemplate = "HomeTemplate"
        static let alertBanner = "AlertBanner"
        static let banners = "Banners"
        static let sportBanners = "SportBanners"
        static let boostedOddsBanners = "BoostedOddsBanners"
        static let heroCards = "HeroCards"
        static let stories = "Stories"
        static let news = "News"
        static let proChoices = "ProChoices"
        static let initialDump = "InitialDump"
    }

    /// API configuration
    struct API {
        static let baseURL = "https://api.gomademo.com"
        static let apiKey = "i4iStOcZWBFbrmWvwaccKpdVhyRpRB6uZGE9akT6IFMpSwIa0Ghl4lqsFSvqPNhi"
        static let deviceUUID = "68de20be-0e53-3cac-a822-ad0414f13502"
        static let deviceType = "ios"
    }

    /// Test authentication token
    /// This is a placeholder and should be replaced with a real token in tests
    static let authToken = "5944|V61S5ZW8Cn98tup13y3TWaOT4yHdclRwDIPrNrPib4ae0087"
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/MockResponses/AlertBanner/response.json
````json
{
  "id": 4,
  "client_id": 2,
  "title": "Alert Banner 1",
  "subtitle": "subtitle information",
  "cta_text": "Button 123",
  "cta_url": "https://betsson.fr",
  "platform": "all",
  "status": "published",
  "start_date": "2025-02-26 12:39:00",
  "end_date": "2026-02-26 12:39:00",
  "user_type": "all",
  "created_at": "2025-02-26T12:39:57.000000Z",
  "updated_at": "2025-02-26T13:28:03.000000Z"
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/MockResponses/Banners/response.json
````json
[
  {
    "id": 4,
    "client_id": 2,
    "title": "Banner 1",
    "subtitle": "subtitle",
    "cta_text": null,
    "cta_url": null,
    "platform": "all",
    "status": "published",
    "start_date": "2025-02-26 14:03:00",
    "end_date": "2026-02-26 14:03:00",
    "user_type": "all",
    "created_at": "2025-02-26T14:03:33.000000Z",
    "updated_at": "2025-02-26T14:03:33.000000Z",
    "image_url": "https://cms.gomademo.com/storage/32/01JN193T46MEGK8JP4AZEP93EY.jpg"
  }
]
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/MockResponses/BoostedOddsBanners/response.json
````json
[
  {
    "id": 4,
    "name": null,
    "title": null,
    "sport_event_id": "4067992.1",
    "sport_event_market_id": "67701178.1",
    "sport_event_boosted_market_id": "67701178.1",
    "cta_url": null
  }
]
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/MockResponses/HeroCards/response.json
````json
[
  {
    "id": 3,
    "sport_event_id": "4067574.1",
    "sport_event_market_ids": [
      "67677928.1",
      "67677925.1",
      "67680507.1"
    ],
    "image_url": "https://cms.gomademo.com/storage/34/01JN1C45A72Y6Q3DN2AQ43WB6Q.png"
  }
]
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/MockResponses/HomeTemplate/response.json
````json
{
  "id": 4,
  "name": "Default Layout",
  "widgets": [
    {
      "id": 1,
      "name": "alertBanners",
      "description": "Display important alerts and notifications to users",
      "web_namespace": "UserAlertBox",
      "ios_namespace": "UserProfile",
      "android_namespace": "UserProfile",
      "user_type": "authenticated",
      "sort_order": 1,
      "orientation": null
    },
    {
      "id": 2,
      "name": "banners",
      "description": "Horizontal scrollable strip of promotional banners",
      "web_namespace": "PromotionBanners",
      "ios_namespace": "PromotionBanners",
      "android_namespace": "PromotionBanners",
      "user_type": "all",
      "sort_order": 2,
      "orientation": null
    },
    {
      "id": 3,
      "name": "carouselEvents",
      "description": "Swipeable match cards for quick access",
      "web_namespace": "MatchBanners",
      "ios_namespace": "MatchBanners",
      "android_namespace": "MatchBanners",
      "user_type": "all",
      "sort_order": 3,
      "orientation": null
    },
    {
      "id": 4,
      "name": "stories",
      "description": "Instagram-style promotional stories",
      "web_namespace": "PromotionStories",
      "ios_namespace": "PromotionStories",
      "android_namespace": "PromotionStories",
      "user_type": "all",
      "sort_order": 4,
      "orientation": null
    },
    {
      "id": 5,
      "name": "heroCardEvents",
      "description": "Large featured promotional banner",
      "web_namespace": "HeroBanners",
      "ios_namespace": "HeroBanners",
      "android_namespace": "HeroBanners",
      "user_type": "all",
      "sort_order": 5,
      "orientation": null
    },
    {
      "id": 6,
      "name": "highlightedLiveEvents",
      "description": "Featured currently live matches",
      "web_namespace": "LiveGamesHome",
      "ios_namespace": "LiveGamesHome",
      "android_namespace": "LiveGamesHome",
      "user_type": "all",
      "sort_order": 6,
      "orientation": null
    },
    {
      "id": 7,
      "name": "betSwipe",
      "description": "Call-to-action for custom bet creation (Bet Swipe).",
      "web_namespace": "MakeYourOwnBet",
      "ios_namespace": "MakeYourOwnBet",
      "android_namespace": "MakeYourOwnBet",
      "user_type": "all",
      "sort_order": 7,
      "orientation": null
    },
    {
      "id": 8,
      "name": "highlightedEvents",
      "description": "Highlighted match cards",
      "web_namespace": "HighlightsImageCards",
      "ios_namespace": "HighlightsImageCards",
      "android_namespace": "HighlightsImageCards",
      "user_type": "all",
      "sort_order": 8,
      "orientation": "horizontal"
    },
    {
      "id": 9,
      "name": "boostedEvents",
      "description": "Matches with enhanced odds",
      "web_namespace": "HighlightsBoostedCards",
      "ios_namespace": "HighlightsBoostedCards",
      "android_namespace": "HighlightsBoostedCards",
      "user_type": "all",
      "sort_order": 9,
      "orientation": "horizontal"
    },
    {
      "id": 10,
      "name": "proChoices",
      "description": "Professional betting picks and choices",
      "web_namespace": "HighlightsProChoices",
      "ios_namespace": "HighlightsProChoices",
      "android_namespace": "HighlightsProChoices",
      "user_type": "all",
      "sort_order": 10,
      "orientation": "horizontal"
    },
    {
      "id": 11,
      "name": "topCompetitions",
      "description": "Quick access to popular competitions",
      "web_namespace": "TopCompetitionsMobile",
      "ios_namespace": "TopCompetitionsMobile",
      "android_namespace": "TopCompetitionsMobile",
      "user_type": "all",
      "sort_order": 11,
      "orientation": null
    },
    {
      "id": 12,
      "name": "suggestedBets",
      "description": "Curated betting suggestions",
      "web_namespace": "SuggestedBets",
      "ios_namespace": "SuggestedBets",
      "android_namespace": "SuggestedBets",
      "user_type": "all",
      "sort_order": 12,
      "orientation": null
    },
    {
      "id": 13,
      "name": "popularEvents",
      "description": "Popular events list",
      "web_namespace": "Games",
      "ios_namespace": "Games",
      "android_namespace": "Games",
      "user_type": "all",
      "sort_order": 13,
      "orientation": null
    }
  ]
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/MockResponses/InitialDump/response.json
````json
{
  "home_template": {
    "id": 4,
    "name": "Default Layout",
    "widgets": [
      {
        "id": 1,
        "name": "alertBanners",
        "description": "Display important alerts and notifications to users",
        "web_namespace": "UserAlertBox",
        "ios_namespace": "UserProfile",
        "android_namespace": "UserProfile",
        "user_type": "authenticated",
        "sort_order": 1,
        "orientation": null
      },
      {
        "id": 2,
        "name": "banners",
        "description": "Horizontal scrollable strip of promotional banners",
        "web_namespace": "PromotionBanners",
        "ios_namespace": "PromotionBanners",
        "android_namespace": "PromotionBanners",
        "user_type": "all",
        "sort_order": 2,
        "orientation": null
      },
      {
        "id": 3,
        "name": "carouselEvents",
        "description": "Swipeable match cards for quick access",
        "web_namespace": "MatchBanners",
        "ios_namespace": "MatchBanners",
        "android_namespace": "MatchBanners",
        "user_type": "all",
        "sort_order": 3,
        "orientation": null
      },
      {
        "id": 4,
        "name": "stories",
        "description": "Instagram-style promotional stories",
        "web_namespace": "PromotionStories",
        "ios_namespace": "PromotionStories",
        "android_namespace": "PromotionStories",
        "user_type": "all",
        "sort_order": 4,
        "orientation": null
      },
      {
        "id": 5,
        "name": "heroCardEvents",
        "description": "Large featured promotional banner",
        "web_namespace": "HeroBanners",
        "ios_namespace": "HeroBanners",
        "android_namespace": "HeroBanners",
        "user_type": "all",
        "sort_order": 5,
        "orientation": null
      },
      {
        "id": 6,
        "name": "highlightedLiveEvents",
        "description": "Featured currently live matches",
        "web_namespace": "LiveGamesHome",
        "ios_namespace": "LiveGamesHome",
        "android_namespace": "LiveGamesHome",
        "user_type": "all",
        "sort_order": 6,
        "orientation": null
      },
      {
        "id": 7,
        "name": "betSwipe",
        "description": "Call-to-action for custom bet creation (Bet Swipe).",
        "web_namespace": "MakeYourOwnBet",
        "ios_namespace": "MakeYourOwnBet",
        "android_namespace": "MakeYourOwnBet",
        "user_type": "all",
        "sort_order": 7,
        "orientation": null
      },
      {
        "id": 8,
        "name": "highlightedEvents",
        "description": "Highlighted match cards",
        "web_namespace": "HighlightsImageCards",
        "ios_namespace": "HighlightsImageCards",
        "android_namespace": "HighlightsImageCards",
        "user_type": "all",
        "sort_order": 8,
        "orientation": "horizontal"
      },
      {
        "id": 9,
        "name": "boostedEvents",
        "description": "Matches with enhanced odds",
        "web_namespace": "HighlightsBoostedCards",
        "ios_namespace": "HighlightsBoostedCards",
        "android_namespace": "HighlightsBoostedCards",
        "user_type": "all",
        "sort_order": 9,
        "orientation": "horizontal"
      },
      {
        "id": 10,
        "name": "proChoices",
        "description": "Professional betting picks and choices",
        "web_namespace": "HighlightsProChoices",
        "ios_namespace": "HighlightsProChoices",
        "android_namespace": "HighlightsProChoices",
        "user_type": "all",
        "sort_order": 10,
        "orientation": "horizontal"
      },
      {
        "id": 11,
        "name": "topCompetitions",
        "description": "Quick access to popular competitions",
        "web_namespace": "TopCompetitionsMobile",
        "ios_namespace": "TopCompetitionsMobile",
        "android_namespace": "TopCompetitionsMobile",
        "user_type": "all",
        "sort_order": 11,
        "orientation": null
      },
      {
        "id": 12,
        "name": "suggestedBets",
        "description": "Curated betting suggestions",
        "web_namespace": "SuggestedBets",
        "ios_namespace": "SuggestedBets",
        "android_namespace": "SuggestedBets",
        "user_type": "all",
        "sort_order": 12,
        "orientation": null
      },
      {
        "id": 13,
        "name": "popularEvents",
        "description": "Popular events list",
        "web_namespace": "Games",
        "ios_namespace": "Games",
        "android_namespace": "Games",
        "user_type": "all",
        "sort_order": 13,
        "orientation": null
      }
    ]
  },
  "promotions": {
    "alert_banner": {
      "id": 4,
      "client_id": 2,
      "title": "Alert Banner 1",
      "subtitle": "subtitle information",
      "cta_text": "Button 123",
      "cta_url": "https://betsson.fr",
      "platform": "all",
      "status": "published",
      "start_date": "2025-02-26 12:39:00",
      "end_date": "2026-02-26 12:39:00",
      "user_type": "all",
      "created_at": "2025-02-26T12:39:57.000000Z",
      "updated_at": "2025-02-26T13:28:03.000000Z"
    },
    "banners": [
      {
        "id": 4,
        "client_id": 2,
        "title": "Banner 1",
        "subtitle": "subtitle",
        "cta_text": null,
        "cta_url": null,
        "platform": "all",
        "status": "published",
        "start_date": "2025-02-26 14:03:00",
        "end_date": "2026-02-26 14:03:00",
        "user_type": "all",
        "created_at": "2025-02-26T14:03:33.000000Z",
        "updated_at": "2025-02-26T14:03:33.000000Z",
        "image_url": "https://cms.gomademo.com/storage/32/01JN193T46MEGK8JP4AZEP93EY.jpg"
      }
    ],
    "sport_banners": [
      {
        "id": 6,
        "sport_event_id": "4067574.1",
        "sport_event_market_id": "67677928.1",
        "cta_url": null,
        "image_url": "https://cms.gomademo.com/storage/33/01JN1BK4W59DSA5NTCDN7PZ5Z3.png"
      }
    ],
    "highlighted_events": [
      {
        "sport_event_id": "4067574.1",
        "sport_event_market_id": "67677928.1",
        "image_url": "https://cms.gomademo.com/storage/41/01JN1JGAA9DEVP2STJQ95XFKSJ.png"
      },
      {
        "sport_event_id": "4057834.1",
        "sport_event_market_id": "66859225.1",
        "image_url": "https://cms.gomademo.com/storage/44/01JN45TPDSQKY5N1HRSV6AZBND.png"
      },
      {
        "sport_event_id": "4068041.1",
        "sport_event_market_id": "67713812.1",
        "image_url": "https://cms.gomademo.com/storage/45/01JN4643VVNJYR6Y4Q906NBC3H.png"
      }
    ],
    "pro_choices": [
      {
        "sport_event_id": "4067574.1",
        "sport_event_market_id": "67677928.1",
        "image_url": "https://cms.gomademo.com/storage/43/01JN44GTRM13CHZJ63M573RS4W.png"
      },
      {
        "sport_event_id": "4057834.1",
        "sport_event_market_id": "66935497.1",
        "image_url": "https://cms.gomademo.com/storage/46/01JN47B1K46WNNXR01NR65T9AC.png"
      }
    ],
    "boosted_odds_banners": [
      {
        "id": 4,
        "name": null,
        "title": null,
        "sport_event_id": "4067992.1",
        "sport_event_market_id": "67701178.1",
        "sport_event_boosted_market_id": "67701178.1",
        "cta_url": null
      }
    ],
    "hero_cards": [
      {
        "id": 3,
        "sport_event_id": "4067574.1",
        "sport_event_market_ids": [
          "67677928.1",
          "67677925.1",
          "67680507.1"
        ],
        "image_url": "https://cms.gomademo.com/storage/34/01JN1C45A72Y6Q3DN2AQ43WB6Q.png"
      }
    ],
    "stories": [
      {
        "id": 5,
        "client_id": 2,
        "title": "Story 1",
        "media_type": "image",
        "cta_text": null,
        "cta_url": null,
        "platform": "all",
        "status": "published",
        "start_date": "2025-02-26 16:02:00",
        "end_date": "2026-02-26 16:02:00",
        "user_type": "all",
        "created_at": "2025-02-26T16:02:53.000000Z",
        "updated_at": "2025-02-26T16:02:53.000000Z",
        "media_url": "https://cms.gomademo.com/storage/36/01JN1FYATNGDZC3A5SVX7BPQ2B.jpg",
        "icon_url": "https://cms.gomademo.com/storage/35/01JN1FYARZZ76AJ65K0JR33WND.png"
      },
      {
        "id": 6,
        "client_id": 2,
        "title": "Story 2",
        "media_type": "image",
        "cta_text": null,
        "cta_url": null,
        "platform": "all",
        "status": "published",
        "start_date": "2025-02-26 16:04:00",
        "end_date": "2026-02-26 16:04:00",
        "user_type": "all",
        "created_at": "2025-02-26T16:04:27.000000Z",
        "updated_at": "2025-02-26T16:04:27.000000Z",
        "media_url": "https://cms.gomademo.com/storage/38/01JN1G16MDG7E45WR863HDVYA8.png",
        "icon_url": "https://cms.gomademo.com/storage/37/01JN1G16KDQ4115KZ0HQ69H186.png"
      },
      {
        "id": 7,
        "client_id": 2,
        "title": "Story 3",
        "media_type": "video",
        "cta_text": null,
        "cta_url": "https://betsson.fr",
        "platform": "all",
        "status": "published",
        "start_date": "2025-02-26 16:08:00",
        "end_date": "2026-02-26 16:08:00",
        "user_type": "all",
        "created_at": "2025-02-26T16:11:10.000000Z",
        "updated_at": "2025-02-26T16:11:10.000000Z",
        "media_url": "https://cms.gomademo.com/storage/40/01JN1GDFZ8BWV9H58FH0P7CT5Q.mp4",
        "icon_url": "https://cms.gomademo.com/storage/39/01JN1GDFY2X828DTFX21M2YAFY.png"
      }
    ],
    "popular_events": [],
    "news": []
  },
  "competitions": {
    "featured": [
      "55807.1",
      "55834.1",
      "55806.1",
      "55852.1"
    ]
  },
  "cms": {
    "pdfs": []
  }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/MockResponses/News/response.json
````json
[]
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/MockResponses/ProChoices/response.json
````json
[
  {
    "sport_event_id": "4067574.1",
    "sport_event_market_id": "67677928.1",
    "image_url": "https://cms.gomademo.com/storage/43/01JN44GTRM13CHZJ63M573RS4W.png"
  },
  {
    "sport_event_id": "4057834.1",
    "sport_event_market_id": "66935497.1",
    "image_url": "https://cms.gomademo.com/storage/46/01JN47B1K46WNNXR01NR65T9AC.png"
  }
]
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/MockResponses/SportBanners/response.json
````json
[
  {
    "id": 6,
    "sport_event_id": "4067574.1",
    "sport_event_market_id": "67677928.1",
    "cta_url": null,
    "image_url": "https://cms.gomademo.com/storage/33/01JN1BK4W59DSA5NTCDN7PZ5Z3.png"
  }
]
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/MockResponses/Stories/response.json
````json
[
  {
    "id": 5,
    "client_id": 2,
    "title": "Story 1",
    "media_type": "image",
    "cta_text": null,
    "cta_url": null,
    "platform": "all",
    "status": "published",
    "start_date": "2025-02-26 16:02:00",
    "end_date": "2026-02-26 16:02:00",
    "user_type": "all",
    "created_at": "2025-02-26T16:02:53.000000Z",
    "updated_at": "2025-02-26T16:02:53.000000Z",
    "media_url": "https://cms.gomademo.com/storage/36/01JN1FYATNGDZC3A5SVX7BPQ2B.jpg",
    "icon_url": "https://cms.gomademo.com/storage/35/01JN1FYARZZ76AJ65K0JR33WND.png"
  },
  {
    "id": 6,
    "client_id": 2,
    "title": "Story 2",
    "media_type": "image",
    "cta_text": null,
    "cta_url": null,
    "platform": "all",
    "status": "published",
    "start_date": "2025-02-26 16:04:00",
    "end_date": "2026-02-26 16:04:00",
    "user_type": "all",
    "created_at": "2025-02-26T16:04:27.000000Z",
    "updated_at": "2025-02-26T16:04:27.000000Z",
    "media_url": "https://cms.gomademo.com/storage/38/01JN1G16MDG7E45WR863HDVYA8.png",
    "icon_url": "https://cms.gomademo.com/storage/37/01JN1G16KDQ4115KZ0HQ69H186.png"
  },
  {
    "id": 7,
    "client_id": 2,
    "title": "Story 3",
    "media_type": "video",
    "cta_text": null,
    "cta_url": "https://betsson.fr",
    "platform": "all",
    "status": "published",
    "start_date": "2025-02-26 16:08:00",
    "end_date": "2026-02-26 16:08:00",
    "user_type": "all",
    "created_at": "2025-02-26T16:11:10.000000Z",
    "updated_at": "2025-02-26T16:11:10.000000Z",
    "media_url": "https://cms.gomademo.com/storage/40/01JN1GDFZ8BWV9H58FH0P7CT5Q.mp4",
    "icon_url": "https://cms.gomademo.com/storage/39/01JN1GDFY2X828DTFX21M2YAFY.png"
  }
]
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/AlertBannerTests.swift
````swift
import XCTest
import Combine
@testable import ServicesProvider

/// Integration tests for the Alert Banner endpoint
class AlertBannerTests: BaseIntegrationTest {
    
    /// Test that GomaPromotionsAPIClient.alertBanner endpoint builds the correct URL with query parameters
    func testAlertBannerEndpointBuildsCorrectURL() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // When
        let request = apiClient.alertBanner()
        
        // Then
        XCTAssertEqual(
            request.url?.absoluteString,
            "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.alertBanner)"
        )
    }
    
    /// Test that GomaPromotionsAPIClient.alertBanner endpoint uses the correct HTTP method (GET)
    func testAlertBannerEndpointUsesCorrectHTTPMethod() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // When
        let request = apiClient.alertBanner()
        
        // Then
        XCTAssertEqual(request.httpMethod, "GET")
    }
    
    /// Test that the JSON response for alertBanner decodes to GomaModels.AlertBannerData
    func testAlertBannerResponseDecodesToInternalModel() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.alertBanner
        )
        
        // When
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let alertBanner = try decoder.decode(GomaModels.AlertBannerData.self, from: jsonData)
        
        // Then
        XCTAssertNotNil(alertBanner)
        XCTAssertNotNil(alertBanner.id)
        XCTAssertNotNil(alertBanner.title)
        XCTAssertNotNil(alertBanner.subtitle)
        XCTAssertNotNil(alertBanner.ctaText)
        XCTAssertNotNil(alertBanner.ctaUrl)
        XCTAssertNotNil(alertBanner.status)
    }
    
    /// Test that GomaModelMapper.alertBanner transforms GomaModels.AlertBannerData to AlertBanner correctly
    func testAlertBannerModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.alertBanner
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModel = try decoder.decode(GomaModels.AlertBannerData.self, from: jsonData)
        
        // When
        let domainModel = GomaModelMapper.alertBanner(fromInternalAlertBanner: internalModel)
        
        // Then
        XCTAssertEqual(domainModel.id, internalModel.id)
        XCTAssertEqual(domainModel.title, internalModel.title)
        XCTAssertEqual(domainModel.subtitle, internalModel.subtitle)
        XCTAssertEqual(domainModel.ctaText, internalModel.ctaText)
        
        // Check URL transformation
        if let ctaUrl = internalModel.ctaUrl {
            XCTAssertEqual(domainModel.ctaUrl?.absoluteString, ctaUrl)
        } else {
            XCTAssertNil(domainModel.ctaUrl)
        }
    }
    
    /// Test that transformation correctly sets isActive based on status field
    func testIsActiveIsCorrectlyMappedFromStatus() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.alertBanner
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModel = try decoder.decode(GomaModels.AlertBannerData.self, from: jsonData)
        
        // When
        let domainModel = GomaModelMapper.alertBanner(fromInternalAlertBanner: internalModel)
        
        // Then
        if internalModel.status == "published" {
            XCTAssertTrue(domainModel.isActive)
        } else {
            XCTAssertFalse(domainModel.isActive)
        }
    }
    
    /// Test URL construction for imageUrl field
    func testURLConstructionForImageUrl() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.alertBanner
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModel = try decoder.decode(GomaModels.AlertBannerData.self, from: jsonData)
        
        // When
        let domainModel = GomaModelMapper.alertBanner(fromInternalAlertBanner: internalModel)
        
        // Then
        if let ctaUrl = internalModel.ctaUrl {
            XCTAssertEqual(domainModel.ctaUrl?.absoluteString, ctaUrl)
        } else {
            XCTAssertNil(domainModel.ctaUrl)
        }
    }
    
    /// Test that GomaManagedContentProvider.getAlertBanner() calls the correct API endpoint
    func testGetAlertBannerCallsCorrectAPIEndpoint() throws {
        // Given
        let expectation = XCTestExpectation(description: "API call made")
        try registerMockAlertBannerResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getAlertBanner()
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { _ in
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        // Then
        wait(for: [expectation], timeout: 1.0)
        XCTAssertTrue(MockURLProtocol.requestsForEndpoint(TestConfiguration.EndpointPaths.alertBanner).count > 0)
    }
    
    /// Test that GomaManagedContentProvider.getAlertBanner() handles successful responses
    func testGetAlertBannerHandlesSuccessfulResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received alert banner")
        try registerMockAlertBannerResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getAlertBanner()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { alertBanner in
                    // Then
                    XCTAssertNotNil(alertBanner)
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test that GomaManagedContentProvider.getAlertBanner() handles error responses
    func testGetAlertBannerHandlesErrorResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received error")
        
        // Register a mock error response
        let errorURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.alertBanner)")!
        MockURLProtocol.registerMockResponse(
            for: errorURL,
            data: "Internal Server Error".data(using: .utf8)!,
            statusCode: 500
        )
        
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getAlertBanner()
            .sink(
                receiveCompletion: { completion in
                    if case .failure(let error) = completion {
                        // Then
                        XCTAssertNotNil(error)
                        expectation.fulfill()
                    }
                },
                receiveValue: { _ in
                    XCTFail("Should not receive a value")
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test that GomaManagedContentProvider.getAlertBanner() handles empty/null responses
    func testGetAlertBannerHandlesEmptyResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received empty response")
        
        // Register a mock empty response
        let emptyURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.alertBanner)")!
        MockURLProtocol.registerMockResponse(
            for: emptyURL,
            data: "{}".data(using: .utf8)!,
            statusCode: 200
        )
        
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getAlertBanner()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        expectation.fulfill()
                    }
                },
                receiveValue: { alertBanner in
                    // Then
                    // If we get a value, it should be a default/empty alert banner
                    XCTAssertEqual(alertBanner.id, 0)
                    XCTAssertEqual(alertBanner.title, "")
                    XCTAssertEqual(alertBanner.subtitle, "")
                    XCTAssertNil(alertBanner.ctaUrl)
                    XCTAssertEqual(alertBanner.ctaText, "")
                    XCTAssertFalse(alertBanner.isActive)
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test the end-to-end flow with mocked API response to final domain model
    func testEndToEndFlowWithMockedAPIResponse() throws {
        // Given
        let expectation = XCTestExpectation(description: "End-to-end flow completed")
        try registerMockAlertBannerResponse()
        let contentProvider = createMockContentProvider()
        
        // Load the expected data for comparison
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.alertBanner
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModel = try decoder.decode(GomaModels.AlertBannerData.self, from: jsonData)
        let expectedDomainModel = GomaModelMapper.alertBanner(fromInternalAlertBanner: internalModel)
        
        // When
        contentProvider.getAlertBanner()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { alertBanner in
                    // Then
                    XCTAssertEqual(alertBanner.id, expectedDomainModel.id)
                    XCTAssertEqual(alertBanner.title, expectedDomainModel.title)
                    XCTAssertEqual(alertBanner.subtitle, expectedDomainModel.subtitle)
                    XCTAssertEqual(alertBanner.ctaText, expectedDomainModel.ctaText)
                    
                    // Compare URLs
                    if let expectedURL = expectedDomainModel.ctaUrl {
                        XCTAssertEqual(alertBanner.ctaUrl?.absoluteString, expectedURL.absoluteString)
                    } else {
                        XCTAssertNil(alertBanner.ctaUrl)
                    }
                    
                    XCTAssertEqual(alertBanner.isActive, expectedDomainModel.isActive)
                    
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/BannersTests.swift
````swift
import XCTest
import Combine
@testable import ServicesProvider

/// Integration tests for the Banners endpoint
class BannersTests: BaseIntegrationTest {
    
    /// Test that GomaPromotionsAPIClient.banners endpoint builds the correct URL with query parameters
    func testBannersEndpointBuildsCorrectURL() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // When
        let request = apiClient.banners()
        
        // Then
        XCTAssertEqual(
            request.url?.absoluteString,
            "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.banners)"
        )
    }
    
    /// Test that GomaPromotionsAPIClient.banners endpoint uses the correct HTTP method (GET)
    func testBannersEndpointUsesCorrectHTTPMethod() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // When
        let request = apiClient.banners()
        
        // Then
        XCTAssertEqual(request.httpMethod, "GET")
    }
    
    /// Test that the JSON response for banners decodes to [GomaModels.BannerData]
    func testBannersResponseDecodesToInternalModel() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.banners
        )
        
        // When
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let banners = try decoder.decode([GomaModels.BannerData].self, from: jsonData)
        
        // Then
        XCTAssertNotNil(banners)
        XCTAssertFalse(banners.isEmpty, "Banners array should not be empty")
        
        // Verify first banner has all required properties
        if let firstBanner = banners.first {
            XCTAssertNotNil(firstBanner.id)
            XCTAssertNotNil(firstBanner.title)
            XCTAssertNotNil(firstBanner.imageUrl)
            XCTAssertNotNil(firstBanner.status)
        }
    }
    
    /// Test that GomaModelMapper.banner transforms single GomaModels.BannerData to Banner correctly
    func testSingleBannerModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.banners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let banners = try decoder.decode([GomaModels.BannerData].self, from: jsonData)
        
        // Ensure we have at least one banner to test
        guard let internalModel = banners.first else {
            XCTFail("No banners found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.banner(fromInternalBanner: internalModel)
        
        // Then
        XCTAssertEqual(domainModel.id, internalModel.id)
        XCTAssertEqual(domainModel.title, internalModel.title)
        
        // Check URL transformation
        if let imageUrl = internalModel.imageUrl {
            XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
        } else {
            XCTAssertNil(domainModel.imageUrl)
        }
        
        // Check action URL transformation
        if let actionUrl = internalModel.actionUrl {
            XCTAssertEqual(domainModel.actionUrl?.absoluteString, actionUrl)
        } else {
            XCTAssertNil(domainModel.actionUrl)
        }
    }
    
    /// Test that GomaModelMapper.banners transforms array of GomaModels.BannerData to [Banner] correctly
    func testBannersArrayModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.banners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModels = try decoder.decode([GomaModels.BannerData].self, from: jsonData)
        
        // When
        let domainModels = GomaModelMapper.banners(fromInternalBanners: internalModels)
        
        // Then
        XCTAssertEqual(domainModels.count, internalModels.count, "Domain model count should match internal model count")
        
        // Check that each banner was transformed correctly
        for (index, internalModel) in internalModels.enumerated() {
            let domainModel = domainModels[index]
            
            XCTAssertEqual(domainModel.id, internalModel.id)
            XCTAssertEqual(domainModel.title, internalModel.title)
            
            // Check URL transformation
            if let imageUrl = internalModel.imageUrl {
                XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
            } else {
                XCTAssertNil(domainModel.imageUrl)
            }
        }
    }
    
    /// Test that transformation correctly sets isActive based on status field
    func testIsActiveIsCorrectlyMappedFromStatus() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.banners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let banners = try decoder.decode([GomaModels.BannerData].self, from: jsonData)
        
        // Ensure we have at least one banner to test
        guard let internalModel = banners.first else {
            XCTFail("No banners found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.banner(fromInternalBanner: internalModel)
        
        // Then
        if internalModel.status == "published" {
            XCTAssertTrue(domainModel.isActive)
        } else {
            XCTAssertFalse(domainModel.isActive)
        }
    }
    
    /// Test URL construction for imageUrl field
    func testURLConstructionForImageUrl() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.banners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let banners = try decoder.decode([GomaModels.BannerData].self, from: jsonData)
        
        // Ensure we have at least one banner to test
        guard let internalModel = banners.first else {
            XCTFail("No banners found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.banner(fromInternalBanner: internalModel)
        
        // Then
        if let imageUrl = internalModel.imageUrl {
            XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
        } else {
            XCTAssertNil(domainModel.imageUrl)
        }
    }
    
    /// Test that GomaManagedContentProvider.getBanners() calls the correct API endpoint
    func testGetBannersCallsCorrectAPIEndpoint() throws {
        // Given
        let expectation = XCTestExpectation(description: "API call made")
        try registerMockBannersResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getBanners()
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { _ in
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        // Then
        wait(for: [expectation], timeout: 1.0)
        XCTAssertTrue(MockURLProtocol.requestsForEndpoint(TestConfiguration.EndpointPaths.banners).count > 0)
    }
    
    /// Test that GomaManagedContentProvider.getBanners() handles successful responses
    func testGetBannersHandlesSuccessfulResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received banners")
        try registerMockBannersResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getBanners()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { banners in
                    // Then
                    XCTAssertNotNil(banners)
                    XCTAssertFalse(banners.isEmpty, "Banners array should not be empty")
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test that GomaManagedContentProvider.getBanners() handles error responses
    func testGetBannersHandlesErrorResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received error")
        
        // Register a mock error response
        let errorURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.banners)")!
        MockURLProtocol.registerMockResponse(
            for: errorURL,
            data: "Internal Server Error".data(using: .utf8)!,
            statusCode: 500
        )
        
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getBanners()
            .sink(
                receiveCompletion: { completion in
                    if case .failure(let error) = completion {
                        // Then
                        XCTAssertNotNil(error)
                        expectation.fulfill()
                    }
                },
                receiveValue: { _ in
                    XCTFail("Should not receive a value")
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test that GomaManagedContentProvider.getBanners() handles empty array responses
    func testGetBannersHandlesEmptyArrayResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received empty array")
        
        // Register a mock empty array response
        let emptyURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.banners)")!
        MockURLProtocol.registerMockResponse(
            for: emptyURL,
            data: "[]".data(using: .utf8)!,
            statusCode: 200
        )
        
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getBanners()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Empty array should not cause failure")
                    }
                },
                receiveValue: { banners in
                    // Then
                    XCTAssertTrue(banners.isEmpty, "Banners array should be empty")
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test the end-to-end flow with mocked API response to final domain model
    func testEndToEndFlowWithMockedAPIResponse() throws {
        // Given
        let expectation = XCTestExpectation(description: "End-to-end flow completed")
        try registerMockBannersResponse()
        let contentProvider = createMockContentProvider()
        
        // Load the expected data for comparison
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.banners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModels = try decoder.decode([GomaModels.BannerData].self, from: jsonData)
        let expectedDomainModels = GomaModelMapper.banners(fromInternalBanners: internalModels)
        
        // When
        contentProvider.getBanners()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { banners in
                    // Then
                    XCTAssertEqual(banners.count, expectedDomainModels.count)
                    
                    // Compare each banner with its expected model
                    for (index, expectedBanner) in expectedDomainModels.enumerated() {
                        let actualBanner = banners[index]
                        
                        XCTAssertEqual(actualBanner.id, expectedBanner.id)
                        XCTAssertEqual(actualBanner.title, expectedBanner.title)
                        XCTAssertEqual(actualBanner.isActive, expectedBanner.isActive)
                        
                        // Compare URLs
                        if let expectedImageURL = expectedBanner.imageUrl {
                            XCTAssertEqual(actualBanner.imageUrl?.absoluteString, expectedImageURL.absoluteString)
                        } else {
                            XCTAssertNil(actualBanner.imageUrl)
                        }
                        
                        if let expectedActionURL = expectedBanner.actionUrl {
                            XCTAssertEqual(actualBanner.actionUrl?.absoluteString, expectedActionURL.absoluteString)
                        } else {
                            XCTAssertNil(actualBanner.actionUrl)
                        }
                    }
                    
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/BaseIntegrationTest.swift
````swift
import XCTest
import Combine
@testable import ServicesProvider

/// Base class for integration tests
class BaseIntegrationTest: XCTestCase {

    /// URLSession configured with MockURLProtocol
    var mockURLSession: URLSession!

    /// Set of cancellables for Combine subscriptions
    var cancellables: Set<AnyCancellable> = []

    /// Setup method called before each test
    override func setUp() {
        super.setUp()

        // Reset mock responses
        MockURLProtocol.reset()

        // Create a configuration with the mock protocol
        let configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [MockURLProtocol.self]

        // Create a URLSession with the configuration
        mockURLSession = URLSession(configuration: configuration)
    }

    /// Teardown method called after each test
    override func tearDown() {
        // Cancel all subscriptions
        cancellables.removeAll()

        // Reset mock responses
        MockURLProtocol.reset()

        // Nil out the session
        mockURLSession = nil

        super.tearDown()
    }

    /// Create a GomaAPIAuthenticator with a mock token
    /// - Returns: A configured GomaAPIAuthenticator
    func createMockAuthenticator() -> GomaAPIAuthenticator {
        let authenticator = GomaAPIAuthenticator(deviceUUID: TestConfiguration.API.deviceUUID,
                                                deviceType: TestConfiguration.API.deviceType,
                                                apiKey: TestConfiguration.API.apiKey)

        // Set a mock token
        authenticator.setToken(TestConfiguration.authToken)

        return authenticator
    }

    /// Create a GomaManagedContentProvider with mock dependencies
    /// - Returns: A configured GomaManagedContentProvider
    func createMockContentProvider() -> GomaManagedContentProvider {
        let authenticator = createMockAuthenticator()
        return GomaManagedContentProvider(gomaAPIAuthenticator: authenticator)
    }

    /// Register mock responses for all endpoints
    /// - Throws: If loading the mock responses fails
    func registerAllMockResponses() throws {
        try registerMockHomeTemplateResponse()
        try registerMockAlertBannerResponse()
        try registerMockBannersResponse()
        try registerMockSportBannersResponse()
        try registerMockBoostedOddsBannersResponse()
        try registerMockHeroCardsResponse()
        try registerMockStoriesResponse()
        try registerMockNewsResponse()
        try registerMockProChoicesResponse()
        try registerMockInitialDumpResponse()
    }

    /// Register a mock response for the home template endpoint
    /// - Throws: If loading the mock response fails
    func registerMockHomeTemplateResponse() throws {
        try MockURLProtocol.registerMockResponseForGomaEndpoint(
            endpoint: TestConfiguration.EndpointPaths.homeTemplate,
            subdirectory: TestConfiguration.MockResponseDirectories.homeTemplate
        )
    }

    /// Register a mock response for the alert banner endpoint
    /// - Throws: If loading the mock response fails
    func registerMockAlertBannerResponse() throws {
        try MockURLProtocol.registerMockResponseForGomaEndpoint(
            endpoint: TestConfiguration.EndpointPaths.alertBanner,
            subdirectory: TestConfiguration.MockResponseDirectories.alertBanner
        )
    }

    /// Register a mock response for the banners endpoint
    /// - Throws: If loading the mock response fails
    func registerMockBannersResponse() throws {
        try MockURLProtocol.registerMockResponseForGomaEndpoint(
            endpoint: TestConfiguration.EndpointPaths.banners,
            subdirectory: TestConfiguration.MockResponseDirectories.banners
        )
    }

    /// Register a mock response for the sport banners endpoint
    /// - Throws: If loading the mock response fails
    func registerMockSportBannersResponse() throws {
        try MockURLProtocol.registerMockResponseForGomaEndpoint(
            endpoint: TestConfiguration.EndpointPaths.sportBanners,
            subdirectory: TestConfiguration.MockResponseDirectories.sportBanners
        )
    }

    /// Register a mock response for the boosted odds banners endpoint
    /// - Throws: If loading the mock response fails
    func registerMockBoostedOddsBannersResponse() throws {
        try MockURLProtocol.registerMockResponseForGomaEndpoint(
            endpoint: TestConfiguration.EndpointPaths.boostedOddsBanners,
            subdirectory: TestConfiguration.MockResponseDirectories.boostedOddsBanners
        )
    }

    /// Register a mock response for the hero cards endpoint
    /// - Throws: If loading the mock response fails
    func registerMockHeroCardsResponse() throws {
        try MockURLProtocol.registerMockResponseForGomaEndpoint(
            endpoint: TestConfiguration.EndpointPaths.heroCards,
            subdirectory: TestConfiguration.MockResponseDirectories.heroCards
        )
    }

    /// Register a mock response for the stories endpoint
    /// - Throws: If loading the mock response fails
    func registerMockStoriesResponse() throws {
        try MockURLProtocol.registerMockResponseForGomaEndpoint(
            endpoint: TestConfiguration.EndpointPaths.stories,
            subdirectory: TestConfiguration.MockResponseDirectories.stories
        )
    }

    /// Register a mock response for the news endpoint
    /// - Throws: If loading the mock response fails
    func registerMockNewsResponse() throws {
        try MockURLProtocol.registerMockResponseForGomaEndpoint(
            endpoint: TestConfiguration.EndpointPaths.news,
            subdirectory: TestConfiguration.MockResponseDirectories.news
        )
    }

    /// Register a mock response for the pro choices endpoint
    /// - Throws: If loading the mock response fails
    func registerMockProChoicesResponse() throws {
        try MockURLProtocol.registerMockResponseForGomaEndpoint(
            endpoint: TestConfiguration.EndpointPaths.proChoices,
            subdirectory: TestConfiguration.MockResponseDirectories.proChoices
        )
    }

    /// Register a mock response for the initial dump endpoint
    /// - Throws: If loading the mock response fails
    func registerMockInitialDumpResponse() throws {
        try MockURLProtocol.registerMockResponseForGomaEndpoint(
            endpoint: TestConfiguration.EndpointPaths.initialDump,
            subdirectory: TestConfiguration.MockResponseDirectories.initialDump
        )
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/BoostedOddsBannersTests.swift
````swift
import XCTest
import Combine
@testable import ServicesProvider

/// Integration tests for the Boosted Odds Banners endpoint
class BoostedOddsBannersTests: BaseIntegrationTest {
    
    /// Test that GomaPromotionsAPIClient.boostedOddsBanners endpoint builds the correct URL with query parameters
    func testBoostedOddsBannersEndpointBuildsCorrectURL() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // When
        let request = apiClient.boostedOddsBanners()
        
        // Then
        XCTAssertEqual(
            request.url?.absoluteString,
            "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.boostedOddsBanners)"
        )
    }
    
    /// Test that GomaPromotionsAPIClient.boostedOddsBanners endpoint uses the correct HTTP method (GET)
    func testBoostedOddsBannersEndpointUsesCorrectHTTPMethod() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // When
        let request = apiClient.boostedOddsBanners()
        
        // Then
        XCTAssertEqual(request.httpMethod, "GET")
    }
    
    /// Test that the JSON response for boostedOddsBanners decodes to [GomaModels.BoostedOddsBannerData]
    func testBoostedOddsBannersResponseDecodesToInternalModel() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.boostedOddsBanners
        )
        
        // When
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let boostedOddsBanners = try decoder.decode([GomaModels.BoostedOddsBannerData].self, from: jsonData)
        
        // Then
        XCTAssertNotNil(boostedOddsBanners)
        XCTAssertFalse(boostedOddsBanners.isEmpty, "Boosted Odds Banners array should not be empty")
        
        // Verify first boosted odds banner has all required properties
        if let firstBanner = boostedOddsBanners.first {
            XCTAssertNotNil(firstBanner.id)
            XCTAssertNotNil(firstBanner.title)
            XCTAssertNotNil(firstBanner.imageUrl)
            XCTAssertNotNil(firstBanner.status)
            XCTAssertNotNil(firstBanner.originalOdd)
            XCTAssertNotNil(firstBanner.boostedOdd)
            XCTAssertNotNil(firstBanner.event)
        }
    }
    
    /// Test that GomaModelMapper.boostedOddsBanner transforms GomaModels.BoostedOddsBannerData to BoostedOddsBanner correctly
    func testSingleBoostedOddsBannerModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.boostedOddsBanners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let boostedOddsBanners = try decoder.decode([GomaModels.BoostedOddsBannerData].self, from: jsonData)
        
        // Ensure we have at least one boosted odds banner to test
        guard let internalModel = boostedOddsBanners.first else {
            XCTFail("No boosted odds banners found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.boostedOddsBanner(fromInternalBoostedOddsBanner: internalModel)
        
        // Then
        XCTAssertEqual(domainModel.id, internalModel.id)
        XCTAssertEqual(domainModel.title, internalModel.title)
        
        // Check URL transformation
        if let imageUrl = internalModel.imageUrl {
            XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
        } else {
            XCTAssertNil(domainModel.imageUrl)
        }
        
        // Check action URL transformation
        if let actionUrl = internalModel.actionUrl {
            XCTAssertEqual(domainModel.actionUrl?.absoluteString, actionUrl)
        } else {
            XCTAssertNil(domainModel.actionUrl)
        }
        
        // Check isActive transformation
        if internalModel.status == "published" {
            XCTAssertTrue(domainModel.isActive)
        } else {
            XCTAssertFalse(domainModel.isActive)
        }
    }
    
    /// Test that GomaModelMapper.boostedOddsBanners transforms array of GomaModels.BoostedOddsBannerData to [BoostedOddsBanner] correctly
    func testBoostedOddsBannersArrayModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.boostedOddsBanners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModels = try decoder.decode([GomaModels.BoostedOddsBannerData].self, from: jsonData)
        
        // When
        let domainModels = GomaModelMapper.boostedOddsBanners(fromInternalBoostedOddsBanners: internalModels)
        
        // Then
        XCTAssertEqual(domainModels.count, internalModels.count, "Domain model count should match internal model count")
        
        // Check that each boosted odds banner was transformed correctly
        for (index, internalModel) in internalModels.enumerated() {
            let domainModel = domainModels[index]
            
            XCTAssertEqual(domainModel.id, internalModel.id)
            XCTAssertEqual(domainModel.title, internalModel.title)
            
            // Check URL transformation
            if let imageUrl = internalModel.imageUrl {
                XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
            } else {
                XCTAssertNil(domainModel.imageUrl)
            }
        }
    }
    
    /// Test originalOdd and boostedOdd values are correctly mapped
    func testOddsValuesAreCorrectlyMapped() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.boostedOddsBanners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let boostedOddsBanners = try decoder.decode([GomaModels.BoostedOddsBannerData].self, from: jsonData)
        
        // Ensure we have at least one boosted odds banner to test
        guard let internalModel = boostedOddsBanners.first else {
            XCTFail("No boosted odds banners found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.boostedOddsBanner(fromInternalBoostedOddsBanner: internalModel)
        
        // Then
        XCTAssertEqual(domainModel.originalOdd, internalModel.originalOdd)
        XCTAssertEqual(domainModel.boostedOdd, internalModel.boostedOdd)
    }
    
    /// Test nested SportEventData mapping to SportEventSummary
    func testNestedSportEventDataMapping() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.boostedOddsBanners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let boostedOddsBanners = try decoder.decode([GomaModels.BoostedOddsBannerData].self, from: jsonData)
        
        // Ensure we have at least one boosted odds banner with event data to test
        guard let internalModel = boostedOddsBanners.first, let eventData = internalModel.event else {
            XCTFail("No boosted odds banners with event data found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.boostedOddsBanner(fromInternalBoostedOddsBanner: internalModel)
        
        // Then
        XCTAssertNotNil(domainModel.event)
        XCTAssertEqual(domainModel.event?.id, eventData.id)
        XCTAssertEqual(domainModel.event?.sportId, eventData.sportId)
        XCTAssertEqual(domainModel.event?.competitionId, eventData.competitionId)
        
        // Check date transformation
        if let dateTimeString = eventData.dateTime {
            let dateFormatter = ISO8601DateFormatter()
            let expectedDate = dateFormatter.date(from: dateTimeString)
            XCTAssertEqual(domainModel.event?.dateTime, expectedDate)
        } else {
            XCTAssertNil(domainModel.event?.dateTime)
        }
        
        // Check team data if present
        if let homeTeam = eventData.homeTeam, let awayTeam = eventData.awayTeam {
            XCTAssertEqual(domainModel.event?.homeTeam.id, homeTeam.id)
            XCTAssertEqual(domainModel.event?.homeTeam.name, homeTeam.name)
            XCTAssertEqual(domainModel.event?.awayTeam.id, awayTeam.id)
            XCTAssertEqual(domainModel.event?.awayTeam.name, awayTeam.name)
        }
    }
    
    /// Test URL construction for imageUrl field
    func testURLConstructionForImageUrl() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.boostedOddsBanners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let boostedOddsBanners = try decoder.decode([GomaModels.BoostedOddsBannerData].self, from: jsonData)
        
        // Ensure we have at least one boosted odds banner to test
        guard let internalModel = boostedOddsBanners.first else {
            XCTFail("No boosted odds banners found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.boostedOddsBanner(fromInternalBoostedOddsBanner: internalModel)
        
        // Then
        if let imageUrl = internalModel.imageUrl {
            XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
        } else {
            XCTAssertNil(domainModel.imageUrl)
        }
    }
    
    /// Test that GomaManagedContentProvider.getBoostedOddsBanners() calls the correct API endpoint
    func testGetBoostedOddsBannersCallsCorrectAPIEndpoint() throws {
        // Given
        let expectation = XCTestExpectation(description: "API call made")
        try registerMockBoostedOddsBannersResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getBoostedOddsBanners()
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { _ in
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        // Then
        wait(for: [expectation], timeout: 1.0)
        XCTAssertTrue(MockURLProtocol.requestsForEndpoint(TestConfiguration.EndpointPaths.boostedOddsBanners).count > 0)
    }
    
    /// Test that GomaManagedContentProvider.getBoostedOddsBanners() handles successful responses
    func testGetBoostedOddsBannersHandlesSuccessfulResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received boosted odds banners")
        try registerMockBoostedOddsBannersResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getBoostedOddsBanners()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { boostedOddsBanners in
                    // Then
                    XCTAssertNotNil(boostedOddsBanners)
                    XCTAssertFalse(boostedOddsBanners.isEmpty, "Boosted Odds Banners array should not be empty")
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test that GomaManagedContentProvider.getBoostedOddsBanners() handles error responses
    func testGetBoostedOddsBannersHandlesErrorResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received error")
        
        // Register a mock error response
        let errorURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.boostedOddsBanners)")!
        MockURLProtocol.registerMockResponse(
            for: errorURL,
            data: "Internal Server Error".data(using: .utf8)!,
            statusCode: 500
        )
        
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getBoostedOddsBanners()
            .sink(
                receiveCompletion: { completion in
                    if case .failure(let error) = completion {
                        // Then
                        XCTAssertNotNil(error)
                        expectation.fulfill()
                    }
                },
                receiveValue: { _ in
                    XCTFail("Should not receive a value")
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test that GomaManagedContentProvider.getBoostedOddsBanners() handles empty array responses
    func testGetBoostedOddsBannersHandlesEmptyArrayResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received empty array")
        
        // Register a mock empty array response
        let emptyURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.boostedOddsBanners)")!
        MockURLProtocol.registerMockResponse(
            for: emptyURL,
            data: "[]".data(using: .utf8)!,
            statusCode: 200
        )
        
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getBoostedOddsBanners()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Empty array should not cause failure")
                    }
                },
                receiveValue: { boostedOddsBanners in
                    // Then
                    XCTAssertTrue(boostedOddsBanners.isEmpty, "Boosted Odds Banners array should be empty")
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test the end-to-end flow with mocked API response to final domain model
    func testEndToEndFlowWithMockedAPIResponse() throws {
        // Given
        let expectation = XCTestExpectation(description: "End-to-end flow completed")
        try registerMockBoostedOddsBannersResponse()
        let contentProvider = createMockContentProvider()
        
        // Load the expected data for comparison
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.boostedOddsBanners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModels = try decoder.decode([GomaModels.BoostedOddsBannerData].self, from: jsonData)
        let expectedDomainModels = GomaModelMapper.boostedOddsBanners(fromInternalBoostedOddsBanners: internalModels)
        
        // When
        contentProvider.getBoostedOddsBanners()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { boostedOddsBanners in
                    // Then
                    XCTAssertEqual(boostedOddsBanners.count, expectedDomainModels.count)
                    
                    // Compare each boosted odds banner with its expected model
                    for (index, expectedBanner) in expectedDomainModels.enumerated() {
                        let actualBanner = boostedOddsBanners[index]
                        
                        XCTAssertEqual(actualBanner.id, expectedBanner.id)
                        XCTAssertEqual(actualBanner.title, expectedBanner.title)
                        XCTAssertEqual(actualBanner.isActive, expectedBanner.isActive)
                        XCTAssertEqual(actualBanner.originalOdd, expectedBanner.originalOdd)
                        XCTAssertEqual(actualBanner.boostedOdd, expectedBanner.boostedOdd)
                        
                        // Compare URLs
                        if let expectedImageURL = expectedBanner.imageUrl {
                            XCTAssertEqual(actualBanner.imageUrl?.absoluteString, expectedImageURL.absoluteString)
                        } else {
                            XCTAssertNil(actualBanner.imageUrl)
                        }
                        
                        if let expectedActionURL = expectedBanner.actionUrl {
                            XCTAssertEqual(actualBanner.actionUrl?.absoluteString, expectedActionURL.absoluteString)
                        } else {
                            XCTAssertNil(actualBanner.actionUrl)
                        }
                        
                        // Compare event data if present
                        if let expectedEvent = expectedBanner.event, let actualEvent = actualBanner.event {
                            XCTAssertEqual(actualEvent.id, expectedEvent.id)
                            XCTAssertEqual(actualEvent.sportId, expectedEvent.sportId)
                            XCTAssertEqual(actualEvent.competitionId, expectedEvent.competitionId)
                            
                            // Compare teams if present
                            if expectedEvent.homeTeam != nil && expectedEvent.awayTeam != nil {
                                XCTAssertEqual(actualEvent.homeTeam.id, expectedEvent.homeTeam.id)
                                XCTAssertEqual(actualEvent.homeTeam.name, expectedEvent.homeTeam.name)
                                XCTAssertEqual(actualEvent.awayTeam.id, expectedEvent.awayTeam.id)
                                XCTAssertEqual(actualEvent.awayTeam.name, expectedEvent.awayTeam.name)
                            }
                            
                            // Compare date
                            if let expectedDate = expectedEvent.dateTime {
                                XCTAssertEqual(actualEvent.dateTime, expectedDate)
                            } else {
                                XCTAssertNil(actualEvent.dateTime)
                            }
                        } else {
                            XCTAssertEqual(actualBanner.event == nil, expectedBanner.event == nil)
                        }
                    }
                    
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/HeroCardsTests.swift
````swift
import XCTest
import Combine
@testable import ServicesProvider

/// Integration tests for the Hero Cards endpoint
class HeroCardsTests: BaseIntegrationTest {
    
    /// Test that GomaPromotionsAPIClient.heroCards endpoint builds the correct URL with query parameters
    func testHeroCardsEndpointBuildsCorrectURL() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // When
        let request = apiClient.heroCards()
        
        // Then
        XCTAssertEqual(
            request.url?.absoluteString,
            "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.heroCards)"
        )
    }
    
    /// Test that GomaPromotionsAPIClient.heroCards endpoint uses the correct HTTP method (GET)
    func testHeroCardsEndpointUsesCorrectHTTPMethod() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // When
        let request = apiClient.heroCards()
        
        // Then
        XCTAssertEqual(request.httpMethod, "GET")
    }
    
    /// Test that the JSON response for heroCards decodes to [GomaModels.HeroCardData]
    func testHeroCardsResponseDecodesToInternalModel() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.heroCards
        )
        
        // When
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let heroCards = try decoder.decode([GomaModels.HeroCardData].self, from: jsonData)
        
        // Then
        XCTAssertNotNil(heroCards)
        XCTAssertFalse(heroCards.isEmpty, "Hero Cards array should not be empty")
        
        // Verify first hero card has all required properties
        if let firstCard = heroCards.first {
            XCTAssertNotNil(firstCard.id)
            XCTAssertNotNil(firstCard.title)
            XCTAssertNotNil(firstCard.imageUrl)
            XCTAssertNotNil(firstCard.status)
            XCTAssertNotNil(firstCard.actionType)
        }
    }
    
    /// Test that GomaModelMapper.heroCard transforms GomaModels.HeroCardData to HeroCard correctly
    func testSingleHeroCardModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.heroCards
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let heroCards = try decoder.decode([GomaModels.HeroCardData].self, from: jsonData)
        
        // Ensure we have at least one hero card to test
        guard let internalModel = heroCards.first else {
            XCTFail("No hero cards found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.heroCard(fromInternalHeroCard: internalModel)
        
        // Then
        XCTAssertEqual(domainModel.id, internalModel.id)
        XCTAssertEqual(domainModel.title, internalModel.title)
        
        // Check URL transformation
        if let imageUrl = internalModel.imageUrl {
            XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
        } else {
            XCTAssertNil(domainModel.imageUrl)
        }
        
        // Check isActive transformation
        if internalModel.status == "published" {
            XCTAssertTrue(domainModel.isActive)
        } else {
            XCTAssertFalse(domainModel.isActive)
        }
    }
    
    /// Test that GomaModelMapper.heroCards transforms array of GomaModels.HeroCardData to [HeroCard] correctly
    func testHeroCardsArrayModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.heroCards
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModels = try decoder.decode([GomaModels.HeroCardData].self, from: jsonData)
        
        // When
        let domainModels = GomaModelMapper.heroCards(fromInternalHeroCards: internalModels)
        
        // Then
        XCTAssertEqual(domainModels.count, internalModels.count, "Domain model count should match internal model count")
        
        // Check that each hero card was transformed correctly
        for (index, internalModel) in internalModels.enumerated() {
            let domainModel = domainModels[index]
            
            XCTAssertEqual(domainModel.id, internalModel.id)
            XCTAssertEqual(domainModel.title, internalModel.title)
            
            // Check URL transformation
            if let imageUrl = internalModel.imageUrl {
                XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
            } else {
                XCTAssertNil(domainModel.imageUrl)
            }
        }
    }
    
    /// Test actionType and actionTarget fields are correctly mapped
    func testActionTypeAndTargetAreCorrectlyMapped() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.heroCards
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let heroCards = try decoder.decode([GomaModels.HeroCardData].self, from: jsonData)
        
        // Ensure we have at least one hero card to test
        guard let internalModel = heroCards.first else {
            XCTFail("No hero cards found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.heroCard(fromInternalHeroCard: internalModel)
        
        // Then
        XCTAssertEqual(domainModel.actionType, internalModel.actionType)
        XCTAssertEqual(domainModel.actionTarget, internalModel.actionTarget)
    }
    
    /// Test eventId and eventData fields are correctly mapped
    func testEventDataIsCorrectlyMapped() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.heroCards
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let heroCards = try decoder.decode([GomaModels.HeroCardData].self, from: jsonData)
        
        // Find a hero card with event data to test
        guard let cardWithEvent = heroCards.first(where: { $0.event != nil }) else {
            // If no card has event data, skip this test
            print("No hero cards with event data found in test data, skipping test")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.heroCard(fromInternalHeroCard: cardWithEvent)
        
        // Then
        XCTAssertNotNil(domainModel.event)
        XCTAssertEqual(domainModel.event?.id, cardWithEvent.event?.id)
        
        // Check event details if present
        if let eventData = cardWithEvent.event {
            XCTAssertEqual(domainModel.event?.sportId, eventData.sportId)
            XCTAssertEqual(domainModel.event?.competitionId, eventData.competitionId)
            
            // Check teams if present
            if let homeTeam = eventData.homeTeam, let awayTeam = eventData.awayTeam {
                XCTAssertEqual(domainModel.event?.homeTeam.id, homeTeam.id)
                XCTAssertEqual(domainModel.event?.homeTeam.name, homeTeam.name)
                XCTAssertEqual(domainModel.event?.awayTeam.id, awayTeam.id)
                XCTAssertEqual(domainModel.event?.awayTeam.name, awayTeam.name)
            }
        }
    }
    
    /// Test URL construction for imageUrl field
    func testURLConstructionForImageUrl() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.heroCards
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let heroCards = try decoder.decode([GomaModels.HeroCardData].self, from: jsonData)
        
        // Ensure we have at least one hero card to test
        guard let internalModel = heroCards.first else {
            XCTFail("No hero cards found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.heroCard(fromInternalHeroCard: internalModel)
        
        // Then
        if let imageUrl = internalModel.imageUrl {
            XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
        } else {
            XCTAssertNil(domainModel.imageUrl)
        }
    }
    
    /// Test that GomaManagedContentProvider.getHeroCards() calls the correct API endpoint
    func testGetHeroCardsCallsCorrectAPIEndpoint() throws {
        // Given
        let expectation = XCTestExpectation(description: "API call made")
        try registerMockHeroCardsResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getHeroCards()
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { _ in
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        // Then
        wait(for: [expectation], timeout: 1.0)
        XCTAssertTrue(MockURLProtocol.requestsForEndpoint(TestConfiguration.EndpointPaths.heroCards).count > 0)
    }
    
    /// Test that GomaManagedContentProvider.getHeroCards() handles successful responses
    func testGetHeroCardsHandlesSuccessfulResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received hero cards")
        try registerMockHeroCardsResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getHeroCards()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { heroCards in
                    // Then
                    XCTAssertNotNil(heroCards)
                    XCTAssertFalse(heroCards.isEmpty, "Hero Cards array should not be empty")
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test that GomaManagedContentProvider.getHeroCards() handles error responses
    func testGetHeroCardsHandlesErrorResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received error")
        
        // Register a mock error response
        let errorURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.heroCards)")!
        MockURLProtocol.registerMockResponse(
            for: errorURL,
            data: "Internal Server Error".data(using: .utf8)!,
            statusCode: 500
        )
        
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getHeroCards()
            .sink(
                receiveCompletion: { completion in
                    if case .failure(let error) = completion {
                        // Then
                        XCTAssertNotNil(error)
                        expectation.fulfill()
                    }
                },
                receiveValue: { _ in
                    XCTFail("Should not receive a value")
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test that GomaManagedContentProvider.getHeroCards() handles empty array responses
    func testGetHeroCardsHandlesEmptyArrayResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received empty array")
        
        // Register a mock empty array response
        let emptyURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.heroCards)")!
        MockURLProtocol.registerMockResponse(
            for: emptyURL,
            data: "[]".data(using: .utf8)!,
            statusCode: 200
        )
        
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getHeroCards()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Empty array should not cause failure")
                    }
                },
                receiveValue: { heroCards in
                    // Then
                    XCTAssertTrue(heroCards.isEmpty, "Hero Cards array should be empty")
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test the end-to-end flow with mocked API response to final domain model
    func testEndToEndFlowWithMockedAPIResponse() throws {
        // Given
        let expectation = XCTestExpectation(description: "End-to-end flow completed")
        try registerMockHeroCardsResponse()
        let contentProvider = createMockContentProvider()
        
        // Load the expected data for comparison
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.heroCards
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModels = try decoder.decode([GomaModels.HeroCardData].self, from: jsonData)
        let expectedDomainModels = GomaModelMapper.heroCards(fromInternalHeroCards: internalModels)
        
        // When
        contentProvider.getHeroCards()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { heroCards in
                    // Then
                    XCTAssertEqual(heroCards.count, expectedDomainModels.count)
                    
                    // Compare each hero card with its expected model
                    for (index, expectedCard) in expectedDomainModels.enumerated() {
                        let actualCard = heroCards[index]
                        
                        XCTAssertEqual(actualCard.id, expectedCard.id)
                        XCTAssertEqual(actualCard.title, expectedCard.title)
                        XCTAssertEqual(actualCard.isActive, expectedCard.isActive)
                        XCTAssertEqual(actualCard.actionType, expectedCard.actionType)
                        XCTAssertEqual(actualCard.actionTarget, expectedCard.actionTarget)
                        
                        // Compare URLs
                        if let expectedImageURL = expectedCard.imageUrl {
                            XCTAssertEqual(actualCard.imageUrl?.absoluteString, expectedImageURL.absoluteString)
                        } else {
                            XCTAssertNil(actualCard.imageUrl)
                        }
                        
                        // Compare event data if present
                        if let expectedEvent = expectedCard.event, let actualEvent = actualCard.event {
                            XCTAssertEqual(actualEvent.id, expectedEvent.id)
                            XCTAssertEqual(actualEvent.sportId, expectedEvent.sportId)
                            XCTAssertEqual(actualEvent.competitionId, expectedEvent.competitionId)
                            
                            // Compare teams if present
                            if expectedEvent.homeTeam != nil && expectedEvent.awayTeam != nil {
                                XCTAssertEqual(actualEvent.homeTeam.id, expectedEvent.homeTeam.id)
                                XCTAssertEqual(actualEvent.homeTeam.name, expectedEvent.homeTeam.name)
                                XCTAssertEqual(actualEvent.awayTeam.id, expectedEvent.awayTeam.id)
                                XCTAssertEqual(actualEvent.awayTeam.name, expectedEvent.awayTeam.name)
                            }
                            
                            // Compare date
                            if let expectedDate = expectedEvent.dateTime {
                                XCTAssertEqual(actualEvent.dateTime, expectedDate)
                            } else {
                                XCTAssertNil(actualEvent.dateTime)
                            }
                        } else {
                            XCTAssertEqual(actualCard.event == nil, expectedCard.event == nil)
                        }
                    }
                    
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/HomeTemplateTests.swift
````swift
import XCTest
import Combine
@testable import ServicesProvider

/// Integration tests for the Home Template endpoint
class HomeTemplateTests: BaseIntegrationTest {
    
    /// Test that GomaPromotionsAPIClient.homeTemplate builds the correct URL with query parameters
    func testHomeTemplateEndpointBuildsCorrectURL() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // When
        let request = apiClient.homeTemplate()
        
        // Then
        XCTAssertEqual(
            request.url?.absoluteString,
            "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.homeTemplate)?platform=ios"
        )
    }
    
    /// Test that GomaPromotionsAPIClient.homeTemplate uses the correct HTTP method (GET)
    func testHomeTemplateEndpointUsesCorrectHTTPMethod() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // When
        let request = apiClient.homeTemplate()
        
        // Then
        XCTAssertEqual(request.httpMethod, "GET")
    }
    
    /// Test that the JSON response for homeTemplate decodes to GomaModels.HomeTemplate
    func testHomeTemplateResponseDecodesToInternalModel() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.homeTemplate
        )
        
        // When
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let homeTemplate = try decoder.decode(GomaModels.HomeTemplate.self, from: jsonData)
        
        // Then
        XCTAssertNotNil(homeTemplate)
        XCTAssertNotNil(homeTemplate.id)
        XCTAssertNotNil(homeTemplate.name)
        XCTAssertNotNil(homeTemplate.widgets)
        XCTAssertFalse(homeTemplate.widgets.isEmpty)
    }
    
    /// Test that GomaModelMapper.homeTemplate transforms GomaModels.HomeTemplate to HomeTemplate correctly
    func testHomeTemplateModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.homeTemplate
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModel = try decoder.decode(GomaModels.HomeTemplate.self, from: jsonData)
        
        // When
        let domainModel = GomaModelMapper.homeTemplate(fromInternalHomeTemplate: internalModel)
        
        // Then
        XCTAssertEqual(domainModel.id, internalModel.id)
        XCTAssertEqual(domainModel.name, internalModel.name)
        XCTAssertEqual(domainModel.widgets.count, internalModel.widgets.count)
    }
    
    /// Test that widget types are correctly mapped in the transformation
    func testWidgetTypesAreCorrectlyMapped() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.homeTemplate
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModel = try decoder.decode(GomaModels.HomeTemplate.self, from: jsonData)
        
        // When
        let domainModel = GomaModelMapper.homeTemplate(fromInternalHomeTemplate: internalModel)
        
        // Then
        for (index, widget) in internalModel.widgets.enumerated() {
            let mappedWidget = domainModel.widgets[index]
            XCTAssertEqual(mappedWidget.id, widget.id)
            XCTAssertEqual(mappedWidget.name, widget.name)
            XCTAssertEqual(mappedWidget.description, widget.description)
            
            // Check that the widget type is correctly mapped based on the name
            switch widget.name {
            case "alertBanners":
                XCTAssertEqual(mappedWidget.type, .alertBanners)
            case "banners":
                XCTAssertEqual(mappedWidget.type, .banners)
            case "sportBanners":
                XCTAssertEqual(mappedWidget.type, .sportBanners)
            case "boostedOddsBanners":
                XCTAssertEqual(mappedWidget.type, .boostedOddsBanners)
            case "heroCards":
                XCTAssertEqual(mappedWidget.type, .heroCards)
            case "stories":
                XCTAssertEqual(mappedWidget.type, .stories)
            case "news":
                XCTAssertEqual(mappedWidget.type, .news)
            case "proChoices":
                XCTAssertEqual(mappedWidget.type, .proChoices)
            default:
                XCTAssertEqual(mappedWidget.type, .unknown)
            }
        }
    }
    
    /// Test that GomaManagedContentProvider.getHomeTemplate() calls the correct API endpoint
    func testGetHomeTemplateCallsCorrectAPIEndpoint() throws {
        // Given
        let expectation = XCTestExpectation(description: "API call made")
        try registerMockHomeTemplateResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getHomeTemplate()
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { _ in
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        // Then
        wait(for: [expectation], timeout: 1.0)
        XCTAssertTrue(MockURLProtocol.requestsForEndpoint(TestConfiguration.EndpointPaths.homeTemplate).count > 0)
    }
    
    /// Test that GomaManagedContentProvider.getHomeTemplate() handles successful responses
    func testGetHomeTemplateHandlesSuccessfulResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received home template")
        try registerMockHomeTemplateResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getHomeTemplate()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { homeTemplate in
                    // Then
                    XCTAssertNotNil(homeTemplate)
                    XCTAssertFalse(homeTemplate.widgets.isEmpty)
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test that GomaManagedContentProvider.getHomeTemplate() handles error responses
    func testGetHomeTemplateHandlesErrorResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received error")
        
        // Register a mock error response
        let errorURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.homeTemplate)?platform=ios")!
        MockURLProtocol.registerMockResponse(
            for: errorURL,
            data: "Internal Server Error".data(using: .utf8)!,
            statusCode: 500
        )
        
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getHomeTemplate()
            .sink(
                receiveCompletion: { completion in
                    if case .failure(let error) = completion {
                        // Then
                        XCTAssertNotNil(error)
                        expectation.fulfill()
                    }
                },
                receiveValue: { _ in
                    XCTFail("Should not receive a value")
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test that GomaManagedContentProvider.getHomeTemplate() applies authentication correctly
    func testGetHomeTemplateAppliesAuthenticationCorrectly() throws {
        // Given
        let expectation = XCTestExpectation(description: "API call made with authentication")
        try registerMockHomeTemplateResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getHomeTemplate()
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { _ in
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        // Then
        wait(for: [expectation], timeout: 1.0)
        
        let requests = MockURLProtocol.requestsForEndpoint(TestConfiguration.EndpointPaths.homeTemplate)
        XCTAssertTrue(requests.count > 0)
        
        let request = requests.first!
        XCTAssertNotNil(request.allHTTPHeaderFields?["Authorization"])
        XCTAssertEqual(
            request.allHTTPHeaderFields?["Authorization"],
            "Bearer \(TestConfiguration.authToken)"
        )
    }
    
    /// Test the end-to-end flow with mocked API response to final domain model
    func testEndToEndFlowWithMockedAPIResponse() throws {
        // Given
        let expectation = XCTestExpectation(description: "End-to-end flow completed")
        try registerMockHomeTemplateResponse()
        let contentProvider = createMockContentProvider()
        
        // Load the expected data for comparison
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.homeTemplate
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModel = try decoder.decode(GomaModels.HomeTemplate.self, from: jsonData)
        let expectedDomainModel = GomaModelMapper.homeTemplate(fromInternalHomeTemplate: internalModel)
        
        // When
        contentProvider.getHomeTemplate()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { homeTemplate in
                    // Then
                    XCTAssertEqual(homeTemplate.id, expectedDomainModel.id)
                    XCTAssertEqual(homeTemplate.name, expectedDomainModel.name)
                    XCTAssertEqual(homeTemplate.widgets.count, expectedDomainModel.widgets.count)
                    
                    // Compare each widget
                    for (index, expectedWidget) in expectedDomainModel.widgets.enumerated() {
                        let actualWidget = homeTemplate.widgets[index]
                        XCTAssertEqual(actualWidget.id, expectedWidget.id)
                        XCTAssertEqual(actualWidget.name, expectedWidget.name)
                        XCTAssertEqual(actualWidget.description, expectedWidget.description)
                        XCTAssertEqual(actualWidget.type, expectedWidget.type)
                    }
                    
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/NewsTests.swift
````swift
import XCTest
import Combine
@testable import ServicesProvider

/// Integration tests for the News endpoint
class NewsTests: BaseIntegrationTest {
    
    /// Test that GomaPromotionsAPIClient.news endpoint builds the correct URL with query parameters
    func testNewsEndpointBuildsCorrectURL() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // When
        let request = apiClient.news(pageIndex: 0, pageSize: 10)
        
        // Then
        XCTAssertEqual(
            request.url?.absoluteString,
            "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.news)?pageIndex=0&pageSize=10"
        )
    }
    
    /// Test that GomaPromotionsAPIClient.news endpoint uses the correct HTTP method (GET)
    func testNewsEndpointUsesCorrectHTTPMethod() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // When
        let request = apiClient.news(pageIndex: 0, pageSize: 10)
        
        // Then
        XCTAssertEqual(request.httpMethod, "GET")
    }
    
    /// Verify pagination parameters (pageIndex, pageSize) are correctly added to URL
    func testPaginationParametersAreCorrectlyAddedToURL() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // Test different pagination values
        let testCases = [
            (pageIndex: 0, pageSize: 10),
            (pageIndex: 1, pageSize: 20),
            (pageIndex: 2, pageSize: 5)
        ]
        
        for (pageIndex, pageSize) in testCases {
            // When
            let request = apiClient.news(pageIndex: pageIndex, pageSize: pageSize)
            
            // Then
            XCTAssertEqual(
                request.url?.absoluteString,
                "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.news)?pageIndex=\(pageIndex)&pageSize=\(pageSize)"
            )
        }
    }
    
    /// Test that the JSON response for news decodes to [GomaModels.NewsItemData]
    func testNewsResponseDecodesToInternalModel() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.news
        )
        
        // When
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let news = try decoder.decode([GomaModels.NewsItemData].self, from: jsonData)
        
        // Then
        XCTAssertNotNil(news)
        XCTAssertFalse(news.isEmpty, "News array should not be empty")
        
        // Verify first news item has all required properties
        if let firstItem = news.first {
            XCTAssertNotNil(firstItem.id)
            XCTAssertNotNil(firstItem.title)
            XCTAssertNotNil(firstItem.imageUrl)
            XCTAssertNotNil(firstItem.status)
            XCTAssertNotNil(firstItem.content)
        }
    }
    
    /// Test that GomaModelMapper.newsItem transforms GomaModels.NewsItemData to NewsItem correctly
    func testSingleNewsItemModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.news
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let news = try decoder.decode([GomaModels.NewsItemData].self, from: jsonData)
        
        // Ensure we have at least one news item to test
        guard let internalModel = news.first else {
            XCTFail("No news items found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.newsItem(fromInternalNewsItem: internalModel)
        
        // Then
        XCTAssertEqual(domainModel.id, internalModel.id)
        XCTAssertEqual(domainModel.title, internalModel.title)
        
        // Check URL transformation
        if let imageUrl = internalModel.imageUrl {
            XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
        } else {
            XCTAssertNil(domainModel.imageUrl)
        }
        
        // Check isActive transformation
        if internalModel.status == "published" {
            XCTAssertTrue(domainModel.isActive)
        } else {
            XCTAssertFalse(domainModel.isActive)
        }
    }
    
    /// Test that GomaModelMapper.newsItems transforms array of GomaModels.NewsItemData to [NewsItem] correctly
    func testNewsItemsArrayModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.news
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModels = try decoder.decode([GomaModels.NewsItemData].self, from: jsonData)
        
        // When
        let domainModels = GomaModelMapper.newsItems(fromInternalNewsItems: internalModels)
        
        // Then
        XCTAssertEqual(domainModels.count, internalModels.count, "Domain model count should match internal model count")
        
        // Check that each news item was transformed correctly
        for (index, internalModel) in internalModels.enumerated() {
            let domainModel = domainModels[index]
            
            XCTAssertEqual(domainModel.id, internalModel.id)
            XCTAssertEqual(domainModel.title, internalModel.title)
            
            // Check URL transformation
            if let imageUrl = internalModel.imageUrl {
                XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
            } else {
                XCTAssertNil(domainModel.imageUrl)
            }
        }
    }
    
    /// Test author and tags fields are correctly mapped
    func testAuthorAndTagsFieldsAreCorrectlyMapped() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.news
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let news = try decoder.decode([GomaModels.NewsItemData].self, from: jsonData)
        
        // Ensure we have at least one news item to test
        guard let internalModel = news.first else {
            XCTFail("No news items found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.newsItem(fromInternalNewsItem: internalModel)
        
        // Then
        XCTAssertEqual(domainModel.author, internalModel.author)
        XCTAssertEqual(domainModel.tags, internalModel.tags)
    }
    
    /// Test content field is correctly mapped
    func testContentFieldIsCorrectlyMapped() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.news
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let news = try decoder.decode([GomaModels.NewsItemData].self, from: jsonData)
        
        // Ensure we have at least one news item to test
        guard let internalModel = news.first else {
            XCTFail("No news items found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.newsItem(fromInternalNewsItem: internalModel)
        
        // Then
        XCTAssertEqual(domainModel.content, internalModel.content)
    }
    
    /// Test URL construction for imageUrl field
    func testURLConstructionForImageUrl() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.news
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let news = try decoder.decode([GomaModels.NewsItemData].self, from: jsonData)
        
        // Ensure we have at least one news item to test
        guard let internalModel = news.first else {
            XCTFail("No news items found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.newsItem(fromInternalNewsItem: internalModel)
        
        // Then
        if let imageUrl = internalModel.imageUrl {
            XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
        } else {
            XCTAssertNil(domainModel.imageUrl)
        }
    }
    
    /// Test that GomaManagedContentProvider.getNews() calls the correct API endpoint
    func testGetNewsCallsCorrectAPIEndpoint() throws {
        // Given
        let expectation = XCTestExpectation(description: "API call made")
        try registerMockNewsResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getNews(pageIndex: 0, pageSize: 10)
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { _ in
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        // Then
        wait(for: [expectation], timeout: 1.0)
        XCTAssertTrue(MockURLProtocol.requestsForEndpoint("\(TestConfiguration.EndpointPaths.news)?pageIndex=0&pageSize=10").count > 0)
    }
    
    /// Test that GomaManagedContentProvider.getNews() handles successful responses
    func testGetNewsHandlesSuccessfulResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received news")
        try registerMockNewsResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getNews(pageIndex: 0, pageSize: 10)
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { news in
                    // Then
                    XCTAssertNotNil(news)
                    XCTAssertFalse(news.isEmpty, "News array should not be empty")
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test that GomaManagedContentProvider.getNews() handles error responses
    func testGetNewsHandlesErrorResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received error")
        
        // Register a mock error response
        let errorURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.news)?pageIndex=0&pageSize=10")!
        MockURLProtocol.registerMockResponse(
            for: errorURL,
            data: "Internal Server Error".data(using: .utf8)!,
            statusCode: 500
        )
        
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getNews(pageIndex: 0, pageSize: 10)
            .sink(
                receiveCompletion: { completion in
                    if case .failure(let error) = completion {
                        // Then
                        XCTAssertNotNil(error)
                        expectation.fulfill()
                    }
                },
                receiveValue: { _ in
                    XCTFail("Should not receive a value")
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test that GomaManagedContentProvider.getNews() handles empty array responses
    func testGetNewsHandlesEmptyArrayResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received empty array")
        
        // Register a mock empty array response
        let emptyURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.news)?pageIndex=0&pageSize=10")!
        MockURLProtocol.registerMockResponse(
            for: emptyURL,
            data: "[]".data(using: .utf8)!,
            statusCode: 200
        )
        
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getNews(pageIndex: 0, pageSize: 10)
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Empty array should not cause failure")
                    }
                },
                receiveValue: { news in
                    // Then
                    XCTAssertTrue(news.isEmpty, "News array should be empty")
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test pagination works correctly with different page indexes and sizes
    func testPaginationWorksCorrectlyWithDifferentPageIndexesAndSizes() throws {
        // Given
        let testCases = [
            (pageIndex: 0, pageSize: 10),
            (pageIndex: 1, pageSize: 20),
            (pageIndex: 2, pageSize: 5)
        ]
        
        for (pageIndex, pageSize) in testCases {
            let expectation = XCTestExpectation(description: "Pagination test for page \(pageIndex), size \(pageSize)")
            
            // Register a mock response for this pagination
            let url = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.news)?pageIndex=\(pageIndex)&pageSize=\(pageSize)")!
            
            // Create a mock response with the page index and size in the first item's title
            // to verify the correct endpoint was called
            let mockResponse = """
            [
                {
                    "id": "test-\(pageIndex)-\(pageSize)",
                    "title": "News Item Page \(pageIndex) Size \(pageSize)",
                    "image_url": "https://example.com/image.jpg",
                    "status": "published",
                    "content": "Test content",
                    "author": "Test Author",
                    "tags": ["test", "pagination"]
                }
            ]
            """.data(using: .utf8)!
            
            MockURLProtocol.registerMockResponse(
                for: url,
                data: mockResponse,
                statusCode: 200
            )
            
            let contentProvider = createMockContentProvider()
            
            // When
            contentProvider.getNews(pageIndex: pageIndex, pageSize: pageSize)
                .sink(
                    receiveCompletion: { completion in
                        if case .failure = completion {
                            XCTFail("Should not fail")
                        }
                    },
                    receiveValue: { news in
                        // Then
                        XCTAssertFalse(news.isEmpty, "News array should not be empty")
                        if let firstItem = news.first {
                            XCTAssertEqual(firstItem.id, "test-\(pageIndex)-\(pageSize)")
                            XCTAssertEqual(firstItem.title, "News Item Page \(pageIndex) Size \(pageSize)")
                        }
                        expectation.fulfill()
                    }
                )
                .store(in: &cancellables)
            
            wait(for: [expectation], timeout: 1.0)
        }
    }
    
    /// Test the end-to-end flow with mocked API response to final domain model
    func testEndToEndFlowWithMockedAPIResponse() throws {
        // Given
        let expectation = XCTestExpectation(description: "End-to-end flow completed")
        try registerMockNewsResponse()
        let contentProvider = createMockContentProvider()
        
        // Load the expected data for comparison
        let jsonData = try JSONLoader.loadJSON(
            fromSubdirectory: TestConfiguration.MockResponseDirectories.news,
            filename: "response.json"
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModels = try decoder.decode([GomaModels.NewsItemData].self, from: jsonData)
        let expectedDomainModels = GomaModelMapper.newsItems(fromInternalNewsItems: internalModels)
        
        // When
        contentProvider.getNews(pageIndex: 0, pageSize: 10)
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { news in
                    // Then
                    XCTAssertEqual(news.count, expectedDomainModels.count)
                    
                    // Compare each news item with its expected model
                    for (index, expectedItem) in expectedDomainModels.enumerated() {
                        let actualItem = news[index]
                        
                        XCTAssertEqual(actualItem.id, expectedItem.id)
                        XCTAssertEqual(actualItem.title, expectedItem.title)
                        XCTAssertEqual(actualItem.isActive, expectedItem.isActive)
                        XCTAssertEqual(actualItem.content, expectedItem.content)
                        XCTAssertEqual(actualItem.author, expectedItem.author)
                        XCTAssertEqual(actualItem.tags, expectedItem.tags)
                        
                        // Compare URLs
                        if let expectedImageURL = expectedItem.imageUrl {
                            XCTAssertEqual(actualItem.imageUrl?.absoluteString, expectedImageURL.absoluteString)
                        } else {
                            XCTAssertNil(actualItem.imageUrl)
                        }
                    }
                    
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    // MARK: - Helper Methods
    
    /// Register a mock response for the news endpoint with the specified pagination parameters
    private func registerMockNewsResponse(pageIndex: Int = 0, pageSize: Int = 10) throws {
        let jsonData = try JSONLoader.loadJSON(
            fromSubdirectory: TestConfiguration.MockResponseDirectories.news,
            filename: "response.json"
        )
        
        let url = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.news)?pageIndex=\(pageIndex)&pageSize=\(pageSize)")!
        MockURLProtocol.registerMockResponse(
            for: url,
            data: jsonData,
            statusCode: 200
        )
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/ProChoicesTests.swift
````swift
import XCTest
import Combine
@testable import ServicesProvider

/// Integration tests for the Pro Choices endpoint
class ProChoicesTests: BaseIntegrationTest {

    /// Test that GomaPromotionsAPIClient.proChoices endpoint builds the correct URL with query parameters
    func testProChoicesEndpointBuildsCorrectURL() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )

        // When
        let request = apiClient.proChoices()

        // Then
        XCTAssertEqual(
            request.url?.absoluteString,
            "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.proChoices)"
        )
    }

    /// Test that GomaPromotionsAPIClient.proChoices endpoint uses the correct HTTP method (GET)
    func testProChoicesEndpointUsesCorrectHTTPMethod() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )

        // When
        let request = apiClient.proChoices()

        // Then
        XCTAssertEqual(request.httpMethod, "GET")
    }

    /// Test that the JSON response for proChoices decodes to [GomaModels.ProChoiceData]
    func testProChoicesResponseDecodesToInternalModel() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.proChoices
        )

        // When
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let proChoices = try decoder.decode([GomaModels.ProChoiceData].self, from: jsonData)

        // Then
        XCTAssertNotNil(proChoices)
        XCTAssertFalse(proChoices.isEmpty, "Pro Choices array should not be empty")

        // Verify first pro choice has all required properties
        if let firstChoice = proChoices.first {
            XCTAssertNotNil(firstChoice.id)
            XCTAssertNotNil(firstChoice.tipster)
            XCTAssertNotNil(firstChoice.event)
            XCTAssertNotNil(firstChoice.selection)
            XCTAssertNotNil(firstChoice.status)
        }
    }

    /// Test that GomaModelMapper.proChoice transforms GomaModels.ProChoiceData to ProChoice correctly
    func testSingleProChoiceModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.proChoices
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let proChoices = try decoder.decode([GomaModels.ProChoiceData].self, from: jsonData)

        // Ensure we have at least one pro choice to test
        guard let internalModel = proChoices.first else {
            XCTFail("No pro choices found in test data")
            return
        }

        // When
        let domainModel = GomaModelMapper.proChoice(fromInternalProChoice: internalModel)

        // Then
        XCTAssertEqual(domainModel.id, internalModel.id)

        // Check isActive transformation
        if internalModel.status == "published" {
            XCTAssertTrue(domainModel.isActive)
        } else {
            XCTAssertFalse(domainModel.isActive)
        }

        // Check reasoning field
        XCTAssertEqual(domainModel.reasoning, internalModel.reasoning)
    }

    /// Test that GomaModelMapper.proChoices transforms array of GomaModels.ProChoiceData to [ProChoice] correctly
    func testProChoicesArrayModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.proChoices
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModels = try decoder.decode([GomaModels.ProChoiceData].self, from: jsonData)

        // When
        let domainModels = GomaModelMapper.proChoices(fromInternalProChoices: internalModels)

        // Then
        XCTAssertEqual(domainModels.count, internalModels.count, "Domain model count should match internal model count")

        // Check that each pro choice was transformed correctly
        for (index, internalModel) in internalModels.enumerated() {
            let domainModel = domainModels[index]

            XCTAssertEqual(domainModel.id, internalModel.id)
            XCTAssertEqual(domainModel.reasoning, internalModel.reasoning)

            // Check isActive transformation
            if internalModel.status == "published" {
                XCTAssertTrue(domainModel.isActive)
            } else {
                XCTAssertFalse(domainModel.isActive)
            }
        }
    }

    /// Test tipster data mapping (id, name, winRate, avatar)
    func testTipsterDataMapping() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.proChoices
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let proChoices = try decoder.decode([GomaModels.ProChoiceData].self, from: jsonData)

        // Ensure we have at least one pro choice with tipster data to test
        guard let internalModel = proChoices.first, let tipsterData = internalModel.tipster else {
            XCTFail("No pro choices with tipster data found in test data")
            return
        }

        // When
        let domainModel = GomaModelMapper.proChoice(fromInternalProChoice: internalModel)

        // Then
        XCTAssertNotNil(domainModel.tipster)
        XCTAssertEqual(domainModel.tipster.id, tipsterData.id)
        XCTAssertEqual(domainModel.tipster.name, tipsterData.name)
        XCTAssertEqual(domainModel.tipster.winRate, tipsterData.winRate)

        // Check avatar URL transformation
        if let avatarUrl = tipsterData.avatarUrl {
            XCTAssertEqual(domainModel.tipster.avatarUrl?.absoluteString, avatarUrl)
        } else {
            XCTAssertNil(domainModel.tipster.avatarUrl)
        }
    }

    /// Test event summary mapping (id, homeTeam, awayTeam, dateTime)
    func testEventSummaryMapping() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.proChoices
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let proChoices = try decoder.decode([GomaModels.ProChoiceData].self, from: jsonData)

        // Ensure we have at least one pro choice with event data to test
        guard let internalModel = proChoices.first, let eventData = internalModel.event else {
            XCTFail("No pro choices with event data found in test data")
            return
        }

        // When
        let domainModel = GomaModelMapper.proChoice(fromInternalProChoice: internalModel)

        // Then
        XCTAssertNotNil(domainModel.event)
        XCTAssertEqual(domainModel.event.id, eventData.id)

        // Check teams data
        if let homeTeam = eventData.homeTeam, let awayTeam = eventData.awayTeam {
            XCTAssertEqual(domainModel.event.homeTeam.id, homeTeam.id)
            XCTAssertEqual(domainModel.event.homeTeam.name, homeTeam.name)
            XCTAssertEqual(domainModel.event.awayTeam.id, awayTeam.id)
            XCTAssertEqual(domainModel.event.awayTeam.name, awayTeam.name)
        }

        // Check date transformation
        if let dateTimeString = eventData.dateTime {
            let dateFormatter = ISO8601DateFormatter()
            let expectedDate = dateFormatter.date(from: dateTimeString)
            XCTAssertEqual(domainModel.event.dateTime, expectedDate)
        } else {
            XCTAssertNil(domainModel.event.dateTime)
        }
    }

    /// Test selection mapping (marketName, outcomeName, odds)
    func testSelectionMapping() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.proChoices
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let proChoices = try decoder.decode([GomaModels.ProChoiceData].self, from: jsonData)

        // Ensure we have at least one pro choice with selection data to test
        guard let internalModel = proChoices.first, let selectionData = internalModel.selection else {
            XCTFail("No pro choices with selection data found in test data")
            return
        }

        // When
        let domainModel = GomaModelMapper.proChoice(fromInternalProChoice: internalModel)

        // Then
        XCTAssertNotNil(domainModel.selection)
        XCTAssertEqual(domainModel.selection.marketName, selectionData.marketName)
        XCTAssertEqual(domainModel.selection.outcomeName, selectionData.outcomeName)
        XCTAssertEqual(domainModel.selection.odds, selectionData.odds)
    }

    /// Test reasoning field is correctly mapped
    func testReasoningFieldIsCorrectlyMapped() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.proChoices
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let proChoices = try decoder.decode([GomaModels.ProChoiceData].self, from: jsonData)

        // Ensure we have at least one pro choice to test
        guard let internalModel = proChoices.first else {
            XCTFail("No pro choices found in test data")
            return
        }

        // When
        let domainModel = GomaModelMapper.proChoice(fromInternalProChoice: internalModel)

        // Then
        XCTAssertEqual(domainModel.reasoning, internalModel.reasoning)
    }

    /// Test URL construction for tipster avatar
    func testURLConstructionForTipsterAvatar() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.proChoices
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let proChoices = try decoder.decode([GomaModels.ProChoiceData].self, from: jsonData)

        // Ensure we have at least one pro choice with tipster data to test
        guard let internalModel = proChoices.first, let tipsterData = internalModel.tipster else {
            XCTFail("No pro choices with tipster data found in test data")
            return
        }

        // When
        let domainModel = GomaModelMapper.proChoice(fromInternalProChoice: internalModel)

        // Then
        if let avatarUrl = tipsterData.avatarUrl {
            XCTAssertEqual(domainModel.tipster.avatarUrl?.absoluteString, avatarUrl)
        } else {
            XCTAssertNil(domainModel.tipster.avatarUrl)
        }
    }

    /// Test that GomaManagedContentProvider.getProChoices() calls the correct API endpoint
    func testGetProChoicesCallsCorrectAPIEndpoint() throws {
        // Given
        let expectation = XCTestExpectation(description: "API call made")
        try registerMockProChoicesResponse()
        let contentProvider = createMockContentProvider()

        // When
        contentProvider.getProChoices()
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { _ in
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)

        // Then
        wait(for: [expectation], timeout: 1.0)
        XCTAssertTrue(MockURLProtocol.requestsForEndpoint(TestConfiguration.EndpointPaths.proChoices).count > 0)
    }

    /// Test that GomaManagedContentProvider.getProChoices() handles successful responses
    func testGetProChoicesHandlesSuccessfulResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received pro choices")
        try registerMockProChoicesResponse()
        let contentProvider = createMockContentProvider()

        // When
        contentProvider.getProChoices()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { proChoices in
                    // Then
                    XCTAssertNotNil(proChoices)
                    XCTAssertFalse(proChoices.isEmpty, "Pro Choices array should not be empty")
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)

        wait(for: [expectation], timeout: 1.0)
    }

    /// Test that GomaManagedContentProvider.getProChoices() handles error responses
    func testGetProChoicesHandlesErrorResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received error")

        // Register a mock error response
        let errorURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.proChoices)")!
        MockURLProtocol.registerMockResponse(
            for: errorURL,
            data: "Internal Server Error".data(using: .utf8)!,
            statusCode: 500
        )

        let contentProvider = createMockContentProvider()

        // When
        contentProvider.getProChoices()
            .sink(
                receiveCompletion: { completion in
                    if case .failure(let error) = completion {
                        // Then
                        XCTAssertNotNil(error)
                        expectation.fulfill()
                    }
                },
                receiveValue: { _ in
                    XCTFail("Should not receive a value")
                }
            )
            .store(in: &cancellables)

        wait(for: [expectation], timeout: 1.0)
    }

    /// Test that GomaManagedContentProvider.getProChoices() handles empty array responses
    func testGetProChoicesHandlesEmptyArrayResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received empty array")

        // Register a mock empty array response
        let emptyURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.proChoices)")!
        MockURLProtocol.registerMockResponse(
            for: emptyURL,
            data: "[]".data(using: .utf8)!,
            statusCode: 200
        )

        let contentProvider = createMockContentProvider()

        // When
        contentProvider.getProChoices()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Empty array should not cause failure")
                    }
                },
                receiveValue: { proChoices in
                    // Then
                    XCTAssertTrue(proChoices.isEmpty, "Pro Choices array should be empty")
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)

        wait(for: [expectation], timeout: 1.0)
    }

    /// Test the end-to-end flow with mocked API response to final domain model
    func testEndToEndFlowWithMockedAPIResponse() throws {
        // Given
        let expectation = XCTestExpectation(description: "End-to-end flow completed")
        try registerMockProChoicesResponse()
        let contentProvider = createMockContentProvider()

        // Load the expected data for comparison
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.proChoices
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModels = try decoder.decode([GomaModels.ProChoiceData].self, from: jsonData)
        let expectedDomainModels = GomaModelMapper.proChoices(fromInternalProChoices: internalModels)

        // When
        contentProvider.getProChoices()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { proChoices in
                    // Then
                    XCTAssertEqual(proChoices.count, expectedDomainModels.count)

                    // Compare each pro choice with its expected model
                    for (index, expectedChoice) in expectedDomainModels.enumerated() {
                        let actualChoice = proChoices[index]

                        XCTAssertEqual(actualChoice.id, expectedChoice.id)
                        XCTAssertEqual(actualChoice.isActive, expectedChoice.isActive)
                        XCTAssertEqual(actualChoice.reasoning, expectedChoice.reasoning)

                        // Compare tipster data
                        XCTAssertEqual(actualChoice.tipster.id, expectedChoice.tipster.id)
                        XCTAssertEqual(actualChoice.tipster.name, expectedChoice.tipster.name)
                        XCTAssertEqual(actualChoice.tipster.winRate, expectedChoice.tipster.winRate)

                        if let expectedAvatarURL = expectedChoice.tipster.avatarUrl {
                            XCTAssertEqual(actualChoice.tipster.avatarUrl?.absoluteString, expectedAvatarURL.absoluteString)
                        } else {
                            XCTAssertNil(actualChoice.tipster.avatarUrl)
                        }

                        // Compare event data
                        XCTAssertEqual(actualChoice.event.id, expectedChoice.event.id)
                        XCTAssertEqual(actualChoice.event.homeTeam.id, expectedChoice.event.homeTeam.id)
                        XCTAssertEqual(actualChoice.event.homeTeam.name, expectedChoice.event.homeTeam.name)
                        XCTAssertEqual(actualChoice.event.awayTeam.id, expectedChoice.event.awayTeam.id)
                        XCTAssertEqual(actualChoice.event.awayTeam.name, expectedChoice.event.awayTeam.name)

                        if let expectedDate = expectedChoice.event.dateTime {
                            XCTAssertEqual(actualChoice.event.dateTime, expectedDate)
                        } else {
                            XCTAssertNil(actualChoice.event.dateTime)
                        }

                        // Compare selection data
                        XCTAssertEqual(actualChoice.selection.marketName, expectedChoice.selection.marketName)
                        XCTAssertEqual(actualChoice.selection.outcomeName, expectedChoice.selection.outcomeName)
                        XCTAssertEqual(actualChoice.selection.odds, expectedChoice.selection.odds)
                    }

                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)

        wait(for: [expectation], timeout: 1.0)
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/SportBannersTests.swift
````swift
import XCTest
import Combine
@testable import ServicesProvider

/// Integration tests for the Sport Banners endpoint
class SportBannersTests: BaseIntegrationTest {
    
    /// Test that GomaPromotionsAPIClient.sportBanners endpoint builds the correct URL with query parameters
    func testSportBannersEndpointBuildsCorrectURL() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // When
        let request = apiClient.sportBanners()
        
        // Then
        XCTAssertEqual(
            request.url?.absoluteString,
            "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.sportBanners)"
        )
    }
    
    /// Test that GomaPromotionsAPIClient.sportBanners endpoint uses the correct HTTP method (GET)
    func testSportBannersEndpointUsesCorrectHTTPMethod() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )
        
        // When
        let request = apiClient.sportBanners()
        
        // Then
        XCTAssertEqual(request.httpMethod, "GET")
    }
    
    /// Test that the JSON response for sportBanners decodes to [GomaModels.SportBannerData]
    func testSportBannersResponseDecodesToInternalModel() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.sportBanners
        )
        
        // When
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let sportBanners = try decoder.decode([GomaModels.SportBannerData].self, from: jsonData)
        
        // Then
        XCTAssertNotNil(sportBanners)
        XCTAssertFalse(sportBanners.isEmpty, "Sport Banners array should not be empty")
        
        // Verify first sport banner has all required properties
        if let firstBanner = sportBanners.first {
            XCTAssertNotNil(firstBanner.id)
            XCTAssertNotNil(firstBanner.title)
            XCTAssertNotNil(firstBanner.imageUrl)
            XCTAssertNotNil(firstBanner.status)
            XCTAssertNotNil(firstBanner.event)
        }
    }
    
    /// Test that GomaModelMapper.sportBanner transforms GomaModels.SportBannerData to SportBanner correctly
    func testSingleSportBannerModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.sportBanners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let sportBanners = try decoder.decode([GomaModels.SportBannerData].self, from: jsonData)
        
        // Ensure we have at least one sport banner to test
        guard let internalModel = sportBanners.first else {
            XCTFail("No sport banners found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.sportBanner(fromInternalSportBanner: internalModel)
        
        // Then
        XCTAssertEqual(domainModel.id, internalModel.id)
        XCTAssertEqual(domainModel.title, internalModel.title)
        
        // Check URL transformation
        if let imageUrl = internalModel.imageUrl {
            XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
        } else {
            XCTAssertNil(domainModel.imageUrl)
        }
        
        // Check action URL transformation
        if let actionUrl = internalModel.actionUrl {
            XCTAssertEqual(domainModel.actionUrl?.absoluteString, actionUrl)
        } else {
            XCTAssertNil(domainModel.actionUrl)
        }
        
        // Check isActive transformation
        if internalModel.status == "published" {
            XCTAssertTrue(domainModel.isActive)
        } else {
            XCTAssertFalse(domainModel.isActive)
        }
    }
    
    /// Test that GomaModelMapper.sportBanners transforms array of GomaModels.SportBannerData to [SportBanner] correctly
    func testSportBannersArrayModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.sportBanners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModels = try decoder.decode([GomaModels.SportBannerData].self, from: jsonData)
        
        // When
        let domainModels = GomaModelMapper.sportBanners(fromInternalSportBanners: internalModels)
        
        // Then
        XCTAssertEqual(domainModels.count, internalModels.count, "Domain model count should match internal model count")
        
        // Check that each sport banner was transformed correctly
        for (index, internalModel) in internalModels.enumerated() {
            let domainModel = domainModels[index]
            
            XCTAssertEqual(domainModel.id, internalModel.id)
            XCTAssertEqual(domainModel.title, internalModel.title)
            
            // Check URL transformation
            if let imageUrl = internalModel.imageUrl {
                XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
            } else {
                XCTAssertNil(domainModel.imageUrl)
            }
        }
    }
    
    /// Test nested SportEventData mapping to SportEventSummary
    func testNestedSportEventDataMapping() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.sportBanners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let sportBanners = try decoder.decode([GomaModels.SportBannerData].self, from: jsonData)
        
        // Ensure we have at least one sport banner with event data to test
        guard let internalModel = sportBanners.first, let eventData = internalModel.event else {
            XCTFail("No sport banners with event data found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.sportBanner(fromInternalSportBanner: internalModel)
        
        // Then
        XCTAssertNotNil(domainModel.event)
        XCTAssertEqual(domainModel.event?.id, eventData.id)
        XCTAssertEqual(domainModel.event?.sportId, eventData.sportId)
        XCTAssertEqual(domainModel.event?.competitionId, eventData.competitionId)
        
        // Check date transformation
        if let dateTimeString = eventData.dateTime {
            let dateFormatter = ISO8601DateFormatter()
            let expectedDate = dateFormatter.date(from: dateTimeString)
            XCTAssertEqual(domainModel.event?.dateTime, expectedDate)
        } else {
            XCTAssertNil(domainModel.event?.dateTime)
        }
    }
    
    /// Test team data mapping for home and away teams
    func testTeamDataMapping() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.sportBanners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let sportBanners = try decoder.decode([GomaModels.SportBannerData].self, from: jsonData)
        
        // Ensure we have at least one sport banner with event data to test
        guard let internalModel = sportBanners.first, 
              let eventData = internalModel.event,
              let homeTeam = eventData.homeTeam,
              let awayTeam = eventData.awayTeam else {
            XCTFail("No sport banners with complete team data found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.sportBanner(fromInternalSportBanner: internalModel)
        
        // Then
        XCTAssertNotNil(domainModel.event?.homeTeam)
        XCTAssertNotNil(domainModel.event?.awayTeam)
        
        // Check home team mapping
        XCTAssertEqual(domainModel.event?.homeTeam.id, homeTeam.id)
        XCTAssertEqual(domainModel.event?.homeTeam.name, homeTeam.name)
        
        // Check away team mapping
        XCTAssertEqual(domainModel.event?.awayTeam.id, awayTeam.id)
        XCTAssertEqual(domainModel.event?.awayTeam.name, awayTeam.name)
    }
    
    /// Test URL construction for imageUrl and team logo URLs
    func testURLConstructionForImageAndLogoUrls() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.sportBanners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let sportBanners = try decoder.decode([GomaModels.SportBannerData].self, from: jsonData)
        
        // Ensure we have at least one sport banner with event data to test
        guard let internalModel = sportBanners.first, 
              let eventData = internalModel.event,
              let homeTeam = eventData.homeTeam,
              let awayTeam = eventData.awayTeam else {
            XCTFail("No sport banners with complete team data found in test data")
            return
        }
        
        // When
        let domainModel = GomaModelMapper.sportBanner(fromInternalSportBanner: internalModel)
        
        // Then
        // Check banner image URL
        if let imageUrl = internalModel.imageUrl {
            XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
        } else {
            XCTAssertNil(domainModel.imageUrl)
        }
        
        // Check home team logo URL
        if let logoUrl = homeTeam.logoUrl {
            XCTAssertEqual(domainModel.event?.homeTeam.logoUrl?.absoluteString, logoUrl)
        } else {
            XCTAssertNil(domainModel.event?.homeTeam.logoUrl)
        }
        
        // Check away team logo URL
        if let logoUrl = awayTeam.logoUrl {
            XCTAssertEqual(domainModel.event?.awayTeam.logoUrl?.absoluteString, logoUrl)
        } else {
            XCTAssertNil(domainModel.event?.awayTeam.logoUrl)
        }
    }
    
    /// Test that GomaManagedContentProvider.getSportBanners() calls the correct API endpoint
    func testGetSportBannersCallsCorrectAPIEndpoint() throws {
        // Given
        let expectation = XCTestExpectation(description: "API call made")
        try registerMockSportBannersResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getSportBanners()
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { _ in
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        // Then
        wait(for: [expectation], timeout: 1.0)
        XCTAssertTrue(MockURLProtocol.requestsForEndpoint(TestConfiguration.EndpointPaths.sportBanners).count > 0)
    }
    
    /// Test that GomaManagedContentProvider.getSportBanners() handles successful responses
    func testGetSportBannersHandlesSuccessfulResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received sport banners")
        try registerMockSportBannersResponse()
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getSportBanners()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { sportBanners in
                    // Then
                    XCTAssertNotNil(sportBanners)
                    XCTAssertFalse(sportBanners.isEmpty, "Sport Banners array should not be empty")
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test that GomaManagedContentProvider.getSportBanners() handles error responses
    func testGetSportBannersHandlesErrorResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received error")
        
        // Register a mock error response
        let errorURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.sportBanners)")!
        MockURLProtocol.registerMockResponse(
            for: errorURL,
            data: "Internal Server Error".data(using: .utf8)!,
            statusCode: 500
        )
        
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getSportBanners()
            .sink(
                receiveCompletion: { completion in
                    if case .failure(let error) = completion {
                        // Then
                        XCTAssertNotNil(error)
                        expectation.fulfill()
                    }
                },
                receiveValue: { _ in
                    XCTFail("Should not receive a value")
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test that GomaManagedContentProvider.getSportBanners() handles empty array responses
    func testGetSportBannersHandlesEmptyArrayResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received empty array")
        
        // Register a mock empty array response
        let emptyURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.sportBanners)")!
        MockURLProtocol.registerMockResponse(
            for: emptyURL,
            data: "[]".data(using: .utf8)!,
            statusCode: 200
        )
        
        let contentProvider = createMockContentProvider()
        
        // When
        contentProvider.getSportBanners()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Empty array should not cause failure")
                    }
                },
                receiveValue: { sportBanners in
                    // Then
                    XCTAssertTrue(sportBanners.isEmpty, "Sport Banners array should be empty")
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
    
    /// Test the end-to-end flow with mocked API response to final domain model
    func testEndToEndFlowWithMockedAPIResponse() throws {
        // Given
        let expectation = XCTestExpectation(description: "End-to-end flow completed")
        try registerMockSportBannersResponse()
        let contentProvider = createMockContentProvider()
        
        // Load the expected data for comparison
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.sportBanners
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModels = try decoder.decode([GomaModels.SportBannerData].self, from: jsonData)
        let expectedDomainModels = GomaModelMapper.sportBanners(fromInternalSportBanners: internalModels)
        
        // When
        contentProvider.getSportBanners()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { sportBanners in
                    // Then
                    XCTAssertEqual(sportBanners.count, expectedDomainModels.count)
                    
                    // Compare each sport banner with its expected model
                    for (index, expectedBanner) in expectedDomainModels.enumerated() {
                        let actualBanner = sportBanners[index]
                        
                        XCTAssertEqual(actualBanner.id, expectedBanner.id)
                        XCTAssertEqual(actualBanner.title, expectedBanner.title)
                        XCTAssertEqual(actualBanner.isActive, expectedBanner.isActive)
                        
                        // Compare URLs
                        if let expectedImageURL = expectedBanner.imageUrl {
                            XCTAssertEqual(actualBanner.imageUrl?.absoluteString, expectedImageURL.absoluteString)
                        } else {
                            XCTAssertNil(actualBanner.imageUrl)
                        }
                        
                        if let expectedActionURL = expectedBanner.actionUrl {
                            XCTAssertEqual(actualBanner.actionUrl?.absoluteString, expectedActionURL.absoluteString)
                        } else {
                            XCTAssertNil(actualBanner.actionUrl)
                        }
                        
                        // Compare event data if present
                        if let expectedEvent = expectedBanner.event, let actualEvent = actualBanner.event {
                            XCTAssertEqual(actualEvent.id, expectedEvent.id)
                            XCTAssertEqual(actualEvent.sportId, expectedEvent.sportId)
                            XCTAssertEqual(actualEvent.competitionId, expectedEvent.competitionId)
                            
                            // Compare teams
                            XCTAssertEqual(actualEvent.homeTeam.id, expectedEvent.homeTeam.id)
                            XCTAssertEqual(actualEvent.homeTeam.name, expectedEvent.homeTeam.name)
                            XCTAssertEqual(actualEvent.awayTeam.id, expectedEvent.awayTeam.id)
                            XCTAssertEqual(actualEvent.awayTeam.name, expectedEvent.awayTeam.name)
                            
                            // Compare team logo URLs
                            if let expectedHomeLogoURL = expectedEvent.homeTeam.logoUrl {
                                XCTAssertEqual(actualEvent.homeTeam.logoUrl?.absoluteString, expectedHomeLogoURL.absoluteString)
                            } else {
                                XCTAssertNil(actualEvent.homeTeam.logoUrl)
                            }
                            
                            if let expectedAwayLogoURL = expectedEvent.awayTeam.logoUrl {
                                XCTAssertEqual(actualEvent.awayTeam.logoUrl?.absoluteString, expectedAwayLogoURL.absoluteString)
                            } else {
                                XCTAssertNil(actualEvent.awayTeam.logoUrl)
                            }
                            
                            // Compare date
                            if let expectedDate = expectedEvent.dateTime {
                                XCTAssertEqual(actualEvent.dateTime, expectedDate)
                            } else {
                                XCTAssertNil(actualEvent.dateTime)
                            }
                        } else {
                            XCTAssertEqual(actualBanner.event == nil, expectedBanner.event == nil)
                        }
                    }
                    
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)
        
        wait(for: [expectation], timeout: 1.0)
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Integration/StoriesTests.swift
````swift
import XCTest
import Combine
@testable import ServicesProvider

/// Integration tests for the Stories endpoint
class StoriesTests: BaseIntegrationTest {

    /// Test that GomaPromotionsAPIClient.stories endpoint builds the correct URL with query parameters
    func testStoriesEndpointBuildsCorrectURL() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )

        // When
        let request = apiClient.stories()

        // Then
        XCTAssertEqual(
            request.url?.absoluteString,
            "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.stories)"
        )
    }

    /// Test that GomaPromotionsAPIClient.stories endpoint uses the correct HTTP method (GET)
    func testStoriesEndpointUsesCorrectHTTPMethod() {
        // Given
        let apiClient = GomaPromotionsAPIClient(
            baseURL: URL(string: TestConfiguration.API.baseURL)!,
            apiKey: TestConfiguration.API.apiKey,
            session: mockURLSession
        )

        // When
        let request = apiClient.stories()

        // Then
        XCTAssertEqual(request.httpMethod, "GET")
    }

    /// Test that the JSON response for stories decodes to [GomaModels.StoryData]
    func testStoriesResponseDecodesToInternalModel() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.stories
        )

        // When
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let stories = try decoder.decode([GomaModels.StoryData].self, from: jsonData)

        // Then
        XCTAssertNotNil(stories)
        XCTAssertFalse(stories.isEmpty, "Stories array should not be empty")

        // Verify first story has all required properties
        if let firstStory = stories.first {
            XCTAssertNotNil(firstStory.id)
            XCTAssertNotNil(firstStory.title)
            XCTAssertNotNil(firstStory.imageUrl)
            XCTAssertNotNil(firstStory.status)
            XCTAssertNotNil(firstStory.content)
        }
    }

    /// Test that GomaModelMapper.story transforms GomaModels.StoryData to Story correctly
    func testSingleStoryModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.stories
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let stories = try decoder.decode([GomaModels.StoryData].self, from: jsonData)

        // Ensure we have at least one story to test
        guard let internalModel = stories.first else {
            XCTFail("No stories found in test data")
            return
        }

        // When
        let domainModel = GomaModelMapper.story(fromInternalStory: internalModel)

        // Then
        XCTAssertEqual(domainModel.id, internalModel.id)
        XCTAssertEqual(domainModel.title, internalModel.title)

        // Check URL transformation
        if let imageUrl = internalModel.imageUrl {
            XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
        } else {
            XCTAssertNil(domainModel.imageUrl)
        }

        // Check isActive transformation
        if internalModel.status == "published" {
            XCTAssertTrue(domainModel.isActive)
        } else {
            XCTAssertFalse(domainModel.isActive)
        }
    }

    /// Test that GomaModelMapper.stories transforms array of GomaModels.StoryData to [Story] correctly
    func testStoriesArrayModelMapperTransformsCorrectly() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.stories
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModels = try decoder.decode([GomaModels.StoryData].self, from: jsonData)

        // When
        let domainModels = GomaModelMapper.stories(fromInternalStories: internalModels)

        // Then
        XCTAssertEqual(domainModels.count, internalModels.count, "Domain model count should match internal model count")

        // Check that each story was transformed correctly
        for (index, internalModel) in internalModels.enumerated() {
            let domainModel = domainModels[index]

            XCTAssertEqual(domainModel.id, internalModel.id)
            XCTAssertEqual(domainModel.title, internalModel.title)

            // Check URL transformation
            if let imageUrl = internalModel.imageUrl {
                XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
            } else {
                XCTAssertNil(domainModel.imageUrl)
            }
        }
    }

    /// Test content field is correctly mapped
    func testContentFieldIsCorrectlyMapped() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.stories
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let stories = try decoder.decode([GomaModels.StoryData].self, from: jsonData)

        // Ensure we have at least one story to test
        guard let internalModel = stories.first else {
            XCTFail("No stories found in test data")
            return
        }

        // When
        let domainModel = GomaModelMapper.story(fromInternalStory: internalModel)

        // Then
        XCTAssertEqual(domainModel.content, internalModel.content)
    }

    /// Test duration field is correctly mapped
    func testDurationFieldIsCorrectlyMapped() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.stories
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let stories = try decoder.decode([GomaModels.StoryData].self, from: jsonData)

        // Ensure we have at least one story to test
        guard let internalModel = stories.first else {
            XCTFail("No stories found in test data")
            return
        }

        // When
        let domainModel = GomaModelMapper.story(fromInternalStory: internalModel)

        // Then
        XCTAssertEqual(domainModel.duration, internalModel.duration)
    }

    /// Test URL construction for imageUrl field
    func testURLConstructionForImageUrl() throws {
        // Given
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.stories
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let stories = try decoder.decode([GomaModels.StoryData].self, from: jsonData)

        // Ensure we have at least one story to test
        guard let internalModel = stories.first else {
            XCTFail("No stories found in test data")
            return
        }

        // When
        let domainModel = GomaModelMapper.story(fromInternalStory: internalModel)

        // Then
        if let imageUrl = internalModel.imageUrl {
            XCTAssertEqual(domainModel.imageUrl?.absoluteString, imageUrl)
        } else {
            XCTAssertNil(domainModel.imageUrl)
        }
    }

    /// Test that GomaManagedContentProvider.getStories() calls the correct API endpoint
    func testGetStoriesCallsCorrectAPIEndpoint() throws {
        // Given
        let expectation = XCTestExpectation(description: "API call made")
        try registerMockStoriesResponse()
        let contentProvider = createMockContentProvider()

        // When
        contentProvider.getStories()
            .sink(
                receiveCompletion: { _ in },
                receiveValue: { _ in
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)

        // Then
        wait(for: [expectation], timeout: 1.0)
        XCTAssertTrue(MockURLProtocol.requestsForEndpoint(TestConfiguration.EndpointPaths.stories).count > 0)
    }

    /// Test that GomaManagedContentProvider.getStories() handles successful responses
    func testGetStoriesHandlesSuccessfulResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received stories")
        try registerMockStoriesResponse()
        let contentProvider = createMockContentProvider()

        // When
        contentProvider.getStories()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { stories in
                    // Then
                    XCTAssertNotNil(stories)
                    XCTAssertFalse(stories.isEmpty, "Stories array should not be empty")
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)

        wait(for: [expectation], timeout: 1.0)
    }

    /// Test that GomaManagedContentProvider.getStories() handles error responses
    func testGetStoriesHandlesErrorResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received error")

        // Register a mock error response
        let errorURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.stories)")!
        MockURLProtocol.registerMockResponse(
            for: errorURL,
            data: "Internal Server Error".data(using: .utf8)!,
            statusCode: 500
        )

        let contentProvider = createMockContentProvider()

        // When
        contentProvider.getStories()
            .sink(
                receiveCompletion: { completion in
                    if case .failure(let error) = completion {
                        // Then
                        XCTAssertNotNil(error)
                        expectation.fulfill()
                    }
                },
                receiveValue: { _ in
                    XCTFail("Should not receive a value")
                }
            )
            .store(in: &cancellables)

        wait(for: [expectation], timeout: 1.0)
    }

    /// Test that GomaManagedContentProvider.getStories() handles empty array responses
    func testGetStoriesHandlesEmptyArrayResponses() throws {
        // Given
        let expectation = XCTestExpectation(description: "Received empty array")

        // Register a mock empty array response
        let emptyURL = URL(string: "\(TestConfiguration.API.baseURL)\(TestConfiguration.EndpointPaths.stories)")!
        MockURLProtocol.registerMockResponse(
            for: emptyURL,
            data: "[]".data(using: .utf8)!,
            statusCode: 200
        )

        let contentProvider = createMockContentProvider()

        // When
        contentProvider.getStories()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Empty array should not cause failure")
                    }
                },
                receiveValue: { stories in
                    // Then
                    XCTAssertTrue(stories.isEmpty, "Stories array should be empty")
                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)

        wait(for: [expectation], timeout: 1.0)
    }

    /// Test the end-to-end flow with mocked API response to final domain model
    func testEndToEndFlowWithMockedAPIResponse() throws {
        // Given
        let expectation = XCTestExpectation(description: "End-to-end flow completed")
        try registerMockStoriesResponse()
        let contentProvider = createMockContentProvider()

        // Load the expected data for comparison
        let jsonData = try JSONLoader.loadJSON(
            fileName: "response.json",
            subdirectory: TestConfiguration.MockResponseDirectories.stories
        )
        let decoder = JSONDecoder()
        decoder.keyDecodingStrategy = .convertFromSnakeCase
        let internalModels = try decoder.decode([GomaModels.StoryData].self, from: jsonData)
        let expectedDomainModels = GomaModelMapper.stories(fromInternalStories: internalModels)

        // When
        contentProvider.getStories()
            .sink(
                receiveCompletion: { completion in
                    if case .failure = completion {
                        XCTFail("Should not fail")
                    }
                },
                receiveValue: { stories in
                    // Then
                    XCTAssertEqual(stories.count, expectedDomainModels.count)

                    // Compare each story with its expected model
                    for (index, expectedStory) in expectedDomainModels.enumerated() {
                        let actualStory = stories[index]

                        XCTAssertEqual(actualStory.id, expectedStory.id)
                        XCTAssertEqual(actualStory.title, expectedStory.title)
                        XCTAssertEqual(actualStory.isActive, expectedStory.isActive)
                        XCTAssertEqual(actualStory.content, expectedStory.content)
                        XCTAssertEqual(actualStory.duration, expectedStory.duration)

                        // Compare URLs
                        if let expectedImageURL = expectedStory.imageUrl {
                            XCTAssertEqual(actualStory.imageUrl?.absoluteString, expectedImageURL.absoluteString)
                        } else {
                            XCTAssertNil(actualStory.imageUrl)
                        }
                    }

                    expectation.fulfill()
                }
            )
            .store(in: &cancellables)

        wait(for: [expectation], timeout: 1.0)
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Models/Mappers/GomaModelMapperPromotionsTests.swift
````swift
import XCTest
@testable import ServicesProvider

final class GomaModelMapperPromotionsTests: XCTestCase {
    
    // MARK: - Home Template Tests
    
    func testHomeTemplateMapping() {
        // Given
        let internalWidget = GomaModels.HomeWidget(
            id: "1",
            type: "banners",
            description: "Test Banner Widget",
            userType: "any",
            sortOrder: 1,
            orientation: "horizontal"
        )
        
        let internalTemplate = GomaModels.HomeTemplate(
            id: 101,
            type: "home",
            widgets: [internalWidget]
        )
        
        // When
        let result = GomaModelMapper.homeTemplate(fromInternalHomeTemplate: internalTemplate)
        
        // Then
        XCTAssertEqual(result.id, 101)
        XCTAssertEqual(result.type, "home")
        XCTAssertEqual(result.widgets.count, 1)
        
        if case let .banners(widgetData) = result.widgets.first! {
            XCTAssertEqual(widgetData.id, 1)
            XCTAssertEqual(widgetData.type, "banners")
            XCTAssertEqual(widgetData.description, "Test Banner Widget")
            XCTAssertEqual(widgetData.userState, .any)
            XCTAssertEqual(widgetData.sortOrder, 1)
            XCTAssertEqual(widgetData.orientation, .horizontal)
        } else {
            XCTFail("Wrong widget type")
        }
    }
    
    // MARK: - Alert Banner Tests
    
    func testAlertBannerMapping() {
        // Given
        let internalBanner = GomaModels.AlertBannerData(
            id: 123,
            title: "Alert Title",
            content: "Alert Content",
            backgroundColor: "#FF0000",
            textColor: "#FFFFFF",
            actionType: "deeplink",
            actionTarget: "app://promo/1",
            startDate: "2024-05-10T10:00:00Z",
            endDate: "2024-05-20T10:00:00Z",
            status: "active",
            imageUrl: "https://example.com/image.jpg"
        )
        
        // When
        let result = GomaModelMapper.alertBanner(fromInternalAlertBanner: internalBanner)
        
        // Then
        XCTAssertEqual(result.id, "123")
        XCTAssertEqual(result.title, "Alert Title")
        XCTAssertNil(result.subtitle)
        XCTAssertEqual(result.content, "Alert Content")
        XCTAssertEqual(result.backgroundColor, "#FF0000")
        XCTAssertEqual(result.textColor, "#FFFFFF")
        XCTAssertNil(result.callToActionText)
        XCTAssertEqual(result.actionType, "deeplink")
        XCTAssertEqual(result.actionTarget, "app://promo/1")
        XCTAssertTrue(result.isActive)
        XCTAssertEqual(result.status, "active")
        XCTAssertEqual(result.imageUrl?.absoluteString, "https://example.com/image.jpg")
    }
    
    // MARK: - Banner Tests
    
    func testBannerMapping() {
        // Given
        let internalBanner = GomaModels.BannerData(
            id: 456,
            title: "Banner Title",
            subtitle: "Banner Subtitle",
            actionType: "url",
            actionTarget: "https://example.com",
            startDate: "2024-05-10T10:00:00Z",
            endDate: "2024-05-20T10:00:00Z",
            status: "active",
            imageUrl: "https://example.com/banner.jpg"
        )
        
        // When
        let result = GomaModelMapper.banner(fromInternalBanner: internalBanner)
        
        // Then
        XCTAssertEqual(result.id, "456")
        XCTAssertEqual(result.title, "Banner Title")
        XCTAssertEqual(result.subtitle, "Banner Subtitle")
        XCTAssertEqual(result.actionType, "url")
        XCTAssertEqual(result.actionTarget, "https://example.com")
        XCTAssertNil(result.callToActionText)
        XCTAssertTrue(result.isActive)
        XCTAssertEqual(result.status, "active")
        XCTAssertEqual(result.imageUrl?.absoluteString, "https://example.com/banner.jpg")
    }
    
    func testBannersMapping() {
        // Given
        let internalBanners = [
            GomaModels.BannerData(
                id: 456,
                title: "Banner Title 1",
                subtitle: "Banner Subtitle 1",
                actionType: "url",
                actionTarget: "https://example.com/1",
                startDate: "2024-05-10T10:00:00Z",
                endDate: "2024-05-20T10:00:00Z",
                status: "active",
                imageUrl: "https://example.com/banner1.jpg"
            ),
            GomaModels.BannerData(
                id: 457,
                title: "Banner Title 2",
                subtitle: "Banner Subtitle 2",
                actionType: "deeplink",
                actionTarget: "app://promo/2",
                startDate: "2024-05-10T10:00:00Z",
                endDate: "2024-05-20T10:00:00Z",
                status: "inactive",
                imageUrl: nil
            )
        ]
        
        // When
        let results = GomaModelMapper.banners(fromInternalBanners: internalBanners)
        
        // Then
        XCTAssertEqual(results.count, 2)
        XCTAssertEqual(results[0].id, "456")
        XCTAssertEqual(results[0].title, "Banner Title 1")
        XCTAssertEqual(results[1].id, "457")
        XCTAssertEqual(results[1].title, "Banner Title 2")
        XCTAssertFalse(results[1].isActive)
        XCTAssertNil(results[1].imageUrl)
    }
    
    // MARK: - Sport Banner Tests
    
    func testSportBannerMapping() {
        // Given
        let internalTeamHome = GomaModels.TeamData(
            id: 11,
            name: "Home Team",
            logo: "https://example.com/home-logo.png"
        )
        
        let internalTeamAway = GomaModels.TeamData(
            id: 22,
            name: "Away Team",
            logo: "https://example.com/away-logo.png"
        )
        
        let internalEvent = GomaModels.SportEventData(
            id: 555,
            sportId: 1,
            homeTeamId: 11,
            awayTeamId: 22,
            dateTime: "2024-05-15T15:00:00Z",
            homeTeam: internalTeamHome,
            awayTeam: internalTeamAway,
            market: nil
        )
        
        let internalBanner = GomaModels.SportBannerData(
            id: 789,
            title: "Sport Banner Title",
            subtitle: "Sport Banner Subtitle",
            startDate: "2024-05-10T10:00:00Z",
            endDate: "2024-05-20T10:00:00Z",
            status: "active",
            imageUrl: "https://example.com/sport-banner.jpg",
            sportEventId: 555,
            event: internalEvent
        )
        
        // When
        let result = GomaModelMapper.sportBanner(fromInternalSportBanner: internalBanner)
        
        // Then
        XCTAssertEqual(result.id, 789)
        XCTAssertEqual(result.title, "Sport Banner Title")
        XCTAssertEqual(result.subtitle, "Sport Banner Subtitle")
        XCTAssertEqual(result.sportEventId, 555)
        XCTAssertEqual(result.status, "active")
        XCTAssertEqual(result.imageUrl?.absoluteString, "https://example.com/sport-banner.jpg")
        
        XCTAssertNotNil(result.event)
        XCTAssertEqual(result.event?.id, 555)
        XCTAssertEqual(result.event?.homeTeam, "Home Team")
        XCTAssertEqual(result.event?.awayTeam, "Away Team")
        XCTAssertEqual(result.event?.homeTeamLogo?.absoluteString, "https://example.com/home-logo.png")
        XCTAssertEqual(result.event?.awayTeamLogo?.absoluteString, "https://example.com/away-logo.png")
    }
    
    // MARK: - Pro Choice Tests
    
    func testProChoiceMapping() {
        // Given
        let internalTipster = GomaModels.ProChoiceData.TipsterData(
            id: 123,
            name: "Expert Tipster",
            winRate: 0.75,
            avatar: "https://example.com/avatar.jpg"
        )
        
        let internalEvent = GomaModels.ProChoiceData.EventSummaryData(
            id: 456,
            homeTeam: "Home Team",
            awayTeam: "Away Team",
            dateTime: "2024-05-15T15:00:00Z"
        )
        
        let internalSelection = GomaModels.ProChoiceData.SelectionData(
            marketName: "Match Result",
            outcomeName: "Home Win",
            odds: 2.1
        )
        
        let internalProChoice = GomaModels.ProChoiceData(
            id: 789,
            title: "Top Pick of the Day",
            tipster: internalTipster,
            event: internalEvent,
            selection: internalSelection,
            reasoning: "The home team has been in excellent form."
        )
        
        // When
        let result = GomaModelMapper.proChoice(fromInternalProChoice: internalProChoice)
        
        // Then
        XCTAssertEqual(result.id, 789)
        XCTAssertEqual(result.title, "Top Pick of the Day")
        XCTAssertEqual(result.reasoning, "The home team has been in excellent form.")
        
        XCTAssertEqual(result.tipster.id, 123)
        XCTAssertEqual(result.tipster.name, "Expert Tipster")
        XCTAssertEqual(result.tipster.winRate, 0.75)
        XCTAssertEqual(result.tipster.avatar?.absoluteString, "https://example.com/avatar.jpg")
        
        XCTAssertEqual(result.event.id, 456)
        XCTAssertEqual(result.event.homeTeam, "Home Team")
        XCTAssertEqual(result.event.awayTeam, "Away Team")
        
        XCTAssertEqual(result.selection.marketName, "Match Result")
        XCTAssertEqual(result.selection.outcomeName, "Home Win")
        XCTAssertEqual(result.selection.odds, 2.1)
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Goma/Models/GomaModelsPromotionsTests.swift
````swift
import XCTest
@testable import ServicesProvider

final class GomaModelsPromotionsTests: XCTestCase {
    
    // MARK: - HomeTemplate Tests
    
    func testHomeTemplateDecoding() {
        // Given
        let json = """
        {
            "id": 101,
            "name": "home",
            "widgets": [
                {
                    "id": "1",
                    "name": "banners",
                    "description": "Rotating banners",
                    "user_type": "any",
                    "sort_order": 1,
                    "orientation": "horizontal"
                },
                {
                    "id": "2",
                    "name": "alertbanners",
                    "description": "Alert messages",
                    "user_type": "authenticated",
                    "sort_order": 2,
                    "orientation": null
                }
            ]
        }
        """
        
        let jsonData = json.data(using: .utf8)!
        
        // When
        let decoder = JSONDecoder()
        let template = try! decoder.decode(GomaModels.HomeTemplate.self, from: jsonData)
        
        // Then
        XCTAssertEqual(template.id, 101)
        XCTAssertEqual(template.type, "home")
        XCTAssertEqual(template.widgets.count, 2)
        
        // First widget
        XCTAssertEqual(template.widgets[0].id, "1")
        XCTAssertEqual(template.widgets[0].type, "banners")
        XCTAssertEqual(template.widgets[0].description, "Rotating banners")
        XCTAssertEqual(template.widgets[0].userType, "any")
        XCTAssertEqual(template.widgets[0].sortOrder, 1)
        XCTAssertEqual(template.widgets[0].orientation, "horizontal")
        
        // Second widget
        XCTAssertEqual(template.widgets[1].id, "2")
        XCTAssertEqual(template.widgets[1].type, "alertbanners")
        XCTAssertEqual(template.widgets[1].description, "Alert messages")
        XCTAssertEqual(template.widgets[1].userType, "authenticated")
        XCTAssertEqual(template.widgets[1].sortOrder, 2)
        XCTAssertNil(template.widgets[1].orientation)
    }
    
    // MARK: - AlertBanner Tests
    
    func testAlertBannerDecoding() {
        // Given
        let json = """
        {
            "id": 123,
            "title": "Important Notice",
            "content": "This is an important notice for all users",
            "background_color": "#FF0000",
            "text_color": "#FFFFFF",
            "action_type": "deeplink",
            "action_target": "app://settings",
            "start_date": "2024-05-10T10:00:00Z",
            "end_date": "2024-05-20T10:00:00Z",
            "status": "active",
            "image_url": "https://example.com/notice.jpg"
        }
        """
        
        let jsonData = json.data(using: .utf8)!
        
        // When
        let decoder = JSONDecoder()
        let banner = try! decoder.decode(GomaModels.AlertBannerData.self, from: jsonData)
        
        // Then
        XCTAssertEqual(banner.id, 123)
        XCTAssertEqual(banner.title, "Important Notice")
        XCTAssertEqual(banner.content, "This is an important notice for all users")
        XCTAssertEqual(banner.backgroundColor, "#FF0000")
        XCTAssertEqual(banner.textColor, "#FFFFFF")
        XCTAssertEqual(banner.actionType, "deeplink")
        XCTAssertEqual(banner.actionTarget, "app://settings")
        XCTAssertEqual(banner.startDate, "2024-05-10T10:00:00Z")
        XCTAssertEqual(banner.endDate, "2024-05-20T10:00:00Z")
        XCTAssertEqual(banner.status, "active")
        XCTAssertEqual(banner.imageUrl, "https://example.com/notice.jpg")
    }
    
    // MARK: - Banner Tests
    
    func testBannerDecoding() {
        // Given
        let json = """
        {
            "id": 456,
            "title": "Special Offer",
            "subtitle": "Limited time only",
            "action_type": "url",
            "action_target": "https://example.com/offer",
            "start_date": "2024-05-10T10:00:00Z",
            "end_date": "2024-05-20T10:00:00Z",
            "status": "active",
            "image_url": "https://example.com/offer.jpg"
        }
        """
        
        let jsonData = json.data(using: .utf8)!
        
        // When
        let decoder = JSONDecoder()
        let banner = try! decoder.decode(GomaModels.BannerData.self, from: jsonData)
        
        // Then
        XCTAssertEqual(banner.id, 456)
        XCTAssertEqual(banner.title, "Special Offer")
        XCTAssertEqual(banner.subtitle, "Limited time only")
        XCTAssertEqual(banner.actionType, "url")
        XCTAssertEqual(banner.actionTarget, "https://example.com/offer")
        XCTAssertEqual(banner.startDate, "2024-05-10T10:00:00Z")
        XCTAssertEqual(banner.endDate, "2024-05-20T10:00:00Z")
        XCTAssertEqual(banner.status, "active")
        XCTAssertEqual(banner.imageUrl, "https://example.com/offer.jpg")
    }
    
    // MARK: - SportEvent Tests
    
    func testSportEventDecoding() {
        // Given
        let json = """
        {
            "id": 789,
            "sport_id": 1,
            "home_team_id": 101,
            "away_team_id": 102,
            "date_time": "2024-05-15T15:00:00Z",
            "home_team": {
                "id": 101,
                "name": "Home Team",
                "logo": "https://example.com/home-logo.png"
            },
            "away_team": {
                "id": 102,
                "name": "Away Team",
                "logo": "https://example.com/away-logo.png"
            },
            "market": {
                "id": 1001,
                "name": "Match Result",
                "outcomes": [
                    {
                        "id": 2001,
                        "name": "Home Win",
                        "price": 2.1
                    },
                    {
                        "id": 2002,
                        "name": "Draw",
                        "price": 3.4
                    },
                    {
                        "id": 2003,
                        "name": "Away Win",
                        "price": 3.8
                    }
                ]
            }
        }
        """
        
        let jsonData = json.data(using: .utf8)!
        
        // When
        let decoder = JSONDecoder()
        let sportEvent = try! decoder.decode(GomaModels.SportEventData.self, from: jsonData)
        
        // Then
        XCTAssertEqual(sportEvent.id, 789)
        XCTAssertEqual(sportEvent.sportId, 1)
        XCTAssertEqual(sportEvent.homeTeamId, 101)
        XCTAssertEqual(sportEvent.awayTeamId, 102)
        XCTAssertEqual(sportEvent.dateTime, "2024-05-15T15:00:00Z")
        
        // Home team
        XCTAssertEqual(sportEvent.homeTeam.id, 101)
        XCTAssertEqual(sportEvent.homeTeam.name, "Home Team")
        XCTAssertEqual(sportEvent.homeTeam.logo, "https://example.com/home-logo.png")
        
        // Away team
        XCTAssertEqual(sportEvent.awayTeam.id, 102)
        XCTAssertEqual(sportEvent.awayTeam.name, "Away Team")
        XCTAssertEqual(sportEvent.awayTeam.logo, "https://example.com/away-logo.png")
        
        // Market
        XCTAssertNotNil(sportEvent.market)
        XCTAssertEqual(sportEvent.market?.id, 1001)
        XCTAssertEqual(sportEvent.market?.name, "Match Result")
        XCTAssertEqual(sportEvent.market?.outcomes.count, 3)
        
        // Outcomes
        XCTAssertEqual(sportEvent.market?.outcomes[0].id, 2001)
        XCTAssertEqual(sportEvent.market?.outcomes[0].name, "Home Win")
        XCTAssertEqual(sportEvent.market?.outcomes[0].price, 2.1)
        
        XCTAssertEqual(sportEvent.market?.outcomes[1].id, 2002)
        XCTAssertEqual(sportEvent.market?.outcomes[1].name, "Draw")
        XCTAssertEqual(sportEvent.market?.outcomes[1].price, 3.4)
        
        XCTAssertEqual(sportEvent.market?.outcomes[2].id, 2003)
        XCTAssertEqual(sportEvent.market?.outcomes[2].name, "Away Win")
        XCTAssertEqual(sportEvent.market?.outcomes[2].price, 3.8)
    }
    
    // MARK: - ProChoice Tests
    
    func testProChoiceDecoding() {
        // Given
        let json = """
        {
            "id": 555,
            "title": "Top Pick of the Day",
            "tipster": {
                "id": 123,
                "name": "Expert Tipster",
                "win_rate": 0.75,
                "avatar": "https://example.com/avatar.jpg"
            },
            "event": {
                "id": 789,
                "home_team": "Home Team",
                "away_team": "Away Team",
                "date_time": "2024-05-15T15:00:00Z"
            },
            "selection": {
                "market_name": "Match Result",
                "outcome_name": "Home Win",
                "odds": 2.1
            },
            "reasoning": "The home team has been in excellent form, winning their last 5 matches."
        }
        """
        
        let jsonData = json.data(using: .utf8)!
        
        // When
        let decoder = JSONDecoder()
        let proChoice = try! decoder.decode(GomaModels.ProChoiceData.self, from: jsonData)
        
        // Then
        XCTAssertEqual(proChoice.id, 555)
        XCTAssertEqual(proChoice.title, "Top Pick of the Day")
        XCTAssertEqual(proChoice.reasoning, "The home team has been in excellent form, winning their last 5 matches.")
        
        // Tipster
        XCTAssertEqual(proChoice.tipster.id, 123)
        XCTAssertEqual(proChoice.tipster.name, "Expert Tipster")
        XCTAssertEqual(proChoice.tipster.winRate, 0.75)
        XCTAssertEqual(proChoice.tipster.avatar, "https://example.com/avatar.jpg")
        
        // Event
        XCTAssertEqual(proChoice.event.id, 789)
        XCTAssertEqual(proChoice.event.homeTeam, "Home Team")
        XCTAssertEqual(proChoice.event.awayTeam, "Away Team")
        XCTAssertEqual(proChoice.event.dateTime, "2024-05-15T15:00:00Z")
        
        // Selection
        XCTAssertEqual(proChoice.selection.marketName, "Match Result")
        XCTAssertEqual(proChoice.selection.outcomeName, "Home Win")
        XCTAssertEqual(proChoice.selection.odds, 2.1)
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Sportsradar/APIs/Events-Poseidon/Helpers/SportsMergerTestHelpers.swift
````swift
import Foundation
import XCTest
import Combine
@testable import ServicesProvider

// MARK: - Test Sport Creation
extension SportType {
    static func createTestSport(
        id: String = UUID().uuidString,
        name: String = "Test Sport",
        alphaId: String? = nil,
        numericId: String? = nil,
        iconId: String? = nil,
        showEventCategory: Bool = false,
        numberEvents: Int = 0,
        numberLiveEvents: Int = 0,
        numberOutrightEvents: Int = 0,
        numberOutrightMarkets: Int = 0
    ) -> SportType {
        return SportType(
            name: name,
            numericId: numericId ?? id,
            alphaId: alphaId ?? "TST",
            iconId: iconId,
            showEventCategory: showEventCategory,
            numberEvents: numberEvents,
            numberOutrightEvents: numberOutrightEvents,
            numberOutrightMarkets: numberOutrightMarkets,
            numberLiveEvents: numberLiveEvents
        )
    }
}

// MARK: - Test Content Identifiers
extension ContentIdentifier {
    static var allSports: ContentIdentifier {
        ContentIdentifier(contentType: .allSports, contentRoute: .allSports)
    }
    
    static var liveSports: ContentIdentifier {
        ContentIdentifier(contentType: .liveSports, contentRoute: .liveSports)
    }
}

// MARK: - Test Assertions
extension XCTestCase {
    func assertSportsEqual(
        _ actual: [SportType],
        _ expected: [SportType],
        file: StaticString = #file,
        line: UInt = #line
    ) {
        XCTAssertEqual(actual.count, expected.count, "Sport count mismatch", file: file, line: line)
        
        for (actualSport, expectedSport) in zip(actual, expected) {
            XCTAssertEqual(actualSport.name, expectedSport.name, "Sport name mismatch", file: file, line: line)
            XCTAssertEqual(actualSport.alphaId, expectedSport.alphaId, "Sport alphaId mismatch", file: file, line: line)
            XCTAssertEqual(actualSport.numericId, expectedSport.numericId, "Sport numericId mismatch", file: file, line: line)
            XCTAssertEqual(actualSport.numberEvents, expectedSport.numberEvents, "Sport events count mismatch", file: file, line: line)
            XCTAssertEqual(actualSport.numberLiveEvents, expectedSport.numberLiveEvents, "Sport live events count mismatch", file: file, line: line)
            XCTAssertEqual(actualSport.numberOutrightEvents, expectedSport.numberOutrightEvents, "Sport outright events count mismatch", file: file, line: line)
            XCTAssertEqual(actualSport.numberOutrightMarkets, expectedSport.numberOutrightMarkets, "Sport outright markets count mismatch", file: file, line: line)
        }
    }
    
    func waitForPublisher<T: Publisher>(
        _ publisher: T,
        timeout: TimeInterval = 1.0,
        file: StaticString = #file,
        line: UInt = #line
    ) -> T.Output? {
        let expectation = expectation(description: "Waiting for publisher")
        var result: T.Output?
        
        let cancellable = publisher.sink(
            receiveCompletion: { _ in
                expectation.fulfill()
            },
            receiveValue: { value in
                result = value
                expectation.fulfill()
            }
        )
        
        wait(for: [expectation], timeout: timeout)
        cancellable.cancel()
        
        return result
    }
    
    func waitForPublisherError<T: Publisher>(
        _ publisher: T,
        timeout: TimeInterval = 1.0,
        file: StaticString = #file,
        line: UInt = #line
    ) -> Error? {
        let expectation = expectation(description: "Waiting for publisher error")
        var receivedError: Error?
        
        let cancellable = publisher.sink(
            receiveCompletion: { completion in
                if case .failure(let error) = completion {
                    receivedError = error
                }
                expectation.fulfill()
            },
            receiveValue: { _ in }
        )
        
        wait(for: [expectation], timeout: timeout)
        cancellable.cancel()
        
        return receivedError
    }
}

// MARK: - Test Constants
enum TestConstants {
    static let defaultTimeout: TimeInterval = 1.0
    static let extendedTimeout: TimeInterval = 5.0
    
    static let mockSessionToken = "test_session_token"
    
    // Common errors used in tests
    static let onSubscribeError = ServiceProviderError.onSubscribe
    static let invalidResponseError = ServiceProviderError.invalidResponse
    static let subscriptionNotFoundError = ServiceProviderError.subscriptionNotFound
    static let userSessionNotFoundError = ServiceProviderError.userSessionNotFound
    static let incompletedSportDataError = ServiceProviderError.incompletedSportData
    
    static func createTestSports(count: Int = 3) -> [SportType] {
        return (0..<count).map { i in
            SportType.createTestSport(
                id: "sport_\(i)",
                name: "Sport \(i)",
                alphaId: "SP\(i)",
                numericId: "\(i)",
                iconId: "icon_\(i)",
                showEventCategory: i % 2 == 0,
                numberEvents: 10,
                numberLiveEvents: i % 2 == 0 ? 5 : 0
            )
        }
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Sportsradar/APIs/Events-Poseidon/Mocks/TestableSubscription.swift
````swift
import Foundation
@testable import ServicesProvider

class TestableSubscription: ServicesProvider.Subscription {
    // MARK: - Properties
    private(set) var isActive: Bool = false
    private(set) var wasUnsubscribed: Bool = false
    private(set) var receivedUpdates: [(sports: [SportType], timestamp: Date)] = []

    // MARK: - Lifecycle
    override init(contentIdentifier: ContentIdentifier, sessionToken: String = "test_session_token", unsubscriber: UnsubscriptionController) {
        super.init(contentIdentifier: contentIdentifier, sessionToken: sessionToken, unsubscriber: unsubscriber)
        self.isActive = true
    }

    // MARK: - Update Tracking
    func recordUpdate(sports: [SportType]) {
        receivedUpdates.append((sports: sports, timestamp: Date()))
    }

    func markAsUnsubscribed() {
        isActive = false
        wasUnsubscribed = true
    }

    // MARK: - Test Helper Methods
    func reset() {
        isActive = true
        wasUnsubscribed = false
        receivedUpdates.removeAll()
    }

    var lastUpdate: [SportType]? {
        receivedUpdates.last?.sports
    }

    var updateCount: Int {
        receivedUpdates.count
    }

    // MARK: - Associated Subscriptions
    func addAssociatedSubscription(_ subscription: ServicesProvider.Subscription) {
        associateSubscription(subscription)
    }

    var associatedSubscriptionCount: Int {
        associatedSubscriptions.count
    }
}
````

## File: Tests/ServicesProviderTests/Providers/Sportsradar/APIs/Events-Poseidon/SportsMergerTests.swift
````swift
import XCTest
import Combine
@testable import ServicesProvider

// MARK: - URLProtocolMock
/// A mock URLProtocol implementation that allows us to intercept network requests and provide mock responses
/// This enables us to test network-dependent code without making actual network calls
///
/// Key Features:
/// - Stores mock responses for specific requests
/// - Tracks all received requests for verification
/// - Can simulate success responses, errors, and different HTTP status codes
/// - Identifies requests uniquely based on both URL and body content
class URLProtocolMock: URLProtocol {
    /// Dictionary that stores mock responses for requests
    /// - Key: A unique identifier generated from the request's URL and body
    /// - Value: A tuple containing:
    ///   - error: Optional error to simulate network/server errors
    ///   - data: Optional response data
    ///   - response: Optional HTTP response with status code and headers
    static var mockResponses = [String: (error: Error?, data: Data?, response: HTTPURLResponse?)]()

    /// Keeps track of all requests received by the mock
    /// Useful for verifying that expected requests were made
    static var requestsReceived: [URLRequest] = []

    /// Dictionary to store request bodies since they might not be available in startLoading
    private static var requestBodies = [URL?: Data]()

    /// Creates a unique identifier for a request by combining its URL and body
    /// This allows us to differentiate between requests that have the same URL but different bodies
    /// - Parameter request: The URLRequest to create an identifier for
    /// - Returns: A string that uniquely identifies the request
    static func requestIdentifier(for request: URLRequest) -> String {
        let url = request.url?.absoluteString ?? ""

        // Try to get body from the request or from our stored bodies
        let bodyData = request.httpBody ?? requestBodies[request.url]
        if let bodyData = bodyData,
           let bodyString = String(data: bodyData, encoding: .utf8) {
            return "\(url)_\(bodyString)"
        }
        return url
    }

    /// Required override that tells URLSession whether this protocol can handle a given request
    /// We return true to handle all requests in our tests
    override class func canInit(with request: URLRequest) -> Bool {
        // Store the body when we first see the request
        if let body = request.httpBody {
            requestBodies[request.url] = body
        }
        return true
    }

    /// Required override that allows URLSession to create a canonical version of the request
    /// We simply return the original request as we don't need to modify it
    override class func canonicalRequest(for request: URLRequest) -> URLRequest {
        // Store the body when we see the canonical request
        if let body = request.httpBody {
            requestBodies[request.url] = body
        }
        return request
    }

    /// The main method where we intercept requests and return mock responses
    /// This is called by URLSession when a request is made
    override func startLoading() {
        // Store the request for later verification
        URLProtocolMock.requestsReceived.append(request)

        // Get the unique identifier for this request using stored body if needed
        let identifier = URLProtocolMock.requestIdentifier(for: request)

        print("[SERVICEPROVIDER][MOCK] Received request with identifier: \(identifier)")
        print("[SERVICEPROVIDER][MOCK] URL: \(request.url?.absoluteString ?? "nil")")

        // Try to get body from request or stored bodies
        let bodyData = request.httpBody ?? URLProtocolMock.requestBodies[request.url]
        if let bodyData = bodyData,
           let bodyString = String(data: bodyData, encoding: .utf8) {
            print("[SERVICEPROVIDER][MOCK] Body: \(bodyString)")
        } else {
            print("[SERVICEPROVIDER][MOCK] ⚠️ No body found for request")
        }

        // If we have a mock response for this request, return it
        if let (error, data, response) = URLProtocolMock.mockResponses[identifier] {
            print("[SERVICEPROVIDER][MOCK] Found mock response for request")

            // Send the mock HTTP response if provided
            if let responseStrong = response {
                print("[SERVICEPROVIDER][MOCK] Sending response with status code: \(responseStrong.statusCode)")
                self.client?.urlProtocol(self, didReceive: responseStrong, cacheStoragePolicy: .notAllowed)
            }

            // Send the mock response data if provided
            if let dataStrong = data {
                print("[SERVICEPROVIDER][MOCK] Sending response data: \(String(data: dataStrong, encoding: .utf8) ?? "nil")")
                self.client?.urlProtocol(self, didLoad: dataStrong)
            }

            // Send the mock error if provided
            if let errorStrong = error {
                print("[SERVICEPROVIDER][MOCK] Sending error: \(errorStrong)")
                self.client?.urlProtocol(self, didFailWithError: errorStrong)
            }
        } else {
            print("[SERVICEPROVIDER][MOCK] ⚠️ No mock response found for request")
            print("[SERVICEPROVIDER][MOCK] Available mock identifiers:")
            for (key, _) in URLProtocolMock.mockResponses {
                print("[SERVICEPROVIDER][MOCK] - \(key)")
            }
        }

        // Signal that we're done loading
        self.client?.urlProtocolDidFinishLoading(self)
    }

    /// Required override for cleanup
    /// Not used in our implementation
    override func stopLoading() {}

    /// Resets all static state between tests
    /// Important to prevent test cross-contamination
    static func reset() {
        mockResponses.removeAll()
        requestsReceived.removeAll()
        requestBodies.removeAll()
    }

    /// Verifies that a specific request was received
    /// - Parameter request: The request to verify
    /// - Returns: True if the request was received, false otherwise
    static func verifyRequest(_ request: URLRequest) -> Bool {
        let identifier = requestIdentifier(for: request)
        return requestsReceived.contains { requestIdentifier(for: $0) == identifier }
    }
}

final class SportsMergerTests: XCTestCase {

    // MARK: - Properties
    private var cancellables: Set<AnyCancellable>!
    private var mockedSession: URLSession!

    override func setUp() {
        super.setUp()
        cancellables = []

        // Configure mocked session
        let configuration = URLSessionConfiguration.ephemeral
        configuration.protocolClasses = [URLProtocolMock.self]
        mockedSession = URLSession(configuration: configuration)
    }

    override func tearDown() {
        URLProtocolMock.reset()
        cancellables = nil
        mockedSession = nil
        super.tearDown()
    }

    // MARK: - Helper Methods

    /// Sets up a mock response for a single SportRadarRestAPIClient endpoint
    /// This is the lowest level helper that actually configures the mock response
    ///
    /// Usage example:
    /// ```
    /// setupMockResponse(
    ///     for: .subscribe(sessionToken: "token", contentIdentifier: .allSports),
    ///     statusCode: 404,
    ///     error: ServiceProviderError.onSubscribe
    /// )
    /// ```
    ///
    /// - Parameters:
    ///   - endpoint: The SportRadarRestAPIClient endpoint to mock
    ///   - statusCode: HTTP status code for the response (default: 200)
    ///   - responseData: Optional JSON data to return (default: {"version": "1.0"})
    ///   - error: Optional error to return (default: nil)
    private func setupMockResponse(
        for endpoint: SportRadarRestAPIClient,
        statusCode: Int = 200,
        responseData: Data? = """
        {
            "version": "1.0"
        }
        """.data(using: .utf8),
        error: Error? = nil
    ) {
        guard let request = endpoint.request(),
              let url = request.url else {
            XCTFail("Failed to create request for endpoint")
            return
        }

        let identifier = URLProtocolMock.requestIdentifier(for: request)
        print("[SERVICEPROVIDER][TEST] Setting up mock response for identifier: \(identifier)")
        print("[SERVICEPROVIDER][TEST] URL: \(url.absoluteString)")
        if let body = request.httpBody, let bodyString = String(data: body, encoding: .utf8) {
            print("[SERVICEPROVIDER][TEST] Body: \(bodyString)")
        }

        URLProtocolMock.mockResponses[identifier] = (
            error: error,
            data: responseData,
            response: HTTPURLResponse(
                url: url,
                statusCode: statusCode,
                httpVersion: nil,
                headerFields: nil
            )
        )
    }

    /// Sets up mock responses for multiple endpoints with the same configuration
    /// Useful when testing system-wide states like server outages or authentication failures
    ///
    /// Usage example:
    /// ```
    /// setupMockResponses(
    ///     for: [.subscribe(...), .unsubscribe(...)],
    ///     statusCode: 500,
    ///     error: ServiceProviderError.serverError
    /// )
    /// ```
    ///
    /// - Parameters:
    ///   - endpoints: Array of endpoints to mock
    ///   - statusCode: HTTP status code for all responses (default: 200)
    ///   - responseData: Optional JSON data to return for all endpoints (default: {"version": "1.0"})
    ///   - error: Optional error to return for all endpoints (default: nil)
    private func setupMockResponses(
        for endpoints: [SportRadarRestAPIClient],
        statusCode: Int = 200,
        responseData: Data? = """
        {
            "version": "1.0"
        }
        """.data(using: .utf8),
        error: Error? = nil
    ) {
        endpoints.forEach { endpoint in
            setupMockResponse(
                for: endpoint,
                statusCode: statusCode,
                responseData: responseData,
                error: error
            )
        }
    }

    /// Convenience method specifically for setting up subscription mock responses
    /// This is a higher-level helper that uses setupMockResponses internally
    ///
    /// Usage example:
    /// ```
    /// setupMockResponses(forSessionToken: "test_token")
    /// ```
    ///
    /// - Parameter sessionToken: The session token to use for the subscription requests
    private func setupMockResponses(forSessionToken sessionToken: String) {
        // Create subscription endpoints for both all sports and live sports
        let endpoints: [SportRadarRestAPIClient] = [
            .subscribe(sessionToken: sessionToken, contentIdentifier: ContentIdentifier.allSports),
            .subscribe(sessionToken: sessionToken, contentIdentifier: ContentIdentifier.liveSports)
        ]

        // Setup mock responses for all endpoints with default success values
        setupMockResponses(for: endpoints)
    }

    // MARK: - Initial Connection Tests

    /// Test verifies that SportsMerger successfully handles the initial subscription process
    ///
    /// Flow:
    /// 1. Setup:
    ///    - Creates MockURLSession to simulate network responses
    ///    - Prepares mock responses for both all sports and live sports subscriptions
    ///    - Each response contains a version number which validates the subscription
    ///
    /// 2. Subscription Process:
    ///    - SportsMerger initiates two parallel subscriptions:
    ///      a) All sports subscription (required)
    ///      b) Live sports subscription (optional)
    ///    - Both REST calls must return success (200) with valid version
    ///
    /// 3. State Management:
    ///    - SportsMerger transitions from .disconnected -> .connecting -> .connected
    ///    - Creates Subscription objects for successful responses
    ///    - Sends .connected state through sportsPublisher
    ///
    /// 4. Verification:
    ///    - Confirms we receive exactly one state update
    ///    - Verifies it's a .connected state with proper subscription
    ///    - Checks subscription has correct contentIdentifier and sessionToken
    ///    - Verifies the correct REST requests were made
    ///
    /// Note: This test only verifies the REST subscription part.
    /// Socket connection and updates are handled separately.
    func test_subscribeSportTypes_WhenSuccessful_ShouldReceiveConnectedState() {
        // Given
        let sessionToken = TestConstants.mockSessionToken
        let expectation = expectation(description: "Should receive connected state")
        var receivedStates: [SubscribableContent<[SportType]>] = []

        // Setup mock responses
        setupMockResponses(forSessionToken: sessionToken)

        // Create SportsMerger instance with mocked session
        let sportsMerger = SportsMerger(sessionToken: sessionToken, urlSession: mockedSession)

        // When
        sportsMerger.sportsPublisher
            .sink(
                receiveCompletion: { completion in
                    if case .failure(let error) = completion {
                        XCTFail("Unexpected error: \(error)")
                    }
                },
                receiveValue: { state in
                    print("[SERVICEPROVIDER][TEST] Received state: \(state)")
                    receivedStates.append(state)
                    if case .connected = state {
                        expectation.fulfill()
                    }
                }
            )
            .store(in: &cancellables)

        // Then
        waitForExpectations(timeout: TestConstants.defaultTimeout)

        // Verify we received the correct number of states
        XCTAssertEqual(receivedStates.count, 1, "Should receive exactly one state update")

        // Verify the received state is .connected with correct subscription
        if case .connected(let subscription) = receivedStates.first {
            XCTAssertEqual(subscription.sessionToken, sessionToken, "Session token should match")
            XCTAssertEqual(subscription.contentIdentifier, ContentIdentifier.allSports, "Content identifier should be for all sports")

            // Verify that both subscription requests were made
            let allSportsEndpoint = SportRadarRestAPIClient.subscribe(
                sessionToken: sessionToken,
                contentIdentifier: ContentIdentifier.allSports
            )
            let liveSportsEndpoint = SportRadarRestAPIClient.subscribe(
                sessionToken: sessionToken,
                contentIdentifier: ContentIdentifier.liveSports
            )

            guard let allSportsRequest = allSportsEndpoint.request(),
                  let liveSportsRequest = liveSportsEndpoint.request() else {
                XCTFail("Failed to create verification requests")
                return
            }

            XCTAssertTrue(
                URLProtocolMock.verifyRequest(allSportsRequest),
                "All sports subscription request should have been made"
            )
            XCTAssertTrue(
                URLProtocolMock.verifyRequest(liveSportsRequest),
                "Live sports subscription request should have been made"
            )

            // Print received requests for debugging
            print("[SERVICEPROVIDER][TEST] Received requests:")
            for request in URLProtocolMock.requestsReceived {
                print("[SERVICEPROVIDER][TEST] - URL: \(request.url?.absoluteString ?? "nil")")
                if let body = request.httpBody, let bodyString = String(data: body, encoding: .utf8) {
                    print("[SERVICEPROVIDER][TEST] - Body: \(bodyString)")
                }
            }
        } else {
            XCTFail("First state should be .connected")
        }
    }
}
````

## File: Tests/ServicesProviderTests/ServicesProviderTests.swift
````swift
import XCTest
@testable import ServicesProvider

final class ServicesProviderTests: XCTestCase {
    func testExample() throws {
        // This is an example of a functional test case.
        // Use XCTAssert and related functions to verify your tests produce the correct
        // results.
        XCTAssertEqual("q", "q")
    }
}
````

## File: .gitignore
````
.DS_Store
/.build
/Packages
/*.xcodeproj
xcuserdata/
DerivedData/
.swiftpm/config/registries.json
.swiftpm/xcode/package.xcworkspace/contents.xcworkspacedata
.netrc
````

## File: .repomixignore
````
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
.build
.swiftpm
Package.resolved
````

## File: Package.swift
````swift
// swift-tools-version: 5.7
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription

let package = Package(
    name: "ServicesProvider",
    platforms: [
        .iOS(.v13),
        .macOS(.v12)
    ],
    products: [
        // Products define the executables and libraries a package produces, and make them visible to other packages.
        .library(
            name: "ServicesProvider",
            targets: ["ServicesProvider"]),
    ],
    dependencies: [
        // Dependencies declare other packages that this package depends on.
        // .package(url: /* package url */, from: "1.0.0"),
        .package(url: "https://github.com/apple/swift-collections.git", .upToNextMajor(from: "1.0.0")),
        // .package(url: "https://github.com/daltoniam/Starscream.git", .upToNextMajor(from: "4.0.0")),
        .package(url: "https://github.com/rubenroques/Starscream.git", branch: "native-socket" ),
        .package(url: "https://github.com/airbnb/lottie-spm.git", .upToNextMajor(from: "4.2.0")),
        .package(name: "SharedModels", path: "../SharedModels"),
        .package(name: "Extensions", path: "../Extensions"),
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite.
        // Targets can depend on other targets in this package, and on products in packages this package depends on.
        .target(
            name: "ServicesProvider",
            dependencies: [
                .product(name: "OrderedCollections", package: "swift-collections"),
                .product(name: "Lottie", package: "lottie-spm"),
                "Starscream",
                "SharedModels",
                "Extensions",
            ]),
        .testTarget(
            name: "ServicesProviderTests",
            dependencies: ["ServicesProvider"]),
    ]
)
````

## File: README.md
````markdown
# ServicesProvider

## Overview

The ServicesProvider package is a core component of the GOMA iOS application that handles all external API communication and data transformation. It follows a clean architecture pattern that separates API data models from domain models, providing a robust and maintainable interface for the application to consume remote data.

## Architecture

The package implements a layered architecture with clear separation of concerns:

```
API Request → Internal GomaModels → GomaModelMapper → Domain Models
```

### Key Components

#### API Clients
- **GomaPromotionsAPIClient**: Handles all HTTP requests to the promotions endpoints
- **GomaAPIAuthenticator**: Manages authentication tokens for API requests

#### Content Providers
- **ManagedContentProvider**: Protocol defining the interface for content retrieval
- **GomaManagedContentProvider**: Implementation of the provider that coordinates API requests and data transformation

#### Models
- **Internal Models** (`GomaModels+*.swift`): Direct representations of API JSON responses
- **Domain Models** (`HomeTemplate.swift`, `Banner.swift`, etc.): Clean models used by the application UI

#### Mappers
- **GomaModelMapper**: Transforms internal API models into domain models

## Provider Protocols

The package is organized around several provider protocols that define clear interfaces for different aspects of the application:

### Connector
The base protocol for all providers that maintain a connection state:
- Provides a publisher for connection state changes (connected/disconnected)
- Serves as the foundation for other provider protocols

### ManagedContentProvider
Handles retrieval of promotional and templated content:
- **Home Template**: Configuration for the home screen layout
- **Alert Banners**: Time-sensitive notifications
- **Banners**: Promotional banners for marketing campaigns
- **Sport Banners**: Sport-specific promotional content
- **Boosted Odds Banners**: Special odds promotions
- **Hero Cards**: Featured promotional content
- **Stories**: Ephemeral promotional content
- **News**: Articles and updates with pagination support
- **Pro Choices**: Expert betting tips

### AnalyticsProvider
Manages tracking of user events and interactions:
- Tracks events with optional user identification
- Supports custom event types with associated data

### BettingProvider
Handles all betting-related operations:
- Bet history and details retrieval
- Bet placement and calculation
- Cashout functionality
- Freebet and bonus management
- Shared ticket functionality

### EventsProvider
Manages sports events data:
- Live and pre-live match subscriptions
- Sport types and competition data
- Market and outcome information
- Event details and statistics
- Favorites management

### PrivilegedAccessManager
Handles user authentication and account management:
- User login and registration
- Profile management
- Payment processing
- Responsible gaming limits
- KYC verification
- Social features (friends, followers)

### PromotionsProvider
Manages promotional content and campaigns:
- User session management
- Device identification
- Anonymous and authenticated access to promotions
- Sign-up through promotions

## Provider Implementations

The package includes implementations for different backend systems:

### Goma Providers
- **GomaManagedContentProvider**: Implements the ManagedContentProvider protocol for the Goma API
- **GomaAPIClient**: Base client for Goma API requests
- **GomaConnector**: Manages connection state for Goma services

### Sportsradar Providers
- **SportRadarManagedContentProvider**: Alternative implementation for Sportsradar backend
- **SportRadarBettingProvider**: Handles betting operations through Sportsradar
- **SportRadarEventsProvider**: Manages sports events data from Sportsradar
- **SportRadarAnalyticsProvider**: Tracks analytics through Sportsradar

## Service Provider Client

The **ServicesProviderClient** class serves as the main entry point for the application:
- Initializes and configures the appropriate providers based on configuration
- Provides a unified interface to access all provider functionality
- Manages connection state and authentication
- Handles provider switching and reconnection

## Data Flow

1. **API Request Stage**:
   - The application requests data through the `ManagedContentProvider` interface
   - `GomaManagedContentProvider` initiates an API request using `GomaPromotionsAPIClient`
   - Authentication is applied via `GomaAPIAuthenticator`

2. **Internal Model Decoding Stage**:
   - JSON responses are decoded into internal `GomaModels` structs
   - These models directly map to the API's JSON structure

3. **Model Transformation Stage**:
   - `GomaModelMapper` transforms internal models to domain models
   - Data types are converted, optionals are handled, and structures are made app-friendly

4. **Domain Model Return Stage**:
   - Clean domain models are returned to the application via Combine publishers

## Supported Endpoints

The package supports multiple content endpoints:

- Home Template
- Alert Banners
- Banners
- Sport Banners
- Boosted Odds Banners
- Hero Cards
- Stories
- News (with pagination)
- Pro Choices

## Usage Example

```swift
// Access the managed content provider
let contentProvider: ManagedContentProvider = GomaManagedContentProvider()

// Request home template data
contentProvider.getHomeTemplate()
    .sink(
        receiveCompletion: { completion in
            // Handle completion
        },
        receiveValue: { homeTemplate in
            // Use the domain model
        }
    )
    .store(in: &cancellables)
```

## Testing

The package includes comprehensive tests:

- **Unit Tests**: Test individual components in isolation
- **Integration Tests**: Verify the entire flow from API request to domain model
- **Mock Responses**: Real API responses are captured and stored as JSON files for testing

For detailed information on the integration testing approach, see the [Integration Tests documentation](Docs/IntegrationTests.md).

## Dependencies

- **Combine**: Used for asynchronous data flow
- **Foundation**: Networking and data parsing

## Project Structure

```
ServicesProvider/
├── Sources/
│   ├── API/
│   │   ├── GomaPromotionsAPIClient.swift
│   │   └── GomaAPIAuthenticator.swift
│   ├── Models/
│   │   ├── Internal/
│   │   │   └── GomaModels+*.swift
│   │   └── Domain/
│   │       ├── HomeTemplate.swift
│   │       ├── Banner.swift
│   │       └── ...
│   ├── Mappers/
│   │   └── GomaModelMapper+*.swift
│   ├── Protocols/
│   │   ├── Connector.swift
│   │   ├── ManagedContentProvider.swift
│   │   ├── AnalyticsProvider.swift
│   │   ├── BettingProvider.swift
│   │   ├── EventsProvider.swift
│   │   ├── PrivilegedAccessManager.swift
│   │   └── PromotionsProvider.swift
│   ├── Providers/
│   │   ├── Goma/
│   │   │   ├── GomaManagedContentProvider.swift
│   │   │   ├── GomaAPIClient.swift
│   │   │   └── ...
│   │   └── Sportsradar/
│   │       ├── SportRadarManagedContentProvider.swift
│   │       ├── SportRadarBettingProvider.swift
│   │       └── ...
│   └── ServiceProviderClient.swift
├── Tests/
│   ├── Unit/
│   └── Integration/
└── Docs/
    └── IntegrationTests.md
```
````

## File: repomix.config.json
````json
{
  "output": {
    "filePath": "repomix-output.md",
    "style": "markdown",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
````
